# Copyright (C) 2023 Apple, Inc.
# 
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
# 
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
# 
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA

# The 22.1.1 tarball contains an empty sources/freetype directory, which confuses the default CurlDownloadStrategy.
# A custom strategy also allows us to restrict extraction to just the wine.
class TarballDownloadStrategy < CurlDownloadStrategy
  def stage
    ohai "Staging #{cached_location} in #{pwd}"
    system "tar", "-xf", cached_location, "--include=sources/wine/*", "--strip-components=2"
    yield
  end
end

class GamePortingToolkit < Formula
  desc "Apple Game Porting Toolkit"
  homepage "https://developer.apple.com/"
  url "https://media.codeweavers.com/pub/crossover/source/crossover-sources-22.1.1.tar.gz", using: TarballDownloadStrategy
  version "1.0.2"
  sha256 "cdfe282ce33788bd4f969c8bfb1d3e2de060eb6c296fa1c3cdf4e4690b8b1831"

  keg_only :versioned_formula

  depends_on "bison" => :build
  depends_on "cx-llvm" => :build
  depends_on "mingw-w64" => :build
  depends_on "pkg-config" => :build
  depends_on arch: :x86_64
  depends_on "freetype"
  depends_on "gettext"
  depends_on "gnutls"
  depends_on "gstreamer"
  depends_on "sdl2"

  uses_from_macos "flex" => :build

  resource "gecko-x86" do
    url "https://dl.winehq.org/wine/wine-gecko/2.47.2/wine-gecko-2.47.2-x86.tar.xz"
    sha256 "8fab46ea2110b2b0beed414e3ebb4e038a3da04900e7a28492ca3c3ccf9fea94"
  end

  resource "gecko-x86_64" do
    url "https://dl.winehq.org/wine/wine-gecko/2.47.2/wine-gecko-2.47.2-x86_64.tar.xz"
    sha256 "b4476706a4c3f23461da98bed34f355ff623c5d2bb2da1e2fa0c6a310bc33014"
  end

  patch :p0, :DATA

  def install
    # Bypass the Homebrew shims to build native binaries with the dedicated compiler.
    # (PE binaries will be built with mingw32-gcc.)
    compiler = Formula["game-porting-toolkit-compiler"]
    compiler_options = ["CC=#{compiler.bin}/clang",
                        "CXX=#{compiler.bin}/clang++"]

    # We also need to tell the linker to add Homebrew to the rpath stack.
    ENV.append "LDFLAGS", "-lSystem"
    ENV.append "LDFLAGS", "-L#{HOMEBREW_PREFIX}/lib"
    ENV.append "LDFLAGS", "-Wl,-rpath,#{HOMEBREW_PREFIX}/lib"
    ENV.append "LDFLAGS", "-Wl,-rpath,@executable_path/../lib/external"

    # Common compiler flags for both Mach-O and PE binaries.
    ENV.append_to_cflags "-O3 -Wno-deprecated-declarations -Wno-incompatible-pointer-types"
    # Use an older deployment target to avoid new dyld behaviors.
    # The custom compiler is too old to accept "13.0", so we use "10.14".
    ENV["MACOSX_DEPLOYMENT_TARGET"] = "10.14"

    wine_configure_options = ["--prefix=#{prefix}",
                              "--disable-tests",
                              "--without-alsa",
                              "--without-capi",
                              "--with-coreaudio",
                              "--with-cups",
                              "--without-dbus",
                              "--with-freetype",
                              "--with-gettext",
                              "--without-gettextpo",
                              "--without-gphoto",
                              "--with-gnutls",
                              "--without-gssapi",
                              "--with-gstreamer",
                              "--without-inotify",
                              "--without-krb5",
                              "--with-mingw",
                              "--without-netapi",
                              "--without-openal",
                              "--with-opencl",
                              "--with-opengl",
                              "--without-oss",
                              "--with-pcap",
                              "--with-pthread",
                              "--without-pulse",
                              "--without-sane",
                              "--with-sdl",
                              "--without-udev",
                              "--with-unwind",
                              "--without-usb",
                              "--without-v4l2",
                              "--without-vulkan",
                              "--without-x"]

    wine64_configure_options = ["--enable-win64"]

    # These are provided by Game Porting Toolkit
    wine64_configure_options += ["--disable-d3d9",
                                 "--disable-d3d10",
                                 "--disable-d3d11",
                                 "--disable-d3d12",
                                 "--disable-dxgi"]

    wine32_configure_options = ["--enable-win32on64",
                                "--with-wine64=../wine64-build"]

    # We don't need wineloader
    wine32_configure_options += ["--disable-loader"]

    # Build 64-bit Wine first.
    mkdir buildpath/"wine64-build" do
      system buildpath/"configure", *wine_configure_options, *wine64_configure_options, *compiler_options
      system "make"
    end

    # Now build 32-on-64 Wine.
    mkdir buildpath/"wine32-build" do
      system buildpath/"configure", *wine_configure_options, *wine32_configure_options, *compiler_options
      system "make"
    end

    # Install both builds.
    cd "wine64-build" do
      system "make", "install-lib"
    end

    cd "wine32-build" do
      system "make", "install-lib"
    end
  end

  def post_install
    # Homebrew replaces wine's rpath names with absolute paths, we need to change them back to @rpath relative paths
    # Wine relies on @rpath names to cause dlopen to always return the first dylib with that name loaded into
    # the process rather than the actual dylib found using rpath lookup.
    Dir["#{lib}/wine/{x86_64-unix,x86_32on64-unix}/*.so"].each do |dylib|
      chmod 0664, dylib
      MachO::Tools.change_dylib_id(dylib, "@rpath/#{File.basename(dylib)}")
      MachO.codesign!(dylib)
      chmod 0444, dylib
    end

    # Install wine-gecko into place
    (share/"wine"/"gecko"/"wine-gecko-2.47.2-x86").install resource("gecko-x86")
    (share/"wine"/"gecko"/"wine-gecko-2.47.2-x86_64").install resource("gecko-x86_64")
  end

  def caveats
    return unless latest_version_installed?

    "Please follow the instructions in the Game Porting Toolkit README to complete installation."
  end

  test do
    system bin/"wine64", "--version"
  end
end

__END__
diff --git a/include/distversion.h b/include/distversion.h
new file mode 100644
index 00000000000..b8a3724b76b
--- /dev/null
+++ wine/include/distversion.h
@@ -0,0 +1,12 @@
+/* ---------------------------------------------------------------
+*   distversion.c
+*
+* Copyright 2013, CodeWeavers, Inc.
+*
+* Information from DISTVERSION which needs to find
+* its way into the wine tree.
+* --------------------------------------------------------------- */
+
+#define WINDEBUG_WHAT_HAPPENED_MESSAGE "This can be caused by a problem in the program or a deficiency in Wine. You may want to check <a href=\"http://www.codeweavers.com/compatibility/\">http://www.codeweavers.com/compatibility/</a> for tips about running this application."
+
+#define WINDEBUG_USER_SUGGESTION_MESSAGE "If this problem is not present under Windows and has not been reported yet, you can save the detailed information to a file using the \"Save As\" button, then <a href=\"http://www.codeweavers.com/support/tickets/enter/\">file a bug report</a> and attach that file to the report."
\ No newline at end of file
-- 
2.39.2 (Apple Git-144)

diff --git a/configure b/configure
index 2d57c7e085d..b9b57c0d509 100755
--- wine/configure
+++ wine/configure
@@ -950,6 +950,7 @@ enable_amstream
 enable_apisetschema
 enable_apphelp
 enable_appwiz_cpl
+enable_api_ms_win_power_base_l1_1_0
 enable_atl
 enable_atl100
 enable_atl110
@@ -21776,6 +21777,7 @@ wine_fn_config_makefile dlls/apisetschema enable_apisetschema
 wine_fn_config_makefile dlls/apphelp enable_apphelp
 wine_fn_config_makefile dlls/apphelp/tests enable_tests
 wine_fn_config_makefile dlls/appwiz.cpl enable_appwiz_cpl
+wine_fn_config_makefile dlls/api-ms-win-power-base-l1-1-0 enable_api_ms_win_power_base_l1_1_0
 wine_fn_config_makefile dlls/atl enable_atl
 wine_fn_config_makefile dlls/atl/tests enable_tests
 wine_fn_config_makefile dlls/atl100 enable_atl100
diff --git a/configure.ac b/configure.ac
diff --git a/configure.ac b/configure.ac
index 50c50d15eda..58063421cce 100644
--- wine/configure.ac
+++ wine/configure.ac
@@ -2424,6 +2424,7 @@ WINE_CONFIG_MAKEFILE(dlls/apisetschema)
 WINE_CONFIG_MAKEFILE(dlls/apphelp)
 WINE_CONFIG_MAKEFILE(dlls/apphelp/tests)
 WINE_CONFIG_MAKEFILE(dlls/appwiz.cpl)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-power-base-l1-1-0)
 WINE_CONFIG_MAKEFILE(dlls/atl)
 WINE_CONFIG_MAKEFILE(dlls/atl/tests)
 WINE_CONFIG_MAKEFILE(dlls/atl100)
diff --git a/dlls/api-ms-win-power-base-l1-1-0/Makefile.in b/dlls/api-ms-win-power-base-l1-1-0/Makefile.in
new file mode 100644
index 00000000000..8b26d4be82f
--- /dev/null
+++ wine/dlls/api-ms-win-power-base-l1-1-0/Makefile.in
@@ -0,0 +1 @@
+MODULE    = api-ms-win-power-base-l1-1-0.dll
diff --git a/dlls/api-ms-win-power-base-l1-1-0/api-ms-win-power-base-l1-1-0.spec b/dlls/api-ms-win-power-base-l1-1-0/api-ms-win-power-base-l1-1-0.spec
new file mode 100644
index 00000000000..dd056946ac6
--- /dev/null
+++ wine/dlls/api-ms-win-power-base-l1-1-0/api-ms-win-power-base-l1-1-0.spec
@@ -0,0 +1,5 @@
+@ stdcall CallNtPowerInformation(long ptr long ptr long) powrprof.CallNtPowerInformation
+@ stdcall GetPwrCapabilities(ptr) powrprof.GetPwrCapabilities
+@ stdcall PowerDeterminePlatformRoleEx(long) powrprof.PowerDeterminePlatformRoleEx
+@ stdcall PowerRegisterSuspendResumeNotification(long ptr ptr) powrprof.PowerRegisterSuspendResumeNotification
+@ stub PowerUnregisterSuspendResumeNotification
diff --git a/tools/make_specfiles b/tools/make_specfiles
index 3c4c40544b8..cdaf0ccf209 100755
--- wine/tools/make_specfiles
+++ wine/tools/make_specfiles
@@ -139,6 +139,11 @@ my @dll_groups =
   "sppc",
   "slc",
  ],
+ [
+    "ntdll",
+    "powrprof",
+    "api-ms-win-power-base-l1-1-0",
+ ]
 );
 
 my $update_flags = 0;
-- 
2.39.2 (Apple Git-144)

diff --git a/configure b/configure
index b9b57c0d509..24f958073a0 100755
--- wine/configure
+++ wine/configure
@@ -950,6 +950,7 @@ enable_amstream
 enable_apisetschema
 enable_apphelp
 enable_appwiz_cpl
+enable_api_ms_win_core_psm_appnotify_l1_1_0
 enable_api_ms_win_power_base_l1_1_0
 enable_atl
 enable_atl100
@@ -21777,6 +21778,7 @@ wine_fn_config_makefile dlls/apisetschema enable_apisetschema
 wine_fn_config_makefile dlls/apphelp enable_apphelp
 wine_fn_config_makefile dlls/apphelp/tests enable_tests
 wine_fn_config_makefile dlls/appwiz.cpl enable_appwiz_cpl
+wine_fn_config_makefile dlls/api-ms-win-core-psm-appnotify-l1-1-0 enable_api_ms_win_core_psm_appnotify_l1_1_0
 wine_fn_config_makefile dlls/api-ms-win-power-base-l1-1-0 enable_api_ms_win_power_base_l1_1_0
 wine_fn_config_makefile dlls/atl enable_atl
 wine_fn_config_makefile dlls/atl/tests enable_tests
diff --git a/dlls/api-ms-win-core-psm-appnotify-l1-1-0/Makefile.in b/dlls/api-ms-win-core-psm-appnotify-l1-1-0/Makefile.in
new file mode 100644
index 00000000000..8a3d2ad98cb
--- /dev/null
+++ wine/dlls/api-ms-win-core-psm-appnotify-l1-1-0/Makefile.in
@@ -0,0 +1 @@
+MODULE    = api-ms-win-core-psm-appnotify-l1-1-0.dll
diff --git a/dlls/api-ms-win-core-psm-appnotify-l1-1-0/api-ms-win-core-psm-appnotify-l1-1-0.spec b/dlls/api-ms-win-core-psm-appnotify-l1-1-0/api-ms-win-core-psm-appnotify-l1-1-0.spec
new file mode 100644
index 00000000000..8b069d66e62
--- /dev/null
+++ wine/dlls/api-ms-win-core-psm-appnotify-l1-1-0/api-ms-win-core-psm-appnotify-l1-1-0.spec
@@ -0,0 +1,2 @@
+@ stub RegisterAppStateChangeNotification
+@ stub UnregisterAppStateChangeNotification
-- 
2.39.2 (Apple Git-144)

diff --git a/dlls/crypt32/base64.c b/dlls/crypt32/base64.c
index 11fb137ed91..b61ed7ff8cc 100644
--- wine/dlls/crypt32/base64.c
+++ wine/dlls/crypt32/base64.c
@@ -241,6 +241,63 @@ static BOOL BinaryToBase64A(const BYTE *pbBinary,
     return ret;
 }
 
+static BOOL BinaryToHexRawA(const BYTE *bin, DWORD nbin, DWORD flags, char *str, DWORD *nstr)
+{
+    static const char hex[] = "0123456789abcdef";
+    DWORD needed;
+
+    if (flags & CRYPT_STRING_NOCRLF)
+        needed = 0;
+    else if (flags & CRYPT_STRING_NOCR)
+        needed = 1;
+    else
+        needed = 2;
+
+    needed += nbin * 2 + 1;
+
+    if (!str)
+    {
+        *nstr = needed;
+        return TRUE;
+    }
+
+    if (needed > *nstr && *nstr < 3)
+    {
+        SetLastError(ERROR_MORE_DATA);
+        return FALSE;
+    }
+
+    nbin = min(nbin, (*nstr - 1) / 2);
+
+    while (nbin--)
+    {
+        *str++ = hex[(*bin >> 4) & 0xf];
+        *str++ = hex[*bin & 0xf];
+        bin++;
+    }
+
+    if (needed > *nstr)
+    {
+        *str = 0;
+        SetLastError(ERROR_MORE_DATA);
+        return FALSE;
+    }
+
+    if (flags & CRYPT_STRING_NOCR)
+    {
+        *str++ = '\n';
+    }
+    else if (!(flags & CRYPT_STRING_NOCRLF))
+    {
+        *str++ = '\r';
+        *str++ = '\n';
+    }
+
+    *str = 0;
+    *nstr = needed - 1;
+    return TRUE;
+}
+
 BOOL WINAPI CryptBinaryToStringA(const BYTE *pbBinary,
  DWORD cbBinary, DWORD dwFlags, LPSTR pszString, DWORD *pcchString)
 {
@@ -271,6 +328,9 @@ BOOL WINAPI CryptBinaryToStringA(const BYTE *pbBinary,
     case CRYPT_STRING_BASE64X509CRLHEADER:
         encoder = BinaryToBase64A;
         break;
+    case CRYPT_STRING_HEXRAW:
+        encoder = BinaryToHexRawA;
+        break;
     case CRYPT_STRING_HEX:
     case CRYPT_STRING_HEXASCII:
     case CRYPT_STRING_HEXADDR:
@@ -883,6 +943,120 @@ static LONG DecodeAnyA(LPCSTR pszString, DWORD cchString,
     return ret;
 }
 
+static BOOL is_hex_string_special_char(WCHAR c)
+{
+    switch (c)
+    {
+        case '-':
+        case ',':
+        case ' ':
+        case '\t':
+        case '\r':
+        case '\n':
+            return TRUE;
+
+        default:
+            return FALSE;
+    }
+}
+
+static WCHAR wchar_from_str(BOOL wide, const void **str, DWORD *len)
+{
+    WCHAR c;
+
+    if (!*len)
+        return 0;
+
+    --*len;
+    if (wide)
+        c = *(*(const WCHAR **)str)++;
+    else
+        c = *(*(const char **)str)++;
+
+    return c ? c : 0xffff;
+}
+
+static BYTE digit_from_char(WCHAR c)
+{
+    if (c >= '0' && c <= '9')
+        return c - '0';
+    c = towlower(c);
+    if (c >= 'a' && c <= 'f')
+        return c - 'a' + 0xa;
+    return 0xff;
+}
+
+static LONG string_to_hex(const void* str, BOOL wide, DWORD len, BYTE *hex, DWORD *hex_len,
+        DWORD *skipped, DWORD *ret_flags)
+{
+    unsigned int byte_idx = 0;
+    BYTE d1, d2;
+    WCHAR c;
+
+    if (!str || !hex_len)
+        return ERROR_INVALID_PARAMETER;
+
+    if (!len)
+        len = wide ? wcslen(str) : strlen(str);
+
+    if (wide && !len)
+        return ERROR_INVALID_PARAMETER;
+
+    if (skipped)
+        *skipped = 0;
+    if (ret_flags)
+        *ret_flags = 0;
+
+    while ((c = wchar_from_str(wide, &str, &len)) && is_hex_string_special_char(c))
+        ;
+
+    while ((d1 = digit_from_char(c)) != 0xff)
+    {
+        if ((d2 = digit_from_char(wchar_from_str(wide, &str, &len))) == 0xff)
+        {
+            if (!hex)
+                *hex_len = 0;
+            return ERROR_INVALID_DATA;
+        }
+
+        if (hex && byte_idx < *hex_len)
+            hex[byte_idx] = (d1 << 4) | d2;
+
+        ++byte_idx;
+
+        do
+        {
+            c = wchar_from_str(wide, &str, &len);
+        } while (c == '-' || c == ',');
+    }
+
+    while (c)
+    {
+        if (!is_hex_string_special_char(c))
+        {
+            if (!hex)
+                *hex_len = 0;
+            return ERROR_INVALID_DATA;
+        }
+        c = wchar_from_str(wide, &str, &len);
+    }
+
+    if (hex && byte_idx > *hex_len)
+        return ERROR_MORE_DATA;
+
+    if (ret_flags)
+        *ret_flags = CRYPT_STRING_HEX;
+
+    *hex_len = byte_idx;
+
+    return ERROR_SUCCESS;
+}
+
+static LONG string_to_hexA(const char *str, DWORD len, BYTE *hex, DWORD *hex_len, DWORD *skipped, DWORD *ret_flags)
+{
+    return string_to_hex(str, FALSE, len, hex, hex_len, skipped, ret_flags);
+}
+
 BOOL WINAPI CryptStringToBinaryA(LPCSTR pszString,
  DWORD cchString, DWORD dwFlags, BYTE *pbBinary, DWORD *pcbBinary,
  DWORD *pdwSkip, DWORD *pdwFlags)
@@ -928,6 +1102,8 @@ BOOL WINAPI CryptStringToBinaryA(LPCSTR pszString,
         decoder = DecodeAnyA;
         break;
     case CRYPT_STRING_HEX:
+        decoder = string_to_hexA;
+        break;
     case CRYPT_STRING_HEXASCII:
     case CRYPT_STRING_HEXADDR:
     case CRYPT_STRING_HEXASCIIADDR:
@@ -1094,6 +1270,11 @@ static LONG DecodeAnyW(LPCWSTR pszString, DWORD cchString,
     return ret;
 }
 
+static LONG string_to_hexW(const WCHAR *str, DWORD len, BYTE *hex, DWORD *hex_len, DWORD *skipped, DWORD *ret_flags)
+{
+    return string_to_hex(str, TRUE, len, hex, hex_len, skipped, ret_flags);
+}
+
 BOOL WINAPI CryptStringToBinaryW(LPCWSTR pszString,
  DWORD cchString, DWORD dwFlags, BYTE *pbBinary, DWORD *pcbBinary,
  DWORD *pdwSkip, DWORD *pdwFlags)
@@ -1139,6 +1320,8 @@ BOOL WINAPI CryptStringToBinaryW(LPCWSTR pszString,
         decoder = DecodeAnyW;
         break;
     case CRYPT_STRING_HEX:
+        decoder = string_to_hexW;
+        break;
     case CRYPT_STRING_HEXASCII:
     case CRYPT_STRING_HEXADDR:
     case CRYPT_STRING_HEXASCIIADDR:
diff --git a/dlls/crypt32/cert.c b/dlls/crypt32/cert.c
index ad39b7d18c7..b57cc685212 100644
--- wine/dlls/crypt32/cert.c
+++ wine/dlls/crypt32/cert.c
@@ -1006,6 +1006,7 @@ BOOL WINAPI CryptAcquireCertificatePrivateKey(PCCERT_CONTEXT pCert,
     CryptMemFree(info);
     if (cert_in_store)
         CertFreeCertificateContext(cert_in_store);
+    if (ret) SetLastError(0);
     return ret;
 }
 
diff --git a/dlls/crypt32/chain.c b/dlls/crypt32/chain.c
index cf244f2ac6c..4a60e9a60ff 100644
--- wine/dlls/crypt32/chain.c
+++ wine/dlls/crypt32/chain.c
@@ -3696,6 +3696,44 @@ static BYTE msPubKey4[] = {
 0xa6,0xc6,0x48,0x4c,0xc3,0x37,0x51,0x23,0xd3,0x27,0xd7,0xb8,0x4e,0x70,0x96,
 0xf0,0xa1,0x44,0x76,0xaf,0x78,0xcf,0x9a,0xe1,0x66,0x13,0x02,0x03,0x01,0x00,
 0x01 };
+/* from Microsoft Root Certificate Authority 2011 */
+static BYTE msPubKey5[] = {
+0x30,0x82,0x02,0x0a,0x02,0x82,0x02,0x01,0x00,0xb2,0x80,0x41,0xaa,0x35,0x38,
+0x4d,0x13,0x72,0x32,0x68,0x22,0x4d,0xb8,0xb2,0xf1,0xff,0xd5,0x52,0xbc,0x6c,
+0xc7,0xf5,0xd2,0x4a,0x8c,0x36,0xee,0xd1,0xc2,0x5c,0x7e,0x8c,0x8a,0xae,0xaf,
+0x13,0x28,0x6f,0xc0,0x73,0xe3,0x3a,0xce,0xd0,0x25,0xa8,0x5a,0x3a,0x6d,0xef,
+0xa8,0xb8,0x59,0xab,0x13,0x23,0x68,0xcd,0x0c,0x29,0x87,0xd1,0x6f,0x80,0x5c,
+0x8f,0x44,0x7f,0x5d,0x90,0x01,0x52,0x58,0xac,0x51,0xc5,0x5f,0x2a,0x87,0xdc,
+0xdc,0xd8,0x0a,0x1d,0xc1,0x03,0xb9,0x7b,0xb0,0x56,0xe8,0xa3,0xde,0x64,0x61,
+0xc2,0x9e,0xf8,0xf3,0x7c,0xb9,0xec,0x0d,0xb5,0x54,0xfe,0x4c,0xb6,0x65,0x4f,
+0x88,0xf0,0x9c,0x48,0x99,0x0c,0x42,0x0b,0x09,0x7c,0x31,0x59,0x17,0x79,0x06,
+0x78,0x28,0x8d,0x89,0x3a,0x4c,0x03,0x25,0xbe,0x71,0x6a,0x5c,0x0b,0xe7,0x84,
+0x60,0xa4,0x99,0x22,0xe3,0xd2,0xaf,0x84,0xa4,0xa7,0xfb,0xd1,0x98,0xed,0x0c,
+0xa9,0xde,0x94,0x89,0xe1,0x0e,0xa0,0xdc,0xc0,0xce,0x99,0x3d,0xea,0x08,0x52,
+0xbb,0x56,0x79,0xe4,0x1f,0x84,0xba,0x1e,0xb8,0xb4,0xc4,0x49,0x5c,0x4f,0x31,
+0x4b,0x87,0xdd,0xdd,0x05,0x67,0x26,0x99,0x80,0xe0,0x71,0x11,0xa3,0xb8,0xa5,
+0x41,0xe2,0xa4,0x53,0xb9,0xf7,0x32,0x29,0x83,0x0c,0x13,0xbf,0x36,0x5e,0x04,
+0xb3,0x4b,0x43,0x47,0x2f,0x6b,0xe2,0x91,0x1e,0xd3,0x98,0x4f,0xdd,0x42,0x07,
+0xc8,0xe8,0x1d,0x12,0xfc,0x99,0xa9,0x6b,0x3e,0x92,0x7e,0xc8,0xd6,0x69,0x3a,
+0xfc,0x64,0xbd,0xb6,0x09,0x9d,0xca,0xfd,0x0c,0x0b,0xa2,0x9b,0x77,0x60,0x4b,
+0x03,0x94,0xa4,0x30,0x69,0x12,0xd6,0x42,0x2d,0xc1,0x41,0x4c,0xca,0xdc,0xaa,
+0xfd,0x8f,0x5b,0x83,0x46,0x9a,0xd9,0xfc,0xb1,0xd1,0xe3,0xb3,0xc9,0x7f,0x48,
+0x7a,0xcd,0x24,0xf0,0x41,0x8f,0x5c,0x74,0xd0,0xac,0xb0,0x10,0x20,0x06,0x49,
+0xb7,0xc7,0x2d,0x21,0xc8,0x57,0xe3,0xd0,0x86,0xf3,0x03,0x68,0xfb,0xd0,0xce,
+0x71,0xc1,0x89,0x99,0x4a,0x64,0x01,0x6c,0xfd,0xec,0x30,0x91,0xcf,0x41,0x3c,
+0x92,0xc7,0xe5,0xba,0x86,0x1d,0x61,0x84,0xc7,0x5f,0x83,0x39,0x62,0xae,0xb4,
+0x92,0x2f,0x47,0xf3,0x0b,0xf8,0x55,0xeb,0xa0,0x1f,0x59,0xd0,0xbb,0x74,0x9b,
+0x1e,0xd0,0x76,0xe6,0xf2,0xe9,0x06,0xd7,0x10,0xe8,0xfa,0x64,0xde,0x69,0xc6,
+0x35,0x96,0x88,0x02,0xf0,0x46,0xb8,0x3f,0x27,0x99,0x6f,0xcb,0x71,0x89,0x29,
+0x35,0xf7,0x48,0x16,0x02,0x35,0x8f,0xd5,0x79,0x7c,0x4d,0x02,0xcf,0x5f,0xeb,
+0x8a,0x83,0x4f,0x45,0x71,0x88,0xf9,0xa9,0x0d,0x4e,0x72,0xe9,0xc2,0x9c,0x07,
+0xcf,0x49,0x1b,0x4e,0x04,0x0e,0x63,0x51,0x8c,0x5e,0xd8,0x00,0xc1,0x55,0x2c,
+0xb6,0xc6,0xe0,0xc2,0x65,0x4e,0xc9,0x34,0x39,0xf5,0x9c,0xb3,0xc4,0x7e,0xe8,
+0x61,0x6e,0x13,0x5f,0x15,0xc4,0x5f,0xd9,0x7e,0xed,0x1d,0xce,0xee,0x44,0xec,
+0xcb,0x2e,0x86,0xb1,0xec,0x38,0xf6,0x70,0xed,0xab,0x5c,0x13,0xc1,0xd9,0x0f,
+0x0d,0xc7,0x80,0xb2,0x55,0xed,0x34,0xf7,0xac,0x9b,0xe4,0xc3,0xda,0xe7,0x47,
+0x3c,0xa6,0xb5,0x8f,0x31,0xdf,0xc5,0x4b,0xaf,0xeb,0xf1,0x02,0x03,0x01,0x00,
+0x01 };
 
 static BOOL WINAPI verify_ms_root_policy(LPCSTR szPolicyOID,
  PCCERT_CHAIN_CONTEXT pChainContext, PCERT_CHAIN_POLICY_PARA pPolicyPara,
@@ -3705,21 +3743,38 @@ static BOOL WINAPI verify_ms_root_policy(LPCSTR szPolicyOID,
 
     CERT_PUBLIC_KEY_INFO msPubKey = { { 0 } };
     DWORD i;
-    CRYPT_DATA_BLOB keyBlobs[] = {
+    static const CRYPT_DATA_BLOB keyBlobs[] = {
         { sizeof(msPubKey1), msPubKey1 },
         { sizeof(msPubKey2), msPubKey2 },
         { sizeof(msPubKey3), msPubKey3 },
         { sizeof(msPubKey4), msPubKey4 },
     };
+    static const CRYPT_DATA_BLOB keyBlobs_approot[] = {
+        { sizeof(msPubKey5), msPubKey5 },
+    };
     PCERT_SIMPLE_CHAIN rootChain =
         pChainContext->rgpChain[pChainContext->cChain - 1];
     PCCERT_CONTEXT root =
         rootChain->rgpElement[rootChain->cElement - 1]->pCertContext;
 
-    for (i = 0; !isMSRoot && i < ARRAY_SIZE(keyBlobs); i++)
+    const CRYPT_DATA_BLOB *keys;
+    unsigned int key_count;
+
+    if (pPolicyPara && pPolicyPara->dwFlags & MICROSOFT_ROOT_CERT_CHAIN_POLICY_CHECK_APPLICATION_ROOT_FLAG)
+    {
+        keys = keyBlobs_approot;
+        key_count = ARRAY_SIZE(keyBlobs_approot);
+    }
+    else
+    {
+        keys = keyBlobs;
+        key_count = ARRAY_SIZE(keyBlobs);
+    }
+
+    for (i = 0; !isMSRoot && i < key_count; i++)
     {
-        msPubKey.PublicKey.cbData = keyBlobs[i].cbData;
-        msPubKey.PublicKey.pbData = keyBlobs[i].pbData;
+        msPubKey.PublicKey.cbData = keys[i].cbData;
+        msPubKey.PublicKey.pbData = keys[i].pbData;
         if (CertComparePublicKeyInfo(X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                 &root->pCertInfo->SubjectPublicKeyInfo, &msPubKey)) isMSRoot = TRUE;
     }
diff --git a/dlls/crypt32/decode.c b/dlls/crypt32/decode.c
index 762d1b54661..19643194b49 100644
--- wine/dlls/crypt32/decode.c
+++ wine/dlls/crypt32/decode.c
@@ -3874,7 +3874,7 @@ static BOOL WINAPI CRYPT_AsnDecodeCertPolicyConstraints(
 
 struct DECODED_RSA_PUB_KEY
 {
-    DWORD              pubexp;
+    CRYPT_INTEGER_BLOB pubexp;
     CRYPT_INTEGER_BLOB modulus;
 };
 
@@ -3893,12 +3893,23 @@ static BOOL CRYPT_raw_decode_rsa_pub_key(struct DECODED_RSA_PUB_KEY **decodedKey
        FALSE, TRUE, offsetof(struct DECODED_RSA_PUB_KEY, modulus.pbData),
        0 },
      { ASN_INTEGER, offsetof(struct DECODED_RSA_PUB_KEY, pubexp),
-       CRYPT_AsnDecodeIntInternal, sizeof(DWORD), FALSE, FALSE, 0, 0 },
+       CRYPT_AsnDecodeUnsignedIntegerInternal, sizeof(CRYPT_INTEGER_BLOB),
+       FALSE, TRUE, offsetof(struct DECODED_RSA_PUB_KEY, pubexp.pbData),
+       0 },
     };
 
     ret = CRYPT_AsnDecodeSequence(items, ARRAY_SIZE(items),
      pbEncoded, cbEncoded, CRYPT_DECODE_ALLOC_FLAG, NULL, decodedKey,
      size, NULL, NULL);
+
+    if (ret && (*decodedKey)->pubexp.cbData > sizeof(DWORD))
+    {
+        WARN("Unexpected exponent length %lu.\n", (*decodedKey)->pubexp.cbData);
+        LocalFree(*decodedKey);
+        SetLastError(CRYPT_E_ASN1_LARGE);
+        ret = FALSE;
+    }
+
     return ret;
 }
 
@@ -3920,7 +3931,7 @@ static BOOL WINAPI CRYPT_AsnDecodeRsaPubKey_Bcrypt(DWORD dwCertEncodingType,
         if (ret)
         {
             /* Header, exponent, and modulus */
-            DWORD bytesNeeded = sizeof(BCRYPT_RSAKEY_BLOB) + sizeof(DWORD) +
+            DWORD bytesNeeded = sizeof(BCRYPT_RSAKEY_BLOB) + decodedKey->pubexp.cbData +
              decodedKey->modulus.cbData;
 
             if (!pvStructInfo)
@@ -3939,7 +3950,7 @@ static BOOL WINAPI CRYPT_AsnDecodeRsaPubKey_Bcrypt(DWORD dwCertEncodingType,
                 hdr = pvStructInfo;
                 hdr->Magic = BCRYPT_RSAPUBLIC_MAGIC;
                 hdr->BitLength = decodedKey->modulus.cbData * 8;
-                hdr->cbPublicExp = sizeof(DWORD);
+                hdr->cbPublicExp = decodedKey->pubexp.cbData;
                 hdr->cbModulus = decodedKey->modulus.cbData;
                 hdr->cbPrime1 = 0;
                 hdr->cbPrime2 = 0;
@@ -3947,9 +3958,9 @@ static BOOL WINAPI CRYPT_AsnDecodeRsaPubKey_Bcrypt(DWORD dwCertEncodingType,
                  * in big-endian format, so we need to convert from little-endian
                  */
                 CRYPT_CopyReversed((BYTE *)pvStructInfo + sizeof(BCRYPT_RSAKEY_BLOB),
-                 (BYTE *)&decodedKey->pubexp, sizeof(DWORD));
+                 decodedKey->pubexp.pbData, hdr->cbPublicExp);
                 CRYPT_CopyReversed((BYTE *)pvStructInfo + sizeof(BCRYPT_RSAKEY_BLOB) +
-                 sizeof(DWORD), decodedKey->modulus.pbData,
+                 hdr->cbPublicExp, decodedKey->modulus.pbData,
                  decodedKey->modulus.cbData);
             }
             LocalFree(decodedKey);
@@ -3984,13 +3995,13 @@ static BOOL WINAPI CRYPT_AsnDecodeRsaPubKey(DWORD dwCertEncodingType,
             if (!pvStructInfo)
             {
                 *pcbStructInfo = bytesNeeded;
-                ret = TRUE;
             }
             else if ((ret = CRYPT_DecodeEnsureSpace(dwFlags, pDecodePara,
              pvStructInfo, pcbStructInfo, bytesNeeded)))
             {
                 BLOBHEADER *hdr;
                 RSAPUBKEY *rsaPubKey;
+                unsigned int i;
 
                 if (dwFlags & CRYPT_DECODE_ALLOC_FLAG)
                     pvStructInfo = *(BYTE **)pvStructInfo;
@@ -4002,7 +4013,11 @@ static BOOL WINAPI CRYPT_AsnDecodeRsaPubKey(DWORD dwCertEncodingType,
                 rsaPubKey = (RSAPUBKEY *)((BYTE *)pvStructInfo +
                  sizeof(BLOBHEADER));
                 rsaPubKey->magic = RSA1_MAGIC;
-                rsaPubKey->pubexp = decodedKey->pubexp;
+                rsaPubKey->pubexp = 0;
+                assert(decodedKey->pubexp.cbData <= sizeof(rsaPubKey->pubexp));
+                for (i = 0; i < decodedKey->pubexp.cbData; ++i)
+                    rsaPubKey->pubexp |= decodedKey->pubexp.pbData[i] << (i * 8);
+
                 rsaPubKey->bitlen = decodedKey->modulus.cbData * 8;
                 memcpy((BYTE *)pvStructInfo + sizeof(BLOBHEADER) +
                  sizeof(RSAPUBKEY), decodedKey->modulus.pbData,
@@ -6351,6 +6366,112 @@ static BOOL CRYPT_AsnDecodeOCSPNextUpdate(const BYTE *pbEncoded,
     return ret;
 }
 
+static BOOL CRYPT_AsnDecodeCertStatus(const BYTE *pbEncoded,
+ DWORD cbEncoded, DWORD dwFlags, void *pvStructInfo, DWORD *pcbStructInfo,
+ DWORD *pcbDecoded)
+{
+    BOOL ret = TRUE;
+    BYTE tag = pbEncoded[0] & ~3, status = pbEncoded[0] & 3;
+    DWORD bytesNeeded = FIELD_OFFSET(OCSP_BASIC_RESPONSE_ENTRY, ThisUpdate) -
+                        FIELD_OFFSET(OCSP_BASIC_RESPONSE_ENTRY, dwCertStatus);
+
+    if (!cbEncoded)
+    {
+        SetLastError(CRYPT_E_ASN1_EOD);
+        return FALSE;
+    }
+
+    switch (status)
+    {
+    case 0:
+        if (tag != ASN_CONTEXT)
+        {
+            WARN("Unexpected tag %02x\n", tag);
+            SetLastError(CRYPT_E_ASN1_BADTAG);
+            return FALSE;
+        }
+        if (cbEncoded < 2 || pbEncoded[1])
+        {
+            SetLastError(CRYPT_E_ASN1_CORRUPT);
+            return FALSE;
+        }
+        if (!pvStructInfo)
+            *pcbStructInfo = bytesNeeded;
+        else if (*pcbStructInfo < bytesNeeded)
+        {
+            *pcbStructInfo = bytesNeeded;
+            SetLastError(ERROR_MORE_DATA);
+            return FALSE;
+        }
+        if (pvStructInfo)
+        {
+            *(DWORD *)pvStructInfo = 0;
+            *(OCSP_BASIC_REVOKED_INFO **)((char *)pvStructInfo
+                + FIELD_OFFSET(OCSP_BASIC_RESPONSE_ENTRY, u.pRevokedInfo)
+                - FIELD_OFFSET(OCSP_BASIC_RESPONSE_ENTRY, dwCertStatus)) = NULL;
+        }
+        *pcbStructInfo = bytesNeeded;
+        *pcbDecoded = 2;
+        break;
+
+    case 1:
+    {
+        DWORD dataLen;
+
+        if (tag != (ASN_CONTEXT | ASN_CONSTRUCTOR))
+        {
+            WARN("Unexpected tag %02x\n", tag);
+            SetLastError(CRYPT_E_ASN1_BADTAG);
+            return FALSE;
+        }
+        if ((ret = CRYPT_GetLen(pbEncoded, cbEncoded, &dataLen)))
+        {
+            BYTE lenBytes = GET_LEN_BYTES(pbEncoded[1]);
+            DWORD bytesDecoded, size;
+            FILETIME date;
+
+            if (dataLen)
+            {
+                size = sizeof(date);
+                ret = CRYPT_AsnDecodeGeneralizedTime(pbEncoded + 1 + lenBytes, cbEncoded - 1 - lenBytes,
+                 dwFlags, &date, &size, &bytesDecoded);
+                if (ret)
+                {
+                    OCSP_BASIC_REVOKED_INFO *info;
+
+                    bytesNeeded += sizeof(*info);
+                    if (!pvStructInfo)
+                        *pcbStructInfo = bytesNeeded;
+                    else if (*pcbStructInfo < bytesNeeded)
+                    {
+                        *pcbStructInfo = bytesNeeded;
+                        SetLastError(ERROR_MORE_DATA);
+                        return FALSE;
+                    }
+                    if (pvStructInfo)
+                    {
+                        *(DWORD *)pvStructInfo = 1;
+                        info = *(OCSP_BASIC_REVOKED_INFO **)((char *)pvStructInfo
+                            + FIELD_OFFSET(OCSP_BASIC_RESPONSE_ENTRY, u.pRevokedInfo)
+                            - FIELD_OFFSET(OCSP_BASIC_RESPONSE_ENTRY, dwCertStatus));
+                        info->RevocationDate = date;
+                    }
+                    *pcbStructInfo = bytesNeeded;
+                    *pcbDecoded = 1 + lenBytes + bytesDecoded;
+                }
+            }
+        }
+        break;
+    }
+    default:
+        FIXME("Unhandled status %u\n", status);
+        SetLastError(CRYPT_E_ASN1_BADTAG);
+        return FALSE;
+    }
+
+    return ret;
+}
+
 static BOOL CRYPT_AsnDecodeOCSPBasicResponseEntry(const BYTE *pbEncoded, DWORD cbEncoded,
  DWORD dwFlags, void *pvStructInfo, DWORD *pcbStructInfo, DWORD *pcbDecoded)
 {
@@ -6367,10 +6488,9 @@ static BOOL CRYPT_AsnDecodeOCSPBasicResponseEntry(const BYTE *pbEncoded, DWORD c
      { ASN_INTEGER, offsetof(OCSP_BASIC_RESPONSE_ENTRY, CertId.SerialNumber),
        CRYPT_AsnDecodeIntegerInternal, sizeof(CRYPT_INTEGER_BLOB), FALSE, TRUE,
        offsetof(OCSP_BASIC_RESPONSE_ENTRY, CertId.SerialNumber.pbData), 0 },
-     { ASN_CONTEXT, offsetof(OCSP_BASIC_RESPONSE_ENTRY, dwCertStatus),
-       CRYPT_AsnDecodeIntInternal, sizeof(DWORD), FALSE, FALSE,
-       0, 0 },
-      /* FIXME: pRevokedInfo */
+     { 0, offsetof(OCSP_BASIC_RESPONSE_ENTRY, dwCertStatus),
+       CRYPT_AsnDecodeCertStatus, sizeof(DWORD), FALSE, TRUE,
+       offsetof(OCSP_BASIC_RESPONSE_ENTRY, u.pRevokedInfo), 0 },
      { ASN_GENERALTIME, offsetof(OCSP_BASIC_RESPONSE_ENTRY, ThisUpdate),
        CRYPT_AsnDecodeGeneralizedTime, sizeof(FILETIME), FALSE, FALSE,
        0, 0 },
@@ -6401,13 +6521,13 @@ static BOOL CRYPT_AsnDecodeOCSPBasicResponseEntriesArray(const BYTE *pbEncoded,
      dwFlags, NULL, pvStructInfo, pcbStructInfo, pcbDecoded);
 }
 
-static BOOL CRYPT_AsnDecodeResponderID(const BYTE *pbEncoded,
+static BOOL CRYPT_AsnDecodeResponderIDByName(const BYTE *pbEncoded,
  DWORD cbEncoded, DWORD dwFlags, void *pvStructInfo, DWORD *pcbStructInfo,
  DWORD *pcbDecoded)
 {
     OCSP_BASIC_RESPONSE_INFO *info = pvStructInfo;
-    BYTE tag = pbEncoded[0] & ~3, choice = pbEncoded[0] & 3;
-    DWORD decodedLen, dataLen, lenBytes, bytesNeeded = sizeof(*info), len;
+    DWORD dataLen, decodedLen, lenBytes, bytesNeeded = sizeof(*info);
+    BYTE tag = pbEncoded[0] & ~3;
     CERT_NAME_BLOB *blob;
 
     if (tag != (ASN_CONTEXT | ASN_CONSTRUCTOR))
@@ -6416,15 +6536,78 @@ static BOOL CRYPT_AsnDecodeResponderID(const BYTE *pbEncoded,
         SetLastError(CRYPT_E_ASN1_BADTAG);
         return FALSE;
     }
-    if (choice > 2)
+
+    if (!CRYPT_GetLen(pbEncoded, cbEncoded, &dataLen))
+        return FALSE;
+    lenBytes = GET_LEN_BYTES(pbEncoded[1]);
+    cbEncoded -= 1 + lenBytes;
+
+    if (dataLen > cbEncoded)
     {
-        WARN("Unexpected choice %02x\n", choice);
-        SetLastError(CRYPT_E_ASN1_CORRUPT);
+        SetLastError(CRYPT_E_ASN1_EOD);
+        return FALSE;
+    }
+    pbEncoded += 1 + lenBytes;
+    decodedLen = 1 + lenBytes + dataLen;
+
+    if (pbEncoded[0] != ASN_SEQUENCE)
+    {
+        WARN("Unexpected tag %02x %02x\n", pbEncoded[0], pbEncoded[1]);
+        SetLastError(CRYPT_E_ASN1_BADTAG);
         return FALSE;
     }
 
+    if (!(dwFlags & CRYPT_DECODE_NOCOPY_FLAG)) bytesNeeded += dataLen;
     if (pvStructInfo && *pcbStructInfo >= bytesNeeded)
-        info->dwResponderIdChoice = choice;
+    {
+        info->dwResponderIdChoice = 1;
+
+        blob = &info->u.ByNameResponderId;
+        blob->cbData = dataLen;
+        if (dwFlags & CRYPT_DECODE_NOCOPY_FLAG)
+            blob->pbData = (BYTE *)pbEncoded;
+        else if (blob->cbData)
+        {
+            blob->pbData = (BYTE *)(info + 1);
+            memcpy(blob->pbData, pbEncoded, blob->cbData);
+        }
+    }
+
+    if (pcbDecoded)
+        *pcbDecoded = decodedLen;
+
+    if (!pvStructInfo)
+    {
+        *pcbStructInfo = bytesNeeded;
+        return TRUE;
+    }
+
+    if (*pcbStructInfo < bytesNeeded)
+    {
+        SetLastError(ERROR_MORE_DATA);
+        *pcbStructInfo = bytesNeeded;
+        return FALSE;
+    }
+
+    *pcbStructInfo = bytesNeeded;
+    return TRUE;
+}
+
+static BOOL CRYPT_AsnDecodeResponderIDByKey(const BYTE *pbEncoded,
+ DWORD cbEncoded, DWORD dwFlags, void *pvStructInfo, DWORD *pcbStructInfo,
+ DWORD *pcbDecoded)
+{
+    OCSP_BASIC_RESPONSE_INFO *info = pvStructInfo;
+    DWORD dataLen, decodedLen, lenBytes, bytesNeeded = sizeof(*info), len;
+    BYTE tag = pbEncoded[0] & ~3;
+    CRYPT_HASH_BLOB *blob;
+
+    if (tag != (ASN_CONTEXT | ASN_CONSTRUCTOR))
+    {
+        WARN("Unexpected tag %02x\n", tag);
+        SetLastError(CRYPT_E_ASN1_BADTAG);
+        return FALSE;
+    }
 
     if (!CRYPT_GetLen(pbEncoded, cbEncoded, &dataLen))
         return FALSE;
@@ -6461,7 +6644,8 @@ static BOOL CRYPT_AsnDecodeResponderID(const BYTE *pbEncoded,
     if (!(dwFlags & CRYPT_DECODE_NOCOPY_FLAG)) bytesNeeded += len;
     if (pvStructInfo && *pcbStructInfo >= bytesNeeded)
     {
-        blob = &info->u.ByNameResponderId;
+        info->dwResponderIdChoice = 2;
+        blob = &info->u.ByKeyResponderId;
         blob->cbData = len;
         if (dwFlags & CRYPT_DECODE_NOCOPY_FLAG)
             blob->pbData = (BYTE *)pbEncoded;
@@ -6492,6 +6676,28 @@ static BOOL CRYPT_AsnDecodeResponderID(const BYTE *pbEncoded,
     return TRUE;
 }
 
+static BOOL CRYPT_AsnDecodeResponderID(const BYTE *pbEncoded,
+ DWORD cbEncoded, DWORD dwFlags, void *pvStructInfo, DWORD *pcbStructInfo,
+ DWORD *pcbDecoded)
+{
+    BYTE choice = pbEncoded[0] & 3;
+
+    TRACE("choice %02x\n", choice);
+    switch (choice)
+    {
+    case 1:
+        return CRYPT_AsnDecodeResponderIDByName(pbEncoded, cbEncoded, dwFlags,
+                pvStructInfo, pcbStructInfo, pcbDecoded);
+    case 2:
+        return CRYPT_AsnDecodeResponderIDByKey(pbEncoded, cbEncoded, dwFlags,
+                pvStructInfo, pcbStructInfo, pcbDecoded);
+    default:
+        WARN("Unexpected choice %02x\n", choice);
+        SetLastError(CRYPT_E_ASN1_CORRUPT);
+        return FALSE;
+    }
+}
+
 static BOOL WINAPI CRYPT_AsnDecodeOCSPBasicResponse(DWORD dwCertEncodingType,
  LPCSTR lpszStructType, const BYTE *pbEncoded, DWORD cbEncoded, DWORD dwFlags,
  CRYPT_DECODE_PARA *pDecodePara, void *pvStructInfo, DWORD *pcbStructInfo)
diff --git a/dlls/crypt32/encode.c b/dlls/crypt32/encode.c
index 8086ad2fc0a..8968eb9f15a 100644
--- wine/dlls/crypt32/encode.c
+++ wine/dlls/crypt32/encode.c
@@ -4500,7 +4500,7 @@ static BOOL WINAPI CRYPT_AsnEncodeCertId(DWORD dwCertEncodingType,
     return ret;
 }
 
-static BOOL WINAPI CRYPT_AsnEncodeOCSPRequestEntry(DWORD dwCertEncodingType,
+static BOOL CRYPT_AsnEncodeOCSPRequestEntry(DWORD dwCertEncodingType,
  LPCSTR lpszStructType, const void *pvStructInfo, DWORD dwFlags,
  PCRYPT_ENCODE_PARA pEncodePara, BYTE *pbEncoded, DWORD *pcbEncoded)
 {
diff --git a/dlls/crypt32/object.c b/dlls/crypt32/object.c
index 8123ed73351..4440c9e0498 100644
--- wine/dlls/crypt32/object.c
+++ wine/dlls/crypt32/object.c
@@ -643,7 +643,7 @@ static BOOL CRYPT_QueryEmbeddedMessageObject(DWORD dwObjectType,
         }
         file = CreateFileW(temp_name, GENERIC_READ | GENERIC_WRITE, 0,
                 NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_DELETE_ON_CLOSE, NULL);
-        if (file == INVALID_HANDLE_VALUE)
+        if (!file)
         {
             ERR("Could not create temp file.\n");
             SetLastError(ERROR_OUTOFMEMORY);
diff --git a/dlls/crypt32/str.c b/dlls/crypt32/str.c
index 277aeb70d4a..d74df308e4a 100644
--- wine/dlls/crypt32/str.c
+++ wine/dlls/crypt32/str.c
@@ -29,77 +29,45 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(crypt);
 
-DWORD WINAPI CertRDNValueToStrA(DWORD dwValueType, PCERT_RDN_VALUE_BLOB pValue,
- LPSTR psz, DWORD csz)
+DWORD WINAPI CertRDNValueToStrA(DWORD type, PCERT_RDN_VALUE_BLOB value_blob,
+                                LPSTR value, DWORD value_len)
 {
-    DWORD ret = 0, len;
+    DWORD len, len_mb, ret;
+    LPWSTR valueW;
 
-    TRACE("(%ld, %p, %p, %ld)\n", dwValueType, pValue, psz, csz);
+    TRACE("(%ld, %p, %p, %ld)\n", type, value_blob, value, value_len);
 
-    switch (dwValueType)
-    {
-    case CERT_RDN_ANY_TYPE:
-        break;
-    case CERT_RDN_NUMERIC_STRING:
-    case CERT_RDN_PRINTABLE_STRING:
-    case CERT_RDN_TELETEX_STRING:
-    case CERT_RDN_VIDEOTEX_STRING:
-    case CERT_RDN_IA5_STRING:
-    case CERT_RDN_GRAPHIC_STRING:
-    case CERT_RDN_VISIBLE_STRING:
-    case CERT_RDN_GENERAL_STRING:
-        len = pValue->cbData;
-        if (!psz || !csz)
-            ret = len;
-        else
-        {
-            DWORD chars = min(len, csz - 1);
+    len = CertRDNValueToStrW(type, value_blob, NULL, 0);
 
-            if (chars)
-            {
-                memcpy(psz, pValue->pbData, chars);
-                ret += chars;
-                csz -= chars;
-            }
-        }
-        break;
-    case CERT_RDN_BMP_STRING:
-    case CERT_RDN_UTF8_STRING:
-        len = WideCharToMultiByte(CP_ACP, 0, (LPCWSTR)pValue->pbData,
-         pValue->cbData / sizeof(WCHAR), NULL, 0, NULL, NULL);
-        if (!psz || !csz)
-            ret = len;
-        else
-        {
-            DWORD chars = min(pValue->cbData / sizeof(WCHAR), csz - 1);
+    if (!(valueW = CryptMemAlloc(len * sizeof(*valueW))))
+    {
+        ERR("No memory.\n");
+        if (value && value_len) *value = 0;
+        return 1;
+    }
 
-            if (chars)
-            {
-                ret = WideCharToMultiByte(CP_ACP, 0, (LPCWSTR)pValue->pbData,
-                 chars, psz, csz - 1, NULL, NULL);
-                csz -= ret;
-            }
-        }
-        break;
-    default:
-        FIXME("string type %ld unimplemented\n", dwValueType);
+    len = CertRDNValueToStrW(type, value_blob, valueW, len);
+    len_mb = WideCharToMultiByte(CP_ACP, 0, valueW, len, NULL, 0, NULL, NULL);
+    if (!value || !value_len)
+    {
+        CryptMemFree(valueW);
+        return len_mb;
     }
-    if (psz && csz)
+
+    ret = WideCharToMultiByte(CP_ACP, 0, valueW, len, value, value_len, NULL, NULL);
+    if (ret < len_mb)
     {
-        *(psz + ret) = '\0';
-        csz--;
-        ret++;
+        value[0] = 0;
+        ret = 1;
     }
-    else
-        ret++;
-    TRACE("returning %ld (%s)\n", ret, debugstr_a(psz));
+    CryptMemFree(valueW);
     return ret;
 }
 
-DWORD WINAPI CertRDNValueToStrW(DWORD dwValueType, PCERT_RDN_VALUE_BLOB pValue,
- LPWSTR psz, DWORD csz)
+static DWORD rdn_value_to_strW(DWORD dwValueType, PCERT_RDN_VALUE_BLOB pValue,
+                               LPWSTR psz, DWORD csz, BOOL partial_copy)
 {
-    DWORD ret = 0, len, i, strLen;
+    DWORD ret = 0, len, i;
 
     TRACE("(%ld, %p, %p, %ld)\n", dwValueType, pValue, psz, csz);
 
@@ -116,44 +84,42 @@ DWORD WINAPI CertRDNValueToStrW(DWORD dwValueType, PCERT_RDN_VALUE_BLOB pValue,
     case CERT_RDN_VISIBLE_STRING:
     case CERT_RDN_GENERAL_STRING:
         len = pValue->cbData;
-        if (!psz || !csz)
-            ret = len;
-        else
+        if (!psz || !csz) ret = len;
+        else if (len < csz || partial_copy)
         {
-            WCHAR *ptr = psz;
-
-            for (i = 0; i < pValue->cbData && ptr - psz < csz; ptr++, i++)
-                *ptr = pValue->pbData[i];
-            ret = ptr - psz;
+            len = min(len, csz - 1);
+            for (i = 0; i < len; ++i)
+                psz[i] = pValue->pbData[i];
+            ret = len;
         }
         break;
     case CERT_RDN_BMP_STRING:
     case CERT_RDN_UTF8_STRING:
-        strLen = len = pValue->cbData / sizeof(WCHAR);
+        len = pValue->cbData / sizeof(WCHAR);
         if (!psz || !csz)
             ret = len;
-        else
+        else if (len < csz || partial_copy)
         {
             WCHAR *ptr = psz;
 
-            for (i = 0; i < strLen && ptr - psz < csz; ptr++, i++)
-                *ptr = ((LPCWSTR)pValue->pbData)[i];
-            ret = ptr - psz;
+            len = min(len, csz - 1);
+            for (i = 0; i < len; ++i)
+                ptr[i] = ((LPCWSTR)pValue->pbData)[i];
+            ret = len;
         }
         break;
     default:
         FIXME("string type %ld unimplemented\n", dwValueType);
     }
-    if (psz && csz)
-    {
-        *(psz + ret) = '\0';
-        csz--;
-        ret++;
-    }
-    else
-        ret++;
-    TRACE("returning %ld (%s)\n", ret, debugstr_w(psz));
-    return ret;
+    if (psz && csz) psz[ret] = 0;
+    TRACE("returning %ld (%s)\n", ret + 1, debugstr_w(psz));
+    return ret + 1;
+}
+
+DWORD WINAPI CertRDNValueToStrW(DWORD dwValueType, PCERT_RDN_VALUE_BLOB pValue,
+                                LPWSTR psz, DWORD csz)
+{
+    return rdn_value_to_strW(dwValueType, pValue, psz, csz, FALSE);
 }
 
 static inline BOOL is_quotable_char(WCHAR c)
@@ -175,115 +141,6 @@ static inline BOOL is_quotable_char(WCHAR c)
     }
 }
 
-static DWORD quote_rdn_value_to_str_a(DWORD dwValueType,
- PCERT_RDN_VALUE_BLOB pValue, LPSTR psz, DWORD csz)
-{
-    DWORD ret = 0, len, i;
-    BOOL needsQuotes = FALSE;
-
-    TRACE("(%ld, %p, %p, %ld)\n", dwValueType, pValue, psz, csz);
-
-    switch (dwValueType)
-    {
-    case CERT_RDN_ANY_TYPE:
-        break;
-    case CERT_RDN_NUMERIC_STRING:
-    case CERT_RDN_PRINTABLE_STRING:
-    case CERT_RDN_TELETEX_STRING:
-    case CERT_RDN_VIDEOTEX_STRING:
-    case CERT_RDN_IA5_STRING:
-    case CERT_RDN_GRAPHIC_STRING:
-    case CERT_RDN_VISIBLE_STRING:
-    case CERT_RDN_GENERAL_STRING:
-        len = pValue->cbData;
-        if (pValue->cbData && isspace(pValue->pbData[0]))
-            needsQuotes = TRUE;
-        if (pValue->cbData && isspace(pValue->pbData[pValue->cbData - 1]))
-            needsQuotes = TRUE;
-        for (i = 0; i < pValue->cbData; i++)
-        {
-            if (is_quotable_char(pValue->pbData[i]))
-                needsQuotes = TRUE;
-            if (pValue->pbData[i] == '"')
-                len += 1;
-        }
-        if (needsQuotes)
-            len += 2;
-        if (!psz || !csz)
-            ret = len;
-        else
-        {
-            char *ptr = psz;
-
-            if (needsQuotes)
-                *ptr++ = '"';
-            for (i = 0; i < pValue->cbData && ptr - psz < csz; ptr++, i++)
-            {
-                *ptr = pValue->pbData[i];
-                if (pValue->pbData[i] == '"' && ptr - psz < csz - 1)
-                    *(++ptr) = '"';
-            }
-            if (needsQuotes && ptr - psz < csz)
-                *ptr++ = '"';
-            ret = ptr - psz;
-        }
-        break;
-    case CERT_RDN_BMP_STRING:
-    case CERT_RDN_UTF8_STRING:
-        len = WideCharToMultiByte(CP_ACP, 0, (LPCWSTR)pValue->pbData,
-         pValue->cbData / sizeof(WCHAR), NULL, 0, NULL, NULL);
-        if (pValue->cbData && iswspace(((LPCWSTR)pValue->pbData)[0]))
-            needsQuotes = TRUE;
-        if (pValue->cbData &&
-         iswspace(((LPCWSTR)pValue->pbData)[pValue->cbData / sizeof(WCHAR)-1]))
-            needsQuotes = TRUE;
-        for (i = 0; i < pValue->cbData / sizeof(WCHAR); i++)
-        {
-            if (is_quotable_char(((LPCWSTR)pValue->pbData)[i]))
-                needsQuotes = TRUE;
-            if (((LPCWSTR)pValue->pbData)[i] == '"')
-                len += 1;
-        }
-        if (needsQuotes)
-            len += 2;
-        if (!psz || !csz)
-            ret = len;
-        else
-        {
-            char *dst = psz;
-
-            if (needsQuotes)
-                *dst++ = '"';
-            for (i = 0; i < pValue->cbData / sizeof(WCHAR) &&
-             dst - psz < csz; dst++, i++)
-            {
-                LPCWSTR src = (LPCWSTR)pValue->pbData + i;
-
-                WideCharToMultiByte(CP_ACP, 0, src, 1, dst,
-                 csz - (dst - psz) - 1, NULL, NULL);
-                if (*src == '"' && dst - psz < csz - 1)
-                    *(++dst) = '"';
-            }
-            if (needsQuotes && dst - psz < csz)
-                *dst++ = '"';
-            ret = dst - psz;
-        }
-        break;
-    default:
-        FIXME("string type %ld unimplemented\n", dwValueType);
-    }
-    if (psz && csz)
-    {
-        *(psz + ret) = '\0';
-        csz--;
-        ret++;
-    }
-    else
-        ret++;
-    TRACE("returning %ld (%s)\n", ret, debugstr_a(psz));
-    return ret;
-}
-
 static DWORD quote_rdn_value_to_str_w(DWORD dwValueType,
  PCERT_RDN_VALUE_BLOB pValue, LPWSTR psz, DWORD csz)
 {
@@ -375,148 +232,41 @@ static DWORD quote_rdn_value_to_str_w(DWORD dwValueType,
     default:
         FIXME("string type %ld unimplemented\n", dwValueType);
     }
-    if (psz && csz)
-    {
-        *(psz + ret) = '\0';
-        csz--;
-        ret++;
-    }
-    else
-        ret++;
     TRACE("returning %ld (%s)\n", ret, debugstr_w(psz));
     return ret;
 }
 
-/* Adds the prefix prefix to the string pointed to by psz, followed by the
- * character '='.  Copies no more than csz characters.  Returns the number of
- * characters copied.  If psz is NULL, returns the number of characters that
- * would be copied.
- */
-static DWORD CRYPT_AddPrefixA(LPCSTR prefix, LPSTR psz, DWORD csz)
+DWORD WINAPI CertNameToStrA(DWORD encoding_type, PCERT_NAME_BLOB name_blob, DWORD str_type, LPSTR str, DWORD str_len)
 {
-    DWORD chars;
+    DWORD len, len_mb, ret;
+    LPWSTR strW;
 
-    TRACE("(%s, %p, %ld)\n", debugstr_a(prefix), psz, csz);
+    TRACE("(%ld, %p, %08lx, %p, %ld)\n", encoding_type, name_blob, str_type, str, str_len);
 
-    if (psz)
+    len = CertNameToStrW(encoding_type, name_blob, str_type, NULL, 0);
+
+    if (!(strW = CryptMemAlloc(len * sizeof(*strW))))
     {
-        chars = min(strlen(prefix), csz);
-        memcpy(psz, prefix, chars);
-        *(psz + chars) = '=';
-        chars++;
+        ERR("No memory.\n");
+        if (str && str_len) *str = 0;
+        return 1;
     }
-    else
-        chars = lstrlenA(prefix) + 1;
-    return chars;
-}
 
-DWORD WINAPI CertNameToStrA(DWORD dwCertEncodingType, PCERT_NAME_BLOB pName,
- DWORD dwStrType, LPSTR psz, DWORD csz)
-{
-    static const DWORD unsupportedFlags = CERT_NAME_STR_NO_QUOTING_FLAG |
-     CERT_NAME_STR_ENABLE_T61_UNICODE_FLAG;
-    static const char commaSep[] = ", ";
-    static const char semiSep[] = "; ";
-    static const char crlfSep[] = "\r\n";
-    static const char plusSep[] = " + ";
-    static const char spaceSep[] = " ";
-    DWORD ret = 0, bytes = 0;
-    BOOL bRet;
-    CERT_NAME_INFO *info;
-
-    TRACE("(%ld, %p, %08lx, %p, %ld)\n", dwCertEncodingType, pName, dwStrType,
-     psz, csz);
-    if (dwStrType & unsupportedFlags)
-        FIXME("unsupported flags: %08lx\n", dwStrType & unsupportedFlags);
-
-    bRet = CryptDecodeObjectEx(dwCertEncodingType, X509_NAME, pName->pbData,
-     pName->cbData, CRYPT_DECODE_ALLOC_FLAG, NULL, &info, &bytes);
-    if (bRet)
+    len = CertNameToStrW(encoding_type, name_blob, str_type, strW, len);
+    len_mb = WideCharToMultiByte(CP_ACP, 0, strW, len, NULL, 0, NULL, NULL);
+    if (!str || !str_len)
     {
-        DWORD i, j, sepLen, rdnSepLen;
-        LPCSTR sep, rdnSep;
-        BOOL reverse = dwStrType & CERT_NAME_STR_REVERSE_FLAG;
-        const CERT_RDN *rdn = info->rgRDN;
-
-        if(reverse && info->cRDN > 1) rdn += (info->cRDN - 1);
-
-        if (dwStrType & CERT_NAME_STR_SEMICOLON_FLAG)
-            sep = semiSep;
-        else if (dwStrType & CERT_NAME_STR_CRLF_FLAG)
-            sep = crlfSep;
-        else
-            sep = commaSep;
-        sepLen = strlen(sep);
-        if (dwStrType & CERT_NAME_STR_NO_PLUS_FLAG)
-            rdnSep = spaceSep;
-        else
-            rdnSep = plusSep;
-        rdnSepLen = strlen(rdnSep);
-        for (i = 0; (!psz || ret < csz) && i < info->cRDN; i++)
-        {
-            for (j = 0; (!psz || ret < csz) && j < rdn->cRDNAttr; j++)
-            {
-                DWORD chars;
-                char prefixBuf[13]; /* big enough for SERIALNUMBER */
-                LPCSTR prefix = NULL;
-
-                if ((dwStrType & 0x000000ff) == CERT_OID_NAME_STR)
-                    prefix = rdn->rgRDNAttr[j].pszObjId;
-                else if ((dwStrType & 0x000000ff) == CERT_X500_NAME_STR)
-                {
-                    PCCRYPT_OID_INFO oidInfo = CryptFindOIDInfo(
-                     CRYPT_OID_INFO_OID_KEY,
-                     rdn->rgRDNAttr[j].pszObjId,
-                     CRYPT_RDN_ATTR_OID_GROUP_ID);
-
-                    if (oidInfo)
-                    {
-                        WideCharToMultiByte(CP_ACP, 0, oidInfo->pwszName, -1,
-                         prefixBuf, sizeof(prefixBuf), NULL, NULL);
-                        prefix = prefixBuf;
-                    }
-                    else
-                        prefix = rdn->rgRDNAttr[j].pszObjId;
-                }
-                if (prefix)
-                {
-                    /* - 1 is needed to account for the NULL terminator. */
-                    chars = CRYPT_AddPrefixA(prefix,
-                     psz ? psz + ret : NULL, psz ? csz - ret - 1 : 0);
-                    ret += chars;
-                }
-                chars = quote_rdn_value_to_str_a(
-                 rdn->rgRDNAttr[j].dwValueType,
-                 &rdn->rgRDNAttr[j].Value, psz ? psz + ret : NULL,
-                 psz ? csz - ret : 0);
-                if (chars)
-                    ret += chars - 1;
-                if (j < rdn->cRDNAttr - 1)
-                {
-                    if (psz && ret < csz - rdnSepLen - 1)
-                        memcpy(psz + ret, rdnSep, rdnSepLen);
-                    ret += rdnSepLen;
-                }
-            }
-            if (i < info->cRDN - 1)
-            {
-                if (psz && ret < csz - sepLen - 1)
-                    memcpy(psz + ret, sep, sepLen);
-                ret += sepLen;
-            }
-            if(reverse) rdn--;
-            else rdn++;
-        }
-        LocalFree(info);
+        CryptMemFree(strW);
+        return len_mb;
     }
-    if (psz && csz)
+
+    ret = WideCharToMultiByte(CP_ACP, 0, strW, len, str, str_len, NULL, NULL);
+    if (ret < len_mb)
     {
-        *(psz + ret) = '\0';
-        ret++;
+        str[0] = 0;
+        ret = 1;
     }
-    else
-        ret++;
-    TRACE("Returning %s\n", debugstr_a(psz));
+    CryptMemFree(strW);
     return ret;
 }
 
@@ -580,6 +330,7 @@ DWORD cert_name_to_str_with_indent(DWORD dwCertEncodingType, DWORD indentLevel,
     DWORD ret = 0, bytes = 0;
     BOOL bRet;
     CERT_NAME_INFO *info;
+    DWORD chars;
 
     if (dwStrType & unsupportedFlags)
         FIXME("unsupported flags: %08lx\n", dwStrType & unsupportedFlags);
@@ -607,14 +358,17 @@ DWORD cert_name_to_str_with_indent(DWORD dwCertEncodingType, DWORD indentLevel,
         else
             rdnSep = L" + ";
         rdnSepLen = lstrlenW(rdnSep);
-        for (i = 0; (!psz || ret < csz) && i < info->cRDN; i++)
+        if (!csz) psz = NULL;
+        for (i = 0; i < info->cRDN; i++)
         {
-            for (j = 0; (!psz || ret < csz) && j < rdn->cRDNAttr; j++)
+            if (psz && ret + 1 == csz) break;
+            for (j = 0; j < rdn->cRDNAttr; j++)
             {
-                DWORD chars;
                 LPCSTR prefixA = NULL;
                 LPCWSTR prefixW = NULL;
 
+                if (psz && ret + 1 == csz) break;
+
                 if ((dwStrType & 0x000000ff) == CERT_OID_NAME_STR)
                     prefixA = rdn->rgRDNAttr[j].pszObjId;
                 else if ((dwStrType & 0x000000ff) == CERT_X500_NAME_STR)
@@ -644,6 +398,7 @@ DWORD cert_name_to_str_with_indent(DWORD dwCertEncodingType, DWORD indentLevel,
                             chars = lstrlenW(indent);
                         ret += chars;
                     }
+                    if (psz && ret + 1 == csz) break;
                 }
                 if (prefixW)
                 {
@@ -659,38 +414,40 @@ DWORD cert_name_to_str_with_indent(DWORD dwCertEncodingType, DWORD indentLevel,
                      psz ? psz + ret : NULL, psz ? csz - ret - 1 : 0);
                     ret += chars;
                 }
-                chars = quote_rdn_value_to_str_w(
-                 rdn->rgRDNAttr[j].dwValueType,
-                 &rdn->rgRDNAttr[j].Value, psz ? psz + ret : NULL,
-                 psz ? csz - ret : 0);
-                if (chars)
-                    ret += chars - 1;
+                if (psz && ret + 1 == csz) break;
+
+                chars = quote_rdn_value_to_str_w(rdn->rgRDNAttr[j].dwValueType, &rdn->rgRDNAttr[j].Value,
+                                                 psz ? psz + ret : NULL, psz ? csz - ret - 1 : 0);
+                ret += chars;
                 if (j < rdn->cRDNAttr - 1)
                 {
-                    if (psz && ret < csz - rdnSepLen - 1)
-                        memcpy(psz + ret, rdnSep, rdnSepLen * sizeof(WCHAR));
-                    ret += rdnSepLen;
+                    if (psz)
+                    {
+                        chars = min(rdnSepLen, csz - ret - 1);
+                        memcpy(psz + ret, rdnSep, chars * sizeof(WCHAR));
+                        ret += chars;
+                    }
+                    else ret += rdnSepLen;
                 }
             }
+            if (psz && ret + 1 == csz) break;
             if (i < info->cRDN - 1)
             {
-                if (psz && ret < csz - sepLen - 1)
-                    memcpy(psz + ret, sep, sepLen * sizeof(WCHAR));
-                ret += sepLen;
+                if (psz)
+                {
+                    chars = min(sepLen, csz - ret - 1);
+                    memcpy(psz + ret, sep, chars * sizeof(WCHAR));
+                    ret += chars;
+                }
+                else ret += sepLen;
             }
             if(reverse) rdn--;
             else rdn++;
         }
         LocalFree(info);
     }
-    if (psz && csz)
-    {
-        *(psz + ret) = '\0';
-        ret++;
-    }
-    else
-        ret++;
-    return ret;
+    if (psz && csz) psz[ret] = 0;
+    return ret + 1;
 }
 
 DWORD WINAPI CertNameToStrW(DWORD dwCertEncodingType, PCERT_NAME_BLOB pName,
@@ -1113,49 +870,74 @@ BOOL WINAPI CertStrToNameW(DWORD dwCertEncodingType, LPCWSTR pszX500,
     return ret;
 }
 
-DWORD WINAPI CertGetNameStringA(PCCERT_CONTEXT pCertContext, DWORD dwType,
- DWORD dwFlags, void *pvTypePara, LPSTR pszNameString, DWORD cchNameString)
+DWORD WINAPI CertGetNameStringA(PCCERT_CONTEXT cert, DWORD type,
+                                DWORD flags, void *type_para, LPSTR name, DWORD name_len)
 {
-    DWORD ret;
+    DWORD len, len_mb, ret;
+    LPWSTR nameW;
+
+    TRACE("(%p, %ld, %08lx, %p, %p, %ld)\n", cert, type, flags, type_para, name, name_len);
 
-    TRACE("(%p, %ld, %08lx, %p, %p, %ld)\n", pCertContext, dwType, dwFlags,
-     pvTypePara, pszNameString, cchNameString);
+    len = CertGetNameStringW(cert, type, flags, type_para, NULL, 0);
 
-    if (pszNameString)
+    if (!(nameW = CryptMemAlloc(len * sizeof(*nameW))))
     {
-        LPWSTR wideName;
-        DWORD nameLen;
+        ERR("No memory.\n");
+        if (name && name_len) *name = 0;
+        return 1;
+    }
 
-        nameLen = CertGetNameStringW(pCertContext, dwType, dwFlags, pvTypePara,
-         NULL, 0);
-        wideName = CryptMemAlloc(nameLen * sizeof(WCHAR));
-        if (wideName)
-        {
-            CertGetNameStringW(pCertContext, dwType, dwFlags, pvTypePara,
-             wideName, nameLen);
-            nameLen = WideCharToMultiByte(CP_ACP, 0, wideName, nameLen,
-             pszNameString, cchNameString, NULL, NULL);
-            if (nameLen <= cchNameString)
-                ret = nameLen;
-            else
-            {
-                pszNameString[cchNameString - 1] = '\0';
-                ret = cchNameString;
-            }
-            CryptMemFree(wideName);
-        }
-        else
-        {
-            *pszNameString = '\0';
-            ret = 1;
-        }
+    len = CertGetNameStringW(cert, type, flags, type_para, nameW, len);
+    len_mb = WideCharToMultiByte(CP_ACP, 0, nameW, len, NULL, 0, NULL, NULL);
+    if (!name || !name_len)
+    {
+        CryptMemFree(nameW);
+        return len_mb;
     }
-    else
-        ret = CertGetNameStringW(pCertContext, dwType, dwFlags, pvTypePara,
-         NULL, 0);
+
+    ret = WideCharToMultiByte(CP_ACP, 0, nameW, len, name, name_len, NULL, NULL);
+    if (ret < len_mb)
+    {
+        name[0] = 0;
+        ret = 1;
+    }
+    CryptMemFree(nameW);
     return ret;
 }
 
+static BOOL cert_get_alt_name_info(PCCERT_CONTEXT cert, BOOL alt_name_issuer, PCERT_ALT_NAME_INFO *info)
+{
+    static const char *oids[][2] =
+    {
+        { szOID_SUBJECT_ALT_NAME2, szOID_SUBJECT_ALT_NAME },
+        { szOID_ISSUER_ALT_NAME2, szOID_ISSUER_ALT_NAME },
+    };
+    PCERT_EXTENSION ext;
+    DWORD bytes = 0;
+
+    ext = CertFindExtension(oids[!!alt_name_issuer][0], cert->pCertInfo->cExtension, cert->pCertInfo->rgExtension);
+    if (!ext)
+        ext = CertFindExtension(oids[!!alt_name_issuer][1], cert->pCertInfo->cExtension, cert->pCertInfo->rgExtension);
+    if (!ext) return FALSE;
+
+    return CryptDecodeObjectEx(cert->dwCertEncodingType, X509_ALTERNATE_NAME, ext->Value.pbData, ext->Value.cbData,
+                             CRYPT_DECODE_ALLOC_FLAG, NULL, info, &bytes);
+}
+
+static PCERT_ALT_NAME_ENTRY cert_find_next_alt_name_entry(PCERT_ALT_NAME_INFO info, DWORD entry_type,
+                                                          unsigned int *index)
+{
+    unsigned int i;
+
+    for (i = *index; i < info->cAltEntry; ++i)
+        if (info->rgAltEntry[i].dwAltNameChoice == entry_type)
+        {
+            *index = i + 1;
+            return &info->rgAltEntry[i];
+        }
+    return NULL;
+}
+
 /* Searches cert's extensions for the alternate name extension with OID
  * altNameOID, and if found, searches it for the alternate name type entryType.
  * If found, returns a pointer to the entry, otherwise returns NULL.
@@ -1165,31 +947,13 @@ DWORD WINAPI CertGetNameStringA(PCCERT_CONTEXT pCertContext, DWORD dwType,
  * The return value is a pointer within *info, so don't free *info before
  * you're done with the return value.
  */
-static PCERT_ALT_NAME_ENTRY cert_find_alt_name_entry(PCCERT_CONTEXT cert,
- LPCSTR altNameOID, DWORD entryType, PCERT_ALT_NAME_INFO *info)
+static PCERT_ALT_NAME_ENTRY cert_find_alt_name_entry(PCCERT_CONTEXT cert, BOOL alt_name_issuer,
+                                                     DWORD entry_type, PCERT_ALT_NAME_INFO *info)
 {
-    PCERT_ALT_NAME_ENTRY entry = NULL;
-    PCERT_EXTENSION ext = CertFindExtension(altNameOID,
-     cert->pCertInfo->cExtension, cert->pCertInfo->rgExtension);
-
-    if (ext)
-    {
-        DWORD bytes = 0;
+    unsigned int index = 0;
 
-        if (CryptDecodeObjectEx(cert->dwCertEncodingType, X509_ALTERNATE_NAME,
-         ext->Value.pbData, ext->Value.cbData, CRYPT_DECODE_ALLOC_FLAG, NULL,
-         info, &bytes))
-        {
-            DWORD i;
-
-            for (i = 0; !entry && i < (*info)->cAltEntry; i++)
-                if ((*info)->rgAltEntry[i].dwAltNameChoice == entryType)
-                    entry = &(*info)->rgAltEntry[i];
-        }
-    }
-    else
-        *info = NULL;
-    return entry;
+    if (!cert_get_alt_name_info(cert, alt_name_issuer, info)) return NULL;
+    return cert_find_next_alt_name_entry(*info, entry_type, &index);
 }
 
 static DWORD cert_get_name_from_rdn_attr(DWORD encodingType,
@@ -1207,222 +971,195 @@ static DWORD cert_get_name_from_rdn_attr(DWORD encodingType,
             oid = szOID_RSA_emailAddr;
         nameAttr = CertFindRDNAttr(oid, nameInfo);
         if (nameAttr)
-            ret = CertRDNValueToStrW(nameAttr->dwValueType, &nameAttr->Value,
-             pszNameString, cchNameString);
+            ret = rdn_value_to_strW(nameAttr->dwValueType, &nameAttr->Value,
+             pszNameString, cchNameString, TRUE);
         LocalFree(nameInfo);
     }
     return ret;
 }
 
-DWORD WINAPI CertGetNameStringW(PCCERT_CONTEXT pCertContext, DWORD dwType,
- DWORD dwFlags, void *pvTypePara, LPWSTR pszNameString, DWORD cchNameString)
+static DWORD copy_output_str(WCHAR *dst, const WCHAR *src, DWORD dst_size)
 {
-    DWORD ret = 0;
+    DWORD len = wcslen(src);
+
+    if (!dst || !dst_size) return len + 1;
+    len = min(len, dst_size - 1);
+    memcpy(dst, src, len * sizeof(*dst));
+    dst[len] = 0;
+    return len + 1;
+}
+
+DWORD WINAPI CertGetNameStringW(PCCERT_CONTEXT cert, DWORD type, DWORD flags, void *type_para,
+                                LPWSTR name_string, DWORD name_len)
+{
+    static const DWORD supported_flags = CERT_NAME_ISSUER_FLAG | CERT_NAME_SEARCH_ALL_NAMES_FLAG;
+    BOOL alt_name_issuer, search_all_names;
+    CERT_ALT_NAME_INFO *info = NULL;
+    PCERT_ALT_NAME_ENTRY entry;
     PCERT_NAME_BLOB name;
-    LPCSTR altNameOID;
+    DWORD ret = 0;
 
-    TRACE("(%p, %ld, %08lx, %p, %p, %ld)\n", pCertContext, dwType,
-     dwFlags, pvTypePara, pszNameString, cchNameString);
+    TRACE("(%p, %ld, %08lx, %p, %p, %ld)\n", cert, type, flags, type_para, name_string, name_len);
 
-    if (!pCertContext)
+    if (!cert)
         goto done;
 
-    if (dwFlags & CERT_NAME_ISSUER_FLAG)
-    {
-        name = &pCertContext->pCertInfo->Issuer;
-        altNameOID = szOID_ISSUER_ALT_NAME;
-    }
-    else
+    if (flags & ~supported_flags)
+        FIXME("Unsupported flags %#lx.\n", flags);
+
+    search_all_names = flags & CERT_NAME_SEARCH_ALL_NAMES_FLAG;
+    if (search_all_names && type != CERT_NAME_DNS_TYPE)
     {
-        name = &pCertContext->pCertInfo->Subject;
-        altNameOID = szOID_SUBJECT_ALT_NAME;
+        WARN("CERT_NAME_SEARCH_ALL_NAMES_FLAG used with type %lu.\n", type);
+        goto done;
     }
 
-    switch (dwType)
+    alt_name_issuer = flags & CERT_NAME_ISSUER_FLAG;
+    name = alt_name_issuer ? &cert->pCertInfo->Issuer : &cert->pCertInfo->Subject;
+
+    switch (type)
     {
     case CERT_NAME_EMAIL_TYPE:
     {
-        CERT_ALT_NAME_INFO *info;
-        PCERT_ALT_NAME_ENTRY entry = cert_find_alt_name_entry(pCertContext,
-         altNameOID, CERT_ALT_NAME_RFC822_NAME, &info);
+        entry = cert_find_alt_name_entry(cert, alt_name_issuer, CERT_ALT_NAME_RFC822_NAME, &info);
 
         if (entry)
         {
-            if (!pszNameString)
-                ret = lstrlenW(entry->u.pwszRfc822Name) + 1;
-            else if (cchNameString)
-            {
-                ret = min(lstrlenW(entry->u.pwszRfc822Name), cchNameString - 1);
-                memcpy(pszNameString, entry->u.pwszRfc822Name,
-                 ret * sizeof(WCHAR));
-                pszNameString[ret++] = 0;
-            }
+            ret = copy_output_str(name_string, entry->u.pwszRfc822Name, name_len);
+            break;
         }
-        if (info)
-            LocalFree(info);
-        if (!ret)
-            ret = cert_get_name_from_rdn_attr(pCertContext->dwCertEncodingType,
-             name, szOID_RSA_emailAddr, pszNameString, cchNameString);
+        ret = cert_get_name_from_rdn_attr(cert->dwCertEncodingType, name, szOID_RSA_emailAddr,
+                                          name_string, name_len);
         break;
     }
     case CERT_NAME_RDN_TYPE:
     {
-        DWORD type = pvTypePara ? *(DWORD *)pvTypePara : 0;
+        DWORD param = type_para ? *(DWORD *)type_para : 0;
 
         if (name->cbData)
-            ret = CertNameToStrW(pCertContext->dwCertEncodingType, name,
-             type, pszNameString, cchNameString);
+        {
+            ret = CertNameToStrW(cert->dwCertEncodingType, name, param, name_string, name_len);
+        }
         else
         {
-            CERT_ALT_NAME_INFO *info;
-            PCERT_ALT_NAME_ENTRY entry = cert_find_alt_name_entry(pCertContext,
-             altNameOID, CERT_ALT_NAME_DIRECTORY_NAME, &info);
+            entry = cert_find_alt_name_entry(cert, alt_name_issuer, CERT_ALT_NAME_DIRECTORY_NAME, &info);
 
             if (entry)
-                ret = CertNameToStrW(pCertContext->dwCertEncodingType,
-                 &entry->u.DirectoryName, type, pszNameString, cchNameString);
-            if (info)
-                LocalFree(info);
+                ret = CertNameToStrW(cert->dwCertEncodingType, &entry->u.DirectoryName,
+                                     param, name_string, name_len);
         }
         break;
     }
     case CERT_NAME_ATTR_TYPE:
-        ret = cert_get_name_from_rdn_attr(pCertContext->dwCertEncodingType,
-         name, pvTypePara, pszNameString, cchNameString);
-        if (!ret)
-        {
-            CERT_ALT_NAME_INFO *altInfo;
-            PCERT_ALT_NAME_ENTRY entry = cert_find_alt_name_entry(pCertContext,
-             altNameOID, CERT_ALT_NAME_DIRECTORY_NAME, &altInfo);
+        ret = cert_get_name_from_rdn_attr(cert->dwCertEncodingType, name, type_para,
+                                          name_string, name_len);
+        if (ret) break;
 
-            if (entry)
-                ret = cert_name_to_str_with_indent(X509_ASN_ENCODING, 0,
-                 &entry->u.DirectoryName, 0, pszNameString, cchNameString);
-            if (altInfo)
-                LocalFree(altInfo);
-        }
+        entry = cert_find_alt_name_entry(cert, alt_name_issuer, CERT_ALT_NAME_DIRECTORY_NAME, &info);
+
+        if (entry)
+            ret = cert_name_to_str_with_indent(X509_ASN_ENCODING, 0, &entry->u.DirectoryName,
+                                               0, name_string, name_len);
         break;
     case CERT_NAME_SIMPLE_DISPLAY_TYPE:
     {
-        static const LPCSTR simpleAttributeOIDs[] = { szOID_COMMON_NAME,
-         szOID_ORGANIZATIONAL_UNIT_NAME, szOID_ORGANIZATION_NAME,
-         szOID_RSA_emailAddr };
+        static const LPCSTR simpleAttributeOIDs[] =
+        {
+            szOID_COMMON_NAME, szOID_ORGANIZATIONAL_UNIT_NAME, szOID_ORGANIZATION_NAME, szOID_RSA_emailAddr
+        };
         CERT_NAME_INFO *nameInfo = NULL;
         DWORD bytes = 0, i;
 
-        if (CryptDecodeObjectEx(pCertContext->dwCertEncodingType, X509_NAME,
-         name->pbData, name->cbData, CRYPT_DECODE_ALLOC_FLAG, NULL, &nameInfo,
-         &bytes))
+        if (CryptDecodeObjectEx(cert->dwCertEncodingType, X509_NAME, name->pbData, name->cbData,
+                                CRYPT_DECODE_ALLOC_FLAG, NULL, &nameInfo, &bytes))
         {
             PCERT_RDN_ATTR nameAttr = NULL;
 
             for (i = 0; !nameAttr && i < ARRAY_SIZE(simpleAttributeOIDs); i++)
                 nameAttr = CertFindRDNAttr(simpleAttributeOIDs[i], nameInfo);
             if (nameAttr)
-                ret = CertRDNValueToStrW(nameAttr->dwValueType,
-                 &nameAttr->Value, pszNameString, cchNameString);
+                ret = rdn_value_to_strW(nameAttr->dwValueType, &nameAttr->Value, name_string, name_len, TRUE);
             LocalFree(nameInfo);
         }
-        if (!ret)
-        {
-            CERT_ALT_NAME_INFO *altInfo;
-            PCERT_ALT_NAME_ENTRY entry = cert_find_alt_name_entry(pCertContext,
-             altNameOID, CERT_ALT_NAME_RFC822_NAME, &altInfo);
-
-            if (altInfo)
-            {
-                if (!entry && altInfo->cAltEntry)
-                    entry = &altInfo->rgAltEntry[0];
-                if (entry)
-                {
-                    if (!pszNameString)
-                        ret = lstrlenW(entry->u.pwszRfc822Name) + 1;
-                    else if (cchNameString)
-                    {
-                        ret = min(lstrlenW(entry->u.pwszRfc822Name),
-                         cchNameString - 1);
-                        memcpy(pszNameString, entry->u.pwszRfc822Name,
-                         ret * sizeof(WCHAR));
-                        pszNameString[ret++] = 0;
-                    }
-                }
-                LocalFree(altInfo);
-            }
-        }
+        if (ret) break;
+        entry = cert_find_alt_name_entry(cert, alt_name_issuer, CERT_ALT_NAME_RFC822_NAME, &info);
+        if (!info) break;
+        if (!entry && info->cAltEntry)
+            entry = &info->rgAltEntry[0];
+        if (entry) ret = copy_output_str(name_string, entry->u.pwszRfc822Name, name_len);
         break;
     }
     case CERT_NAME_FRIENDLY_DISPLAY_TYPE:
     {
-        DWORD cch = cchNameString;
+        DWORD len = name_len;
 
-        if (CertGetCertificateContextProperty(pCertContext,
-         CERT_FRIENDLY_NAME_PROP_ID, pszNameString, &cch))
-            ret = cch;
+        if (CertGetCertificateContextProperty(cert, CERT_FRIENDLY_NAME_PROP_ID, name_string, &len))
+            ret = len;
         else
-            ret = CertGetNameStringW(pCertContext,
-             CERT_NAME_SIMPLE_DISPLAY_TYPE, dwFlags, pvTypePara, pszNameString,
-             cchNameString);
+            ret = CertGetNameStringW(cert, CERT_NAME_SIMPLE_DISPLAY_TYPE, flags,
+                                     type_para, name_string, name_len);
         break;
     }
     case CERT_NAME_DNS_TYPE:
     {
-        CERT_ALT_NAME_INFO *info;
-        PCERT_ALT_NAME_ENTRY entry = cert_find_alt_name_entry(pCertContext,
-         altNameOID, CERT_ALT_NAME_DNS_NAME, &info);
+        unsigned int index = 0, len;
 
-        if (entry)
+        if (cert_get_alt_name_info(cert, alt_name_issuer, &info)
+            && (entry = cert_find_next_alt_name_entry(info, CERT_ALT_NAME_DNS_NAME, &index)))
         {
-            if (!pszNameString)
-                ret = lstrlenW(entry->u.pwszDNSName) + 1;
-            else if (cchNameString)
+            if (search_all_names)
             {
-                ret = min(lstrlenW(entry->u.pwszDNSName), cchNameString - 1);
-                memcpy(pszNameString, entry->u.pwszDNSName, ret * sizeof(WCHAR));
-                pszNameString[ret++] = 0;
+                do
+                {
+                    if (name_string && name_len == 1) break;
+                    ret += len = copy_output_str(name_string, entry->u.pwszDNSName, name_len ? name_len - 1 : 0);
+                    if (name_string && name_len)
+                    {
+                        name_string += len;
+                        name_len -= len;
+                    }
+                }
+                while ((entry = cert_find_next_alt_name_entry(info, CERT_ALT_NAME_DNS_NAME, &index)));
             }
+            else ret = copy_output_str(name_string, entry->u.pwszDNSName, name_len);
         }
-        if (info)
-            LocalFree(info);
-        if (!ret)
-            ret = cert_get_name_from_rdn_attr(pCertContext->dwCertEncodingType,
-             name, szOID_COMMON_NAME, pszNameString, cchNameString);
-        break;
-    }
-    case CERT_NAME_URL_TYPE:
-    {
-        CERT_ALT_NAME_INFO *info;
-        PCERT_ALT_NAME_ENTRY entry = cert_find_alt_name_entry(pCertContext,
-         altNameOID, CERT_ALT_NAME_URL, &info);
-
-        if (entry)
+        else
         {
-            if (!pszNameString)
-                ret = lstrlenW(entry->u.pwszURL) + 1;
-            else if (cchNameString)
+            if (!search_all_names || name_len != 1)
             {
-                ret = min(lstrlenW(entry->u.pwszURL), cchNameString - 1);
-                memcpy(pszNameString, entry->u.pwszURL, ret * sizeof(WCHAR));
-                pszNameString[ret++] = 0;
+                len = search_all_names && name_len ? name_len - 1 : name_len;
+                ret = cert_get_name_from_rdn_attr(cert->dwCertEncodingType, name, szOID_COMMON_NAME,
+                                                  name_string, len);
+                if (name_string) name_string += ret;
             }
         }
-        if (info)
-            LocalFree(info);
+
+        if (search_all_names)
+        {
+            if (name_string && name_len) *name_string = 0;
+            ++ret;
+        }
+        break;
+    }
+    case CERT_NAME_URL_TYPE:
+    {
+        if ((entry = cert_find_alt_name_entry(cert, alt_name_issuer, CERT_ALT_NAME_URL, &info)))
+            ret = copy_output_str(name_string, entry->u.pwszURL, name_len);
         break;
     }
     default:
-        FIXME("unimplemented for type %ld\n", dwType);
+        FIXME("unimplemented for type %lu.\n", type);
         ret = 0;
+        break;
     }
 done:
+    if (info)
+        LocalFree(info);
+
     if (!ret)
     {
-        if (!pszNameString)
-            ret = 1;
-        else if (cchNameString)
-        {
-            pszNameString[0] = 0;
-            ret = 1;
-        }
+        ret = 1;
+        if (name_string && name_len) name_string[0] = 0;
     }
     return ret;
 }
diff --git a/dlls/crypt32/tests/base64.c b/dlls/crypt32/tests/base64.c
index a1517b294ad..e81a57c576d 100644
--- wine/dlls/crypt32/tests/base64.c
+++ wine/dlls/crypt32/tests/base64.c
@@ -23,7 +23,6 @@
 #include <windows.h>
 #include <wincrypt.h>
 
-#include "wine/heap.h"
 #include "wine/test.h"
 
 #define CERT_HEADER               "-----BEGIN CERTIFICATE-----\r\n"
@@ -93,7 +92,7 @@ static WCHAR *strdupAtoW(const char *str)
 
     if (!str) return ret;
     len = MultiByteToWideChar(CP_ACP, 0, str, -1, NULL, 0);
-    ret = heap_alloc(len * sizeof(WCHAR));
+    ret = malloc(len * sizeof(WCHAR));
     if (ret)
         MultiByteToWideChar(CP_ACP, 0, str, -1, ret, len);
     return ret;
@@ -128,7 +127,7 @@ static void encodeAndCompareBase64_A(const BYTE *toEncode, DWORD toEncodeLen,
     ok(ret, "CryptBinaryToStringA failed: %ld\n", GetLastError());
     ok(strLen == strLen2, "Unexpected required length %lu, expected %lu.\n", strLen2, strLen);
 
-    str = heap_alloc(strLen);
+    str = malloc(strLen);
 
     /* Partially filled output buffer. */
     strLen2 = strLen - 1;
@@ -157,7 +156,7 @@ static void encodeAndCompareBase64_A(const BYTE *toEncode, DWORD toEncodeLen,
     if (trailer)
         ok(!strncmp(trailer, ptr, strlen(trailer)), "Expected trailer %s, got %s\n", trailer, ptr);
 
-    heap_free(str);
+    free(str);
 }
 
 static void encode_compare_base64_W(const BYTE *toEncode, DWORD toEncodeLen, DWORD format,
@@ -196,7 +195,7 @@ static void encode_compare_base64_W(const BYTE *toEncode, DWORD toEncodeLen, DWO
     ok(ret, "CryptBinaryToStringW failed: %ld\n", GetLastError());
     ok(strLen == strLen2, "Unexpected required length.\n");
 
-    strW = heap_alloc(strLen * sizeof(WCHAR));
+    strW = malloc(strLen * sizeof(WCHAR));
 
     headerW = strdupAtoW(header);
     trailerW = strdupAtoW(trailer);
@@ -231,9 +230,9 @@ static void encode_compare_base64_W(const BYTE *toEncode, DWORD toEncodeLen, DWO
         ok(!memcmp(trailerW, ptr, lstrlenW(trailerW)), "Expected trailer %s, got %s.\n", wine_dbgstr_w(trailerW),
                 wine_dbgstr_w(ptr));
 
-    heap_free(strW);
-    heap_free(headerW);
-    heap_free(trailerW);
+    free(strW);
+    free(headerW);
+    free(trailerW);
 }
 
 static DWORD binary_to_hex_len(DWORD binary_len, DWORD flags)
@@ -267,6 +266,7 @@ static void test_CryptBinaryToString(void)
     BYTE input[256 * sizeof(WCHAR)];
     DWORD strLen, strLen2, i, j, k;
     WCHAR *hex, *cmp, *ptr;
+    char *hex_a, *cmp_a;
     BOOL ret;
 
     ret = CryptBinaryToStringA(NULL, 0, 0, NULL, NULL);
@@ -299,12 +299,12 @@ static void test_CryptBinaryToString(void)
         ok(strLen == tests[i].toEncodeLen, "Unexpected required length %lu.\n", strLen);
 
         strLen2 = strLen;
-        str = heap_alloc(strLen);
+        str = malloc(strLen);
         ret = CryptBinaryToStringA(tests[i].toEncode, tests[i].toEncodeLen, CRYPT_STRING_BINARY, str, &strLen2);
         ok(ret, "CryptBinaryToStringA failed: %ld\n", GetLastError());
         ok(strLen == strLen2, "Expected length %lu, got %lu\n", strLen, strLen2);
         ok(!memcmp(str, tests[i].toEncode, tests[i].toEncodeLen), "Unexpected value\n");
-        heap_free(str);
+        free(str);
 
         strLen = 0;
         ret = CryptBinaryToStringW(tests[i].toEncode, tests[i].toEncodeLen, CRYPT_STRING_BINARY, NULL, &strLen);
@@ -312,12 +312,12 @@ static void test_CryptBinaryToString(void)
         ok(strLen == tests[i].toEncodeLen, "Unexpected required length %lu.\n", strLen);
 
         strLen2 = strLen;
-        strW = heap_alloc(strLen);
+        strW = malloc(strLen);
         ret = CryptBinaryToStringW(tests[i].toEncode, tests[i].toEncodeLen, CRYPT_STRING_BINARY, strW, &strLen2);
         ok(ret, "CryptBinaryToStringW failed: %ld\n", GetLastError());
         ok(strLen == strLen2, "Expected length %lu, got %lu\n", strLen, strLen2);
         ok(!memcmp(strW, tests[i].toEncode, tests[i].toEncodeLen), "Unexpected value\n");
-        heap_free(strW);
+        free(strW);
 
         encodeAndCompareBase64_A(tests[i].toEncode, tests[i].toEncodeLen, CRYPT_STRING_BASE64,
             tests[i].base64, NULL, NULL);
@@ -338,7 +338,7 @@ static void test_CryptBinaryToString(void)
         encode_compare_base64_W(tests[i].toEncode, tests[i].toEncodeLen, CRYPT_STRING_BASE64X509CRLHEADER, encodedW,
             X509_HEADER, X509_TRAILER);
 
-        heap_free(encodedW);
+        free(encodedW);
     }
 
     for (i = 0; i < ARRAY_SIZE(testsNoCR); i++)
@@ -352,13 +352,13 @@ static void test_CryptBinaryToString(void)
         ok(ret, "CryptBinaryToStringA failed: %ld\n", GetLastError());
 
         strLen2 = strLen;
-        str = heap_alloc(strLen);
+        str = malloc(strLen);
         ret = CryptBinaryToStringA(testsNoCR[i].toEncode, testsNoCR[i].toEncodeLen,
             CRYPT_STRING_BINARY | CRYPT_STRING_NOCR, str, &strLen2);
         ok(ret, "CryptBinaryToStringA failed: %ld\n", GetLastError());
         ok(strLen == strLen2, "Expected length %ld, got %ld\n", strLen, strLen2);
         ok(!memcmp(str, testsNoCR[i].toEncode, testsNoCR[i].toEncodeLen), "Unexpected value\n");
-        heap_free(str);
+        free(str);
 
         encodeAndCompareBase64_A(testsNoCR[i].toEncode, testsNoCR[i].toEncodeLen, CRYPT_STRING_BASE64 | CRYPT_STRING_NOCR,
             testsNoCR[i].base64, NULL, NULL);
@@ -383,7 +383,7 @@ static void test_CryptBinaryToString(void)
             CRYPT_STRING_BASE64X509CRLHEADER | CRYPT_STRING_NOCR, encodedW,
             X509_HEADER_NOCR, X509_TRAILER_NOCR);
 
-        heap_free(encodedW);
+        free(encodedW);
     }
 
     /* Systems that don't support HEXRAW format convert to BASE64 instead - 3 bytes in -> 4 chars + crlf + 1 null out. */
@@ -402,11 +402,17 @@ static void test_CryptBinaryToString(void)
 
     for (i = 0; i < ARRAY_SIZE(flags); i++)
     {
+        winetest_push_context("i %lu", i);
         strLen = 0;
         ret = CryptBinaryToStringW(input, sizeof(input), CRYPT_STRING_HEXRAW|flags[i], NULL, &strLen);
         ok(ret, "CryptBinaryToStringW failed: %ld\n", GetLastError());
         ok(strLen > 0, "Unexpected string length.\n");
 
+        strLen = 0;
+        ret = CryptBinaryToStringA(input, sizeof(input), CRYPT_STRING_HEXRAW|flags[i], NULL, &strLen);
+        ok(ret, "failed, error %ld.\n", GetLastError());
+        ok(strLen > 0, "Unexpected string length.\n");
+
         strLen = ~0;
         ret = CryptBinaryToStringW(input, sizeof(input), CRYPT_STRING_HEXRAW|flags[i],
                                    NULL, &strLen);
@@ -420,9 +426,12 @@ static void test_CryptBinaryToString(void)
         strLen2 += sizeof(input) * 2 + 1;
         ok(strLen == strLen2, "Expected length %ld, got %ld\n", strLen2, strLen);
 
-        hex = heap_alloc(strLen * sizeof(WCHAR));
+        hex = malloc(strLen * sizeof(WCHAR));
+        hex_a = malloc(strLen);
+
         memset(hex, 0xcc, strLen * sizeof(WCHAR));
-        ptr = cmp = heap_alloc(strLen * sizeof(WCHAR));
+        ptr = cmp = malloc(strLen * sizeof(WCHAR));
+        cmp_a = malloc(strLen);
         for (j = 0; j < ARRAY_SIZE(input); j++)
         {
             *ptr++ = hexdig[(input[j] >> 4) & 0xf];
@@ -438,6 +447,11 @@ static void test_CryptBinaryToString(void)
             *ptr++ = '\n';
         }
         *ptr++ = 0;
+
+        for (j = 0; cmp[j]; ++j)
+            cmp_a[j] = cmp[j];
+        cmp_a[j] = 0;
+
         ret = CryptBinaryToStringW(input, sizeof(input), CRYPT_STRING_HEXRAW|flags[i],
                                    hex, &strLen);
         ok(ret, "CryptBinaryToStringW failed: %ld\n", GetLastError());
@@ -445,6 +459,13 @@ static void test_CryptBinaryToString(void)
         ok(strLen == strLen2, "Expected length %ld, got %ld\n", strLen, strLen2);
         ok(!memcmp(hex, cmp, strLen * sizeof(WCHAR)), "Unexpected value\n");
 
+        ++strLen;
+        ret = CryptBinaryToStringA(input, sizeof(input), CRYPT_STRING_HEXRAW | flags[i],
+                                   hex_a, &strLen);
+        ok(ret, "failed, error %ld.\n", GetLastError());
+        ok(strLen == strLen2, "Expected length %ld, got %ld.\n", strLen, strLen2);
+        ok(!memcmp(hex_a, cmp_a, strLen), "Unexpected value.\n");
+
         /* adjusts size if buffer too big */
         strLen *= 2;
         ret = CryptBinaryToStringW(input, sizeof(input), CRYPT_STRING_HEXRAW|flags[i],
@@ -452,6 +473,12 @@ static void test_CryptBinaryToString(void)
         ok(ret, "CryptBinaryToStringW failed: %ld\n", GetLastError());
         ok(strLen == strLen2, "Expected length %ld, got %ld\n", strLen, strLen2);
 
+        strLen *= 2;
+        ret = CryptBinaryToStringA(input, sizeof(input), CRYPT_STRING_HEXRAW|flags[i],
+                                   hex_a, &strLen);
+        ok(ret, "failed, error %ld.\n", GetLastError());
+        ok(strLen == strLen2, "Expected length %ld, got %ld.\n", strLen, strLen2);
+
         /* no writes if buffer too small */
         strLen /= 2;
         strLen2 /= 2;
@@ -465,8 +492,49 @@ static void test_CryptBinaryToString(void)
         ok(strLen == strLen2, "Expected length %ld, got %ld\n", strLen, strLen2);
         ok(!memcmp(hex, cmp, strLen * sizeof(WCHAR)), "Unexpected value\n");
 
-        heap_free(hex);
-        heap_free(cmp);
+        SetLastError(0xdeadbeef);
+        memset(hex_a, 0xcc, strLen + 3);
+        ret = CryptBinaryToStringA(input, sizeof(input), CRYPT_STRING_HEXRAW | flags[i],
+                                   hex_a, &strLen);
+        ok(!ret && GetLastError() == ERROR_MORE_DATA,"got ret %d, error %lu.\n", ret, GetLastError());
+        ok(strLen == strLen2, "Expected length %ld, got %ld.\n", strLen2, strLen);
+        /* Output consists of the number of full bytes which fit in plus terminating 0. */
+        strLen = (strLen - 1) & ~1;
+        ok(!memcmp(hex_a, cmp_a, strLen), "Unexpected value\n");
+        ok(!hex_a[strLen], "got %#x.\n", (unsigned char)hex_a[strLen]);
+        ok((unsigned char)hex_a[strLen + 1] == 0xcc, "got %#x.\n", (unsigned char)hex_a[strLen + 1]);
+
+        /* Output is not filled if string length is less than 3. */
+        strLen = 1;
+        memset(hex_a, 0xcc, strLen2);
+        ret = CryptBinaryToStringA(input, sizeof(input), CRYPT_STRING_HEXRAW | flags[i],
+                                   hex_a, &strLen);
+        ok(strLen == 1, "got %ld.\n", strLen);
+        ok((unsigned char)hex_a[0] == 0xcc, "got %#x.\n", (unsigned char)hex_a[strLen - 1]);
+
+        strLen = 2;
+        memset(hex_a, 0xcc, strLen2);
+        ret = CryptBinaryToStringA(input, sizeof(input), CRYPT_STRING_HEXRAW | flags[i],
+                                   hex_a, &strLen);
+        ok(strLen == 2, "got %ld.\n", strLen);
+        ok((unsigned char)hex_a[0] == 0xcc, "got %#x.\n", (unsigned char)hex_a[0]);
+        ok((unsigned char)hex_a[1] == 0xcc, "got %#x.\n", (unsigned char)hex_a[1]);
+
+        strLen = 3;
+        memset(hex_a, 0xcc, strLen2);
+        ret = CryptBinaryToStringA(input, sizeof(input), CRYPT_STRING_HEXRAW | flags[i],
+                                   hex_a, &strLen);
+        ok(strLen == 3, "got %ld.\n", strLen);
+        ok(hex_a[0] == 0x30, "got %#x.\n", (unsigned char)hex_a[0]);
+        ok(hex_a[1] == 0x30, "got %#x.\n", (unsigned char)hex_a[1]);
+        ok(!hex_a[2], "got %#x.\n", (unsigned char)hex_a[2]);
+
+        free(hex);
+        free(hex_a);
+        free(cmp);
+        free(cmp_a);
+
+        winetest_pop_context();
     }
 
     for (k = 0; k < ARRAY_SIZE(sizes); k++)
@@ -483,10 +551,10 @@ static void test_CryptBinaryToString(void)
         strLen2 = binary_to_hex_len(sizes[k], CRYPT_STRING_HEX | flags[i]);
         ok(strLen == strLen2, "%lu: Expected length %ld, got %ld\n", i, strLen2, strLen);
 
-        hex = heap_alloc(strLen * sizeof(WCHAR) + 256);
+        hex = malloc(strLen * sizeof(WCHAR) + 256);
         memset(hex, 0xcc, strLen * sizeof(WCHAR));
 
-        ptr = cmp = heap_alloc(strLen * sizeof(WCHAR) + 256);
+        ptr = cmp = malloc(strLen * sizeof(WCHAR) + 256);
         for (j = 0; j < sizes[k]; j++)
         {
             *ptr++ = hexdig[(input[j] >> 4) & 0xf];
@@ -552,8 +620,8 @@ static void test_CryptBinaryToString(void)
         ok(strLen == strLen2, "%lu: Expected length %ld, got %ld\n", i, strLen, strLen2);
         ok(!memcmp(hex, cmp, strLen * sizeof(WCHAR)), "%lu: got %s\n", i, wine_dbgstr_wn(hex, strLen));
 
-        heap_free(hex);
-        heap_free(cmp);
+        free(hex);
+        free(cmp);
     }
 }
 
@@ -569,7 +637,7 @@ static void decodeAndCompareBase64_A(LPCSTR toDecode, LPCSTR header,
         len += strlen(header);
     if (trailer)
         len += strlen(trailer);
-    str = HeapAlloc(GetProcessHeap(), 0, len);
+    str = malloc(len);
     if (str)
     {
         LPBYTE buf;
@@ -586,7 +654,7 @@ static void decodeAndCompareBase64_A(LPCSTR toDecode, LPCSTR header,
         ret = CryptStringToBinaryA(str, 0, useFormat, NULL, &bufLen, NULL,
          NULL);
         ok(ret, "CryptStringToBinaryA failed: %ld\n", GetLastError());
-        buf = HeapAlloc(GetProcessHeap(), 0, bufLen);
+        buf = malloc(bufLen);
         if (buf)
         {
             DWORD skipped, usedFormat;
@@ -605,7 +673,7 @@ static void decodeAndCompareBase64_A(LPCSTR toDecode, LPCSTR header,
             ok(skipped == 0, "Expected skipped 0, got %ld\n", skipped);
             ok(usedFormat == expectedFormat, "Expected format %ld, got %ld\n",
              expectedFormat, usedFormat);
-            HeapFree(GetProcessHeap(), 0, buf);
+            free(buf);
         }
 
         /* Check again, but with garbage up front */
@@ -625,7 +693,7 @@ static void decodeAndCompareBase64_A(LPCSTR toDecode, LPCSTR header,
              "Expected !ret and last error ERROR_INVALID_DATA, got ret=%d, error=%ld\n", ret, GetLastError());
         if (ret)
         {
-            buf = HeapAlloc(GetProcessHeap(), 0, bufLen);
+            buf = malloc(bufLen);
             if (buf)
             {
                 DWORD skipped, usedFormat;
@@ -636,10 +704,10 @@ static void decodeAndCompareBase64_A(LPCSTR toDecode, LPCSTR header,
                 ok(skipped == strlen(garbage),
                  "Expected %d characters of \"%s\" skipped when trying format %08lx, got %ld (used format is %08lx)\n",
                  lstrlenA(garbage), str, useFormat, skipped, usedFormat);
-                HeapFree(GetProcessHeap(), 0, buf);
+                free(buf);
             }
         }
-        HeapFree(GetProcessHeap(), 0, str);
+        free(str);
     }
 }
 
@@ -707,11 +775,145 @@ static const struct BadString badStrings[] = {
  { "-----BEGIN X509 CRL-----\r\nAA==\r\n", CRYPT_STRING_BASE64X509CRLHEADER },
 };
 
-static void testStringToBinaryA(void)
+static BOOL is_hex_string_special_char(WCHAR c)
 {
-    BOOL ret;
+    switch (c)
+    {
+        case '-':
+        case ',':
+        case ' ':
+        case '\t':
+        case '\r':
+        case '\n':
+            return TRUE;
+
+        default:
+            return FALSE;
+    }
+}
+
+static WCHAR wchar_from_str(BOOL wide, const void **str, DWORD *len)
+{
+    WCHAR c;
+
+    if (!*len)
+        return 0;
+
+    --*len;
+    if (wide)
+        c = *(*(const WCHAR **)str)++;
+    else
+        c = *(*(const char **)str)++;
+
+    return c ? c : 0xffff;
+}
+
+static BYTE digit_from_char(WCHAR c)
+{
+    if (c >= '0' && c <= '9')
+        return c - '0';
+    c = towlower(c);
+    if (c >= 'a' && c <= 'f')
+        return c - 'a' + 0xa;
+    return 0xff;
+}
+
+static LONG string_to_hex(const void* str, BOOL wide, DWORD len, BYTE *hex, DWORD *hex_len,
+        DWORD *skipped, DWORD *ret_flags)
+{
+    unsigned int byte_idx = 0;
+    BYTE d1, d2;
+    WCHAR c;
+
+    if (!str || !hex_len)
+        return ERROR_INVALID_PARAMETER;
+
+    if (!len)
+        len = wide ? wcslen(str) : strlen(str);
+
+    if (wide && !len)
+        return ERROR_INVALID_PARAMETER;
+
+    if (skipped)
+        *skipped = 0;
+    if (ret_flags)
+        *ret_flags = 0;
+
+    while ((c = wchar_from_str(wide, &str, &len)) && is_hex_string_special_char(c))
+        ;
+
+    while ((d1 = digit_from_char(c)) != 0xff)
+    {
+        if ((d2 = digit_from_char(wchar_from_str(wide, &str, &len))) == 0xff)
+        {
+            if (!hex)
+                *hex_len = 0;
+            return ERROR_INVALID_DATA;
+        }
+
+        if (hex && byte_idx < *hex_len)
+            hex[byte_idx] = (d1 << 4) | d2;
+
+        ++byte_idx;
+
+        do
+        {
+            c = wchar_from_str(wide, &str, &len);
+        } while (c == '-' || c == ',');
+    }
+
+    while (c)
+    {
+        if (!is_hex_string_special_char(c))
+        {
+            if (!hex)
+                *hex_len = 0;
+            return ERROR_INVALID_DATA;
+        }
+        c = wchar_from_str(wide, &str, &len);
+    }
+
+    if (hex && byte_idx > *hex_len)
+        return ERROR_MORE_DATA;
+
+    if (ret_flags)
+        *ret_flags = CRYPT_STRING_HEX;
+
+    *hex_len = byte_idx;
+
+    return ERROR_SUCCESS;
+}
+
+static void test_CryptStringToBinary(void)
+{
+    static const char *string_hex_tests[] =
+    {
+        "",
+        "-",
+        ",-",
+        "0",
+        "00",
+        "000",
+        "11220",
+        "1122q",
+        "q1122",
+        " aE\t\n\r\n",
+        "01-02",
+        "-,01-02",
+        "01-02-",
+        "aa,BB-ff,-,",
+        "1-2",
+        "010-02",
+        "aa,BBff,-,",
+        "aa,,-BB---ff,-,",
+        "010203040506070809q",
+    };
+
+    DWORD skipped, flags, expected_err, expected_len, expected_skipped, expected_flags;
+    BYTE buf[8], expected[8];
     DWORD bufLen = 0, i;
-    BYTE buf[8];
+    WCHAR str_w[64];
+    BOOL ret, wide;
 
     ret = CryptStringToBinaryA(NULL, 0, 0, NULL, NULL, NULL, NULL);
     ok(!ret && GetLastError() == ERROR_INVALID_PARAMETER,
@@ -891,10 +1093,254 @@ static void testStringToBinaryA(void)
          CRYPT_STRING_ANY, CRYPT_STRING_BASE64HEADER, testsNoCR[i].toEncode,
          testsNoCR[i].toEncodeLen);
     }
+
+    /* CRYPT_STRING_HEX */
+
+    ret = CryptStringToBinaryW(L"01", 2, CRYPT_STRING_HEX, NULL, NULL, NULL, NULL);
+    ok(!ret && GetLastError() == ERROR_INVALID_PARAMETER, "got ret %d, error %lu.\n", ret, GetLastError());
+    if (0)
+    {
+        /* access violation on Windows. */
+        CryptStringToBinaryA("01", 2, CRYPT_STRING_HEX, NULL, NULL, NULL, NULL);
+    }
+
+    bufLen = 8;
+    ret = CryptStringToBinaryW(L"0102", 2, CRYPT_STRING_HEX, NULL, &bufLen, NULL, NULL);
+    ok(ret, "got error %lu.\n", GetLastError());
+    ok(bufLen == 1, "got length %lu.\n", bufLen);
+
+    bufLen = 8;
+    ret = CryptStringToBinaryW(NULL, 0, CRYPT_STRING_HEX, NULL, &bufLen, NULL, NULL);
+    ok(!ret && GetLastError() == ERROR_INVALID_PARAMETER, "got ret %d, error %lu.\n", ret, GetLastError());
+    ok(bufLen == 8, "got length %lu.\n", bufLen);
+
+    bufLen = 8;
+    ret = CryptStringToBinaryA(NULL, 0, CRYPT_STRING_HEX, NULL, &bufLen, NULL, NULL);
+    ok(!ret && GetLastError() == ERROR_INVALID_PARAMETER, "got ret %d, error %lu.\n", ret, GetLastError());
+    ok(bufLen == 8, "got length %lu.\n", bufLen);
+
+    bufLen = 8;
+    ret = CryptStringToBinaryW(L"0102", 3, CRYPT_STRING_HEX, NULL, &bufLen, NULL, NULL);
+    ok(!ret && GetLastError() == ERROR_INVALID_DATA, "got ret %d, error %lu.\n", ret, GetLastError());
+    ok(!bufLen, "got length %lu.\n", bufLen);
+
+    bufLen = 8;
+    buf[0] = 0xcc;
+    ret = CryptStringToBinaryW(L"0102", 3, CRYPT_STRING_HEX, buf, &bufLen, NULL, NULL);
+    ok(!ret && GetLastError() == ERROR_INVALID_DATA, "got ret %d, error %lu.\n", ret, GetLastError());
+    ok(bufLen == 8, "got length %lu.\n", bufLen);
+    ok(buf[0] == 1, "got buf[0] %#x.\n", buf[0]);
+
+    bufLen = 8;
+    buf[0] = 0xcc;
+    ret = CryptStringToBinaryW(L"0102", 2, CRYPT_STRING_HEX, buf, &bufLen, NULL, NULL);
+    ok(ret, "got error %lu.\n", GetLastError());
+    ok(bufLen == 1, "got length %lu.\n", bufLen);
+    ok(buf[0] == 1, "got buf[0] %#x.\n", buf[0]);
+
+    bufLen = 8;
+    buf[0] = buf[1] = 0xcc;
+    ret = CryptStringToBinaryA("01\0 02", 4, CRYPT_STRING_HEX, buf, &bufLen, NULL, NULL);
+    ok(!ret && GetLastError() == ERROR_INVALID_DATA, "got ret %d, error %lu.\n", ret, GetLastError());
+    ok(bufLen == 8, "got length %lu.\n", bufLen);
+    ok(buf[0] == 1, "got buf[0] %#x.\n", buf[0]);
+    ok(buf[1] == 0xcc, "got buf[1] %#x.\n", buf[1]);
+
+    bufLen = 8;
+    buf[0] = buf[1] = 0xcc;
+    ret = CryptStringToBinaryW(L"01\0 02", 4, CRYPT_STRING_HEX, buf, &bufLen, NULL, NULL);
+    ok(!ret && GetLastError() == ERROR_INVALID_DATA, "got ret %d, error %lu.\n", ret, GetLastError());
+    ok(bufLen == 8, "got length %lu.\n", bufLen);
+    ok(buf[0] == 1, "got buf[0] %#x.\n", buf[0]);
+    ok(buf[1] == 0xcc, "got buf[1] %#x.\n", buf[1]);
+
+    bufLen = 1;
+    buf[0] = 0xcc;
+    skipped = 0xdeadbeef;
+    flags = 0xdeadbeef;
+    ret = CryptStringToBinaryW(L"0102", 4, CRYPT_STRING_HEX, buf, &bufLen, &skipped, &flags);
+    ok(!ret && GetLastError() == ERROR_MORE_DATA, "got ret %d, error %lu.\n", ret, GetLastError());
+    ok(bufLen == 1, "got length %lu.\n", bufLen);
+    ok(buf[0] == 1, "got buf[0] %#x.\n", buf[0]);
+    ok(!flags, "got flags %lu.\n", flags);
+    ok(!skipped, "got skipped %lu.\n", skipped);
+
+    for (i = 0; i < ARRAY_SIZE(string_hex_tests); ++i)
+    {
+        for (wide = 0; wide < 2; ++wide)
+        {
+            if (wide)
+            {
+                unsigned int j = 0;
+
+                while ((str_w[j] = string_hex_tests[i][j]))
+                    ++j;
+            }
+            winetest_push_context("test %lu, %s", i, wide ? debugstr_w(str_w)
+                    : debugstr_a(string_hex_tests[i]));
+
+            expected_len = 0xdeadbeef;
+            expected_skipped = 0xdeadbeef;
+            expected_flags = 0xdeadbeef;
+            expected_err = string_to_hex(wide ? (void *)str_w : (void *)string_hex_tests[i], wide, 0, NULL,
+                    &expected_len, &expected_skipped, &expected_flags);
+
+            bufLen = 0xdeadbeef;
+            skipped = 0xdeadbeef;
+            flags = 0xdeadbeef;
+            SetLastError(0xdeadbeef);
+            if (wide)
+                ret = CryptStringToBinaryW(str_w, 0, CRYPT_STRING_HEX, NULL, &bufLen, &skipped, &flags);
+            else
+                ret = CryptStringToBinaryA(string_hex_tests[i], 0, CRYPT_STRING_HEX, NULL, &bufLen, &skipped, &flags);
+
+            ok(bufLen == expected_len, "got length %lu.\n", bufLen);
+            ok(skipped == expected_skipped, "got skipped %lu.\n", skipped);
+            ok(flags == expected_flags, "got flags %lu.\n", flags);
+
+            if (expected_err)
+                ok(!ret && GetLastError() == expected_err, "got ret %d, error %lu.\n", ret, GetLastError());
+            else
+                ok(ret, "got error %lu.\n", GetLastError());
+
+            memset(expected, 0xcc, sizeof(expected));
+            expected_len = 8;
+            expected_skipped = 0xdeadbeef;
+            expected_flags = 0xdeadbeef;
+            expected_err = string_to_hex(wide ? (void *)str_w : (void *)string_hex_tests[i], wide, 0, expected,
+                    &expected_len, &expected_skipped, &expected_flags);
+
+            memset(buf, 0xcc, sizeof(buf));
+            bufLen = 8;
+            skipped = 0xdeadbeef;
+            flags = 0xdeadbeef;
+            SetLastError(0xdeadbeef);
+            if (wide)
+                ret = CryptStringToBinaryW(str_w, 0, CRYPT_STRING_HEX, buf, &bufLen, &skipped, &flags);
+            else
+                ret = CryptStringToBinaryA(string_hex_tests[i], 0, CRYPT_STRING_HEX, buf, &bufLen, &skipped, &flags);
+
+            ok(!memcmp(buf, expected, sizeof(buf)), "data does not match, buf[0] %#x, buf[1] %#x.\n", buf[0], buf[1]);
+            ok(bufLen == expected_len, "got length %lu.\n", bufLen);
+            if (expected_err)
+                ok(!ret && GetLastError() == expected_err, "got ret %d, error %lu.\n", ret, GetLastError());
+            else
+                ok(ret, "got error %lu.\n", GetLastError());
+
+            ok(bufLen == expected_len, "got length %lu.\n", bufLen);
+            ok(skipped == expected_skipped, "got skipped %lu.\n", skipped);
+            ok(flags == expected_flags, "got flags %lu.\n", flags);
+
+            winetest_pop_context();
+        }
+    }
+
+    bufLen = 1;
+    SetLastError(0xdeadbeef);
+    skipped = 0xdeadbeef;
+    flags = 0xdeadbeef;
+    memset(buf, 0xcc, sizeof(buf));
+    ret = CryptStringToBinaryA("0102", 0, CRYPT_STRING_HEX, buf, &bufLen, &skipped, &flags);
+    ok(!ret && GetLastError() == ERROR_MORE_DATA, "got ret %d, error %lu.\n", ret, GetLastError());
+    ok(bufLen == 1, "got length %lu.\n", bufLen);
+    ok(!skipped, "got skipped %lu.\n", skipped);
+    ok(!flags, "got flags %lu.\n", flags);
+    ok(buf[0] == 1, "got buf[0] %#x.\n", buf[0]);
+    ok(buf[1] == 0xcc, "got buf[1] %#x.\n", buf[1]);
+
+    bufLen = 1;
+    SetLastError(0xdeadbeef);
+    skipped = 0xdeadbeef;
+    flags = 0xdeadbeef;
+    memset(buf, 0xcc, sizeof(buf));
+    ret = CryptStringToBinaryA("0102q", 0, CRYPT_STRING_HEX, buf, &bufLen, &skipped, &flags);
+    ok(!ret && GetLastError() == ERROR_INVALID_DATA, "got ret %d, error %lu.\n", ret, GetLastError());
+    ok(bufLen == 1, "got length %lu.\n", bufLen);
+    ok(!skipped, "got skipped %lu.\n", skipped);
+    ok(!flags, "got flags %lu.\n", flags);
+    ok(buf[0] == 1, "got buf[0] %#x.\n", buf[0]);
+    ok(buf[1] == 0xcc, "got buf[1] %#x.\n", buf[1]);
+
+    bufLen = 1;
+    SetLastError(0xdeadbeef);
+    skipped = 0xdeadbeef;
+    flags = 0xdeadbeef;
+    memset(buf, 0xcc, sizeof(buf));
+    ret = CryptStringToBinaryW(L"0102q", 0, CRYPT_STRING_HEX, buf, &bufLen, &skipped, &flags);
+    ok(!ret && GetLastError() == ERROR_INVALID_DATA, "got ret %d, error %lu.\n", ret, GetLastError());
+    ok(bufLen == 1, "got length %lu.\n", bufLen);
+    ok(!skipped, "got skipped %lu.\n", skipped);
+    ok(!flags, "got flags %lu.\n", flags);
+    ok(buf[0] == 1, "got buf[0] %#x.\n", buf[0]);
+    ok(buf[1] == 0xcc, "got buf[1] %#x.\n", buf[1]);
+
+    bufLen = 1;
+    SetLastError(0xdeadbeef);
+    skipped = 0xdeadbeef;
+    flags = 0xdeadbeef;
+    memset(buf, 0xcc, sizeof(buf));
+    ret = CryptStringToBinaryW(L"0102", 0, CRYPT_STRING_HEX, buf, &bufLen, &skipped, &flags);
+    ok(bufLen == 1, "got length %lu.\n", bufLen);
+    ok(!ret && GetLastError() == ERROR_MORE_DATA, "got ret %d, error %lu.\n", ret, GetLastError());
+    ok(buf[0] == 1, "got buf[0] %#x.\n", buf[0]);
+    ok(buf[1] == 0xcc, "got buf[1] %#x.\n", buf[1]);
+
+    /* It looks like Windows is normalizing Unicode strings in some way which depending on locale may result in
+     * some invalid characters in 128-255 range being converted into sequences starting with valid hex numbers.
+     * Just avoiding characters in the 128-255 range in test. */
+    for (i = 1; i < 128; ++i)
+    {
+        char str_a[16];
+
+        for (wide = 0; wide < 2; ++wide)
+        {
+            if (wide)
+            {
+                str_w[0] = i;
+                wcscpy(str_w + 1, L"00");
+            }
+            else
+            {
+                str_a[0] = i;
+                strcpy(str_a + 1, "00");
+            }
+
+            winetest_push_context("char %#lx, %s", i, wide ? debugstr_w(str_w) : debugstr_a(str_a));
+
+            bufLen = 1;
+            buf[0] = buf[1] = 0xcc;
+            SetLastError(0xdeadbeef);
+            if (wide)
+                ret = CryptStringToBinaryW(str_w, 0, CRYPT_STRING_HEX, buf, &bufLen, &skipped, &flags);
+            else
+                ret = CryptStringToBinaryA(str_a, 0, CRYPT_STRING_HEX, buf, &bufLen, &skipped, &flags);
+            ok(bufLen == 1, "got length %lu.\n", bufLen);
+            if (is_hex_string_special_char(i))
+            {
+                ok(ret, "got error %lu.\n", GetLastError());
+                ok(!buf[0], "got buf[0] %#x.\n", buf[0]);
+                ok(buf[1] == 0xcc, "got buf[1] %#x.\n", buf[1]);
+            }
+            else
+            {
+                ok(!ret && GetLastError() == ERROR_INVALID_DATA, "got ret %d, error %lu.\n", ret, GetLastError());
+                if (isdigit(i) || (tolower(i) >= 'a' && tolower(i) <= 'f'))
+                {
+                    ok(buf[0] == (digit_from_char(i) << 4), "got buf[0] %#x.\n", buf[0]);
+                    ok(buf[1] == 0xcc, "got buf[0] %#x.\n", buf[1]);
+                }
+                else
+                {
+                    ok(buf[0] == 0xcc, "got buf[0] %#x.\n", buf[0]);
+                }
+            }
+            winetest_pop_context();
+        }
+    }
 }
 
 START_TEST(base64)
 {
     test_CryptBinaryToString();
-    testStringToBinaryA();
+    test_CryptStringToBinary();
 }
diff --git a/dlls/crypt32/tests/cert.c b/dlls/crypt32/tests/cert.c
index 3cdb5e5ceea..882bb4a0723 100644
--- wine/dlls/crypt32/tests/cert.c
+++ wine/dlls/crypt32/tests/cert.c
@@ -554,7 +554,7 @@ static void testCertProperties(void)
     ok(ret, "CertGetCertificateContextProperty failed: %08lx\n", GetLastError());
     if (ret)
     {
-        LPBYTE buf = HeapAlloc(GetProcessHeap(), 0, size);
+        LPBYTE buf = malloc(size);
 
         if (buf)
         {
@@ -563,7 +563,7 @@ static void testCertProperties(void)
             ok(ret, "CertGetCertificateContextProperty failed: %08lx\n",
              GetLastError());
             ok(!memcmp(buf, subjectKeyId, size), "Unexpected subject key id\n");
-            HeapFree(GetProcessHeap(), 0, buf);
+            free(buf);
         }
     }
     CertFreeCertificateContext(context);
@@ -1640,7 +1640,7 @@ static void testGetIssuerCert(void)
     size = 0;
     ok(CertStrToNameW(X509_ASN_ENCODING, L"CN=dummy, T=Test", CERT_X500_NAME_STR, NULL, NULL, &size, NULL),
        "CertStrToName should have worked\n");
-    certencoded = HeapAlloc(GetProcessHeap(), 0, size);
+    certencoded = malloc(size);
     ok(CertStrToNameW(X509_ASN_ENCODING, L"CN=dummy, T=Test", CERT_X500_NAME_STR, NULL, certencoded, &size, NULL),
        "CertStrToName should have worked\n");
     certsubject.pbData = certencoded;
@@ -1663,7 +1663,7 @@ static void testGetIssuerCert(void)
     CertFreeCertificateContext(cert2);
     CertFreeCertificateContext(cert3);
     CertCloseStore(store, 0);
-    HeapFree(GetProcessHeap(), 0, certencoded);
+    free(certencoded);
 
     /* Test root storage self-signed certificate */
     store = CertOpenStore(CERT_STORE_PROV_SYSTEM, 0, 0, CERT_SYSTEM_STORE_CURRENT_USER, L"ROOT");
@@ -1913,7 +1913,7 @@ static void testVerifyCertSig(HCRYPTPROV csp, const CRYPT_DATA_BLOB *toBeSigned,
         }
         CryptExportPublicKeyInfoEx(csp, AT_SIGNATURE, X509_ASN_ENCODING,
          (LPSTR)sigOID, 0, NULL, NULL, &pubKeySize);
-        pubKeyInfo = HeapAlloc(GetProcessHeap(), 0, pubKeySize);
+        pubKeyInfo = malloc(pubKeySize);
         if (pubKeyInfo)
         {
             ret = CryptExportPublicKeyInfoEx(csp, AT_SIGNATURE,
@@ -1927,7 +1927,7 @@ static void testVerifyCertSig(HCRYPTPROV csp, const CRYPT_DATA_BLOB *toBeSigned,
                 ok(ret, "CryptVerifyCertificateSignature failed: %08lx\n",
                  GetLastError());
             }
-            HeapFree(GetProcessHeap(), 0, pubKeyInfo);
+            free(pubKeyInfo);
         }
         LocalFree(cert);
     }
@@ -2000,7 +2000,7 @@ static void testVerifyCertSigEx(HCRYPTPROV csp, const CRYPT_DATA_BLOB *toBeSigne
          */
         CryptExportPublicKeyInfoEx(csp, AT_SIGNATURE, X509_ASN_ENCODING,
          (LPSTR)sigOID, 0, NULL, NULL, &size);
-        pubKeyInfo = HeapAlloc(GetProcessHeap(), 0, size);
+        pubKeyInfo = malloc(size);
         if (pubKeyInfo)
         {
             ret = CryptExportPublicKeyInfoEx(csp, AT_SIGNATURE,
@@ -2014,7 +2014,7 @@ static void testVerifyCertSigEx(HCRYPTPROV csp, const CRYPT_DATA_BLOB *toBeSigne
                 ok(ret, "CryptVerifyCertificateSignatureEx failed: %08lx\n",
                  GetLastError());
             }
-            HeapFree(GetProcessHeap(), 0, pubKeyInfo);
+            free(pubKeyInfo);
         }
         LocalFree(cert);
     }
@@ -2114,7 +2114,7 @@ static void testSignAndEncodeCert(void)
     /* oid_rsa_md5 not present in some win2k */
     if (ret)
     {
-        LPBYTE buf = HeapAlloc(GetProcessHeap(), 0, size);
+        LPBYTE buf = malloc(size);
 
         if (buf)
         {
@@ -2135,7 +2135,7 @@ static void testSignAndEncodeCert(void)
             else if (size == sizeof(md5SignedEmptyCertNoNull))
                 ok(!memcmp(buf, md5SignedEmptyCertNoNull, size),
                  "Unexpected value\n");
-            HeapFree(GetProcessHeap(), 0, buf);
+            free(buf);
         }
     }
 }
@@ -2188,7 +2188,7 @@ static void testCreateSelfSignCert(void)
             ok(ret && size, "Expected non-zero key provider info\n");
             if (size)
             {
-                PCRYPT_KEY_PROV_INFO pInfo = HeapAlloc(GetProcessHeap(), 0, size);
+                PCRYPT_KEY_PROV_INFO pInfo = malloc(size);
 
                 if (pInfo)
                 {
@@ -2206,7 +2206,7 @@ static void testCreateSelfSignCert(void)
                         ok(pInfo->dwKeySpec == AT_SIGNATURE,
                          "Expected AT_SIGNATURE, got %ld\n", pInfo->dwKeySpec);
                     }
-                    HeapFree(GetProcessHeap(), 0, pInfo);
+                    free(pInfo);
                 }
             }
 
@@ -2262,7 +2262,7 @@ static void testCreateSelfSignCert(void)
         ok(ret && size, "Expected non-zero key provider info\n");
         if (size)
         {
-            PCRYPT_KEY_PROV_INFO pInfo = HeapAlloc(GetProcessHeap(), 0, size);
+            PCRYPT_KEY_PROV_INFO pInfo = malloc(size);
 
             if (pInfo)
             {
@@ -2280,7 +2280,7 @@ static void testCreateSelfSignCert(void)
                     ok(pInfo->dwKeySpec == AT_SIGNATURE,
                         "Expected AT_SIGNATURE, got %ld\n", pInfo->dwKeySpec);
                 }
-                HeapFree(GetProcessHeap(), 0, pInfo);
+                free(pInfo);
             }
         }
 
@@ -2309,7 +2309,7 @@ static void testCreateSelfSignCert(void)
         ok(ret && size, "Expected non-zero key provider info\n");
         if (size)
         {
-            PCRYPT_KEY_PROV_INFO pInfo = HeapAlloc(GetProcessHeap(), 0, size);
+            PCRYPT_KEY_PROV_INFO pInfo = malloc(size);
 
             if (pInfo)
             {
@@ -2327,7 +2327,7 @@ static void testCreateSelfSignCert(void)
                     ok(pInfo->dwKeySpec == AT_KEYEXCHANGE,
                         "Expected AT_KEYEXCHANGE, got %ld\n", pInfo->dwKeySpec);
                 }
-                HeapFree(GetProcessHeap(), 0, pInfo);
+                free(pInfo);
             }
         }
 
@@ -2386,7 +2386,7 @@ static void testCreateSelfSignCert(void)
         ok(ret && size, "Expected non-zero key provider info\n");
         if (size)
         {
-            PCRYPT_KEY_PROV_INFO pInfo = HeapAlloc(GetProcessHeap(), 0, size);
+            PCRYPT_KEY_PROV_INFO pInfo = malloc(size);
 
             if (pInfo)
             {
@@ -2404,7 +2404,7 @@ static void testCreateSelfSignCert(void)
                     ok(pInfo->dwKeySpec == AT_KEYEXCHANGE,
                         "Expected AT_KEYEXCHANGE, got %ld\n", pInfo->dwKeySpec);
                 }
-                HeapFree(GetProcessHeap(), 0, pInfo);
+                free(pInfo);
             }
         }
 
@@ -2627,7 +2627,7 @@ static void testKeyUsage(void)
         ret = CertGetEnhancedKeyUsage(context,
          CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG, NULL, &bufSize);
         ok(ret, "CertGetEnhancedKeyUsage failed: %08lx\n", GetLastError());
-        buf = HeapAlloc(GetProcessHeap(), 0, bufSize);
+        buf = malloc(bufSize);
         if (buf)
         {
             PCERT_ENHKEY_USAGE pUsage = (PCERT_ENHKEY_USAGE)buf;
@@ -2644,11 +2644,11 @@ static void testKeyUsage(void)
                 ok(!strcmp(pUsage->rgpszUsageIdentifier[i], keyUsages[i]),
                  "Expected %s, got %s\n", keyUsages[i],
                  pUsage->rgpszUsageIdentifier[i]);
-            HeapFree(GetProcessHeap(), 0, buf);
+            free(buf);
         }
         ret = CertGetEnhancedKeyUsage(context, 0, NULL, &bufSize);
         ok(ret, "CertGetEnhancedKeyUsage failed: %08lx\n", GetLastError());
-        buf = HeapAlloc(GetProcessHeap(), 0, bufSize);
+        buf = malloc(bufSize);
         if (buf)
         {
             PCERT_ENHKEY_USAGE pUsage = (PCERT_ENHKEY_USAGE)buf;
@@ -2668,7 +2668,7 @@ static void testKeyUsage(void)
                 ok(!strcmp(pUsage->rgpszUsageIdentifier[i], keyUsages[i]),
                  "Expected %s, got %s\n", keyUsages[i],
                  pUsage->rgpszUsageIdentifier[i]);
-            HeapFree(GetProcessHeap(), 0, buf);
+            free(buf);
         }
         /* Shouldn't find it as an extended property */
         ret = CertGetEnhancedKeyUsage(context,
@@ -2681,7 +2681,7 @@ static void testKeyUsage(void)
          GetLastError());
         ret = CertGetEnhancedKeyUsage(context, 0, NULL, &bufSize);
         ok(ret, "CertGetEnhancedKeyUsage failed: %08lx\n", GetLastError());
-        buf = HeapAlloc(GetProcessHeap(), 0, bufSize);
+        buf = malloc(bufSize);
         if (buf)
         {
             PCERT_ENHKEY_USAGE pUsage = (PCERT_ENHKEY_USAGE)buf;
@@ -2696,13 +2696,13 @@ static void testKeyUsage(void)
             ok(!strcmp(pUsage->rgpszUsageIdentifier[0], szOID_RSA_RSA),
              "Expected %s, got %s\n", szOID_RSA_RSA,
              pUsage->rgpszUsageIdentifier[0]);
-            HeapFree(GetProcessHeap(), 0, buf);
+            free(buf);
         }
         /* But querying the cert directly returns its usage */
         ret = CertGetEnhancedKeyUsage(context,
          CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG, NULL, &bufSize);
         ok(ret, "CertGetEnhancedKeyUsage failed: %08lx\n", GetLastError());
-        buf = HeapAlloc(GetProcessHeap(), 0, bufSize);
+        buf = malloc(bufSize);
         if (buf)
         {
             PCERT_ENHKEY_USAGE pUsage = (PCERT_ENHKEY_USAGE)buf;
@@ -2718,7 +2718,7 @@ static void testKeyUsage(void)
                 ok(!strcmp(pUsage->rgpszUsageIdentifier[i], keyUsages[i]),
                  "Expected %s, got %s\n", keyUsages[i],
                  pUsage->rgpszUsageIdentifier[i]);
-            HeapFree(GetProcessHeap(), 0, buf);
+            free(buf);
         }
         /* And removing the only usage identifier in the extended property
          * results in the cert's key usage being found.
@@ -2727,7 +2727,7 @@ static void testKeyUsage(void)
         ok(ret, "CertRemoveEnhancedKeyUsage failed: %08lx\n", GetLastError());
         ret = CertGetEnhancedKeyUsage(context, 0, NULL, &bufSize);
         ok(ret, "CertGetEnhancedKeyUsage failed: %08lx\n", GetLastError());
-        buf = HeapAlloc(GetProcessHeap(), 0, bufSize);
+        buf = malloc(bufSize);
         if (buf)
         {
             PCERT_ENHKEY_USAGE pUsage = (PCERT_ENHKEY_USAGE)buf;
@@ -2743,7 +2743,7 @@ static void testKeyUsage(void)
                 ok(!strcmp(pUsage->rgpszUsageIdentifier[i], keyUsages[i]),
                  "Expected %s, got %s\n", keyUsages[i],
                  pUsage->rgpszUsageIdentifier[i]);
-            HeapFree(GetProcessHeap(), 0, buf);
+            free(buf);
         }
 
         CertFreeCertificateContext(context);
@@ -2810,7 +2810,7 @@ static void testGetValidUsages(void)
     ok(ret, "CertGetValidUsages failed: %08lx\n", GetLastError());
     ok(numOIDs == 3, "Expected 3, got %d\n", numOIDs);
     ok(size, "Expected non-zero size\n");
-    oids = HeapAlloc(GetProcessHeap(), 0, size);
+    oids = malloc(size);
     if (oids)
     {
         int i;
@@ -2825,7 +2825,7 @@ static void testGetValidUsages(void)
         for (i = 0; i < numOIDs; i++)
             ok(!lstrcmpA(oids[i], expectedOIDs[i]), "unexpected OID %s\n",
              oids[i]);
-        HeapFree(GetProcessHeap(), 0, oids);
+        free(oids);
     }
     numOIDs = 0xdeadbeef;
     /* Oddly enough, this crashes when the number of contexts is not 1:
@@ -2837,7 +2837,7 @@ static void testGetValidUsages(void)
     ok(ret, "CertGetValidUsages failed: %08lx\n", GetLastError());
     ok(numOIDs == 3, "Expected 3, got %d\n", numOIDs);
     ok(size, "Expected non-zero size\n");
-    oids = HeapAlloc(GetProcessHeap(), 0, size);
+    oids = malloc(size);
     if (oids)
     {
         int i;
@@ -2847,7 +2847,7 @@ static void testGetValidUsages(void)
         for (i = 0; i < numOIDs; i++)
             ok(!lstrcmpA(oids[i], expectedOIDs[i]), "unexpected OID %s\n",
              oids[i]);
-        HeapFree(GetProcessHeap(), 0, oids);
+        free(oids);
     }
     numOIDs = 0xdeadbeef;
     size = 0;
@@ -2855,7 +2855,7 @@ static void testGetValidUsages(void)
     ok(ret, "CertGetValidUsages failed: %08lx\n", GetLastError());
     ok(numOIDs == 2, "Expected 2, got %d\n", numOIDs);
     ok(size, "Expected non-zero size\n");
-    oids = HeapAlloc(GetProcessHeap(), 0, size);
+    oids = malloc(size);
     if (oids)
     {
         int i;
@@ -2865,7 +2865,7 @@ static void testGetValidUsages(void)
         for (i = 0; i < numOIDs; i++)
             ok(!lstrcmpA(oids[i], expectedOIDs2[i]), "unexpected OID %s\n",
              oids[i]);
-        HeapFree(GetProcessHeap(), 0, oids);
+        free(oids);
     }
     numOIDs = 0xdeadbeef;
     size = 0;
@@ -2873,7 +2873,7 @@ static void testGetValidUsages(void)
     ok(ret, "CertGetValidUsages failed: %08lx\n", GetLastError());
     ok(numOIDs == 2, "Expected 2, got %d\n", numOIDs);
     ok(size, "Expected non-zero size\n");
-    oids = HeapAlloc(GetProcessHeap(), 0, size);
+    oids = malloc(size);
     if (oids)
     {
         int i;
@@ -2883,7 +2883,7 @@ static void testGetValidUsages(void)
         for (i = 0; i < numOIDs; i++)
             ok(!lstrcmpA(oids[i], expectedOIDs2[i]), "unexpected OID %s\n",
              oids[i]);
-        HeapFree(GetProcessHeap(), 0, oids);
+        free(oids);
     }
     CertFreeCertificateContext(contexts[0]);
     CertFreeCertificateContext(contexts[1]);
@@ -3537,6 +3537,520 @@ static const BYTE rootSignedCRL[] = {
 0xd5,0xbc,0xb0,0xd5,0xa5,0x9c,0x1b,0x72,0xc3,0x0f,0xa3,0xe3,0x3c,0xf0,0xc3,
 0x91,0xe8,0x93,0x4f,0xd4,0x2f };
 
+static const BYTE ocsp_cert[] = {
+  0x30, 0x82, 0x06, 0xcd, 0x30, 0x82, 0x05, 0xb5, 0xa0, 0x03, 0x02, 0x01,
+  0x02, 0x02, 0x10, 0x08, 0x49, 0x8f, 0x6d, 0xd9, 0xef, 0xfb, 0x40, 0x55,
+  0x1e, 0xac, 0x54, 0x54, 0x87, 0xc1, 0xb1, 0x30, 0x0d, 0x06, 0x09, 0x2a,
+  0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x0b, 0x05, 0x00, 0x30, 0x4f,
+  0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55,
+  0x53, 0x31, 0x15, 0x30, 0x13, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x13, 0x0c,
+  0x44, 0x69, 0x67, 0x69, 0x43, 0x65, 0x72, 0x74, 0x20, 0x49, 0x6e, 0x63,
+  0x31, 0x29, 0x30, 0x27, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x20, 0x44,
+  0x69, 0x67, 0x69, 0x43, 0x65, 0x72, 0x74, 0x20, 0x54, 0x4c, 0x53, 0x20,
+  0x52, 0x53, 0x41, 0x20, 0x53, 0x48, 0x41, 0x32, 0x35, 0x36, 0x20, 0x32,
+  0x30, 0x32, 0x30, 0x20, 0x43, 0x41, 0x31, 0x30, 0x1e, 0x17, 0x0d, 0x32,
+  0x31, 0x30, 0x34, 0x32, 0x38, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x5a,
+  0x17, 0x0d, 0x32, 0x32, 0x30, 0x35, 0x32, 0x39, 0x32, 0x33, 0x35, 0x39,
+  0x35, 0x39, 0x5a, 0x30, 0x6b, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55,
+  0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31, 0x13, 0x30, 0x11, 0x06, 0x03,
+  0x55, 0x04, 0x08, 0x13, 0x0a, 0x57, 0x61, 0x73, 0x68, 0x69, 0x6e, 0x67,
+  0x74, 0x6f, 0x6e, 0x31, 0x11, 0x30, 0x0f, 0x06, 0x03, 0x55, 0x04, 0x07,
+  0x13, 0x08, 0x42, 0x65, 0x6c, 0x6c, 0x65, 0x76, 0x75, 0x65, 0x31, 0x14,
+  0x30, 0x12, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x13, 0x0b, 0x56, 0x61, 0x6c,
+  0x76, 0x65, 0x20, 0x43, 0x6f, 0x72, 0x70, 0x2e, 0x31, 0x1e, 0x30, 0x1c,
+  0x06, 0x03, 0x55, 0x04, 0x03, 0x0c, 0x15, 0x2a, 0x2e, 0x63, 0x6d, 0x2e,
+  0x73, 0x74, 0x65, 0x61, 0x6d, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x65, 0x64,
+  0x2e, 0x63, 0x6f, 0x6d, 0x30, 0x82, 0x01, 0x22, 0x30, 0x0d, 0x06, 0x09,
+  0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03,
+  0x82, 0x01, 0x0f, 0x00, 0x30, 0x82, 0x01, 0x0a, 0x02, 0x82, 0x01, 0x01,
+  0x00, 0xcd, 0x98, 0x0c, 0x13, 0xb2, 0xb9, 0xf2, 0xa5, 0xc6, 0x52, 0xad,
+  0xf9, 0x4d, 0xcf, 0x1e, 0x2b, 0x74, 0x05, 0xd1, 0x2e, 0x95, 0xc3, 0x9d,
+  0x9b, 0x03, 0x2a, 0xc6, 0x65, 0x1e, 0xda, 0x5d, 0x57, 0x3c, 0x61, 0xa1,
+  0x3d, 0xa3, 0xe7, 0x0c, 0xdd, 0xb1, 0x6b, 0x30, 0x97, 0x99, 0xc7, 0x77,
+  0xab, 0xc2, 0xb0, 0x0a, 0x5b, 0x1c, 0x86, 0x55, 0x42, 0x25, 0xa8, 0x4e,
+  0xe2, 0x61, 0xfe, 0x88, 0x10, 0x25, 0xf5, 0x8e, 0x9c, 0x0f, 0xc7, 0xa5,
+  0xef, 0x9d, 0xd5, 0xf0, 0x2a, 0xf2, 0x31, 0x59, 0x59, 0xfc, 0xe0, 0x1f,
+  0x8f, 0xb4, 0xa1, 0x06, 0x32, 0x04, 0x37, 0x3d, 0x9d, 0xad, 0xc1, 0xe0,
+  0x00, 0x3d, 0x8d, 0x60, 0x4c, 0x9e, 0x6a, 0x1f, 0xd2, 0xf6, 0xf8, 0x86,
+  0x0b, 0x11, 0x7b, 0xfd, 0x75, 0xae, 0x20, 0x9b, 0xca, 0x52, 0x5f, 0x4e,
+  0xad, 0x2e, 0xa2, 0xce, 0xed, 0x35, 0x08, 0x23, 0xa8, 0x6e, 0x61, 0x7e,
+  0x18, 0x1a, 0x6a, 0xd9, 0xe0, 0x3b, 0x52, 0x64, 0xe9, 0x2c, 0x81, 0x8f,
+  0xbc, 0x4b, 0x48, 0xd1, 0x7a, 0x3e, 0x02, 0x9c, 0xad, 0x87, 0x73, 0xae,
+  0xaa, 0xea, 0x32, 0xfb, 0x07, 0x4e, 0xcb, 0xe9, 0xac, 0xac, 0x50, 0x0f,
+  0x49, 0xb7, 0x23, 0x3b, 0x1f, 0xb2, 0x24, 0x46, 0x78, 0x32, 0x11, 0x9e,
+  0xa2, 0xeb, 0xd8, 0x8b, 0x7e, 0x56, 0x92, 0xaa, 0x29, 0xbd, 0x55, 0xc8,
+  0x3e, 0x69, 0xe2, 0x56, 0xf4, 0x24, 0x58, 0x7b, 0xf8, 0xb0, 0xbb, 0x72,
+  0xb7, 0x38, 0x34, 0xe3, 0x0f, 0x30, 0xf4, 0xfd, 0x44, 0xf1, 0x53, 0x0f,
+  0xc5, 0x31, 0xd6, 0xad, 0x45, 0xbf, 0x57, 0x2c, 0x4c, 0xe5, 0x1a, 0xc0,
+  0x08, 0x25, 0x88, 0x2f, 0xca, 0x07, 0x2e, 0x35, 0x31, 0xa7, 0x40, 0x3a,
+  0x71, 0x1d, 0xba, 0x09, 0xf8, 0x76, 0x6c, 0x69, 0xb2, 0x89, 0xd7, 0xbe,
+  0xca, 0x9d, 0xf5, 0xd4, 0x7d, 0x02, 0x03, 0x01, 0x00, 0x01, 0xa3, 0x82,
+  0x03, 0x87, 0x30, 0x82, 0x03, 0x83, 0x30, 0x1f, 0x06, 0x03, 0x55, 0x1d,
+  0x23, 0x04, 0x18, 0x30, 0x16, 0x80, 0x14, 0xb7, 0x6b, 0xa2, 0xea, 0xa8,
+  0xaa, 0x84, 0x8c, 0x79, 0xea, 0xb4, 0xda, 0x0f, 0x98, 0xb2, 0xc5, 0x95,
+  0x76, 0xb9, 0xf4, 0x30, 0x1d, 0x06, 0x03, 0x55, 0x1d, 0x0e, 0x04, 0x16,
+  0x04, 0x14, 0x22, 0x68, 0x57, 0xb9, 0xc0, 0x1f, 0xce, 0xa6, 0xbf, 0xb6,
+  0x55, 0xcb, 0x2a, 0x1b, 0xe6, 0xe0, 0x76, 0x94, 0x07, 0x06, 0x30, 0x35,
+  0x06, 0x03, 0x55, 0x1d, 0x11, 0x04, 0x2e, 0x30, 0x2c, 0x82, 0x15, 0x2a,
+  0x2e, 0x63, 0x6d, 0x2e, 0x73, 0x74, 0x65, 0x61, 0x6d, 0x70, 0x6f, 0x77,
+  0x65, 0x72, 0x65, 0x64, 0x2e, 0x63, 0x6f, 0x6d, 0x82, 0x13, 0x63, 0x6d,
+  0x2e, 0x73, 0x74, 0x65, 0x61, 0x6d, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x65,
+  0x64, 0x2e, 0x63, 0x6f, 0x6d, 0x30, 0x0e, 0x06, 0x03, 0x55, 0x1d, 0x0f,
+  0x01, 0x01, 0xff, 0x04, 0x04, 0x03, 0x02, 0x05, 0xa0, 0x30, 0x1d, 0x06,
+  0x03, 0x55, 0x1d, 0x25, 0x04, 0x16, 0x30, 0x14, 0x06, 0x08, 0x2b, 0x06,
+  0x01, 0x05, 0x05, 0x07, 0x03, 0x01, 0x06, 0x08, 0x2b, 0x06, 0x01, 0x05,
+  0x05, 0x07, 0x03, 0x02, 0x30, 0x81, 0x8b, 0x06, 0x03, 0x55, 0x1d, 0x1f,
+  0x04, 0x81, 0x83, 0x30, 0x81, 0x80, 0x30, 0x3e, 0xa0, 0x3c, 0xa0, 0x3a,
+  0x86, 0x38, 0x68, 0x74, 0x74, 0x70, 0x3a, 0x2f, 0x2f, 0x63, 0x72, 0x6c,
+  0x33, 0x2e, 0x64, 0x69, 0x67, 0x69, 0x63, 0x65, 0x72, 0x74, 0x2e, 0x63,
+  0x6f, 0x6d, 0x2f, 0x44, 0x69, 0x67, 0x69, 0x43, 0x65, 0x72, 0x74, 0x54,
+  0x4c, 0x53, 0x52, 0x53, 0x41, 0x53, 0x48, 0x41, 0x32, 0x35, 0x36, 0x32,
+  0x30, 0x32, 0x30, 0x43, 0x41, 0x31, 0x2e, 0x63, 0x72, 0x6c, 0x30, 0x3e,
+  0xa0, 0x3c, 0xa0, 0x3a, 0x86, 0x38, 0x68, 0x74, 0x74, 0x70, 0x3a, 0x2f,
+  0x2f, 0x63, 0x72, 0x6c, 0x34, 0x2e, 0x64, 0x69, 0x67, 0x69, 0x63, 0x65,
+  0x72, 0x74, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x44, 0x69, 0x67, 0x69, 0x43,
+  0x65, 0x72, 0x74, 0x54, 0x4c, 0x53, 0x52, 0x53, 0x41, 0x53, 0x48, 0x41,
+  0x32, 0x35, 0x36, 0x32, 0x30, 0x32, 0x30, 0x43, 0x41, 0x31, 0x2e, 0x63,
+  0x72, 0x6c, 0x30, 0x3e, 0x06, 0x03, 0x55, 0x1d, 0x20, 0x04, 0x37, 0x30,
+  0x35, 0x30, 0x33, 0x06, 0x06, 0x67, 0x81, 0x0c, 0x01, 0x02, 0x02, 0x30,
+  0x29, 0x30, 0x27, 0x06, 0x08, 0x2b, 0x06, 0x01, 0x05, 0x05, 0x07, 0x02,
+  0x01, 0x16, 0x1b, 0x68, 0x74, 0x74, 0x70, 0x3a, 0x2f, 0x2f, 0x77, 0x77,
+  0x77, 0x2e, 0x64, 0x69, 0x67, 0x69, 0x63, 0x65, 0x72, 0x74, 0x2e, 0x63,
+  0x6f, 0x6d, 0x2f, 0x43, 0x50, 0x53, 0x30, 0x7d, 0x06, 0x08, 0x2b, 0x06,
+  0x01, 0x05, 0x05, 0x07, 0x01, 0x01, 0x04, 0x71, 0x30, 0x6f, 0x30, 0x24,
+  0x06, 0x08, 0x2b, 0x06, 0x01, 0x05, 0x05, 0x07, 0x30, 0x01, 0x86, 0x18,
+  0x68, 0x74, 0x74, 0x70, 0x3a, 0x2f, 0x2f, 0x6f, 0x63, 0x73, 0x70, 0x2e,
+  0x64, 0x69, 0x67, 0x69, 0x63, 0x65, 0x72, 0x74, 0x2e, 0x63, 0x6f, 0x6d,
+  0x30, 0x47, 0x06, 0x08, 0x2b, 0x06, 0x01, 0x05, 0x05, 0x07, 0x30, 0x02,
+  0x86, 0x3b, 0x68, 0x74, 0x74, 0x70, 0x3a, 0x2f, 0x2f, 0x63, 0x61, 0x63,
+  0x65, 0x72, 0x74, 0x73, 0x2e, 0x64, 0x69, 0x67, 0x69, 0x63, 0x65, 0x72,
+  0x74, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x44, 0x69, 0x67, 0x69, 0x43, 0x65,
+  0x72, 0x74, 0x54, 0x4c, 0x53, 0x52, 0x53, 0x41, 0x53, 0x48, 0x41, 0x32,
+  0x35, 0x36, 0x32, 0x30, 0x32, 0x30, 0x43, 0x41, 0x31, 0x2e, 0x63, 0x72,
+  0x74, 0x30, 0x0c, 0x06, 0x03, 0x55, 0x1d, 0x13, 0x01, 0x01, 0xff, 0x04,
+  0x02, 0x30, 0x00, 0x30, 0x82, 0x01, 0x7e, 0x06, 0x0a, 0x2b, 0x06, 0x01,
+  0x04, 0x01, 0xd6, 0x79, 0x02, 0x04, 0x02, 0x04, 0x82, 0x01, 0x6e, 0x04,
+  0x82, 0x01, 0x6a, 0x01, 0x68, 0x00, 0x76, 0x00, 0x29, 0x79, 0xbe, 0xf0,
+  0x9e, 0x39, 0x39, 0x21, 0xf0, 0x56, 0x73, 0x9f, 0x63, 0xa5, 0x77, 0xe5,
+  0xbe, 0x57, 0x7d, 0x9c, 0x60, 0x0a, 0xf8, 0xf9, 0x4d, 0x5d, 0x26, 0x5c,
+  0x25, 0x5d, 0xc7, 0x84, 0x00, 0x00, 0x01, 0x79, 0x19, 0x43, 0x10, 0x65,
+  0x00, 0x00, 0x04, 0x03, 0x00, 0x47, 0x30, 0x45, 0x02, 0x21, 0x00, 0x93,
+  0x5f, 0x66, 0xe4, 0xfe, 0x76, 0x25, 0xe6, 0x07, 0x74, 0xa1, 0x8b, 0x7f,
+  0x37, 0xad, 0xb1, 0x40, 0x8f, 0x20, 0x66, 0x71, 0x57, 0x14, 0x2c, 0x2e,
+  0x28, 0xe0, 0xb2, 0x95, 0xd5, 0x19, 0xd0, 0x02, 0x20, 0x32, 0xd1, 0xa8,
+  0x59, 0xfd, 0x69, 0x24, 0x8a, 0x27, 0x7e, 0x56, 0x06, 0xce, 0x6d, 0xeb,
+  0xa1, 0xc6, 0x2a, 0xce, 0x4b, 0x37, 0xb1, 0x25, 0xca, 0x6d, 0xd3, 0x43,
+  0xf3, 0xdb, 0xb8, 0xa5, 0x5e, 0x00, 0x76, 0x00, 0x22, 0x45, 0x45, 0x07,
+  0x59, 0x55, 0x24, 0x56, 0x96, 0x3f, 0xa1, 0x2f, 0xf1, 0xf7, 0x6d, 0x86,
+  0xe0, 0x23, 0x26, 0x63, 0xad, 0xc0, 0x4b, 0x7f, 0x5d, 0xc6, 0x83, 0x5c,
+  0x6e, 0xe2, 0x0f, 0x02, 0x00, 0x00, 0x01, 0x79, 0x19, 0x43, 0x10, 0xa4,
+  0x00, 0x00, 0x04, 0x03, 0x00, 0x47, 0x30, 0x45, 0x02, 0x20, 0x3a, 0x73,
+  0x53, 0xfb, 0xbb, 0x42, 0xdf, 0x2e, 0xa2, 0xc0, 0xc5, 0x29, 0x57, 0xda,
+  0xb9, 0x0b, 0x76, 0x58, 0xb6, 0xeb, 0xd3, 0x4d, 0x10, 0x95, 0x1b, 0x58,
+  0x3e, 0x58, 0x86, 0xea, 0xec, 0xe5, 0x02, 0x21, 0x00, 0xeb, 0xb2, 0xfe,
+  0x83, 0x74, 0xdf, 0xb5, 0xfd, 0x8f, 0x74, 0x82, 0xd3, 0x8f, 0x6b, 0xce,
+  0x63, 0x8b, 0x93, 0x94, 0x08, 0x7b, 0x1c, 0x6b, 0x48, 0xae, 0x59, 0xa1,
+  0x7e, 0xec, 0x59, 0xdf, 0x56, 0x00, 0x76, 0x00, 0x51, 0xa3, 0xb0, 0xf5,
+  0xfd, 0x01, 0x79, 0x9c, 0x56, 0x6d, 0xb8, 0x37, 0x78, 0x8f, 0x0c, 0xa4,
+  0x7a, 0xcc, 0x1b, 0x27, 0xcb, 0xf7, 0x9e, 0x88, 0x42, 0x9a, 0x0d, 0xfe,
+  0xd4, 0x8b, 0x05, 0xe5, 0x00, 0x00, 0x01, 0x79, 0x19, 0x43, 0x10, 0xea,
+  0x00, 0x00, 0x04, 0x03, 0x00, 0x47, 0x30, 0x45, 0x02, 0x20, 0x68, 0x89,
+  0x8b, 0xab, 0x98, 0xd3, 0x4f, 0x41, 0x4f, 0x7d, 0x1c, 0x52, 0xbe, 0x1b,
+  0xf1, 0xbe, 0xb3, 0x68, 0x49, 0x5a, 0x91, 0x93, 0xdc, 0xac, 0xba, 0x6e,
+  0x58, 0x8d, 0xcd, 0x3c, 0x5a, 0x26, 0x02, 0x21, 0x00, 0x85, 0x09, 0xf7,
+  0x21, 0x4a, 0x66, 0x45, 0x77, 0xfe, 0xd5, 0x77, 0x25, 0xd5, 0xc5, 0x1a,
+  0xb3, 0x33, 0xd8, 0x86, 0x52, 0xcc, 0xe1, 0x26, 0x21, 0x03, 0xcf, 0x1b,
+  0x34, 0x24, 0xab, 0xc0, 0x1f, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48,
+  0x86, 0xf7, 0x0d, 0x01, 0x01, 0x0b, 0x05, 0x00, 0x03, 0x82, 0x01, 0x01,
+  0x00, 0xbd, 0x22, 0x40, 0xf1, 0x6d, 0xe7, 0x68, 0x89, 0x82, 0x53, 0xcd,
+  0x64, 0xed, 0x21, 0x17, 0x90, 0x3a, 0xd0, 0xa3, 0x21, 0x42, 0x40, 0x60,
+  0xf2, 0x2c, 0xf7, 0x40, 0xef, 0xc3, 0xf0, 0x22, 0x24, 0xc2, 0x51, 0x17,
+  0x9d, 0x4b, 0x10, 0x9f, 0x86, 0x1a, 0x05, 0x4c, 0x6a, 0xe0, 0x13, 0xbb,
+  0x29, 0xad, 0xf7, 0x18, 0x5f, 0x76, 0x01, 0x10, 0x8b, 0x1c, 0x29, 0x79,
+  0x23, 0x94, 0x58, 0x1a, 0xa6, 0xf8, 0xac, 0x9b, 0x2e, 0xe0, 0x70, 0x1d,
+  0x06, 0x1a, 0xe9, 0x5d, 0x24, 0x9f, 0x03, 0xff, 0x40, 0xe5, 0xc1, 0xb0,
+  0xb9, 0xa7, 0x7e, 0x19, 0x3d, 0x0c, 0x99, 0x89, 0x81, 0xe4, 0x53, 0x9b,
+  0xbd, 0x66, 0x1b, 0xba, 0x2e, 0xcd, 0xff, 0x24, 0x16, 0xd2, 0x89, 0xc9,
+  0x75, 0xdd, 0xc9, 0x78, 0x25, 0x1e, 0x11, 0x43, 0x25, 0x06, 0x15, 0xe5,
+  0xe3, 0x6b, 0xf9, 0x33, 0xee, 0x06, 0x16, 0x92, 0x8e, 0xe1, 0x8a, 0x93,
+  0x41, 0x15, 0x8b, 0xf1, 0x06, 0xf7, 0x52, 0x07, 0x25, 0xb8, 0x6a, 0xae,
+  0x46, 0x70, 0xa6, 0x81, 0x74, 0x70, 0x3c, 0x50, 0x42, 0x85, 0x65, 0x41,
+  0xdb, 0x25, 0xb3, 0x4f, 0xce, 0x25, 0xb5, 0x2b, 0x62, 0xb7, 0x2b, 0xbf,
+  0x66, 0xc4, 0xb4, 0x8a, 0x10, 0xb0, 0x50, 0x8e, 0x84, 0xf8, 0xe5, 0x28,
+  0x86, 0xda, 0x7d, 0xe6, 0x65, 0xbf, 0xb1, 0xd5, 0x7d, 0x09, 0x28, 0x61,
+  0xa3, 0x14, 0x89, 0x23, 0x35, 0x6e, 0x9c, 0x70, 0x06, 0x8b, 0xcb, 0x84,
+  0xe8, 0x70, 0x8d, 0xb9, 0xfb, 0x74, 0xcf, 0x77, 0x63, 0x00, 0x5d, 0x8c,
+  0xbb, 0x62, 0x4a, 0x2b, 0xc2, 0x8b, 0x2c, 0xd9, 0x9a, 0xa8, 0x83, 0x6f,
+  0x06, 0x2a, 0x2a, 0x30, 0x4c, 0x39, 0xb4, 0xf8, 0x7d, 0x8c, 0x5e, 0xa7,
+  0xcb, 0xce, 0x64, 0xe0, 0x27, 0xfa, 0x24, 0x42, 0xdd, 0xd1, 0x1d, 0xf8,
+  0xa9, 0xd7, 0xc4, 0x0c, 0x92
+};
+
+static const BYTE ocsp_cert_issuer[] = {
+  0x30, 0x82, 0x04, 0xbe, 0x30, 0x82, 0x03, 0xa6, 0xa0, 0x03, 0x02, 0x01,
+  0x02, 0x02, 0x10, 0x06, 0xd8, 0xd9, 0x04, 0xd5, 0x58, 0x43, 0x46, 0xf6,
+  0x8a, 0x2f, 0xa7, 0x54, 0x22, 0x7e, 0xc4, 0x30, 0x0d, 0x06, 0x09, 0x2a,
+  0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x0b, 0x05, 0x00, 0x30, 0x61,
+  0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55,
+  0x53, 0x31, 0x15, 0x30, 0x13, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x13, 0x0c,
+  0x44, 0x69, 0x67, 0x69, 0x43, 0x65, 0x72, 0x74, 0x20, 0x49, 0x6e, 0x63,
+  0x31, 0x19, 0x30, 0x17, 0x06, 0x03, 0x55, 0x04, 0x0b, 0x13, 0x10, 0x77,
+  0x77, 0x77, 0x2e, 0x64, 0x69, 0x67, 0x69, 0x63, 0x65, 0x72, 0x74, 0x2e,
+  0x63, 0x6f, 0x6d, 0x31, 0x20, 0x30, 0x1e, 0x06, 0x03, 0x55, 0x04, 0x03,
+  0x13, 0x17, 0x44, 0x69, 0x67, 0x69, 0x43, 0x65, 0x72, 0x74, 0x20, 0x47,
+  0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x20, 0x52, 0x6f, 0x6f, 0x74, 0x20, 0x43,
+  0x41, 0x30, 0x1e, 0x17, 0x0d, 0x32, 0x31, 0x30, 0x34, 0x31, 0x34, 0x30,
+  0x30, 0x30, 0x30, 0x30, 0x30, 0x5a, 0x17, 0x0d, 0x33, 0x31, 0x30, 0x34,
+  0x31, 0x33, 0x32, 0x33, 0x35, 0x39, 0x35, 0x39, 0x5a, 0x30, 0x4f, 0x31,
+  0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53,
+  0x31, 0x15, 0x30, 0x13, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x13, 0x0c, 0x44,
+  0x69, 0x67, 0x69, 0x43, 0x65, 0x72, 0x74, 0x20, 0x49, 0x6e, 0x63, 0x31,
+  0x29, 0x30, 0x27, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x20, 0x44, 0x69,
+  0x67, 0x69, 0x43, 0x65, 0x72, 0x74, 0x20, 0x54, 0x4c, 0x53, 0x20, 0x52,
+  0x53, 0x41, 0x20, 0x53, 0x48, 0x41, 0x32, 0x35, 0x36, 0x20, 0x32, 0x30,
+  0x32, 0x30, 0x20, 0x43, 0x41, 0x31, 0x30, 0x82, 0x01, 0x22, 0x30, 0x0d,
+  0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x01, 0x05,
+  0x00, 0x03, 0x82, 0x01, 0x0f, 0x00, 0x30, 0x82, 0x01, 0x0a, 0x02, 0x82,
+  0x01, 0x01, 0x00, 0xc1, 0x4b, 0xb3, 0x65, 0x47, 0x70, 0xbc, 0xdd, 0x4f,
+  0x58, 0xdb, 0xec, 0x9c, 0xed, 0xc3, 0x66, 0xe5, 0x1f, 0x31, 0x13, 0x54,
+  0xad, 0x4a, 0x66, 0x46, 0x1f, 0x2c, 0x0a, 0xec, 0x64, 0x07, 0xe5, 0x2e,
+  0xdc, 0xdc, 0xb9, 0x0a, 0x20, 0xed, 0xdf, 0xe3, 0xc4, 0xd0, 0x9e, 0x9a,
+  0xa9, 0x7a, 0x1d, 0x82, 0x88, 0xe5, 0x11, 0x56, 0xdb, 0x1e, 0x9f, 0x58,
+  0xc2, 0x51, 0xe7, 0x2c, 0x34, 0x0d, 0x2e, 0xd2, 0x92, 0xe1, 0x56, 0xcb,
+  0xf1, 0x79, 0x5f, 0xb3, 0xbb, 0x87, 0xca, 0x25, 0x03, 0x7b, 0x9a, 0x52,
+  0x41, 0x66, 0x10, 0x60, 0x4f, 0x57, 0x13, 0x49, 0xf0, 0xe8, 0x37, 0x67,
+  0x83, 0xdf, 0xe7, 0xd3, 0x4b, 0x67, 0x4c, 0x22, 0x51, 0xa6, 0xdf, 0x0e,
+  0x99, 0x10, 0xed, 0x57, 0x51, 0x74, 0x26, 0xe2, 0x7d, 0xc7, 0xca, 0x62,
+  0x2e, 0x13, 0x1b, 0x7f, 0x23, 0x88, 0x25, 0x53, 0x6f, 0xc1, 0x34, 0x58,
+  0x00, 0x8b, 0x84, 0xff, 0xf8, 0xbe, 0xa7, 0x58, 0x49, 0x22, 0x7b, 0x96,
+  0xad, 0xa2, 0x88, 0x9b, 0x15, 0xbc, 0xa0, 0x7c, 0xdf, 0xe9, 0x51, 0xa8,
+  0xd5, 0xb0, 0xed, 0x37, 0xe2, 0x36, 0xb4, 0x82, 0x4b, 0x62, 0xb5, 0x49,
+  0x9a, 0xec, 0xc7, 0x67, 0xd6, 0xe3, 0x3e, 0xf5, 0xe3, 0xd6, 0x12, 0x5e,
+  0x44, 0xf1, 0xbf, 0x71, 0x42, 0x7d, 0x58, 0x84, 0x03, 0x80, 0xb1, 0x81,
+  0x01, 0xfa, 0xf9, 0xca, 0x32, 0xbb, 0xb4, 0x8e, 0x27, 0x87, 0x27, 0xc5,
+  0x2b, 0x74, 0xd4, 0xa8, 0xd6, 0x97, 0xde, 0xc3, 0x64, 0xf9, 0xca, 0xce,
+  0x53, 0xa2, 0x56, 0xbc, 0x78, 0x17, 0x8e, 0x49, 0x03, 0x29, 0xae, 0xfb,
+  0x49, 0x4f, 0xa4, 0x15, 0xb9, 0xce, 0xf2, 0x5c, 0x19, 0x57, 0x6d, 0x6b,
+  0x79, 0xa7, 0x2b, 0xa2, 0x27, 0x20, 0x13, 0xb5, 0xd0, 0x3d, 0x40, 0xd3,
+  0x21, 0x30, 0x07, 0x93, 0xea, 0x99, 0xf5, 0x02, 0x03, 0x01, 0x00, 0x01,
+  0xa3, 0x82, 0x01, 0x82, 0x30, 0x82, 0x01, 0x7e, 0x30, 0x12, 0x06, 0x03,
+  0x55, 0x1d, 0x13, 0x01, 0x01, 0xff, 0x04, 0x08, 0x30, 0x06, 0x01, 0x01,
+  0xff, 0x02, 0x01, 0x00, 0x30, 0x1d, 0x06, 0x03, 0x55, 0x1d, 0x0e, 0x04,
+  0x16, 0x04, 0x14, 0xb7, 0x6b, 0xa2, 0xea, 0xa8, 0xaa, 0x84, 0x8c, 0x79,
+  0xea, 0xb4, 0xda, 0x0f, 0x98, 0xb2, 0xc5, 0x95, 0x76, 0xb9, 0xf4, 0x30,
+  0x1f, 0x06, 0x03, 0x55, 0x1d, 0x23, 0x04, 0x18, 0x30, 0x16, 0x80, 0x14,
+  0x03, 0xde, 0x50, 0x35, 0x56, 0xd1, 0x4c, 0xbb, 0x66, 0xf0, 0xa3, 0xe2,
+  0x1b, 0x1b, 0xc3, 0x97, 0xb2, 0x3d, 0xd1, 0x55, 0x30, 0x0e, 0x06, 0x03,
+  0x55, 0x1d, 0x0f, 0x01, 0x01, 0xff, 0x04, 0x04, 0x03, 0x02, 0x01, 0x86,
+  0x30, 0x1d, 0x06, 0x03, 0x55, 0x1d, 0x25, 0x04, 0x16, 0x30, 0x14, 0x06,
+  0x08, 0x2b, 0x06, 0x01, 0x05, 0x05, 0x07, 0x03, 0x01, 0x06, 0x08, 0x2b,
+  0x06, 0x01, 0x05, 0x05, 0x07, 0x03, 0x02, 0x30, 0x76, 0x06, 0x08, 0x2b,
+  0x06, 0x01, 0x05, 0x05, 0x07, 0x01, 0x01, 0x04, 0x6a, 0x30, 0x68, 0x30,
+  0x24, 0x06, 0x08, 0x2b, 0x06, 0x01, 0x05, 0x05, 0x07, 0x30, 0x01, 0x86,
+  0x18, 0x68, 0x74, 0x74, 0x70, 0x3a, 0x2f, 0x2f, 0x6f, 0x63, 0x73, 0x70,
+  0x2e, 0x64, 0x69, 0x67, 0x69, 0x63, 0x65, 0x72, 0x74, 0x2e, 0x63, 0x6f,
+  0x6d, 0x30, 0x40, 0x06, 0x08, 0x2b, 0x06, 0x01, 0x05, 0x05, 0x07, 0x30,
+  0x02, 0x86, 0x34, 0x68, 0x74, 0x74, 0x70, 0x3a, 0x2f, 0x2f, 0x63, 0x61,
+  0x63, 0x65, 0x72, 0x74, 0x73, 0x2e, 0x64, 0x69, 0x67, 0x69, 0x63, 0x65,
+  0x72, 0x74, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x44, 0x69, 0x67, 0x69, 0x43,
+  0x65, 0x72, 0x74, 0x47, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x52, 0x6f, 0x6f,
+  0x74, 0x43, 0x41, 0x2e, 0x63, 0x72, 0x74, 0x30, 0x42, 0x06, 0x03, 0x55,
+  0x1d, 0x1f, 0x04, 0x3b, 0x30, 0x39, 0x30, 0x37, 0xa0, 0x35, 0xa0, 0x33,
+  0x86, 0x31, 0x68, 0x74, 0x74, 0x70, 0x3a, 0x2f, 0x2f, 0x63, 0x72, 0x6c,
+  0x33, 0x2e, 0x64, 0x69, 0x67, 0x69, 0x63, 0x65, 0x72, 0x74, 0x2e, 0x63,
+  0x6f, 0x6d, 0x2f, 0x44, 0x69, 0x67, 0x69, 0x43, 0x65, 0x72, 0x74, 0x47,
+  0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x52, 0x6f, 0x6f, 0x74, 0x43, 0x41, 0x2e,
+  0x63, 0x72, 0x6c, 0x30, 0x3d, 0x06, 0x03, 0x55, 0x1d, 0x20, 0x04, 0x36,
+  0x30, 0x34, 0x30, 0x0b, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x86, 0xfd,
+  0x6c, 0x02, 0x01, 0x30, 0x07, 0x06, 0x05, 0x67, 0x81, 0x0c, 0x01, 0x01,
+  0x30, 0x08, 0x06, 0x06, 0x67, 0x81, 0x0c, 0x01, 0x02, 0x01, 0x30, 0x08,
+  0x06, 0x06, 0x67, 0x81, 0x0c, 0x01, 0x02, 0x02, 0x30, 0x08, 0x06, 0x06,
+  0x67, 0x81, 0x0c, 0x01, 0x02, 0x03, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86,
+  0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x0b, 0x05, 0x00, 0x03, 0x82, 0x01,
+  0x01, 0x00, 0x80, 0x32, 0xce, 0x5e, 0x0b, 0xdd, 0x6e, 0x5a, 0x0d, 0x0a,
+  0xaf, 0xe1, 0xd6, 0x84, 0xcb, 0xc0, 0x8e, 0xfa, 0x85, 0x70, 0xed, 0xda,
+  0x5d, 0xb3, 0x0c, 0xf7, 0x2b, 0x75, 0x40, 0xfe, 0x85, 0x0a, 0xfa, 0xf3,
+  0x31, 0x78, 0xb7, 0x70, 0x4b, 0x1a, 0x89, 0x58, 0xba, 0x80, 0xbd, 0xf3,
+  0x6b, 0x1d, 0xe9, 0x7e, 0xcf, 0x0b, 0xba, 0x58, 0x9c, 0x59, 0xd4, 0x90,
+  0xd3, 0xfd, 0x6c, 0xfd, 0xd0, 0x98, 0x6d, 0xb7, 0x71, 0x82, 0x5b, 0xcf,
+  0x6d, 0x0b, 0x5a, 0x09, 0xd0, 0x7b, 0xde, 0xc4, 0x43, 0xd8, 0x2a, 0xa4,
+  0xde, 0x9e, 0x41, 0x26, 0x5f, 0xbb, 0x8f, 0x99, 0xcb, 0xdd, 0xae, 0xe1,
+  0xa8, 0x6f, 0x9f, 0x87, 0xfe, 0x74, 0xb7, 0x1f, 0x1b, 0x20, 0xab, 0xb1,
+  0x4f, 0xc6, 0xf5, 0x67, 0x5d, 0x5d, 0x9b, 0x3c, 0xe9, 0xff, 0x69, 0xf7,
+  0x61, 0x6c, 0xd6, 0xd9, 0xf3, 0xfd, 0x36, 0xc6, 0xab, 0x03, 0x88, 0x76,
+  0xd2, 0x4b, 0x2e, 0x75, 0x86, 0xe3, 0xfc, 0xd8, 0x55, 0x7d, 0x26, 0xc2,
+  0x11, 0x77, 0xdf, 0x3e, 0x02, 0xb6, 0x7c, 0xf3, 0xab, 0x7b, 0x7a, 0x86,
+  0x36, 0x6f, 0xb8, 0xf7, 0xd8, 0x93, 0x71, 0xcf, 0x86, 0xdf, 0x73, 0x30,
+  0xfa, 0x7b, 0xab, 0xed, 0x2a, 0x59, 0xc8, 0x42, 0x84, 0x3b, 0x11, 0x17,
+  0x1a, 0x52, 0xf3, 0xc9, 0x0e, 0x14, 0x7d, 0xa2, 0x5b, 0x72, 0x67, 0xba,
+  0x71, 0xed, 0x57, 0x47, 0x66, 0xc5, 0xb8, 0x02, 0x4a, 0x65, 0x34, 0x5e,
+  0x8b, 0xd0, 0x2a, 0x3c, 0x20, 0x9c, 0x51, 0x99, 0x4c, 0xe7, 0x52, 0x9e,
+  0xf7, 0x6b, 0x11, 0x2b, 0x0d, 0x92, 0x7e, 0x1d, 0xe8, 0x8a, 0xeb, 0x36,
+  0x16, 0x43, 0x87, 0xea, 0x2a, 0x63, 0xbf, 0x75, 0x3f, 0xeb, 0xde, 0xc4,
+  0x03, 0xbb, 0x0a, 0x3c, 0xf7, 0x30, 0xef, 0xeb, 0xaf, 0x4c, 0xfc, 0x8b,
+  0x36, 0x10, 0x73, 0x3e, 0xf3, 0xa4
+};
+
+static const BYTE ocsp_cert_revoked[] = {
+  0x30, 0x82, 0x06, 0x86, 0x30, 0x82, 0x05, 0x6e, 0xa0, 0x03, 0x02, 0x01,
+  0x02, 0x02, 0x10, 0x0d, 0x2e, 0x67, 0xa2, 0x98, 0x85, 0x3b, 0x9a, 0x54,
+  0x52, 0xe3, 0xa2, 0x85, 0xa4, 0x57, 0x2f, 0x30, 0x0d, 0x06, 0x09, 0x2a,
+  0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x0b, 0x05, 0x00, 0x30, 0x59,
+  0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55,
+  0x53, 0x31, 0x15, 0x30, 0x13, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x13, 0x0c,
+  0x44, 0x69, 0x67, 0x69, 0x43, 0x65, 0x72, 0x74, 0x20, 0x49, 0x6e, 0x63,
+  0x31, 0x33, 0x30, 0x31, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x2a, 0x52,
+  0x61, 0x70, 0x69, 0x64, 0x53, 0x53, 0x4c, 0x20, 0x54, 0x4c, 0x53, 0x20,
+  0x44, 0x56, 0x20, 0x52, 0x53, 0x41, 0x20, 0x4d, 0x69, 0x78, 0x65, 0x64,
+  0x20, 0x53, 0x48, 0x41, 0x32, 0x35, 0x36, 0x20, 0x32, 0x30, 0x32, 0x30,
+  0x20, 0x43, 0x41, 0x2d, 0x31, 0x30, 0x1e, 0x17, 0x0d, 0x32, 0x31, 0x31,
+  0x30, 0x32, 0x37, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x5a, 0x17, 0x0d,
+  0x32, 0x32, 0x31, 0x30, 0x32, 0x37, 0x32, 0x33, 0x35, 0x39, 0x35, 0x39,
+  0x5a, 0x30, 0x1d, 0x31, 0x1b, 0x30, 0x19, 0x06, 0x03, 0x55, 0x04, 0x03,
+  0x13, 0x12, 0x72, 0x65, 0x76, 0x6f, 0x6b, 0x65, 0x64, 0x2e, 0x62, 0x61,
+  0x64, 0x73, 0x73, 0x6c, 0x2e, 0x63, 0x6f, 0x6d, 0x30, 0x82, 0x01, 0x22,
+  0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01,
+  0x01, 0x05, 0x00, 0x03, 0x82, 0x01, 0x0f, 0x00, 0x30, 0x82, 0x01, 0x0a,
+  0x02, 0x82, 0x01, 0x01, 0x00, 0xb0, 0x76, 0x2d, 0x55, 0x66, 0xdc, 0x72,
+  0x8a, 0xa0, 0x9e, 0x85, 0x92, 0x38, 0x7f, 0x5b, 0xe1, 0x93, 0x8d, 0xad,
+  0x06, 0xc8, 0xad, 0xe9, 0x89, 0xb4, 0xef, 0x1e, 0x77, 0x5b, 0x33, 0x45,
+  0x16, 0x60, 0x7d, 0x33, 0x38, 0x68, 0x04, 0xd7, 0xc9, 0x83, 0x42, 0x83,
+  0xd9, 0x30, 0x4b, 0x54, 0x49, 0x14, 0xca, 0xed, 0xbe, 0x0c, 0x76, 0xba,
+  0x5f, 0xa6, 0x5c, 0x33, 0x78, 0x3f, 0x39, 0xf2, 0x49, 0xa8, 0x88, 0x32,
+  0xee, 0x53, 0x21, 0x14, 0xd3, 0xaa, 0x5c, 0x58, 0x3c, 0x39, 0xcc, 0xf7,
+  0x80, 0xb1, 0x27, 0x1f, 0x54, 0x79, 0x7b, 0x6c, 0x8b, 0xff, 0x41, 0xaa,
+  0x39, 0x24, 0x95, 0x5f, 0x71, 0xbc, 0x49, 0xbf, 0x39, 0x3b, 0xa5, 0xd5,
+  0xe1, 0xa5, 0xde, 0x1d, 0x40, 0x81, 0x25, 0xdc, 0x8a, 0x47, 0x82, 0xfe,
+  0xcd, 0x7c, 0x4b, 0x2c, 0x04, 0xbb, 0xd3, 0x27, 0x56, 0x51, 0xa0, 0x61,
+  0xf2, 0xd2, 0xcb, 0x55, 0x08, 0x25, 0x2a, 0x85, 0xdb, 0x2c, 0x06, 0x8d,
+  0x0d, 0x61, 0xc2, 0x5b, 0x3e, 0x9b, 0x46, 0xdc, 0x58, 0xff, 0x13, 0x27,
+  0xbe, 0x0a, 0x44, 0x1e, 0x68, 0xfe, 0xe1, 0xf6, 0xb7, 0xde, 0x9f, 0x8e,
+  0x6c, 0xc4, 0xb5, 0x19, 0xfa, 0xd7, 0xd3, 0x4f, 0x55, 0xa8, 0x61, 0x79,
+  0xdb, 0x61, 0x2f, 0x6a, 0x9c, 0x2c, 0xf1, 0xc4, 0x81, 0xbb, 0x9e, 0xd2,
+  0x02, 0x05, 0xba, 0x9c, 0x14, 0xa0, 0xf9, 0xf3, 0x54, 0x79, 0x7d, 0x69,
+  0xd9, 0xba, 0x66, 0x1c, 0x87, 0x95, 0x41, 0x50, 0x0e, 0xf9, 0x5e, 0xe1,
+  0xb7, 0xbd, 0xf5, 0x31, 0x24, 0xc5, 0x21, 0x21, 0x03, 0x8a, 0xcf, 0x6d,
+  0x78, 0x58, 0xde, 0xd9, 0x30, 0x7d, 0x03, 0x42, 0x52, 0xd6, 0xb0, 0x1b,
+  0xb9, 0xc9, 0x54, 0x1b, 0x5a, 0xe8, 0xc8, 0x53, 0xf0, 0xac, 0x2b, 0x82,
+  0x10, 0x27, 0xa6, 0xa9, 0x70, 0x25, 0xae, 0xf8, 0xa7, 0x02, 0x03, 0x01,
+  0x00, 0x01, 0xa3, 0x82, 0x03, 0x84, 0x30, 0x82, 0x03, 0x80, 0x30, 0x1f,
+  0x06, 0x03, 0x55, 0x1d, 0x23, 0x04, 0x18, 0x30, 0x16, 0x80, 0x14, 0xa4,
+  0x8d, 0xe5, 0xbe, 0x7c, 0x79, 0xe4, 0x70, 0x23, 0x6d, 0x2e, 0x29, 0x34,
+  0xad, 0x23, 0x58, 0xdc, 0xf5, 0x31, 0x7f, 0x30, 0x1d, 0x06, 0x03, 0x55,
+  0x1d, 0x0e, 0x04, 0x16, 0x04, 0x14, 0xb0, 0xc8, 0xce, 0x20, 0xb2, 0x78,
+  0xcc, 0x1d, 0x23, 0xef, 0xf0, 0xfe, 0xd6, 0x0e, 0x29, 0x4b, 0xac, 0x15,
+  0x72, 0x3c, 0x30, 0x1d, 0x06, 0x03, 0x55, 0x1d, 0x11, 0x04, 0x16, 0x30,
+  0x14, 0x82, 0x12, 0x72, 0x65, 0x76, 0x6f, 0x6b, 0x65, 0x64, 0x2e, 0x62,
+  0x61, 0x64, 0x73, 0x73, 0x6c, 0x2e, 0x63, 0x6f, 0x6d, 0x30, 0x0e, 0x06,
+  0x03, 0x55, 0x1d, 0x0f, 0x01, 0x01, 0xff, 0x04, 0x04, 0x03, 0x02, 0x05,
+  0xa0, 0x30, 0x1d, 0x06, 0x03, 0x55, 0x1d, 0x25, 0x04, 0x16, 0x30, 0x14,
+  0x06, 0x08, 0x2b, 0x06, 0x01, 0x05, 0x05, 0x07, 0x03, 0x01, 0x06, 0x08,
+  0x2b, 0x06, 0x01, 0x05, 0x05, 0x07, 0x03, 0x02, 0x30, 0x81, 0x9b, 0x06,
+  0x03, 0x55, 0x1d, 0x1f, 0x04, 0x81, 0x93, 0x30, 0x81, 0x90, 0x30, 0x46,
+  0xa0, 0x44, 0xa0, 0x42, 0x86, 0x40, 0x68, 0x74, 0x74, 0x70, 0x3a, 0x2f,
+  0x2f, 0x63, 0x72, 0x6c, 0x33, 0x2e, 0x64, 0x69, 0x67, 0x69, 0x63, 0x65,
+  0x72, 0x74, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x52, 0x61, 0x70, 0x69, 0x64,
+  0x53, 0x53, 0x4c, 0x54, 0x4c, 0x53, 0x44, 0x56, 0x52, 0x53, 0x41, 0x4d,
+  0x69, 0x78, 0x65, 0x64, 0x53, 0x48, 0x41, 0x32, 0x35, 0x36, 0x32, 0x30,
+  0x32, 0x30, 0x43, 0x41, 0x2d, 0x31, 0x2e, 0x63, 0x72, 0x6c, 0x30, 0x46,
+  0xa0, 0x44, 0xa0, 0x42, 0x86, 0x40, 0x68, 0x74, 0x74, 0x70, 0x3a, 0x2f,
+  0x2f, 0x63, 0x72, 0x6c, 0x34, 0x2e, 0x64, 0x69, 0x67, 0x69, 0x63, 0x65,
+  0x72, 0x74, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x52, 0x61, 0x70, 0x69, 0x64,
+  0x53, 0x53, 0x4c, 0x54, 0x4c, 0x53, 0x44, 0x56, 0x52, 0x53, 0x41, 0x4d,
+  0x69, 0x78, 0x65, 0x64, 0x53, 0x48, 0x41, 0x32, 0x35, 0x36, 0x32, 0x30,
+  0x32, 0x30, 0x43, 0x41, 0x2d, 0x31, 0x2e, 0x63, 0x72, 0x6c, 0x30, 0x3e,
+  0x06, 0x03, 0x55, 0x1d, 0x20, 0x04, 0x37, 0x30, 0x35, 0x30, 0x33, 0x06,
+  0x06, 0x67, 0x81, 0x0c, 0x01, 0x02, 0x01, 0x30, 0x29, 0x30, 0x27, 0x06,
+  0x08, 0x2b, 0x06, 0x01, 0x05, 0x05, 0x07, 0x02, 0x01, 0x16, 0x1b, 0x68,
+  0x74, 0x74, 0x70, 0x3a, 0x2f, 0x2f, 0x77, 0x77, 0x77, 0x2e, 0x64, 0x69,
+  0x67, 0x69, 0x63, 0x65, 0x72, 0x74, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x43,
+  0x50, 0x53, 0x30, 0x81, 0x85, 0x06, 0x08, 0x2b, 0x06, 0x01, 0x05, 0x05,
+  0x07, 0x01, 0x01, 0x04, 0x79, 0x30, 0x77, 0x30, 0x24, 0x06, 0x08, 0x2b,
+  0x06, 0x01, 0x05, 0x05, 0x07, 0x30, 0x01, 0x86, 0x18, 0x68, 0x74, 0x74,
+  0x70, 0x3a, 0x2f, 0x2f, 0x6f, 0x63, 0x73, 0x70, 0x2e, 0x64, 0x69, 0x67,
+  0x69, 0x63, 0x65, 0x72, 0x74, 0x2e, 0x63, 0x6f, 0x6d, 0x30, 0x4f, 0x06,
+  0x08, 0x2b, 0x06, 0x01, 0x05, 0x05, 0x07, 0x30, 0x02, 0x86, 0x43, 0x68,
+  0x74, 0x74, 0x70, 0x3a, 0x2f, 0x2f, 0x63, 0x61, 0x63, 0x65, 0x72, 0x74,
+  0x73, 0x2e, 0x64, 0x69, 0x67, 0x69, 0x63, 0x65, 0x72, 0x74, 0x2e, 0x63,
+  0x6f, 0x6d, 0x2f, 0x52, 0x61, 0x70, 0x69, 0x64, 0x53, 0x53, 0x4c, 0x54,
+  0x4c, 0x53, 0x44, 0x56, 0x52, 0x53, 0x41, 0x4d, 0x69, 0x78, 0x65, 0x64,
+  0x53, 0x48, 0x41, 0x32, 0x35, 0x36, 0x32, 0x30, 0x32, 0x30, 0x43, 0x41,
+  0x2d, 0x31, 0x2e, 0x63, 0x72, 0x74, 0x30, 0x09, 0x06, 0x03, 0x55, 0x1d,
+  0x13, 0x04, 0x02, 0x30, 0x00, 0x30, 0x82, 0x01, 0x7d, 0x06, 0x0a, 0x2b,
+  0x06, 0x01, 0x04, 0x01, 0xd6, 0x79, 0x02, 0x04, 0x02, 0x04, 0x82, 0x01,
+  0x6d, 0x04, 0x82, 0x01, 0x69, 0x01, 0x67, 0x00, 0x76, 0x00, 0x29, 0x79,
+  0xbe, 0xf0, 0x9e, 0x39, 0x39, 0x21, 0xf0, 0x56, 0x73, 0x9f, 0x63, 0xa5,
+  0x77, 0xe5, 0xbe, 0x57, 0x7d, 0x9c, 0x60, 0x0a, 0xf8, 0xf9, 0x4d, 0x5d,
+  0x26, 0x5c, 0x25, 0x5d, 0xc7, 0x84, 0x00, 0x00, 0x01, 0x7c, 0xc3, 0xa4,
+  0xf7, 0x37, 0x00, 0x00, 0x04, 0x03, 0x00, 0x47, 0x30, 0x45, 0x02, 0x20,
+  0x77, 0xb0, 0x79, 0x18, 0xf3, 0xde, 0x34, 0x70, 0xfa, 0xf2, 0x1b, 0xc2,
+  0x32, 0x39, 0xc8, 0xc8, 0x95, 0xb0, 0xc8, 0x7a, 0x8f, 0x62, 0x23, 0x58,
+  0xdd, 0xad, 0xf9, 0x1b, 0xbe, 0x84, 0x95, 0xed, 0x02, 0x21, 0x00, 0xdd,
+  0x25, 0x68, 0x47, 0xa3, 0x84, 0x5f, 0x95, 0xb1, 0xea, 0xe7, 0xbc, 0x0a,
+  0x09, 0x92, 0xf9, 0x5a, 0x56, 0x72, 0x31, 0xec, 0x07, 0xd6, 0xc6, 0x97,
+  0x4d, 0x4c, 0x7b, 0x90, 0x75, 0x64, 0xae, 0x00, 0x76, 0x00, 0x51, 0xa3,
+  0xb0, 0xf5, 0xfd, 0x01, 0x79, 0x9c, 0x56, 0x6d, 0xb8, 0x37, 0x78, 0x8f,
+  0x0c, 0xa4, 0x7a, 0xcc, 0x1b, 0x27, 0xcb, 0xf7, 0x9e, 0x88, 0x42, 0x9a,
+  0x0d, 0xfe, 0xd4, 0x8b, 0x05, 0xe5, 0x00, 0x00, 0x01, 0x7c, 0xc3, 0xa4,
+  0xf7, 0x64, 0x00, 0x00, 0x04, 0x03, 0x00, 0x47, 0x30, 0x45, 0x02, 0x20,
+  0x4c, 0x22, 0xff, 0x65, 0x39, 0x6b, 0x7e, 0x7b, 0x15, 0x21, 0x79, 0x44,
+  0xc2, 0xeb, 0xb8, 0x4c, 0x2a, 0xc9, 0xa5, 0xc7, 0xac, 0xce, 0x5f, 0x6a,
+  0x5d, 0xe8, 0xb7, 0x24, 0xc5, 0x76, 0xec, 0x19, 0x02, 0x21, 0x00, 0x94,
+  0x5e, 0x02, 0xee, 0x14, 0x60, 0x80, 0x96, 0xbc, 0x0e, 0x39, 0x16, 0x01,
+  0xa8, 0x37, 0x9f, 0x15, 0xb9, 0xb9, 0xba, 0x0f, 0xa2, 0x0c, 0x5a, 0x17,
+  0x90, 0xa5, 0xe1, 0x33, 0x36, 0x45, 0xf2, 0x00, 0x75, 0x00, 0x41, 0xc8,
+  0xca, 0xb1, 0xdf, 0x22, 0x46, 0x4a, 0x10, 0xc6, 0xa1, 0x3a, 0x09, 0x42,
+  0x87, 0x5e, 0x4e, 0x31, 0x8b, 0x1b, 0x03, 0xeb, 0xeb, 0x4b, 0xc7, 0x68,
+  0xf0, 0x90, 0x62, 0x96, 0x06, 0xf6, 0x00, 0x00, 0x01, 0x7c, 0xc3, 0xa4,
+  0xf6, 0xdf, 0x00, 0x00, 0x04, 0x03, 0x00, 0x46, 0x30, 0x44, 0x02, 0x20,
+  0x68, 0x8a, 0x5f, 0x50, 0xb7, 0x76, 0xda, 0x7e, 0x34, 0x32, 0xa5, 0x77,
+  0x02, 0xa6, 0xfa, 0xa7, 0x87, 0xbb, 0xdb, 0x41, 0x5c, 0x80, 0x40, 0x2c,
+  0x05, 0xe5, 0x09, 0xdd, 0x3f, 0xcc, 0x6d, 0x9f, 0x02, 0x20, 0x7b, 0x1d,
+  0x64, 0x48, 0x61, 0x19, 0x75, 0xb6, 0x37, 0xd1, 0x3c, 0x1e, 0x38, 0x78,
+  0x86, 0x7a, 0xf2, 0x79, 0x14, 0x08, 0x42, 0xe8, 0xdd, 0x0f, 0xff, 0x38,
+  0x3a, 0x3c, 0x36, 0xd9, 0xbf, 0xd9, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86,
+  0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x0b, 0x05, 0x00, 0x03, 0x82, 0x01,
+  0x01, 0x00, 0xd5, 0x8c, 0xbd, 0xbe, 0xe4, 0xdc, 0x94, 0xa4, 0xb7, 0xf3,
+  0x49, 0xaf, 0xc4, 0x99, 0x26, 0xda, 0x27, 0x68, 0xda, 0xe8, 0xb8, 0xc1,
+  0xba, 0xc6, 0x30, 0xb6, 0x16, 0xaa, 0x50, 0xfe, 0xf4, 0x77, 0x07, 0xeb,
+  0x99, 0xf2, 0xda, 0xdd, 0x77, 0x1d, 0x19, 0x82, 0xf7, 0x24, 0x2a, 0x3b,
+  0xa0, 0x63, 0xe0, 0xdb, 0x09, 0xbe, 0x10, 0x7f, 0xc5, 0x1f, 0x81, 0xba,
+  0xaf, 0x9e, 0x49, 0xce, 0x32, 0x30, 0x49, 0x17, 0x8f, 0x74, 0xc6, 0xd6,
+  0xcd, 0x6a, 0xd8, 0x3b, 0x47, 0x7b, 0xf0, 0xe0, 0x0c, 0xbb, 0xc0, 0x8e,
+  0x3a, 0x1d, 0xa3, 0x7f, 0x92, 0xac, 0x7e, 0x8d, 0xdc, 0xa4, 0xb5, 0x30,
+  0x2a, 0x57, 0x13, 0x23, 0xa7, 0xee, 0x25, 0xc6, 0x37, 0xed, 0x48, 0xb2,
+  0x4a, 0xd0, 0x01, 0xfc, 0x85, 0xe5, 0xc1, 0xe2, 0xe0, 0xdc, 0x8c, 0x61,
+  0x74, 0xaa, 0xaf, 0x68, 0x28, 0x26, 0x45, 0x94, 0xa3, 0xb1, 0x4c, 0xc9,
+  0x5c, 0xc7, 0x92, 0xa2, 0x6c, 0x4a, 0x80, 0x6f, 0xdd, 0x48, 0xfa, 0x4f,
+  0x04, 0xb2, 0x4a, 0x73, 0x17, 0xf2, 0xf9, 0x1e, 0x8e, 0x5c, 0xe9, 0x23,
+  0xec, 0x53, 0xff, 0x3e, 0xc7, 0x8a, 0xb6, 0x18, 0x89, 0xbc, 0x77, 0x45,
+  0x67, 0x4b, 0x9a, 0x73, 0x75, 0x6b, 0x57, 0xc8, 0xc0, 0x6a, 0xcb, 0x84,
+  0x1d, 0xf4, 0xed, 0xef, 0x70, 0x16, 0x77, 0x8e, 0xf3, 0x1a, 0x8e, 0xbb,
+  0x95, 0xf3, 0xeb, 0xf8, 0x5a, 0xe4, 0xa9, 0xb1, 0xdf, 0x1d, 0x36, 0xab,
+  0x0a, 0xdd, 0x91, 0xaf, 0x2d, 0x71, 0x3c, 0xab, 0x97, 0x18, 0x03, 0xdc,
+  0x5c, 0x1a, 0xa9, 0xb1, 0xdb, 0xb6, 0x48, 0x40, 0xc7, 0x19, 0xa7, 0x81,
+  0x14, 0x0b, 0x0d, 0xce, 0x38, 0x6f, 0xda, 0xcf, 0xce, 0x0f, 0x64, 0x13,
+  0x28, 0xf3, 0x4d, 0x67, 0x1b, 0x2c, 0xd1, 0x16, 0x54, 0x19, 0x6f, 0xaa,
+  0x08, 0x54, 0xa3, 0x4d, 0x67, 0x64
+};
+
+static const BYTE ocsp_cert_revoked_issuer[] = {
+  0x30, 0x82, 0x05, 0x51, 0x30, 0x82, 0x04, 0x39, 0xa0, 0x03, 0x02, 0x01,
+  0x02, 0x02, 0x10, 0x07, 0x98, 0x36, 0x03, 0xad, 0xe3, 0x99, 0x08, 0x21,
+  0x9c, 0xa0, 0x0c, 0x27, 0xbc, 0x8a, 0x6c, 0x30, 0x0d, 0x06, 0x09, 0x2a,
+  0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x0b, 0x05, 0x00, 0x30, 0x61,
+  0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55,
+  0x53, 0x31, 0x15, 0x30, 0x13, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x13, 0x0c,
+  0x44, 0x69, 0x67, 0x69, 0x43, 0x65, 0x72, 0x74, 0x20, 0x49, 0x6e, 0x63,
+  0x31, 0x19, 0x30, 0x17, 0x06, 0x03, 0x55, 0x04, 0x0b, 0x13, 0x10, 0x77,
+  0x77, 0x77, 0x2e, 0x64, 0x69, 0x67, 0x69, 0x63, 0x65, 0x72, 0x74, 0x2e,
+  0x63, 0x6f, 0x6d, 0x31, 0x20, 0x30, 0x1e, 0x06, 0x03, 0x55, 0x04, 0x03,
+  0x13, 0x17, 0x44, 0x69, 0x67, 0x69, 0x43, 0x65, 0x72, 0x74, 0x20, 0x47,
+  0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x20, 0x52, 0x6f, 0x6f, 0x74, 0x20, 0x43,
+  0x41, 0x30, 0x1e, 0x17, 0x0d, 0x32, 0x30, 0x30, 0x37, 0x31, 0x36, 0x31,
+  0x32, 0x32, 0x35, 0x32, 0x37, 0x5a, 0x17, 0x0d, 0x32, 0x33, 0x30, 0x35,
+  0x33, 0x31, 0x32, 0x33, 0x35, 0x39, 0x35, 0x39, 0x5a, 0x30, 0x59, 0x31,
+  0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53,
+  0x31, 0x15, 0x30, 0x13, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x13, 0x0c, 0x44,
+  0x69, 0x67, 0x69, 0x43, 0x65, 0x72, 0x74, 0x20, 0x49, 0x6e, 0x63, 0x31,
+  0x33, 0x30, 0x31, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x2a, 0x52, 0x61,
+  0x70, 0x69, 0x64, 0x53, 0x53, 0x4c, 0x20, 0x54, 0x4c, 0x53, 0x20, 0x44,
+  0x56, 0x20, 0x52, 0x53, 0x41, 0x20, 0x4d, 0x69, 0x78, 0x65, 0x64, 0x20,
+  0x53, 0x48, 0x41, 0x32, 0x35, 0x36, 0x20, 0x32, 0x30, 0x32, 0x30, 0x20,
+  0x43, 0x41, 0x2d, 0x31, 0x30, 0x82, 0x01, 0x22, 0x30, 0x0d, 0x06, 0x09,
+  0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03,
+  0x82, 0x01, 0x0f, 0x00, 0x30, 0x82, 0x01, 0x0a, 0x02, 0x82, 0x01, 0x01,
+  0x00, 0xda, 0x6e, 0x43, 0x55, 0x55, 0x99, 0x7b, 0xd9, 0x95, 0xa2, 0x66,
+  0xc4, 0x65, 0x58, 0xa2, 0xd0, 0x0c, 0x17, 0x3a, 0x00, 0xa6, 0x88, 0x5b,
+  0x24, 0x07, 0x8d, 0xa7, 0x33, 0x7e, 0xe3, 0xd2, 0xdb, 0x82, 0x4a, 0xcc,
+  0x2e, 0xfd, 0xad, 0x6e, 0x52, 0x08, 0xf0, 0x7e, 0x37, 0xbc, 0xde, 0xd4,
+  0x16, 0xe9, 0xb1, 0x57, 0xb9, 0x49, 0x74, 0xfc, 0x0b, 0x3f, 0x6d, 0xaa,
+  0x6b, 0x4b, 0x15, 0xf5, 0xcc, 0x02, 0xaf, 0xa4, 0x19, 0xa0, 0x61, 0x28,
+  0x6d, 0xd6, 0xbe, 0xe2, 0x9b, 0x9f, 0x1b, 0x46, 0x92, 0x7c, 0x74, 0x02,
+  0x42, 0x1b, 0xa5, 0x6a, 0xa2, 0xa9, 0x3d, 0xc6, 0x18, 0x38, 0xf8, 0xd3,
+  0xc2, 0x0a, 0x89, 0x03, 0xce, 0x00, 0x15, 0x88, 0xfc, 0x97, 0xf2, 0x1e,
+  0x43, 0xc9, 0xf4, 0xd5, 0x5c, 0x82, 0xba, 0xb3, 0x08, 0x1c, 0x0e, 0x3b,
+  0xf2, 0xdb, 0x36, 0x1b, 0xa1, 0x86, 0xb4, 0x4c, 0x74, 0xb9, 0xc9, 0xc4,
+  0x7d, 0x5d, 0x90, 0x1d, 0x42, 0xfa, 0xe0, 0x40, 0xb6, 0xca, 0x1e, 0xf2,
+  0x6d, 0xba, 0x28, 0xe6, 0xff, 0x27, 0x15, 0x65, 0x78, 0x97, 0x1f, 0xf1,
+  0x71, 0xfc, 0x68, 0xc6, 0x41, 0x53, 0x56, 0x70, 0x08, 0x46, 0x01, 0xeb,
+  0x1f, 0x6b, 0xd4, 0x74, 0xe8, 0x95, 0xf6, 0xc9, 0x4e, 0x8b, 0x1d, 0xf3,
+  0xe4, 0xa3, 0xec, 0xda, 0xb2, 0xb6, 0x6d, 0xb6, 0x9c, 0x87, 0xc4, 0xa1,
+  0xe4, 0x64, 0xa4, 0x82, 0x9d, 0x87, 0x46, 0x84, 0xbf, 0x9b, 0x2d, 0x2d,
+  0x0a, 0xad, 0x6f, 0x8f, 0x22, 0xc9, 0x78, 0xfd, 0x1a, 0x37, 0x03, 0xdd,
+  0xde, 0xb9, 0x39, 0x3b, 0xc2, 0xe2, 0x7d, 0xf2, 0xde, 0xbf, 0xd8, 0xfe,
+  0x50, 0xa6, 0x68, 0xd2, 0xdb, 0x74, 0x56, 0xf4, 0xcb, 0x91, 0xd1, 0xa6,
+  0x48, 0xde, 0x21, 0xd6, 0x65, 0x58, 0xe8, 0x39, 0xc6, 0x7c, 0xec, 0x29,
+  0xd4, 0x2e, 0x52, 0x2b, 0x43, 0x02, 0x03, 0x01, 0x00, 0x01, 0xa3, 0x82,
+  0x02, 0x0b, 0x30, 0x82, 0x02, 0x07, 0x30, 0x1d, 0x06, 0x03, 0x55, 0x1d,
+  0x0e, 0x04, 0x16, 0x04, 0x14, 0xa4, 0x8d, 0xe5, 0xbe, 0x7c, 0x79, 0xe4,
+  0x70, 0x23, 0x6d, 0x2e, 0x29, 0x34, 0xad, 0x23, 0x58, 0xdc, 0xf5, 0x31,
+  0x7f, 0x30, 0x1f, 0x06, 0x03, 0x55, 0x1d, 0x23, 0x04, 0x18, 0x30, 0x16,
+  0x80, 0x14, 0x03, 0xde, 0x50, 0x35, 0x56, 0xd1, 0x4c, 0xbb, 0x66, 0xf0,
+  0xa3, 0xe2, 0x1b, 0x1b, 0xc3, 0x97, 0xb2, 0x3d, 0xd1, 0x55, 0x30, 0x0e,
+  0x06, 0x03, 0x55, 0x1d, 0x0f, 0x01, 0x01, 0xff, 0x04, 0x04, 0x03, 0x02,
+  0x01, 0x86, 0x30, 0x1d, 0x06, 0x03, 0x55, 0x1d, 0x25, 0x04, 0x16, 0x30,
+  0x14, 0x06, 0x08, 0x2b, 0x06, 0x01, 0x05, 0x05, 0x07, 0x03, 0x01, 0x06,
+  0x08, 0x2b, 0x06, 0x01, 0x05, 0x05, 0x07, 0x03, 0x02, 0x30, 0x12, 0x06,
+  0x03, 0x55, 0x1d, 0x13, 0x01, 0x01, 0xff, 0x04, 0x08, 0x30, 0x06, 0x01,
+  0x01, 0xff, 0x02, 0x01, 0x00, 0x30, 0x34, 0x06, 0x08, 0x2b, 0x06, 0x01,
+  0x05, 0x05, 0x07, 0x01, 0x01, 0x04, 0x28, 0x30, 0x26, 0x30, 0x24, 0x06,
+  0x08, 0x2b, 0x06, 0x01, 0x05, 0x05, 0x07, 0x30, 0x01, 0x86, 0x18, 0x68,
+  0x74, 0x74, 0x70, 0x3a, 0x2f, 0x2f, 0x6f, 0x63, 0x73, 0x70, 0x2e, 0x64,
+  0x69, 0x67, 0x69, 0x63, 0x65, 0x72, 0x74, 0x2e, 0x63, 0x6f, 0x6d, 0x30,
+  0x7b, 0x06, 0x03, 0x55, 0x1d, 0x1f, 0x04, 0x74, 0x30, 0x72, 0x30, 0x37,
+  0xa0, 0x35, 0xa0, 0x33, 0x86, 0x31, 0x68, 0x74, 0x74, 0x70, 0x3a, 0x2f,
+  0x2f, 0x63, 0x72, 0x6c, 0x33, 0x2e, 0x64, 0x69, 0x67, 0x69, 0x63, 0x65,
+  0x72, 0x74, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x44, 0x69, 0x67, 0x69, 0x43,
+  0x65, 0x72, 0x74, 0x47, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x52, 0x6f, 0x6f,
+  0x74, 0x43, 0x41, 0x2e, 0x63, 0x72, 0x6c, 0x30, 0x37, 0xa0, 0x35, 0xa0,
+  0x33, 0x86, 0x31, 0x68, 0x74, 0x74, 0x70, 0x3a, 0x2f, 0x2f, 0x63, 0x72,
+  0x6c, 0x34, 0x2e, 0x64, 0x69, 0x67, 0x69, 0x63, 0x65, 0x72, 0x74, 0x2e,
+  0x63, 0x6f, 0x6d, 0x2f, 0x44, 0x69, 0x67, 0x69, 0x43, 0x65, 0x72, 0x74,
+  0x47, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x52, 0x6f, 0x6f, 0x74, 0x43, 0x41,
+  0x2e, 0x63, 0x72, 0x6c, 0x30, 0x81, 0xce, 0x06, 0x03, 0x55, 0x1d, 0x20,
+  0x04, 0x81, 0xc6, 0x30, 0x81, 0xc3, 0x30, 0x81, 0xc0, 0x06, 0x04, 0x55,
+  0x1d, 0x20, 0x00, 0x30, 0x81, 0xb7, 0x30, 0x28, 0x06, 0x08, 0x2b, 0x06,
+  0x01, 0x05, 0x05, 0x07, 0x02, 0x01, 0x16, 0x1c, 0x68, 0x74, 0x74, 0x70,
+  0x73, 0x3a, 0x2f, 0x2f, 0x77, 0x77, 0x77, 0x2e, 0x64, 0x69, 0x67, 0x69,
+  0x63, 0x65, 0x72, 0x74, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x43, 0x50, 0x53,
+  0x30, 0x81, 0x8a, 0x06, 0x08, 0x2b, 0x06, 0x01, 0x05, 0x05, 0x07, 0x02,
+  0x02, 0x30, 0x7e, 0x0c, 0x7c, 0x41, 0x6e, 0x79, 0x20, 0x75, 0x73, 0x65,
+  0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x43, 0x65, 0x72,
+  0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x65, 0x20, 0x63, 0x6f, 0x6e,
+  0x73, 0x74, 0x69, 0x74, 0x75, 0x74, 0x65, 0x73, 0x20, 0x61, 0x63, 0x63,
+  0x65, 0x70, 0x74, 0x61, 0x6e, 0x63, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x74,
+  0x68, 0x65, 0x20, 0x52, 0x65, 0x6c, 0x79, 0x69, 0x6e, 0x67, 0x20, 0x50,
+  0x61, 0x72, 0x74, 0x79, 0x20, 0x41, 0x67, 0x72, 0x65, 0x65, 0x6d, 0x65,
+  0x6e, 0x74, 0x20, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x65, 0x64, 0x20, 0x61,
+  0x74, 0x20, 0x68, 0x74, 0x74, 0x70, 0x73, 0x3a, 0x2f, 0x2f, 0x77, 0x77,
+  0x77, 0x2e, 0x64, 0x69, 0x67, 0x69, 0x63, 0x65, 0x72, 0x74, 0x2e, 0x63,
+  0x6f, 0x6d, 0x2f, 0x72, 0x70, 0x61, 0x2d, 0x75, 0x61, 0x30, 0x0d, 0x06,
+  0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x0b, 0x05, 0x00,
+  0x03, 0x82, 0x01, 0x01, 0x00, 0x22, 0xe3, 0xdc, 0x6d, 0x48, 0xeb, 0x8e,
+  0xca, 0x00, 0x72, 0x73, 0x2e, 0x74, 0xaa, 0xe0, 0x93, 0x84, 0x6e, 0x39,
+  0xc4, 0x87, 0x54, 0x02, 0xc4, 0x02, 0x69, 0x71, 0x55, 0x45, 0xaf, 0x5a,
+  0xb0, 0xf6, 0x81, 0xfe, 0x32, 0xc8, 0x35, 0x72, 0x4b, 0xde, 0xa5, 0x7d,
+  0x27, 0x41, 0xa1, 0xd9, 0xb6, 0x4c, 0xd2, 0x4e, 0x32, 0x38, 0xc7, 0x80,
+  0x31, 0x9e, 0x7b, 0xb2, 0x63, 0xfa, 0x26, 0x47, 0x09, 0x8a, 0x18, 0x4e,
+  0x16, 0x57, 0xd0, 0x6b, 0x5f, 0x1a, 0x96, 0x37, 0x7e, 0xc4, 0xd7, 0x3a,
+  0x6f, 0xe1, 0x97, 0xea, 0x81, 0x5c, 0x08, 0x71, 0xab, 0xfa, 0x0b, 0x04,
+  0xc8, 0xf3, 0x3c, 0xaa, 0xf9, 0x4a, 0x1b, 0x17, 0x39, 0x4f, 0x97, 0x87,
+  0x57, 0x35, 0x7a, 0x8e, 0x98, 0xe9, 0xcb, 0x39, 0x7a, 0x54, 0x42, 0xa9,
+  0x6b, 0x11, 0xfa, 0x81, 0xd1, 0x95, 0xa5, 0x05, 0x60, 0x8e, 0x43, 0x91,
+  0xf7, 0x26, 0x3d, 0x5c, 0x05, 0x25, 0x16, 0x7c, 0xe5, 0x38, 0x2a, 0x6a,
+  0xb2, 0x6e, 0xeb, 0xd9, 0x95, 0x0a, 0xa4, 0x37, 0xeb, 0x85, 0x49, 0xd5,
+  0xcd, 0x7d, 0xa7, 0x48, 0xcd, 0x79, 0x5d, 0x28, 0xf8, 0xf2, 0xb5, 0x41,
+  0x04, 0x09, 0xc6, 0x25, 0x69, 0x0b, 0x3e, 0x28, 0xe5, 0x00, 0x27, 0x77,
+  0xb1, 0x61, 0x4c, 0x55, 0x48, 0x8a, 0x47, 0x3d, 0x42, 0xe4, 0xf6, 0x72,
+  0x7a, 0x5d, 0xa5, 0xec, 0x9f, 0xd6, 0xe1, 0xdf, 0x7d, 0x28, 0x52, 0xd2,
+  0x62, 0x0a, 0x32, 0xe4, 0x60, 0xe6, 0x01, 0x1a, 0x70, 0x2d, 0xcf, 0xff,
+  0x7d, 0x77, 0xe4, 0xaf, 0x8d, 0x27, 0x31, 0x8f, 0x22, 0x6c, 0x29, 0xb1,
+  0x0a, 0xc8, 0xd7, 0x41, 0x37, 0xb4, 0x7c, 0x96, 0xed, 0xae, 0xb2, 0xcb,
+  0xc9, 0x64, 0x25, 0x93, 0xd5, 0x43, 0x57, 0x6f, 0x7a, 0x10, 0x8f, 0xe4,
+  0x40, 0xe2, 0x4d, 0x2d, 0x51, 0x24, 0x27, 0x9e, 0x0f
+};
+
 static void testVerifyRevocation(void)
 {
     BOOL ret;
@@ -3643,6 +4157,44 @@ static void testVerifyRevocation(void)
     CertCloseStore(revPara.hCrlStore, 0);
     CertFreeCertificateContext(certs[1]);
     CertFreeCertificateContext(certs[0]);
+
+    /* OCSP */
+    certs[0] = CertCreateCertificateContext(X509_ASN_ENCODING, ocsp_cert, sizeof(ocsp_cert));
+    memset(&revPara, 0, sizeof(revPara));
+    revPara.cbSize = sizeof(revPara);
+    memset(&status, 0x55, sizeof(status));
+    status.cbSize = sizeof(status);
+    SetLastError(0xdeadbeef);
+    ret = CertVerifyRevocation(X509_ASN_ENCODING, CERT_CONTEXT_REVOCATION_TYPE, 1, (void **)&certs[0],
+                               0, &revPara, &status);
+    ok(!ret, "success\n");
+    ok(GetLastError() == CRYPT_E_REVOCATION_OFFLINE, "got %08lx\n", GetLastError());
+
+    revPara.pIssuerCert = CertCreateCertificateContext(X509_ASN_ENCODING, ocsp_cert_issuer,
+                                                       sizeof(ocsp_cert_issuer));
+    ret = CertVerifyRevocation(X509_ASN_ENCODING, CERT_CONTEXT_REVOCATION_TYPE, 1, (void **)&certs[0],
+                               0, &revPara, &status);
+    ok(ret, "got %08lx\n", GetLastError());
+    ok(!status.dwError, "got %08lx\n", status.dwError);
+    ok(!status.dwIndex, "got %ld\n", status.dwIndex);
+    CertFreeCertificateContext(revPara.pIssuerCert);
+    CertFreeCertificateContext(certs[0]);
+
+    certs[0] = CertCreateCertificateContext(X509_ASN_ENCODING, ocsp_cert_revoked, sizeof(ocsp_cert_revoked));
+    revPara.pIssuerCert = CertCreateCertificateContext(X509_ASN_ENCODING, ocsp_cert_revoked_issuer,
+                                                       sizeof(ocsp_cert_revoked_issuer));
+    memset(&status, 0x55, sizeof(status));
+    status.cbSize = sizeof(status);
+    SetLastError(0xdeadbeef);
+    ret = CertVerifyRevocation(X509_ASN_ENCODING, CERT_CONTEXT_REVOCATION_TYPE, 1, (void **)&certs[0],
+                               0, &revPara, &status);
+    ok(!ret, "success\n");
+    ok(GetLastError() == CRYPT_E_REVOKED, "got %08lx\n", GetLastError());
+    ok(status.dwError == CRYPT_E_REVOKED, "got %08lx\n", status.dwError);
+    ok(!status.dwIndex, "got %ld\n", status.dwIndex);
+    ok(!status.dwReason, "got %lu\n", status.dwReason);
+    CertFreeCertificateContext(revPara.pIssuerCert);
+    CertFreeCertificateContext(certs[0]);
 }
 
 static BYTE privKey[] = {
@@ -3753,45 +4305,42 @@ static void testAcquireCertPrivateKey(void)
         CERT_KEY_CONTEXT keyContext;
 
         /* Don't cache provider */
+        SetLastError(0xdeadbeef);
         ret = CryptAcquireCertificatePrivateKey(cert, 0, NULL, &certCSP,
          &keySpec, &callerFree);
-        ok(ret, "CryptAcquireCertificatePrivateKey failed: %08lx\n",
-         GetLastError());
-        if (ret)
-        {
-            ok(callerFree, "Expected callerFree to be TRUE\n");
-            CryptReleaseContext(certCSP, 0);
-        }
+        ok(ret, "CryptAcquireCertificatePrivateKey failed: %08lx\n", GetLastError());
+        ok(GetLastError() == ERROR_SUCCESS, "got %08lx\n", GetLastError());
+        ok(callerFree, "Expected callerFree to be TRUE\n");
+        CryptReleaseContext(certCSP, 0);
 
+        SetLastError(0xdeadbeef);
         ret = CryptAcquireCertificatePrivateKey(cert, 0, NULL, &certCSP,
          NULL, NULL);
-        ok(ret, "CryptAcquireCertificatePrivateKey failed: %08lx\n",
-         GetLastError());
+        ok(ret, "CryptAcquireCertificatePrivateKey failed: %08lx\n", GetLastError());
+        ok(GetLastError() == ERROR_SUCCESS, "got %08lx\n", GetLastError());
         CryptReleaseContext(certCSP, 0);
 
         /* Use the key prov info's caching (there shouldn't be any) */
+        SetLastError(0xdeadbeef);
         ret = CryptAcquireCertificatePrivateKey(cert,
          CRYPT_ACQUIRE_USE_PROV_INFO_FLAG, NULL, &certCSP, &keySpec,
          &callerFree);
-        ok(ret, "CryptAcquireCertificatePrivateKey failed: %08lx\n",
-         GetLastError());
-        if (ret)
-        {
-            ok(callerFree, "Expected callerFree to be TRUE\n");
-            CryptReleaseContext(certCSP, 0);
-        }
+        ok(ret, "CryptAcquireCertificatePrivateKey failed: %08lx\n", GetLastError());
+        ok(GetLastError() == ERROR_SUCCESS, "got %08lx\n", GetLastError());
+        ok(callerFree, "Expected callerFree to be TRUE\n");
+        CryptReleaseContext(certCSP, 0);
 
         /* Cache it (and check that it's cached) */
+        SetLastError(0xdeadbeef);
         ret = CryptAcquireCertificatePrivateKey(cert,
          CRYPT_ACQUIRE_CACHE_FLAG, NULL, &certCSP, &keySpec, &callerFree);
-        ok(ret, "CryptAcquireCertificatePrivateKey failed: %08lx\n",
-         GetLastError());
+        ok(ret, "CryptAcquireCertificatePrivateKey failed: %08lx\n", GetLastError());
+        ok(GetLastError() == ERROR_SUCCESS, "got %08lx\n", GetLastError());
         ok(!callerFree, "Expected callerFree to be FALSE\n");
         size = sizeof(keyContext);
         ret = CertGetCertificateContextProperty(cert, CERT_KEY_CONTEXT_PROP_ID,
          &keyContext, &size);
-        ok(ret, "CertGetCertificateContextProperty failed: %08lx\n",
-         GetLastError());
+        ok(ret, "CertGetCertificateContextProperty failed: %08lx\n", GetLastError());
 
         /* Remove the cached provider */
         CryptReleaseContext(keyContext.hCryptProv, 0);
@@ -3802,17 +4351,17 @@ static void testAcquireCertPrivateKey(void)
         CertSetCertificateContextProperty(cert, CERT_KEY_PROV_INFO_PROP_ID, 0,
          &keyProvInfo);
         /* Now use the key prov info's caching */
+        SetLastError(0xdeadbeef);
         ret = CryptAcquireCertificatePrivateKey(cert,
          CRYPT_ACQUIRE_USE_PROV_INFO_FLAG, NULL, &certCSP, &keySpec,
          &callerFree);
-        ok(ret, "CryptAcquireCertificatePrivateKey failed: %08lx\n",
-         GetLastError());
+        ok(ret, "CryptAcquireCertificatePrivateKey failed: %08lx\n", GetLastError());
+        ok(GetLastError() == ERROR_SUCCESS, "got %08lx\n", GetLastError());
         ok(!callerFree, "Expected callerFree to be FALSE\n");
         size = sizeof(keyContext);
         ret = CertGetCertificateContextProperty(cert, CERT_KEY_CONTEXT_PROP_ID,
          &keyContext, &size);
-        ok(ret, "CertGetCertificateContextProperty failed: %08lx\n",
-         GetLastError());
+        ok(ret, "CertGetCertificateContextProperty failed: %08lx\n", GetLastError());
         CryptReleaseContext(certCSP, 0);
 
         CryptDestroyKey(key);
@@ -3828,7 +4377,7 @@ static void testAcquireCertPrivateKey(void)
         ok(ret, "CryptExportKey failed: %08lx\n", GetLastError());
         if (ret)
         {
-            LPBYTE buf = HeapAlloc(GetProcessHeap(), 0, size), encodedKey;
+            LPBYTE buf = malloc(size), encodedKey;
 
             ret = CryptExportKey(key, 0, PUBLICKEYBLOB, 0, buf, &size);
             ok(ret, "CryptExportKey failed: %08lx\n", GetLastError());
@@ -3846,7 +4395,7 @@ static void testAcquireCertPrivateKey(void)
                  "Unexpected value\n");
                 LocalFree(encodedKey);
             }
-            HeapFree(GetProcessHeap(), 0, buf);
+            free(buf);
         }
         CryptDestroyKey(key);
     }
@@ -3855,7 +4404,7 @@ static void testAcquireCertPrivateKey(void)
     ok(ret, "CryptExportPublicKeyInfoEx failed: %08lx\n", GetLastError());
     if (ret)
     {
-        PCERT_PUBLIC_KEY_INFO info = HeapAlloc(GetProcessHeap(), 0, size);
+        PCERT_PUBLIC_KEY_INFO info = malloc(size);
 
         ret = CryptExportPublicKeyInfoEx(csp, AT_SIGNATURE, X509_ASN_ENCODING,
          NULL, 0, NULL, info, &size);
@@ -3867,7 +4416,7 @@ static void testAcquireCertPrivateKey(void)
             ok(!memcmp(info->PublicKey.pbData, asnEncodedPublicKey,
              info->PublicKey.cbData), "Unexpected value\n");
         }
-        HeapFree(GetProcessHeap(), 0, info);
+        free(info);
     }
 
     CryptReleaseContext(csp, 0);
@@ -3992,7 +4541,7 @@ static void testKeyProvInfo(void)
 
     ret = CertGetCertificateContextProperty(cert, CERT_KEY_PROV_INFO_PROP_ID, NULL, &size);
     ok(ret, "CertGetCertificateContextProperty error %#lx\n", GetLastError());
-    info = HeapAlloc(GetProcessHeap(), 0, size);
+    info = malloc(size);
     ret = CertGetCertificateContextProperty(cert, CERT_KEY_PROV_INFO_PROP_ID, info, &size);
     ok(ret, "CertGetCertificateContextProperty error %#lx\n", GetLastError());
     ok(!lstrcmpW(info->pwszContainerName, containerW), "got %s\n", wine_dbgstr_w(info->pwszContainerName));
@@ -4010,7 +4559,7 @@ static void testKeyProvInfo(void)
     ok(info->rgProvParam[1].cbData == param[1].cbData, "got %#lx\n", info->rgProvParam[1].cbData);
     ok(!memcmp(info->rgProvParam[1].pbData, param[1].pbData, param[1].cbData), "param2 mismatch\n");
     ok(info->rgProvParam[1].dwFlags == param[1].dwFlags, "got %#lx\n", info->rgProvParam[1].dwFlags);
-    HeapFree(GetProcessHeap(), 0, info);
+    free(info);
 
     ret = CertAddCertificateContextToStore(store, cert, CERT_STORE_ADD_NEW, NULL);
     ok(ret, "CertAddCertificateContextToStore error %#lx\n", GetLastError());
@@ -4029,7 +4578,7 @@ static void testKeyProvInfo(void)
 
     ret = CertGetCertificateContextProperty(cert, CERT_KEY_PROV_INFO_PROP_ID, NULL, &size);
     ok(ret, "CertGetCertificateContextProperty error %#lx\n", GetLastError());
-    info = HeapAlloc(GetProcessHeap(), 0, size);
+    info = malloc(size);
     ret = CertGetCertificateContextProperty(cert, CERT_KEY_PROV_INFO_PROP_ID, info, &size);
     ok(ret, "CertGetCertificateContextProperty error %#lx\n", GetLastError());
     ok(!lstrcmpW(info->pwszContainerName, containerW), "got %s\n", wine_dbgstr_w(info->pwszContainerName));
@@ -4047,7 +4596,7 @@ static void testKeyProvInfo(void)
     ok(info->rgProvParam[1].cbData == param[1].cbData, "got %#lx\n", info->rgProvParam[1].cbData);
     ok(!memcmp(info->rgProvParam[1].pbData, param[1].pbData, param[1].cbData), "param2 mismatch\n");
     ok(info->rgProvParam[1].dwFlags == param[1].dwFlags, "got %#lx\n", info->rgProvParam[1].dwFlags);
-    HeapFree(GetProcessHeap(), 0, info);
+    free(info);
 
     ret = CertDeleteCertificateFromStore(cert);
     ok(ret, "CertDeleteCertificateFromStore error %#lx\n", GetLastError());
@@ -4126,7 +4675,7 @@ static void test_VerifySignature(void)
     ok(!status, "got %#lx\n", status);
     ok(hash_len == sizeof(hash_value), "got %lu\n", hash_len);
 
-    sig_value = HeapAlloc(GetProcessHeap(), 0, info->Signature.cbData);
+    sig_value = malloc(info->Signature.cbData);
     for (i = 0; i < info->Signature.cbData; i++)
         sig_value[i] = info->Signature.pbData[info->Signature.cbData - i - 1];
 
@@ -4134,7 +4683,7 @@ static void test_VerifySignature(void)
     status = BCryptVerifySignature(bkey, &pad, hash_value, sizeof(hash_value), sig_value, info->Signature.cbData, BCRYPT_PAD_PKCS1);
     ok(!status, "got %#lx\n", status);
 
-    HeapFree(GetProcessHeap(), 0, sig_value);
+    free(sig_value);
     BCryptDestroyHash(bhash);
     BCryptCloseAlgorithmProvider(alg, 0);
     BCryptDestroyKey(bkey);
diff --git a/dlls/crypt32/tests/chain.c b/dlls/crypt32/tests/chain.c
index 9ed1b28bf70..32f00801799 100644
--- wine/dlls/crypt32/tests/chain.c
+++ wine/dlls/crypt32/tests/chain.c
@@ -4958,6 +4958,13 @@ static const ChainPolicyCheck msRootPolicyCheck[] = {
    { 0, CERT_E_UNTRUSTEDROOT, 0, 0, NULL }, NULL, 0 },
 };
 
+static const ChainPolicyCheck msRootPolicyCheck_approot[] = {
+ { { ARRAY_SIZE(chain32), chain32 },
+   { 0, CERT_E_UNTRUSTEDROOT, 0, 2, NULL }, NULL, TODO_ELEMENTS },
+ { { ARRAY_SIZE(chain33), chain33 },
+   { 0, 0, 0, 0, NULL }, NULL, 0 },
+};
+
 static const char *num_to_str(WORD num)
 {
     static char buf[6];
@@ -5295,8 +5302,16 @@ static void check_ssl_policy(void)
 
 static void check_msroot_policy(void)
 {
+    CERT_CHAIN_POLICY_PARA para;
+
     CHECK_CHAIN_POLICY_STATUS_ARRAY(CERT_CHAIN_POLICY_MICROSOFT_ROOT, NULL,
      msRootPolicyCheck, &may2020, NULL);
+
+    para.cbSize = sizeof(para);
+    para.pvExtraPolicyPara = NULL;
+    para.dwFlags = MICROSOFT_ROOT_CERT_CHAIN_POLICY_CHECK_APPLICATION_ROOT_FLAG;
+    CHECK_CHAIN_POLICY_STATUS_ARRAY(CERT_CHAIN_POLICY_MICROSOFT_ROOT, NULL,
+     msRootPolicyCheck_approot, &may2020, &para);
 }
 
 static void testVerifyCertChainPolicy(void)
diff --git a/dlls/crypt32/tests/encode.c b/dlls/crypt32/tests/encode.c
index 9dabe58efba..527e663860a 100644
--- wine/dlls/crypt32/tests/encode.c
+++ wine/dlls/crypt32/tests/encode.c
@@ -2315,10 +2315,10 @@ static const BYTE modulus1[] = { 0,0,0,1,1,1,1,1 };
 static const BYTE modulus2[] = { 1,1,1,1,1,0,0,0 };
 static const BYTE modulus3[] = { 0x80,1,1,1,1,0,0,0 };
 static const BYTE modulus4[] = { 1,1,1,1,1,0,0,0x80 };
-static const BYTE mod1_encoded[] = { 0x30,0x0f,0x02,0x08,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x00,0x02,0x03,0x01,0x00,0x01 };
-static const BYTE mod2_encoded[] = { 0x30,0x0c,0x02,0x05,0x01,0x01,0x01,0x01,0x01,0x02,0x03,0x01,0x00,0x01 };
-static const BYTE mod3_encoded[] = { 0x30,0x0c,0x02,0x05,0x01,0x01,0x01,0x01,0x80,0x02,0x03,0x01,0x00,0x01 };
-static const BYTE mod4_encoded[] = { 0x30,0x10,0x02,0x09,0x00,0x80,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x02,0x03,0x01,0x00,0x01 };
+static const BYTE mod1_encoded[] = { 0x30,0x0f,0x02,0x08,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x00,0x02,0x03,0x02,0x00,0x01 };
+static const BYTE mod2_encoded[] = { 0x30,0x0c,0x02,0x05,0x01,0x01,0x01,0x01,0x01,0x02,0x03,0x02,0x00,0x01 };
+static const BYTE mod3_encoded[] = { 0x30,0x0c,0x02,0x05,0x01,0x01,0x01,0x01,0x80,0x02,0x03,0x02,0x00,0x01 };
+static const BYTE mod4_encoded[] = { 0x30,0x10,0x02,0x09,0x00,0x80,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x02,0x03,0x02,0x00,0x01 };
 
 struct EncodedRSAPubKey
 {
@@ -2351,7 +2351,7 @@ static void test_encodeRsaPublicKey(DWORD dwEncoding)
     hdr->aiKeyAlg = CALG_RSA_KEYX;
     rsaPubKey->magic = 0x31415352;
     rsaPubKey->bitlen = sizeof(modulus1) * 8;
-    rsaPubKey->pubexp = 65537;
+    rsaPubKey->pubexp = 131073;
     memcpy(toEncode + sizeof(BLOBHEADER) + sizeof(RSAPUBKEY), modulus1,
      sizeof(modulus1));
 
@@ -2480,7 +2480,7 @@ static void test_decodeRsaPublicKey(DWORD dwEncoding)
              "Expected magic RSA1, got %08lx\n", rsaPubKey->magic);
             ok(rsaPubKey->bitlen == rsaPubKeys[i].decodedModulusLen * 8,
              "Wrong bit len %ld\n", rsaPubKey->bitlen);
-            ok(rsaPubKey->pubexp == 65537, "Expected pubexp 65537, got %ld\n",
+            ok(rsaPubKey->pubexp == 131073, "Expected pubexp 131073, got %ld\n",
              rsaPubKey->pubexp);
             ok(!memcmp(buf + sizeof(BLOBHEADER) + sizeof(RSAPUBKEY),
              rsaPubKeys[i].modulus, rsaPubKeys[i].decodedModulusLen),
@@ -2497,7 +2497,7 @@ static void test_encodeRsaPublicKey_Bcrypt(DWORD dwEncoding)
     BOOL ret;
     BYTE *buf = NULL;
     DWORD bufSize = 0, i;
-    BYTE pubexp[] = {0x01,0x00,0x01,0x00}; /* 65537 */
+    BYTE pubexp[] = {0x01,0x00,0x02,0x00}; /* 131073 */
 
     /* Verify that the Magic value doesn't matter */
     hdr->Magic = 1;
@@ -2568,7 +2568,7 @@ static void test_decodeRsaPublicKey_Bcrypt(DWORD dwEncoding)
         if (ret)
         {
             BCRYPT_RSAKEY_BLOB *hdr = (BCRYPT_RSAKEY_BLOB *)buf;
-            BYTE pubexp[] = {0xff,0xff,0xff,0xff}, pubexp_expected[] = {0x01,0x00,0x01};
+            BYTE pubexp[] = {0xff,0xff,0xff,0xcc}, pubexp_expected[] = {0x01,0x00,0x02};
             /* CNG_RSA_PUBLIC_KEY_BLOB stores the exponent
              * in big-endian format, so we need to convert it to little-endian
              */
@@ -2584,15 +2584,15 @@ static void test_decodeRsaPublicKey_Bcrypt(DWORD dwEncoding)
             /* Windows decodes the exponent to 3 bytes, since it will fit.
              * Our implementation currently unconditionally decodes to a DWORD (4 bytes)
              */
-            todo_wine ok(hdr->cbPublicExp == 3, "Expected cbPublicExp 3, got %ld\n", hdr->cbPublicExp);
+            ok(hdr->cbPublicExp == 3, "Expected cbPublicExp 3, got %ld\n", hdr->cbPublicExp);
             ok(hdr->cbModulus == rsaPubKeys[i].decodedModulusLen,
               "Wrong modulus len %ld\n", hdr->cbModulus);
             ok(hdr->cbPrime1 == 0,"Wrong cbPrime1 %ld\n", hdr->cbPrime1);
             ok(hdr->cbPrime2 == 0,"Wrong cbPrime2 %ld\n", hdr->cbPrime2);
             ok(!memcmp(pubexp, pubexp_expected, sizeof(pubexp_expected)), "Wrong exponent\n");
-            todo_wine ok(pubexp[3] == 0xff, "Got %02x\n", pubexp[3]);
+            ok(pubexp[3] == 0xcc, "Got %02x\n", pubexp[3]);
 
-            leModulus = HeapAlloc(GetProcessHeap(), 0, hdr->cbModulus);
+            leModulus = malloc(hdr->cbModulus);
              /*
               * CNG_RSA_PUBLIC_KEY_BLOB stores the modulus in big-endian format,
               * so we need to convert it to little-endian
@@ -2603,7 +2603,7 @@ static void test_decodeRsaPublicKey_Bcrypt(DWORD dwEncoding)
              rsaPubKeys[i].modulus, rsaPubKeys[i].decodedModulusLen),
              "Unexpected modulus\n");
             LocalFree(buf);
-            LocalFree(leModulus);
+            free(leModulus);
         }
     }
 }
@@ -2799,13 +2799,13 @@ static void test_decodeExtensions(DWORD dwEncoding)
         ret = CryptDecodeObjectEx(dwEncoding, X509_EXTENSIONS,
          exts[i].encoded, exts[i].encoded[1] + 2, 0, NULL, NULL, &bufSize);
         ok(ret, "CryptDecodeObjectEx failed: %08lx\n", GetLastError());
-        buf = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, bufSize);
+        buf = calloc(1, bufSize);
         if (buf)
         {
             ret = CryptDecodeObjectEx(dwEncoding, X509_EXTENSIONS,
              exts[i].encoded, exts[i].encoded[1] + 2, 0, NULL, buf, &bufSize);
             ok(ret, "CryptDecodeObjectEx failed: %08lx\n", GetLastError());
-            HeapFree(GetProcessHeap(), 0, buf);
+            free(buf);
         }
     }
 }
@@ -3770,14 +3770,14 @@ static void test_decodeCRLDistPoints(DWORD dwEncoding)
      distPointWithUrlAndIssuer, distPointWithUrlAndIssuer[1] + 2, 0,
      NULL, NULL, &size);
     ok(ret, "CryptDecodeObjectEx failed: %08lx\n", GetLastError());
-    buf = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, size);
+    buf = calloc(1, size);
     if (buf)
     {
         ret = CryptDecodeObjectEx(dwEncoding, X509_CRL_DIST_POINTS,
          distPointWithUrlAndIssuer, distPointWithUrlAndIssuer[1] + 2, 0,
          NULL, buf, &size);
         ok(ret, "CryptDecodeObjectEx failed: %08lx\n", GetLastError());
-        HeapFree(GetProcessHeap(), 0, buf);
+        free(buf);
     }
 }
 
@@ -4906,13 +4906,13 @@ static void test_decodeEnhancedKeyUsage(DWORD dwEncoding)
     ret = CryptDecodeObjectEx(dwEncoding, X509_ENHANCED_KEY_USAGE,
      encodedUsage, sizeof(encodedUsage), 0, NULL, NULL, &size);
     ok(ret, "CryptDecodeObjectEx failed: %08lx\n", GetLastError());
-    buf = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, size);
+    buf = calloc(1, size);
     if (buf)
     {
         ret = CryptDecodeObjectEx(dwEncoding, X509_ENHANCED_KEY_USAGE,
          encodedUsage, sizeof(encodedUsage), 0, NULL, buf, &size);
         ok(ret, "CryptDecodeObjectEx failed: %08lx\n", GetLastError());
-        HeapFree(GetProcessHeap(), 0, buf);
+        free(buf);
     }
 }
 
@@ -5391,14 +5391,14 @@ static void test_decodeAuthorityInfoAccess(DWORD dwEncoding)
      authorityInfoAccessWithUrlAndIPAddr,
      sizeof(authorityInfoAccessWithUrlAndIPAddr), 0, NULL, NULL, &size);
     ok(ret, "CryptDecodeObjectEx failed: %lx\n", GetLastError());
-    buf = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, size);
+    buf = calloc(1, size);
     if (buf)
     {
         ret = CryptDecodeObjectEx(dwEncoding, X509_AUTHORITY_INFO_ACCESS,
          authorityInfoAccessWithUrlAndIPAddr,
          sizeof(authorityInfoAccessWithUrlAndIPAddr), 0, NULL, buf, &size);
         ok(ret, "CryptDecodeObjectEx failed: %lx\n", GetLastError());
-        HeapFree(GetProcessHeap(), 0, buf);
+        free(buf);
     }
 }
 
@@ -6354,13 +6354,13 @@ static void test_decodePKCSAttributes(DWORD dwEncoding)
     ret = CryptDecodeObjectEx(dwEncoding, PKCS_ATTRIBUTES,
      doublePKCSAttributes, sizeof(doublePKCSAttributes), 0, NULL, NULL, &size);
     ok(ret, "CryptDecodeObjectEx failed: %lx\n", GetLastError());
-    buf = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, size);
+    buf = calloc(1, size);
     if (buf)
     {
         ret = CryptDecodeObjectEx(dwEncoding, PKCS_ATTRIBUTES,
          doublePKCSAttributes, sizeof(doublePKCSAttributes), 0, NULL, buf, &size);
         ok(ret, "CryptDecodeObjectEx failed: %lx\n", GetLastError());
-        HeapFree(GetProcessHeap(), 0, buf);
+        free(buf);
     }
 }
 
@@ -6522,14 +6522,14 @@ static void test_decodePKCSSMimeCapabilities(DWORD dwEncoding)
     ret = CryptDecodeObjectEx(dwEncoding, PKCS_SMIME_CAPABILITIES,
      twoCapabilities, sizeof(twoCapabilities), 0, NULL, NULL, &size);
     ok(ret, "CryptDecodeObjectEx failed: %08lx\n", GetLastError());
-    ptr = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, size);
+    ptr = calloc(1, size);
     if (ptr)
     {
         SetLastError(0xdeadbeef);
         ret = CryptDecodeObjectEx(dwEncoding, PKCS_SMIME_CAPABILITIES,
          twoCapabilities, sizeof(twoCapabilities), 0, NULL, ptr, &size);
         ok(ret, "CryptDecodeObjectEx failed: %08lx\n", GetLastError());
-        HeapFree(GetProcessHeap(), 0, ptr);
+        free(ptr);
     }
 }
 
@@ -7645,13 +7645,13 @@ static void test_decodeCertPolicies(DWORD dwEncoding)
     ret = CryptDecodeObjectEx(dwEncoding, X509_CERT_POLICIES,
      twoPolicies, sizeof(twoPolicies), 0, NULL, NULL, &size);
     ok(ret, "CryptDecodeObjectEx failed: %08lx\n", GetLastError());
-    info = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, size);
+    info = calloc(1, size);
     if (info)
     {
         ret = CryptDecodeObjectEx(dwEncoding, X509_CERT_POLICIES,
          twoPolicies, sizeof(twoPolicies), 0, NULL, info, &size);
         ok(ret, "CryptDecodeObjectEx failed: %08lx\n", GetLastError());
-        HeapFree(GetProcessHeap(), 0, info);
+        free(info);
     }
 }
 
@@ -7788,14 +7788,14 @@ static void test_decodeCertPolicyMappings(DWORD dwEncoding)
          policyMappingWithTwoMappings, sizeof(policyMappingWithTwoMappings), 0,
          NULL, NULL, &size);
         ok(ret, "CryptDecodeObjectEx failed: %08lx\n", GetLastError());
-        info = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, size);
+        info = calloc(1, size);
         if (info)
         {
             ret = CryptDecodeObjectEx(dwEncoding, mappingOids[i],
              policyMappingWithTwoMappings, sizeof(policyMappingWithTwoMappings), 0,
              NULL, info, &size);
             ok(ret, "CryptDecodeObjectEx failed: %08lx\n", GetLastError());
-            HeapFree(GetProcessHeap(), 0, info);
+            free(info);
         }
     }
 }
@@ -8225,7 +8225,6 @@ static void test_decodeRsaPrivateKey(DWORD dwEncoding)
     }
 }
 
-/* Free *pInfo with HeapFree */
 static void testExportPublicKey(HCRYPTPROV csp, PCERT_PUBLIC_KEY_INFO *pInfo)
 {
     BOOL ret;
@@ -8262,7 +8261,7 @@ static void testExportPublicKey(HCRYPTPROV csp, PCERT_PUBLIC_KEY_INFO *pInfo)
         ret = CryptExportPublicKeyInfoEx(csp, AT_SIGNATURE, X509_ASN_ENCODING,
          NULL, 0, NULL, NULL, &size);
         ok(ret, "CryptExportPublicKeyInfoEx failed: %08lx\n", GetLastError());
-        *pInfo = HeapAlloc(GetProcessHeap(), 0, size);
+        *pInfo = malloc(size);
         if (*pInfo)
         {
             ret = CryptExportPublicKeyInfoEx(csp, AT_SIGNATURE,
@@ -8411,7 +8410,7 @@ static void testPortPublicKeyInfo(void)
     testExportPublicKey(csp, &info);
     testImportPublicKey(csp, info);
 
-    HeapFree(GetProcessHeap(), 0, info);
+    free(info);
     CryptReleaseContext(csp, 0);
     ret = CryptAcquireContextA(&csp, cspName, MS_DEF_PROV_A, PROV_RSA_FULL,
      CRYPT_DELETEKEYSET);
@@ -8674,6 +8673,26 @@ static const BYTE ocsp_basic_response[] = {
   0x33, 0x36, 0x30, 0x31, 0x5a
 };
 
+static const BYTE ocsp_basic_response2[] = {
+  0x30, 0x81, 0xbe, 0xa1, 0x34, 0x30, 0x32, 0x31, 0x0b, 0x30, 0x09, 0x06,
+  0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31, 0x16, 0x30, 0x14,
+  0x06, 0x03, 0x55, 0x04, 0x0a, 0x13, 0x0d, 0x4c, 0x65, 0x74, 0x27, 0x73,
+  0x20, 0x45, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x31, 0x0b, 0x30, 0x09,
+  0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x02, 0x52, 0x33, 0x18, 0x0f, 0x32,
+  0x30, 0x32, 0x32, 0x31, 0x30, 0x32, 0x30, 0x30, 0x36, 0x30, 0x31, 0x30,
+  0x30, 0x5a, 0x30, 0x75, 0x30, 0x73, 0x30, 0x4b, 0x30, 0x09, 0x06, 0x05,
+  0x2b, 0x0e, 0x03, 0x02, 0x1a, 0x05, 0x00, 0x04, 0x14, 0x48, 0xda, 0xc9,
+  0xa0, 0xfb, 0x2b, 0xd3, 0x2d, 0x4f, 0xf0, 0xde, 0x68, 0xd2, 0xf5, 0x67,
+  0xb7, 0x35, 0xf9, 0xb3, 0xc4, 0x04, 0x14, 0x14, 0x2e, 0xb3, 0x17, 0xb7,
+  0x58, 0x56, 0xcb, 0xae, 0x50, 0x09, 0x40, 0xe6, 0x1f, 0xaf, 0x9d, 0x8b,
+  0x14, 0xc2, 0xc6, 0x02, 0x12, 0x03, 0x26, 0x1c, 0x82, 0x80, 0xf3, 0x8c,
+  0x13, 0xef, 0xae, 0x83, 0x9d, 0x89, 0xb9, 0xcd, 0x59, 0x83, 0x5b, 0x80,
+  0x00, 0x18, 0x0f, 0x32, 0x30, 0x32, 0x32, 0x31, 0x30, 0x32, 0x30, 0x30,
+  0x36, 0x30, 0x30, 0x30, 0x30, 0x5a, 0xa0, 0x11, 0x18, 0x0f, 0x32, 0x30,
+  0x32, 0x32, 0x31, 0x30, 0x32, 0x37, 0x30, 0x35, 0x35, 0x39, 0x35, 0x38,
+  0x5a
+};
+
 static const BYTE ocsp_basic_response_revoked[] = {
   0x30, 0x81, 0xb1, 0xa2, 0x16, 0x04, 0x14, 0xa4, 0x8d, 0xe5, 0xbe, 0x7c,
   0x79, 0xe4, 0x70, 0x23, 0x6d, 0x2e, 0x29, 0x34, 0xad, 0x23, 0x58, 0xdc,
@@ -8759,22 +8778,36 @@ static void test_decodeOCSPBasicResponseInfo(DWORD dwEncoding)
     static const BYTE resp_id2[] = {
         0xa4, 0x8d, 0xe5, 0xbe, 0x7c, 0x79, 0xe4, 0x70, 0x23, 0x6d, 0x2e, 0x29, 0x34, 0xad, 0x23, 0x58,
         0xdc, 0xf5, 0x31, 0x7f};
+    static const BYTE resp_id3[] = {
+        0x30, 0x32, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31,
+        0x16, 0x30, 0x14, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x13, 0x0d, 0x4c, 0x65, 0x74, 0x27, 0x73, 0x20,
+        0x45, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x03,
+        0x13, 0x02, 0x52, 0x33};
     static const BYTE name_hash[] = {
         0xe4, 0xe3, 0x95, 0xa2, 0x29, 0xd3, 0xd4, 0xc1, 0xc3, 0x1f, 0xf0, 0x98, 0x0c, 0x0b, 0x4e, 0xc0,
         0x09, 0x8a, 0xab, 0xd8};
     static const BYTE name_hash2[] = {
         0x74, 0xb4, 0xe7, 0x23, 0x19, 0xc7, 0x65, 0x92, 0x15, 0x40, 0x44, 0x7b, 0xc7, 0xce, 0x3e, 0x90,
         0xc2, 0x18, 0x76, 0xeb};
+    static const BYTE name_hash3[] = {
+        0x48, 0xda, 0xc9, 0xa0, 0xfb, 0x2b, 0xd3, 0x2d, 0x4f, 0xf0, 0xde, 0x68, 0xd2, 0xf5, 0x67, 0xb7,
+        0x35, 0xf9, 0xb3, 0xc4};
     static const BYTE key_hash[] = {
         0xb7, 0x6b, 0xa2, 0xea, 0xa8, 0xaa, 0x84, 0x8c, 0x79, 0xea, 0xb4, 0xda, 0x0f, 0x98, 0xb2, 0xc5,
         0x95, 0x76, 0xb9, 0xf4};
     static const BYTE key_hash2[] = {
         0xa4, 0x8d, 0xe5, 0xbe, 0x7c, 0x79, 0xe4, 0x70, 0x23, 0x6d, 0x2e, 0x29, 0x34, 0xad, 0x23, 0x58,
         0xdc, 0xf5, 0x31, 0x7f};
+    static const BYTE key_hash3[] = {
+        0x14, 0x2e, 0xb3, 0x17, 0xb7, 0x58, 0x56, 0xcb, 0xae, 0x50, 0x09, 0x40, 0xe6, 0x1f, 0xaf, 0x9d,
+        0x8b, 0x14, 0xc2, 0xc6};
     static const BYTE serial[] = {
         0xb1, 0xc1, 0x87, 0x54, 0x54, 0xac, 0x1e, 0x55, 0x40, 0xfb, 0xef, 0xd9, 0x6d, 0x8f, 0x49, 0x08};
     static const BYTE serial2[] = {
         0x2f, 0x57, 0xa4, 0x85, 0xa2, 0xe3, 0x52, 0x54, 0x9a, 0x3b, 0x85, 0x98, 0xa2, 0x67, 0x2e, 0x0d};
+    static const BYTE serial3[] = {
+        0x5b, 0x83, 0x59, 0xcd, 0xb9, 0x89, 0x9d, 0x83, 0xae, 0xef, 0x13, 0x8c, 0xf3, 0x80, 0x82, 0x1c,
+        0x26, 0x03};
     OCSP_BASIC_RESPONSE_INFO *info;
     OCSP_BASIC_RESPONSE_ENTRY *entry;
     OCSP_BASIC_REVOKED_INFO *revoked;
@@ -8801,11 +8834,11 @@ static void test_decodeOCSPBasicResponseInfo(DWORD dwEncoding)
     ok(entry->CertId.HashAlgorithm.Parameters.cbData == 2, "got %lu\n", entry->CertId.HashAlgorithm.Parameters.cbData);
     ok(entry->CertId.HashAlgorithm.Parameters.pbData[0] == 5, "got 0x%02x\n", entry->CertId.HashAlgorithm.Parameters.pbData[0]);
     ok(!entry->CertId.HashAlgorithm.Parameters.pbData[1], "got 0x%02x\n", entry->CertId.HashAlgorithm.Parameters.pbData[1]);
-    ok(entry->CertId.IssuerNameHash.cbData == 20, "got %lu\n", entry->CertId.IssuerNameHash.cbData);
+    ok(entry->CertId.IssuerNameHash.cbData == sizeof(name_hash), "got %lu\n", entry->CertId.IssuerNameHash.cbData);
     ok(!memcmp(entry->CertId.IssuerNameHash.pbData, name_hash, sizeof(name_hash)), "wrong data\n");
-    ok(entry->CertId.IssuerKeyHash.cbData == 20, "got %lu\n", entry->CertId.IssuerKeyHash.cbData);
+    ok(entry->CertId.IssuerKeyHash.cbData == sizeof(key_hash), "got %lu\n", entry->CertId.IssuerKeyHash.cbData);
     ok(!memcmp(entry->CertId.IssuerKeyHash.pbData, key_hash, sizeof(key_hash)), "wrong data\n");
-    ok(entry->CertId.SerialNumber.cbData == 16, "got %lu\n", entry->CertId.SerialNumber.cbData);
+    ok(entry->CertId.SerialNumber.cbData == sizeof(serial), "got %lu\n", entry->CertId.SerialNumber.cbData);
     ok(!memcmp(entry->CertId.SerialNumber.pbData, serial, sizeof(serial)), "wrong data\n");
     ok(entry->dwCertStatus == 0, "got %lu\n", entry->dwCertStatus);
     ok(entry->pRevokedInfo == NULL, "got %p\n", entry->pRevokedInfo);
@@ -8824,9 +8857,8 @@ static void test_decodeOCSPBasicResponseInfo(DWORD dwEncoding)
     size = 0;
     ret = CryptDecodeObjectEx(dwEncoding, OCSP_BASIC_RESPONSE, ocsp_basic_response_revoked,
                               sizeof(ocsp_basic_response_revoked), CRYPT_DECODE_ALLOC_FLAG, NULL, &info, &size);
-    todo_wine ok(ret, "got %08lx\n", GetLastError());
+    ok(ret, "got %08lx\n", GetLastError());
 
-    if (ret) {
     ok(!info->dwVersion, "got %lu\n", info->dwVersion);
     ok(info->dwResponderIdChoice == 2, "got %lu\n", info->dwResponderIdChoice);
     ok(info->ByKeyResponderId.cbData == sizeof(resp_id), "got %lu\n", info->ByKeyResponderId.cbData);
@@ -8841,11 +8873,11 @@ static void test_decodeOCSPBasicResponseInfo(DWORD dwEncoding)
     ok(entry->CertId.HashAlgorithm.Parameters.cbData == 2, "got %lu\n", entry->CertId.HashAlgorithm.Parameters.cbData);
     ok(entry->CertId.HashAlgorithm.Parameters.pbData[0] == 5, "got 0x%02x\n", entry->CertId.HashAlgorithm.Parameters.pbData[0]);
     ok(!entry->CertId.HashAlgorithm.Parameters.pbData[1], "got 0x%02x\n", entry->CertId.HashAlgorithm.Parameters.pbData[1]);
-    ok(entry->CertId.IssuerNameHash.cbData == 20, "got %lu\n", entry->CertId.IssuerNameHash.cbData);
+    ok(entry->CertId.IssuerNameHash.cbData == sizeof(name_hash2), "got %lu\n", entry->CertId.IssuerNameHash.cbData);
     ok(!memcmp(entry->CertId.IssuerNameHash.pbData, name_hash2, sizeof(name_hash2)), "wrong data\n");
-    ok(entry->CertId.IssuerKeyHash.cbData == 20, "got %lu\n", entry->CertId.IssuerKeyHash.cbData);
+    ok(entry->CertId.IssuerKeyHash.cbData == sizeof(key_hash2), "got %lu\n", entry->CertId.IssuerKeyHash.cbData);
     ok(!memcmp(entry->CertId.IssuerKeyHash.pbData, key_hash2, sizeof(key_hash2)), "wrong data\n");
-    ok(entry->CertId.SerialNumber.cbData == 16, "got %lu\n", entry->CertId.SerialNumber.cbData);
+    ok(entry->CertId.SerialNumber.cbData == sizeof(serial2), "got %lu\n", entry->CertId.SerialNumber.cbData);
     ok(!memcmp(entry->CertId.SerialNumber.pbData, serial2, sizeof(serial2)), "wrong data\n");
     ok(entry->dwCertStatus == 1, "got %lu\n", entry->dwCertStatus);
     ok(entry->pRevokedInfo != NULL, "got NULL\n");
@@ -8864,7 +8896,46 @@ static void test_decodeOCSPBasicResponseInfo(DWORD dwEncoding)
 
     ok(!info->cExtension, "got %lu\n", info->cExtension);
     ok(info->rgExtension == NULL, "got %p\n", info->rgExtension);
-    }
+    LocalFree(info);
+
+    size = 0;
+    ret = CryptDecodeObjectEx(dwEncoding, OCSP_BASIC_RESPONSE, ocsp_basic_response2,
+                              sizeof(ocsp_basic_response2), CRYPT_DECODE_ALLOC_FLAG, NULL, &info, &size);
+    ok(ret, "got %08lx\n", GetLastError());
+
+    ok(!info->dwVersion, "got %lu\n", info->dwVersion);
+    ok(info->dwResponderIdChoice == 1, "got %lu\n", info->dwResponderIdChoice);
+    ok(info->ByNameResponderId.cbData == sizeof(resp_id3), "got %lu\n", info->ByNameResponderId.cbData);
+    ok(!memcmp(info->ByNameResponderId.pbData, resp_id3, sizeof(resp_id3)), "wrong data\n");
+
+    ok(info->ProducedAt.dwLowDateTime == 1408824832, "got %lu\n", info->ProducedAt.dwLowDateTime);
+    ok(info->ProducedAt.dwHighDateTime == 30991433, "got %lu\n", info->ProducedAt.dwHighDateTime);
+    ok(info->cResponseEntry == 1, "got %lu\n", info->cResponseEntry);
+    ok(info->rgResponseEntry != NULL, "got %p\n", info->rgResponseEntry);
+
+    entry = info->rgResponseEntry;
+    ok(!strcmp(entry->CertId.HashAlgorithm.pszObjId, szOID_OIWSEC_sha1), "got '%s'\n", entry->CertId.HashAlgorithm.pszObjId);
+    ok(entry->CertId.HashAlgorithm.Parameters.cbData == 2, "got %lu\n", entry->CertId.HashAlgorithm.Parameters.cbData);
+    ok(entry->CertId.HashAlgorithm.Parameters.pbData[0] == 5, "got 0x%02x\n", entry->CertId.HashAlgorithm.Parameters.pbData[0]);
+    ok(!entry->CertId.HashAlgorithm.Parameters.pbData[1], "got 0x%02x\n", entry->CertId.HashAlgorithm.Parameters.pbData[1]);
+    ok(entry->CertId.IssuerNameHash.cbData == sizeof(name_hash3), "got %lu\n", entry->CertId.IssuerNameHash.cbData);
+    ok(!memcmp(entry->CertId.IssuerNameHash.pbData, name_hash3, sizeof(name_hash3)), "wrong data\n");
+
+    ok(entry->CertId.IssuerKeyHash.cbData == sizeof(key_hash3), "got %lu\n", entry->CertId.IssuerKeyHash.cbData);
+    ok(!memcmp(entry->CertId.IssuerKeyHash.pbData, key_hash3, sizeof(key_hash3)), "wrong data\n");
+    ok(entry->CertId.SerialNumber.cbData == sizeof(serial3), "got %lu\n", entry->CertId.SerialNumber.cbData);
+    ok(!memcmp(entry->CertId.SerialNumber.pbData, serial3, sizeof(serial3)), "wrong data\n");
+    ok(entry->dwCertStatus == 0, "got %lu\n", entry->dwCertStatus);
+    ok(entry->pRevokedInfo == NULL, "got %p\n", entry->pRevokedInfo);
+    ok(entry->ThisUpdate.dwLowDateTime == 808824832, "got %lu\n", entry->ThisUpdate.dwLowDateTime);
+    ok(entry->ThisUpdate.dwHighDateTime == 30991433, "got %lu\n", entry->ThisUpdate.dwHighDateTime);
+    ok(entry->NextUpdate.dwLowDateTime == 1474872064, "got %lu\n", entry->NextUpdate.dwLowDateTime);
+    ok(entry->NextUpdate.dwHighDateTime == 30992841, "got %lu\n", entry->NextUpdate.dwHighDateTime);
+    ok(!entry->cExtension, "got %lu\n", entry->cExtension);
+    ok(entry->rgExtension == NULL, "got %p\n", entry->rgExtension);
+
+    ok(!info->cExtension, "got %lu\n", info->cExtension);
+    ok(info->rgExtension == NULL, "got %p\n", info->rgExtension);
     LocalFree(info);
 }
 
diff --git a/dlls/crypt32/tests/main.c b/dlls/crypt32/tests/main.c
index 19dde3fb28f..1b125e89d50 100644
--- wine/dlls/crypt32/tests/main.c
+++ wine/dlls/crypt32/tests/main.c
@@ -349,7 +349,7 @@ static void test_getDefaultCryptProv(void)
         prov = pI_CryptGetDefaultCryptProv(test_prov[i].algid);
         if (!prov)
         {
-            todo_wine_if(test_prov[i].algid == CALG_DSS_SIGN || test_prov[i].algid == CALG_NO_SIGN)
+todo_wine_if(test_prov[i].algid == CALG_DSS_SIGN || test_prov[i].algid == CALG_NO_SIGN)
             ok(test_prov[i].optional, "%lu: I_CryptGetDefaultCryptProv(%#x) failed\n", i, test_prov[i].algid);
             continue;
         }
diff --git a/dlls/crypt32/tests/message.c b/dlls/crypt32/tests/message.c
index fa4790a2a6b..e6339553e52 100644
--- wine/dlls/crypt32/tests/message.c
+++ wine/dlls/crypt32/tests/message.c
@@ -688,14 +688,14 @@ static void test_hash_message(void)
         /* Actually attempting to get the hashed data fails, perhaps because
          * detached is FALSE.
          */
-        hashedBlob = HeapAlloc(GetProcessHeap(), 0, hashedBlobSize);
+        hashedBlob = malloc(hashedBlobSize);
         SetLastError(0xdeadbeef);
         ret = CryptHashMessage(&para, FALSE, 2, toHash, hashSize, hashedBlob,
          &hashedBlobSize, NULL, NULL);
         ok(!ret && GetLastError() == CRYPT_E_MSG_ERROR,
          "expected CRYPT_E_MSG_ERROR, got 0x%08lx (%ld)\n", GetLastError(),
          GetLastError());
-        HeapFree(GetProcessHeap(), 0, hashedBlob);
+        free(hashedBlob);
     }
     /* Repeating tests with fDetached = TRUE results in success */
     SetLastError(0xdeadbeef);
@@ -704,7 +704,7 @@ static void test_hash_message(void)
     ok(ret, "CryptHashMessage failed: 0x%08lx\n", GetLastError());
     if (ret)
     {
-        hashedBlob = HeapAlloc(GetProcessHeap(), 0, hashedBlobSize);
+        hashedBlob = malloc(hashedBlobSize);
         SetLastError(0xdeadbeef);
         ret = CryptHashMessage(&para, TRUE, 2, toHash, hashSize, hashedBlob,
          &hashedBlobSize, NULL, NULL);
@@ -713,7 +713,7 @@ static void test_hash_message(void)
          "unexpected size of detached blob %ld\n", hashedBlobSize);
         ok(!memcmp(hashedBlob, detachedHashBlob, hashedBlobSize),
          "unexpected detached blob value\n");
-        HeapFree(GetProcessHeap(), 0, hashedBlob);
+        free(hashedBlob);
     }
     /* Hashing a single item with fDetached = FALSE also succeeds */
     SetLastError(0xdeadbeef);
@@ -722,7 +722,7 @@ static void test_hash_message(void)
     ok(ret, "CryptHashMessage failed: 0x%08lx\n", GetLastError());
     if (ret)
     {
-        hashedBlob = HeapAlloc(GetProcessHeap(), 0, hashedBlobSize);
+        hashedBlob = malloc(hashedBlobSize);
         ret = CryptHashMessage(&para, FALSE, 1, toHash, hashSize, hashedBlob,
          &hashedBlobSize, NULL, NULL);
         ok(ret, "CryptHashMessage failed: 0x%08lx\n", GetLastError());
@@ -730,7 +730,7 @@ static void test_hash_message(void)
          "unexpected size of detached blob %ld\n", hashedBlobSize);
         ok(!memcmp(hashedBlob, hashBlob, hashedBlobSize),
          "unexpected detached blob value\n");
-        HeapFree(GetProcessHeap(), 0, hashedBlob);
+        free(hashedBlob);
     }
     /* Check the computed hash value too.  You don't need to get the encoded
      * blob to get it.
@@ -743,7 +743,7 @@ static void test_hash_message(void)
      computedHashSize);
     if (ret)
     {
-        computedHash = HeapAlloc(GetProcessHeap(), 0, computedHashSize);
+        computedHash = malloc(computedHashSize);
         SetLastError(0xdeadbeef);
         ret = CryptHashMessage(&para, TRUE, 2, toHash, hashSize, NULL,
          &hashedBlobSize, computedHash, &computedHashSize);
@@ -752,7 +752,7 @@ static void test_hash_message(void)
          "unexpected size of hash value %ld\n", computedHashSize);
         ok(!memcmp(computedHash, hashVal, computedHashSize),
          "unexpected value\n");
-        HeapFree(GetProcessHeap(), 0, computedHash);
+        free(computedHash);
     }
 }
 
diff --git a/dlls/crypt32/tests/msg.c b/dlls/crypt32/tests/msg.c
index f779d70695e..16f7402c613 100644
--- wine/dlls/crypt32/tests/msg.c
+++ wine/dlls/crypt32/tests/msg.c
@@ -274,14 +274,14 @@ static void check_param(LPCSTR test, HCRYPTMSG msg, DWORD param,
     ret = CryptMsgGetParam(msg, param, 0, NULL, &size);
     ok(ret, "%s: CryptMsgGetParam failed: %08lx\n", test, GetLastError());
 
-    buf = HeapAlloc(GetProcessHeap(), 0, size);
+    buf = malloc(size);
     ret = CryptMsgGetParam(msg, param, 0, buf, &size);
     ok(ret, "%s: CryptMsgGetParam failed: %08lx\n", test, GetLastError());
     ok(size == expectedSize, "%s: expected size %ld, got %ld\n", test,
      expectedSize, size);
     if (size == expectedSize && size)
         ok(!memcmp(buf, expected, size), "%s: unexpected data\n", test);
-    HeapFree(GetProcessHeap(), 0, buf);
+    free(buf);
 }
 
 static void test_data_msg_open(void)
diff --git a/dlls/crypt32/tests/object.c b/dlls/crypt32/tests/object.c
index 22936d3738d..a3c7c8c0743 100644
--- wine/dlls/crypt32/tests/object.c
+++ wine/dlls/crypt32/tests/object.c
@@ -95,130 +95,10 @@ L"MIIBiQYJKoZIhvcNAQcCoIIBejCCAXYCAQExDjAMBggqhkiG9w0CBQUAMBMGCSqG"
 "s+9Z0WbRm8CatppebW9tDVmpqm7pLKAe7sJgvFm+P2MGjckRHSNkku8u/FcppK/g"
 "7pMZOVHkRLgLKPSoDQ==";
 
-/* Self-signed .exe, built with tcc, signed with signtool
- * (and a certificate generated on a self-signed CA).
- *
- * small.c:
- * int _start()
- * {
- *     return 0;
- * }
- *
- * tcc -nostdlib small.c
- * signtool sign /v /f codesign.pfx small.exe
- */
-static const BYTE signed_pe_blob[] =
-{
-    0x4D,0x5A,0x90,0x00,0x03,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0xFF,0xFF,0x00,0x00,0xB8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-    0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x0E,0x1F,0xBA,0x0E,0x00,0xB4,0x09,0xCD,
-    0x21,0xB8,0x01,0x4C,0xCD,0x21,0x54,0x68,0x69,0x73,0x20,0x70,0x72,0x6F,0x67,0x72,0x61,0x6D,0x20,0x63,0x61,0x6E,0x6E,0x6F,
-    0x74,0x20,0x62,0x65,0x20,0x72,0x75,0x6E,0x20,0x69,0x6E,0x20,0x44,0x4F,0x53,0x20,0x6D,0x6F,0x64,0x65,0x2E,0x0D,0x0D,0x0A,
-    0x24,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x45,0x00,0x00,0x4C,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-    0x00,0x00,0x00,0x00,0xE0,0x00,0x0F,0x03,0x0B,0x01,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-    0x00,0x10,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x10,0x00,0x00,0x00,0x02,0x00,0x00,
-    0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x02,0x00,0x00,
-    0xE7,0x0C,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x10,0x00,0x00,
-    0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x68,0x05,0x00,0x00,
-    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x2E,0x74,0x65,0x78,0x74,0x00,0x00,0x00,
-    0x18,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-    0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x55,0x89,0xE5,0x81,0xEC,0x00,0x00,0x00,0x00,0x90,0xB8,0x00,0x00,0x00,0x00,0xE9,
-    0x00,0x00,0x00,0x00,0xC9,0xC3,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x68,0x05,0x00,0x00,0x00,0x02,0x02,0x00,
-    /* Start of the signature overlay */
-    0x30,0x82,0x05,0x5A,0x06,0x09,0x2A,0x86,0x48,0x86,0xF7,0x0D,0x01,0x07,0x02,0xA0,0x82,0x05,0x4B,0x30,0x82,0x05,0x47,0x02,
-    0x01,0x01,0x31,0x0B,0x30,0x09,0x06,0x05,0x2B,0x0E,0x03,0x02,0x1A,0x05,0x00,0x30,0x4C,0x06,0x0A,0x2B,0x06,0x01,0x04,0x01,
-    0x82,0x37,0x02,0x01,0x04,0xA0,0x3E,0x30,0x3C,0x30,0x17,0x06,0x0A,0x2B,0x06,0x01,0x04,0x01,0x82,0x37,0x02,0x01,0x0F,0x30,
-    0x09,0x03,0x01,0x00,0xA0,0x04,0xA2,0x02,0x80,0x00,0x30,0x21,0x30,0x09,0x06,0x05,0x2B,0x0E,0x03,0x02,0x1A,0x05,0x00,0x04,
-    0x14,0xA0,0x95,0xDE,0xBD,0x1A,0xB7,0x86,0xAF,0x50,0x63,0xD8,0x8F,0x90,0xD5,0x49,0x96,0x4E,0x44,0xF0,0x71,0xA0,0x82,0x03,
-    0x1D,0x30,0x82,0x03,0x19,0x30,0x82,0x02,0x01,0xA0,0x03,0x02,0x01,0x02,0x02,0x10,0x96,0x53,0x2C,0xC9,0x23,0x56,0x8A,0x87,
-    0x42,0x30,0x3E,0xD5,0x8D,0x72,0xD5,0x25,0x30,0x0D,0x06,0x09,0x2A,0x86,0x48,0x86,0xF7,0x0D,0x01,0x01,0x0B,0x05,0x00,0x30,
-    0x17,0x31,0x15,0x30,0x13,0x06,0x03,0x55,0x04,0x03,0x13,0x0C,0x54,0x65,0x73,0x74,0x20,0x43,0x41,0x20,0x52,0x6F,0x6F,0x74,
-    0x30,0x1E,0x17,0x0D,0x31,0x36,0x30,0x33,0x30,0x33,0x32,0x30,0x32,0x37,0x30,0x37,0x5A,0x17,0x0D,0x34,0x39,0x31,0x32,0x33,
-    0x31,0x32,0x33,0x30,0x30,0x30,0x30,0x5A,0x30,0x17,0x31,0x15,0x30,0x13,0x06,0x03,0x55,0x04,0x03,0x13,0x0C,0x43,0x6F,0x64,
-    0x65,0x53,0x69,0x67,0x6E,0x54,0x65,0x73,0x74,0x30,0x82,0x01,0x22,0x30,0x0D,0x06,0x09,0x2A,0x86,0x48,0x86,0xF7,0x0D,0x01,
-    0x01,0x01,0x05,0x00,0x03,0x82,0x01,0x0F,0x00,0x30,0x82,0x01,0x0A,0x02,0x82,0x01,0x01,0x00,0xB2,0xC9,0x91,0x98,0x8C,0xDC,
-    0x80,0xBC,0x16,0xBF,0xC1,0x04,0x77,0x90,0xC0,0xFD,0x8C,0xBA,0x68,0x26,0xAC,0xB7,0x20,0x68,0x41,0xED,0xC3,0x9C,0x47,0x7C,
-    0x36,0xC2,0x7B,0xE1,0x5E,0xFD,0xA9,0x99,0xF4,0x29,0x36,0x86,0x93,0x40,0x55,0x53,0x65,0x79,0xBC,0x9F,0x8F,0x6E,0x2B,0x05,
-    0x84,0xE1,0xFD,0xD2,0xEF,0xEA,0x89,0x8C,0xEC,0xF9,0x55,0xF0,0x2C,0xE5,0xA7,0x29,0xF9,0x7E,0x50,0xDC,0x9C,0xA1,0x23,0xA5,
-    0xD9,0x78,0xA1,0xE7,0x7C,0xD7,0x04,0x4F,0x11,0xAC,0x9F,0x4A,0x47,0xA1,0x1E,0xD5,0x9E,0xE7,0x5B,0xB5,0x8C,0x9C,0x67,0x7A,
-    0xD0,0xF8,0x54,0xD1,0x64,0x7F,0x39,0x48,0xB6,0xCF,0x2F,0x26,0x7D,0x7B,0x13,0x2B,0xC2,0x8F,0xA6,0x3F,0x42,0x71,0x95,0x3E,
-    0x59,0x0F,0x12,0xFA,0xC2,0x70,0x89,0xB7,0xB6,0x10,0x49,0xE0,0x7D,0x4D,0xFC,0x80,0x61,0x53,0x50,0x72,0xFD,0x46,0x35,0x51,
-    0x36,0xE6,0x06,0xA9,0x4C,0x0D,0x82,0x15,0xF6,0x5D,0xDE,0xD4,0xDB,0xE7,0x82,0x10,0x40,0xA1,0x47,0x68,0x88,0x0C,0x0A,0x80,
-    0xD1,0xE5,0x9A,0x35,0x28,0x82,0x1F,0x0F,0x80,0x5A,0x6E,0x1D,0x22,0x22,0xB3,0xA7,0xA2,0x9E,0x82,0x2D,0xC0,0x7F,0x5A,0xD0,
-    0xBA,0xB2,0xCA,0x20,0xE2,0x97,0xE9,0x72,0x41,0xB7,0xD6,0x1A,0x93,0x23,0x97,0xF0,0xA9,0x61,0xD2,0x91,0xBD,0xB6,0x6B,0x95,
-    0x12,0x67,0x16,0xAC,0x0A,0xB7,0x55,0x02,0x0D,0xA5,0xAD,0x17,0x95,0x77,0xF9,0x96,0x03,0x41,0xD3,0xE1,0x61,0x68,0xBB,0x0A,
-    0xB5,0xC4,0xEE,0x70,0x40,0x08,0x05,0xC4,0xF1,0x5D,0x02,0x03,0x01,0x00,0x01,0xA3,0x61,0x30,0x5F,0x30,0x13,0x06,0x03,0x55,
-    0x1D,0x25,0x04,0x0C,0x30,0x0A,0x06,0x08,0x2B,0x06,0x01,0x05,0x05,0x07,0x03,0x03,0x30,0x48,0x06,0x03,0x55,0x1D,0x01,0x04,
-    0x41,0x30,0x3F,0x80,0x10,0x35,0x40,0x67,0x8F,0x7D,0x03,0x1B,0x76,0x52,0x62,0x2D,0xF5,0x21,0xF6,0x7C,0xBC,0xA1,0x19,0x30,
-    0x17,0x31,0x15,0x30,0x13,0x06,0x03,0x55,0x04,0x03,0x13,0x0C,0x54,0x65,0x73,0x74,0x20,0x43,0x41,0x20,0x52,0x6F,0x6F,0x74,
-    0x82,0x10,0xA0,0x4B,0xEB,0xAC,0xFA,0x08,0xF2,0x8B,0x47,0xD2,0xB3,0x54,0x60,0x6C,0xE6,0x29,0x30,0x0D,0x06,0x09,0x2A,0x86,
-    0x48,0x86,0xF7,0x0D,0x01,0x01,0x0B,0x05,0x00,0x03,0x82,0x01,0x01,0x00,0x5F,0x8C,0x7F,0xDA,0x1D,0x21,0x7A,0x15,0xD8,0x20,
-    0x04,0x53,0x7F,0x44,0x6D,0x7B,0x57,0xBE,0x7F,0x86,0x77,0x58,0xC4,0xD4,0x80,0xC7,0x2E,0x64,0x9B,0x44,0xC5,0x2D,0x6D,0xDB,
-    0x35,0x5A,0xFE,0xA4,0xD8,0x66,0x9B,0xF7,0x6E,0xFC,0xEF,0x52,0x7B,0xC5,0x16,0xE6,0xA3,0x7D,0x59,0xB7,0x31,0x28,0xEB,0xB5,
-    0x45,0xC9,0xB1,0xD1,0x08,0x67,0xC6,0x37,0xE7,0xD7,0x2A,0xE6,0x1F,0xD9,0x6A,0xE5,0x04,0xDF,0x6A,0x9D,0x91,0xFA,0x41,0xBD,
-    0x2A,0x50,0xEA,0x99,0x24,0xA9,0x0F,0x2B,0x50,0x51,0x5F,0xD9,0x0B,0x89,0x1B,0xCB,0xDB,0x88,0xE8,0xEC,0x87,0xB0,0x16,0xCC,
-    0x43,0xEE,0x5A,0xBD,0x57,0xE2,0x46,0xA7,0x56,0x54,0x23,0x32,0x8A,0xFB,0x25,0x51,0x39,0x38,0xE6,0x87,0xF5,0x73,0x63,0xD0,
-    0x5B,0xC7,0x3F,0xFD,0x04,0x75,0x74,0x4C,0x3D,0xB5,0x31,0x22,0x7D,0xF1,0x8D,0xB4,0xE0,0xAA,0xE1,0xFF,0x8F,0xDD,0xB8,0x04,
-    0x6A,0x31,0xEE,0x30,0x2D,0x6E,0x74,0x0F,0x37,0x71,0x77,0x2B,0xB8,0x9E,0x62,0x47,0x00,0x9C,0xA5,0x82,0x2B,0x9F,0x24,0x67,
-    0x50,0x86,0x8B,0xC9,0x36,0x81,0xEB,0x44,0xC2,0xF1,0x91,0xA6,0x84,0x75,0x15,0x8F,0x22,0xDE,0xAC,0xB5,0x16,0xE3,0x96,0x74,
-    0x72,0x2F,0x15,0xD5,0xFB,0x01,0x22,0xC4,0x24,0xEE,0x3D,0xDF,0x9E,0xA9,0x0A,0x5B,0x16,0x21,0xE8,0x4A,0x8C,0x7E,0x3A,0x9C,
-    0x22,0xA0,0x49,0x60,0x97,0x1B,0x3E,0x2D,0x80,0x91,0xDB,0xF7,0x78,0x38,0x76,0x78,0x0C,0xE3,0xD4,0x27,0x77,0x69,0x96,0xE6,
-    0x41,0xC7,0x2E,0xE9,0x61,0xD6,0x31,0x82,0x01,0xC4,0x30,0x82,0x01,0xC0,0x02,0x01,0x01,0x30,0x2B,0x30,0x17,0x31,0x15,0x30,
-    0x13,0x06,0x03,0x55,0x04,0x03,0x13,0x0C,0x54,0x65,0x73,0x74,0x20,0x43,0x41,0x20,0x52,0x6F,0x6F,0x74,0x02,0x10,0x96,0x53,
-    0x2C,0xC9,0x23,0x56,0x8A,0x87,0x42,0x30,0x3E,0xD5,0x8D,0x72,0xD5,0x25,0x30,0x09,0x06,0x05,0x2B,0x0E,0x03,0x02,0x1A,0x05,
-    0x00,0xA0,0x70,0x30,0x10,0x06,0x0A,0x2B,0x06,0x01,0x04,0x01,0x82,0x37,0x02,0x01,0x0C,0x31,0x02,0x30,0x00,0x30,0x19,0x06,
-    0x09,0x2A,0x86,0x48,0x86,0xF7,0x0D,0x01,0x09,0x03,0x31,0x0C,0x06,0x0A,0x2B,0x06,0x01,0x04,0x01,0x82,0x37,0x02,0x01,0x04,
-    0x30,0x1C,0x06,0x0A,0x2B,0x06,0x01,0x04,0x01,0x82,0x37,0x02,0x01,0x0B,0x31,0x0E,0x30,0x0C,0x06,0x0A,0x2B,0x06,0x01,0x04,
-    0x01,0x82,0x37,0x02,0x01,0x15,0x30,0x23,0x06,0x09,0x2A,0x86,0x48,0x86,0xF7,0x0D,0x01,0x09,0x04,0x31,0x16,0x04,0x14,0x3D,
-    0x08,0xC8,0xA3,0xEE,0x05,0x1A,0x61,0xD9,0xFE,0x1A,0x63,0xC0,0x8A,0x6E,0x9D,0xF9,0xC3,0x13,0x98,0x30,0x0D,0x06,0x09,0x2A,
-    0x86,0x48,0x86,0xF7,0x0D,0x01,0x01,0x01,0x05,0x00,0x04,0x82,0x01,0x00,0x90,0xF9,0xC0,0x7F,0x1D,0x70,0x8C,0x04,0x22,0x82,
-    0xB6,0x2D,0x48,0xBF,0x30,0x51,0x29,0xF8,0xE3,0x11,0x39,0xE0,0x64,0x23,0x72,0xE2,0x4C,0x09,0x9F,0x39,0xF2,0x6F,0xDD,0xB9,
-    0x5A,0x3D,0xEF,0xEB,0xBE,0xEC,0x3B,0xE6,0x58,0x4C,0xC9,0x4F,0xED,0xCB,0x6E,0x9D,0x67,0x8E,0x89,0x92,0x40,0x39,0xA2,0x5F,
-    0xF9,0xEF,0xD3,0xF5,0x24,0x27,0x8D,0xF7,0x3C,0x92,0x66,0x56,0xC8,0x2B,0xEA,0x04,0xA1,0x0E,0xDA,0x89,0x30,0xA7,0x01,0xD8,
-    0x0B,0xF8,0xFD,0x99,0xB6,0xC0,0x38,0xB0,0x21,0x50,0x3A,0x86,0x01,0xD0,0xF3,0x86,0x72,0xE3,0x5A,0xBB,0x2A,0x6E,0xBD,0xFB,
-    0x22,0xF9,0x42,0xD3,0x04,0xFE,0x8D,0xD8,0x79,0xD1,0xEE,0x61,0xC6,0x48,0x04,0x99,0x9A,0xA2,0x73,0xE5,0xFB,0x24,0x10,0xD5,
-    0x6B,0x71,0x80,0x0E,0x09,0xEA,0x85,0x9A,0xBD,0xBB,0xDE,0x99,0x5D,0xA3,0x18,0x4D,0xED,0x20,0x73,0x3E,0x32,0xEF,0x2C,0xAC,
-    0x5A,0x83,0x87,0x1F,0x7F,0x19,0x61,0x35,0x53,0xC1,0xAA,0x89,0x97,0xB3,0xDD,0x8D,0xA8,0x67,0x5B,0xC2,0xE2,0x09,0xB7,0xDD,
-    0x6A,0xCB,0xD5,0xBF,0xD6,0x08,0xE2,0x23,0x1A,0x41,0x9D,0xD5,0x6A,0x6B,0x8D,0x3C,0x29,0x1B,0xF1,0x3F,0x4E,0x4A,0x8F,0x29,
-    0x33,0xF9,0x1C,0x60,0xA0,0x92,0x7E,0x4F,0x35,0xB8,0xDD,0xEB,0xD1,0x68,0x1A,0x9D,0xA2,0xA6,0x97,0x1F,0x5F,0xC6,0x2C,0xFB,
-    0xCA,0xDF,0xF7,0x95,0x33,0x95,0xD4,0x79,0x5C,0x73,0x87,0x49,0x1F,0x8C,0x6E,0xCE,0x3E,0x6D,0x3D,0x2B,0x6B,0xD7,0x66,0xE9,
-    0x88,0x6F,0xF2,0x83,0xB9,0x9B,0x00,0x00
-};
-
 static void test_query_object(void)
 {
-    WCHAR tmp_path[MAX_PATH];
     BOOL ret;
     CRYPT_DATA_BLOB blob;
-    DWORD content_type;
 
     /* Test the usual invalid arguments */
     SetLastError(0xdeadbeef);
@@ -308,26 +188,6 @@ static void test_query_object(void)
      CERT_QUERY_CONTENT_FLAG_ALL, CERT_QUERY_FORMAT_FLAG_BASE64_ENCODED, 0,
      NULL, NULL, NULL, NULL, NULL, NULL);
     ok(ret, "CryptQueryObject failed: %08lx\n", GetLastError());
-
-    GetEnvironmentVariableW( L"TMP", tmp_path, MAX_PATH );
-    SetEnvironmentVariableW(L"TMP", L"C:\\nonexistent");
-    blob.pbData = (BYTE *)signed_pe_blob;
-    blob.cbData = sizeof(signed_pe_blob);
-    ret = CryptQueryObject(CERT_QUERY_OBJECT_BLOB, &blob,
-        CERT_QUERY_CONTENT_FLAG_ALL, CERT_QUERY_FORMAT_FLAG_ALL, 0, NULL, &content_type,
-        NULL, NULL, NULL, NULL);
-    ok(!ret, "CryptQueryObject succeeded\n");
-    ok(GetLastError() == CRYPT_E_NO_MATCH, "Unexpected error %lu.\n", GetLastError());
-    SetEnvironmentVariableW(L"TMP", tmp_path);
-
-    blob.pbData = (BYTE *)signed_pe_blob;
-    blob.cbData = sizeof(signed_pe_blob);
-    ret = CryptQueryObject(CERT_QUERY_OBJECT_BLOB, &blob,
-        CERT_QUERY_CONTENT_FLAG_ALL, CERT_QUERY_FORMAT_FLAG_ALL, 0, NULL, &content_type,
-        NULL, NULL, NULL, NULL);
-    ok(ret, "CryptQueryObject failed: %08lx\n", GetLastError());
-    ok(content_type == CERT_QUERY_CONTENT_PKCS7_SIGNED_EMBED,
-            "Got unexpected content_type %#lx.\n", content_type);
 }
 
 START_TEST(object)
diff --git a/dlls/crypt32/tests/oid.c b/dlls/crypt32/tests/oid.c
index 9520e8c5a4a..715d76b9c31 100644
--- wine/dlls/crypt32/tests/oid.c
+++ wine/dlls/crypt32/tests/oid.c
@@ -152,14 +152,14 @@ static void test_oidFunctionSet(void)
         ok(ret, "CryptGetDefaultOIDDllList failed: %08lx\n", GetLastError());
         if (ret)
         {
-            buf = HeapAlloc(GetProcessHeap(), 0, size * sizeof(WCHAR));
+            buf = malloc(size * sizeof(WCHAR));
             if (buf)
             {
                 ret = CryptGetDefaultOIDDllList(set1, 0, buf, &size);
                 ok(ret, "CryptGetDefaultOIDDllList failed: %08lx\n",
                  GetLastError());
                 ok(!*buf, "Expected empty DLL list\n");
-                HeapFree(GetProcessHeap(), 0, buf);
+                free(buf);
             }
         }
     }
diff --git a/dlls/crypt32/tests/store.c b/dlls/crypt32/tests/store.c
index 00c2cae19e0..20d10a110f9 100644
--- wine/dlls/crypt32/tests/store.c
+++ wine/dlls/crypt32/tests/store.c
@@ -216,7 +216,7 @@ static void testMemStore(void)
         ret = CertSerializeCertificateStoreElement(context, 1, NULL, &size);
         ok(ret, "CertSerializeCertificateStoreElement failed: %08lx\n",
          GetLastError());
-        buf = HeapAlloc(GetProcessHeap(), 0, size);
+        buf = malloc(size);
         if (buf)
         {
             ret = CertSerializeCertificateStoreElement(context, 0, buf, &size);
@@ -224,7 +224,7 @@ static void testMemStore(void)
             ok(size == sizeof(serializedCert), "Wrong size %ld\n", size);
             ok(!memcmp(serializedCert, buf, size),
              "Unexpected serialized cert\n");
-            HeapFree(GetProcessHeap(), 0, buf);
+            free(buf);
         }
 
         ret = CertFreeCertificateContext(context);
@@ -311,7 +311,7 @@ static void compareStore(HCERTSTORE store, LPCSTR name, const BYTE *pb,
     todo_wine_if (todo)
         ok(blob.cbData == cb, "%s: expected size %ld, got %ld\n", name, cb,
          blob.cbData);
-    blob.pbData = HeapAlloc(GetProcessHeap(), 0, blob.cbData);
+    blob.pbData = malloc(blob.cbData);
     if (blob.pbData)
     {
         ret = CertSaveStore(store, X509_ASN_ENCODING, CERT_STORE_SAVE_AS_STORE,
@@ -319,7 +319,7 @@ static void compareStore(HCERTSTORE store, LPCSTR name, const BYTE *pb,
         ok(ret, "CertSaveStore failed: %08lx\n", GetLastError());
         todo_wine_if (todo)
             ok(!memcmp(pb, blob.pbData, cb), "%s: unexpected value\n", name);
-        HeapFree(GetProcessHeap(), 0, blob.pbData);
+        free(blob.pbData);
     }
 }
 
@@ -1063,7 +1063,7 @@ static void testRegStore(void)
 
             size = 0;
             RegQueryValueExA(subKey, "Blob", NULL, NULL, NULL, &size);
-            buf = HeapAlloc(GetProcessHeap(), 0, size);
+            buf = malloc(size);
             if (buf)
             {
                 rc = RegQueryValueExA(subKey, "Blob", NULL, NULL, buf, &size);
@@ -1092,7 +1092,7 @@ static void testRegStore(void)
                          hdr->cb), "Unexpected hash in cert property\n");
                     }
                 }
-                HeapFree(GetProcessHeap(), 0, buf);
+                free(buf);
             }
             RegCloseKey(subKey);
         }
@@ -2465,7 +2465,7 @@ static void testAddCertificateLink(void)
         ret = CertSerializeCertificateStoreElement(linked, 0, NULL, &size);
         ok(ret, "CertSerializeCertificateStoreElement failed: %08lx\n",
          GetLastError());
-        buf = HeapAlloc(GetProcessHeap(), 0, size);
+        buf = malloc(size);
         if (buf)
         {
             ret = CertSerializeCertificateStoreElement(linked, 0, buf, &size);
@@ -2477,7 +2477,7 @@ static void testAddCertificateLink(void)
             ok(size == sizeof(serializedCert), "Wrong size %ld\n", size);
             ok(!memcmp(serializedCert, buf, size),
              "Unexpected serialized cert\n");
-            HeapFree(GetProcessHeap(), 0, buf);
+            free(buf);
         }
         /* Set a friendly name on the source certificate... */
         blob.pbData = (LPBYTE)L"WineTest";
@@ -2491,7 +2491,7 @@ static void testAddCertificateLink(void)
          CERT_FRIENDLY_NAME_PROP_ID, NULL, &size);
         ok(ret, "CertGetCertificateContextProperty failed: %08lx\n",
          GetLastError());
-        buf = HeapAlloc(GetProcessHeap(), 0, size);
+        buf = malloc(size);
         if (buf)
         {
             ret = CertGetCertificateContextProperty(linked,
@@ -2500,7 +2500,7 @@ static void testAddCertificateLink(void)
              GetLastError());
             ok(!lstrcmpW((LPCWSTR)buf, L"WineTest"),
              "unexpected friendly name\n");
-            HeapFree(GetProcessHeap(), 0, buf);
+            free(buf);
         }
         CertFreeCertificateContext(linked);
     }
@@ -2541,7 +2541,7 @@ static void testAddCertificateLink(void)
         ret = CertSerializeCertificateStoreElement(linked, 0, NULL, &size);
         ok(ret, "CertSerializeCertificateStoreElement failed: %08lx\n",
          GetLastError());
-        buf = HeapAlloc(GetProcessHeap(), 0, size);
+        buf = malloc(size);
         if (buf)
         {
             ret = CertSerializeCertificateStoreElement(linked, 0, buf, &size);
@@ -2552,7 +2552,7 @@ static void testAddCertificateLink(void)
             ok(size == sizeof(serializedCert), "Wrong size %ld\n", size);
             ok(!memcmp(serializedCert, buf, size),
              "Unexpected serialized cert\n");
-            HeapFree(GetProcessHeap(), 0, buf);
+            free(buf);
         }
         /* Set a friendly name on the source certificate... */
         blob.pbData = (LPBYTE)L"WineTest";
@@ -2566,7 +2566,7 @@ static void testAddCertificateLink(void)
          CERT_FRIENDLY_NAME_PROP_ID, NULL, &size);
         ok(ret, "CertGetCertificateContextProperty failed: %08lx\n",
          GetLastError());
-        buf = HeapAlloc(GetProcessHeap(), 0, size);
+        buf = malloc(size);
         if (buf)
         {
             ret = CertGetCertificateContextProperty(linked,
@@ -2574,7 +2574,7 @@ static void testAddCertificateLink(void)
             ok(ret, "CertGetCertificateContextProperty failed: %08lx\n", GetLastError());
             ok(!lstrcmpW((LPCWSTR)buf, L"WineTest"),
              "unexpected friendly name\n");
-            HeapFree(GetProcessHeap(), 0, buf);
+            free(buf);
         }
         CertFreeCertificateContext(linked);
     }
@@ -2603,7 +2603,7 @@ static void testAddCertificateLink(void)
         ret = CertSerializeCertificateStoreElement(linked, 0, NULL, &size);
         ok(ret, "CertSerializeCertificateStoreElement failed: %08lx\n",
          GetLastError());
-        buf = HeapAlloc(GetProcessHeap(), 0, size);
+        buf = malloc(size);
         if (buf)
         {
             ret = CertSerializeCertificateStoreElement(linked, 0, buf, &size);
@@ -2616,7 +2616,7 @@ static void testAddCertificateLink(void)
              "Wrong size %ld\n", size);
             ok(!memcmp(serializedCertWithFriendlyName, buf, size),
              "Unexpected serialized cert\n");
-            HeapFree(GetProcessHeap(), 0, buf);
+            free(buf);
         }
         CertFreeCertificateContext(linked);
         compareStore(store2, "file store -> file store",
diff --git a/dlls/crypt32/tests/str.c b/dlls/crypt32/tests/str.c
index a94381591c0..5fb05bdb836 100644
--- wine/dlls/crypt32/tests/str.c
+++ wine/dlls/crypt32/tests/str.c
@@ -31,7 +31,6 @@ typedef struct _CertRDNAttrEncoding {
     DWORD  dwValueType;
     CERT_RDN_VALUE_BLOB Value;
     LPCSTR str;
-    BOOL todo;
 } CertRDNAttrEncoding, *PCertRDNAttrEncoding;
 
 typedef struct _CertRDNAttrEncodingW {
@@ -39,7 +38,6 @@ typedef struct _CertRDNAttrEncodingW {
     DWORD  dwValueType;
     CERT_RDN_VALUE_BLOB Value;
     LPCWSTR str;
-    BOOL todo;
 } CertRDNAttrEncodingW, *PCertRDNAttrEncodingW;
 
 static BYTE bin1[] = { 0x55, 0x53 };
@@ -115,6 +113,103 @@ static const BYTE cert[] =
  0x65,0xd3,0xce,0xae,0x26,0x19,0x3,0x2e,0x4f,0x78,0xa5,0xa,0x97,0x7e,0x4f,0xc4,
  0x91,0x8a,0xf8,0x5,0xef,0x5b,0x3b,0x49,0xbf,0x5f,0x2b};
 
+/*
+Certificate:
+    Data:
+        Version: 3 (0x2)
+        Serial Number:
+            5d:79:35:fd:d3:8f:6b:e2:28:3e:94:f4:14:bf:d4:b5:c2:3a:ac:38
+        Signature Algorithm: md5WithRSAEncryption
+        Issuer: C = US, ST = Minnesota, L = Minneapolis, O = CodeWeavers, CN = server_cn.org, emailAddress = test@codeweavers.com
+        Validity
+            Not Before: Apr 14 18:56:22 2022 GMT
+            Not After : Apr 11 18:56:22 2032 GMT
+        Subject: C = US, ST = Minnesota, L = Minneapolis, O = CodeWeavers, CN = server_cn.org, emailAddress = test@codeweavers.com
+        Subject Public Key Info:
+            Public Key Algorithm: rsaEncryption
+                RSA Public-Key: (1024 bit)
+                Modulus:
+...
+                Exponent: 65537 (0x10001)
+        X509v3 extensions:
+            X509v3 Subject Alternative Name:
+                DNS:ex1.org, DNS:*.ex2.org
+            X509v3 Issuer Alternative Name:
+                DNS:ex3.org, DNS:*.ex4.org
+    Signature Algorithm: md5WithRSAEncryption
+...
+*/
+static BYTE cert_v3[] = {
+    0x30, 0x82, 0x02, 0xdf, 0x30, 0x82, 0x02, 0x48, 0xa0, 0x03, 0x02, 0x01,
+    0x02, 0x02, 0x14, 0x5d, 0x79, 0x35, 0xfd, 0xd3, 0x8f, 0x6b, 0xe2, 0x28,
+    0x3e, 0x94, 0xf4, 0x14, 0xbf, 0xd4, 0xb5, 0xc2, 0x3a, 0xac, 0x38, 0x30,
+    0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x04,
+    0x05, 0x00, 0x30, 0x81, 0x8a, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55,
+    0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31, 0x12, 0x30, 0x10, 0x06, 0x03,
+    0x55, 0x04, 0x08, 0x0c, 0x09, 0x4d, 0x69, 0x6e, 0x6e, 0x65, 0x73, 0x6f,
+    0x74, 0x61, 0x31, 0x14, 0x30, 0x12, 0x06, 0x03, 0x55, 0x04, 0x07, 0x0c,
+    0x0b, 0x4d, 0x69, 0x6e, 0x6e, 0x65, 0x61, 0x70, 0x6f, 0x6c, 0x69, 0x73,
+    0x31, 0x14, 0x30, 0x12, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x0c, 0x0b, 0x43,
+    0x6f, 0x64, 0x65, 0x57, 0x65, 0x61, 0x76, 0x65, 0x72, 0x73, 0x31, 0x16,
+    0x30, 0x14, 0x06, 0x03, 0x55, 0x04, 0x03, 0x0c, 0x0d, 0x73, 0x65, 0x72,
+    0x76, 0x65, 0x72, 0x5f, 0x63, 0x6e, 0x2e, 0x6f, 0x72, 0x67, 0x31, 0x23,
+    0x30, 0x21, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x09,
+    0x01, 0x16, 0x14, 0x74, 0x65, 0x73, 0x74, 0x40, 0x63, 0x6f, 0x64, 0x65,
+    0x77, 0x65, 0x61, 0x76, 0x65, 0x72, 0x73, 0x2e, 0x63, 0x6f, 0x6d, 0x30,
+    0x1e, 0x17, 0x0d, 0x32, 0x32, 0x30, 0x34, 0x31, 0x34, 0x31, 0x38, 0x35,
+    0x36, 0x32, 0x32, 0x5a, 0x17, 0x0d, 0x33, 0x32, 0x30, 0x34, 0x31, 0x31,
+    0x31, 0x38, 0x35, 0x36, 0x32, 0x32, 0x5a, 0x30, 0x81, 0x8a, 0x31, 0x0b,
+    0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31,
+    0x12, 0x30, 0x10, 0x06, 0x03, 0x55, 0x04, 0x08, 0x0c, 0x09, 0x4d, 0x69,
+    0x6e, 0x6e, 0x65, 0x73, 0x6f, 0x74, 0x61, 0x31, 0x14, 0x30, 0x12, 0x06,
+    0x03, 0x55, 0x04, 0x07, 0x0c, 0x0b, 0x4d, 0x69, 0x6e, 0x6e, 0x65, 0x61,
+    0x70, 0x6f, 0x6c, 0x69, 0x73, 0x31, 0x14, 0x30, 0x12, 0x06, 0x03, 0x55,
+    0x04, 0x0a, 0x0c, 0x0b, 0x43, 0x6f, 0x64, 0x65, 0x57, 0x65, 0x61, 0x76,
+    0x65, 0x72, 0x73, 0x31, 0x16, 0x30, 0x14, 0x06, 0x03, 0x55, 0x04, 0x03,
+    0x0c, 0x0d, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x5f, 0x63, 0x6e, 0x2e,
+    0x6f, 0x72, 0x67, 0x31, 0x23, 0x30, 0x21, 0x06, 0x09, 0x2a, 0x86, 0x48,
+    0x86, 0xf7, 0x0d, 0x01, 0x09, 0x01, 0x16, 0x14, 0x74, 0x65, 0x73, 0x74,
+    0x40, 0x63, 0x6f, 0x64, 0x65, 0x77, 0x65, 0x61, 0x76, 0x65, 0x72, 0x73,
+    0x2e, 0x63, 0x6f, 0x6d, 0x30, 0x81, 0x9f, 0x30, 0x0d, 0x06, 0x09, 0x2a,
+    0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x81,
+    0x8d, 0x00, 0x30, 0x81, 0x89, 0x02, 0x81, 0x81, 0x00, 0xcd, 0x7c, 0x05,
+    0xba, 0xad, 0xd0, 0xb0, 0x43, 0xcc, 0x47, 0x7d, 0x87, 0xaa, 0xb5, 0x89,
+    0x9f, 0x43, 0x94, 0xa0, 0x84, 0xc0, 0xc0, 0x5e, 0x05, 0x6d, 0x2f, 0x05,
+    0x21, 0x6b, 0x20, 0x39, 0x88, 0x06, 0x4e, 0xce, 0x76, 0xa7, 0x24, 0x77,
+    0x13, 0x71, 0x9b, 0x2a, 0x53, 0x04, 0x4f, 0x0f, 0xfc, 0x3f, 0x4f, 0xb1,
+    0x4e, 0xdc, 0xed, 0x96, 0xd4, 0x55, 0xbd, 0xcf, 0x25, 0xa6, 0x7c, 0xe3,
+    0x35, 0xbf, 0xeb, 0x30, 0xec, 0xef, 0x7f, 0x8e, 0xa1, 0xc6, 0xd3, 0xb2,
+    0x03, 0x62, 0x0a, 0x92, 0x87, 0x17, 0x52, 0x2d, 0x45, 0x2a, 0xdc, 0xdb,
+    0x87, 0xa5, 0x32, 0x4a, 0x78, 0x28, 0x4a, 0x51, 0xff, 0xdb, 0xd5, 0x20,
+    0x47, 0x7e, 0xc5, 0xbe, 0x1d, 0x01, 0x55, 0x13, 0x9f, 0xfb, 0x8e, 0x39,
+    0xd9, 0x1b, 0xe0, 0x34, 0x93, 0x43, 0x9c, 0x02, 0xa3, 0x0f, 0xb5, 0xdc,
+    0x9d, 0x86, 0x45, 0xc5, 0x4d, 0x02, 0x03, 0x01, 0x00, 0x01, 0xa3, 0x40,
+    0x30, 0x3e, 0x30, 0x1d, 0x06, 0x03,
+    0x55, 0x1d, 0x11, /* Subject Alternative Name OID */
+    0x04, 0x16, 0x30, 0x14, 0x82, 0x07, 0x65, 0x78, 0x31, 0x2e, 0x6f, 0x72,
+    0x67, 0x82, 0x09, 0x2a, 0x2e, 0x65, 0x78, 0x32, 0x2e, 0x6f, 0x72, 0x67,
+    0x30, 0x1d, 0x06, 0x03,
+    0x55, 0x1d, 0x12, /* Issuer Alternative Name OID */
+    0x04, 0x16, 0x30, 0x14, 0x82, 0x07, 0x65, 0x78, 0x33, 0x2e, 0x6f, 0x72,
+    0x67, 0x82, 0x09, 0x2a, 0x2e, 0x65, 0x78, 0x34, 0x2e, 0x6f, 0x72, 0x67,
+    0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01,
+    0x04, 0x05, 0x00, 0x03, 0x81, 0x81, 0x00, 0xcc, 0xa3, 0x75, 0x67, 0x61,
+    0x63, 0x1d, 0x99, 0x16, 0xc6, 0x93, 0x35, 0xa4, 0x31, 0xb6, 0x05, 0x05,
+    0x77, 0x12, 0x15, 0x16, 0x78, 0xb3, 0xba, 0x6e, 0xde, 0xfc, 0x73, 0x7c,
+    0x5c, 0xdd, 0xdf, 0x92, 0xde, 0xa0, 0x86, 0xff, 0x77, 0x60, 0x99, 0x8f,
+    0x4a, 0x40, 0xa8, 0x6a, 0xdb, 0x6f, 0x30, 0xe5, 0xce, 0x82, 0x2f, 0xf7,
+    0x09, 0x17, 0xb2, 0xd3, 0x3a, 0x29, 0x9a, 0xd0, 0x73, 0x9c, 0x44, 0xa2,
+    0x19, 0xf3, 0x1d, 0x16, 0x1a, 0x45, 0x2c, 0x4b, 0x94, 0xf1, 0xb8, 0xb6,
+    0xc9, 0x82, 0x6c, 0x1f, 0xae, 0xbc, 0xd1, 0xbe, 0x78, 0xc9, 0x23, 0xf5,
+    0x51, 0x6c, 0x90, 0xbf, 0xa3, 0x5c, 0xa1, 0x3a, 0xd8, 0xe3, 0xcf, 0x82,
+    0x31, 0x78, 0x2b, 0xda, 0x99, 0xff, 0x23, 0x5b, 0xea, 0x59, 0xe0, 0x6d,
+    0xd1, 0x30, 0xfd, 0x96, 0x6a, 0x4d, 0x36, 0x72, 0x96, 0xd7, 0x4f, 0x01,
+    0xa9, 0x4d, 0x8f
+};
+
+#define CERT_V3_SAN_OID_OFFSET 534
+#define CERT_V3_IAN_OID_OFFSET 565
+
 static char issuerStr[] =
  "US, Minnesota, Minneapolis, CodeWeavers, Wine Development, localhost, aric@codeweavers.com";
 static char issuerStrSemicolon[] =
@@ -134,33 +229,34 @@ static void test_CertRDNValueToStrA(void)
 {
     CertRDNAttrEncoding attrs[] = {
      { "2.5.4.6", CERT_RDN_PRINTABLE_STRING,
-       { sizeof(bin1), bin1 }, "US", FALSE },
+       { sizeof(bin1), bin1 }, "US" },
      { "2.5.4.8", CERT_RDN_PRINTABLE_STRING,
-       { sizeof(bin2), bin2 }, "Minnesota", FALSE },
+       { sizeof(bin2), bin2 }, "Minnesota" },
      { "2.5.4.7", CERT_RDN_PRINTABLE_STRING,
-       { sizeof(bin3), bin3 }, "Minneapolis", FALSE },
+       { sizeof(bin3), bin3 }, "Minneapolis" },
      { "2.5.4.10", CERT_RDN_PRINTABLE_STRING,
-       { sizeof(bin4), bin4 }, "CodeWeavers", FALSE },
+       { sizeof(bin4), bin4 }, "CodeWeavers" },
      { "2.5.4.11", CERT_RDN_PRINTABLE_STRING,
-       { sizeof(bin5), bin5 }, "Wine Development", FALSE },
+       { sizeof(bin5), bin5 }, "Wine Development" },
      { "2.5.4.3", CERT_RDN_PRINTABLE_STRING,
-       { sizeof(bin6), bin6 }, "localhost", FALSE },
+       { sizeof(bin6), bin6 }, "localhost" },
      { "1.2.840.113549.1.9.1", CERT_RDN_IA5_STRING,
-       { sizeof(bin7), bin7 }, "aric@codeweavers.com", FALSE },
+       { sizeof(bin7), bin7 }, "aric@codeweavers.com" },
      { "0", CERT_RDN_PRINTABLE_STRING,
-       { sizeof(bin9), bin9 }, "abc\"def", FALSE },
+       { sizeof(bin9), bin9 }, "abc\"def" },
      { "0", CERT_RDN_PRINTABLE_STRING,
-       { sizeof(bin10), bin10 }, "abc'def", FALSE },
+       { sizeof(bin10), bin10 }, "abc'def" },
      { "0", CERT_RDN_PRINTABLE_STRING,
-       { sizeof(bin11), bin11 }, "abc, def", FALSE },
+       { sizeof(bin11), bin11 }, "abc, def" },
      { "0", CERT_RDN_PRINTABLE_STRING,
-       { sizeof(bin12), bin12 }, " abc ", FALSE },
+       { sizeof(bin12), bin12 }, " abc " },
      { "0", CERT_RDN_PRINTABLE_STRING,
-       { sizeof(bin13), bin13 }, "\"def\"", FALSE },
+       { sizeof(bin13), bin13 }, "\"def\"" },
      { "0", CERT_RDN_PRINTABLE_STRING,
-       { sizeof(bin14), bin14 }, "1;3", FALSE },
+       { sizeof(bin14), bin14 }, "1;3" },
     };
-    DWORD i, ret;
+    unsigned int i;
+    DWORD ret, len;
     char buffer[2000];
     CERT_RDN_VALUE_BLOB blob = { 0, NULL };
     static const char ePKI[] = "ePKI Root Certification Authority";
@@ -178,15 +274,21 @@ static void test_CertRDNValueToStrA(void)
 
     for (i = 0; i < ARRAY_SIZE(attrs); i++)
     {
-        ret = CertRDNValueToStrA(attrs[i].dwValueType, &attrs[i].Value,
+        len = CertRDNValueToStrA(attrs[i].dwValueType, &attrs[i].Value,
          buffer, sizeof(buffer));
-        todo_wine_if (attrs[i].todo)
-        {
-            ok(ret == strlen(attrs[i].str) + 1, "Expected length %d, got %ld\n",
-             lstrlenA(attrs[i].str) + 1, ret);
-            ok(!strcmp(buffer, attrs[i].str), "Expected %s, got %s\n",
-             attrs[i].str, buffer);
-        }
+        ok(len == strlen(attrs[i].str) + 1, "Expected length %d, got %ld\n",
+         lstrlenA(attrs[i].str) + 1, ret);
+        ok(!strcmp(buffer, attrs[i].str), "Expected %s, got %s\n",
+         attrs[i].str, buffer);
+        memset(buffer, 0xcc, sizeof(buffer));
+        ret = CertRDNValueToStrA(attrs[i].dwValueType, &attrs[i].Value, buffer, len - 1);
+        ok(ret == 1, "Unexpected ret %lu, expected 1, test %u.\n", ret, i);
+        ok(!buffer[0], "Unexpected value %#x, test %u.\n", buffer[0], i);
+        ok(!strncmp(buffer + 1, attrs[i].str + 1, len - 2), "Strings do not match, test %u.\n", i);
+        memset(buffer, 0xcc, sizeof(buffer));
+        ret = CertRDNValueToStrA(attrs[i].dwValueType, &attrs[i].Value, buffer, 0);
+        ok(ret == len, "Unexpected ret %lu, expected %lu, test %u.\n", ret, len, i);
+        ok((unsigned char)buffer[0] == 0xcc, "Unexpected value %#x, test %u.\n", buffer[0], i);
     }
     blob.pbData = bin8;
     blob.cbData = sizeof(bin8);
@@ -202,33 +304,34 @@ static void test_CertRDNValueToStrW(void)
     static const WCHAR ePKIW[] = L"ePKI Root Certification Authority";
     CertRDNAttrEncodingW attrs[] = {
      { "2.5.4.6", CERT_RDN_PRINTABLE_STRING,
-       { sizeof(bin1), bin1 }, L"US", FALSE },
+       { sizeof(bin1), bin1 }, L"US" },
      { "2.5.4.8", CERT_RDN_PRINTABLE_STRING,
-       { sizeof(bin2), bin2 }, L"Minnesota", FALSE },
+       { sizeof(bin2), bin2 }, L"Minnesota" },
      { "2.5.4.7", CERT_RDN_PRINTABLE_STRING,
-       { sizeof(bin3), bin3 }, L"Minneapolis", FALSE },
+       { sizeof(bin3), bin3 }, L"Minneapolis" },
      { "2.5.4.10", CERT_RDN_PRINTABLE_STRING,
-       { sizeof(bin4), bin4 }, L"CodeWeavers", FALSE },
+       { sizeof(bin4), bin4 }, L"CodeWeavers" },
      { "2.5.4.11", CERT_RDN_PRINTABLE_STRING,
-       { sizeof(bin5), bin5 }, L"Wine Development", FALSE },
+       { sizeof(bin5), bin5 }, L"Wine Development" },
      { "2.5.4.3", CERT_RDN_PRINTABLE_STRING,
-       { sizeof(bin6), bin6 }, L"localhost", FALSE },
+       { sizeof(bin6), bin6 }, L"localhost" },
      { "1.2.840.113549.1.9.1", CERT_RDN_IA5_STRING,
-       { sizeof(bin7), bin7 }, L"aric@codeweavers.com", FALSE },
+       { sizeof(bin7), bin7 }, L"aric@codeweavers.com" },
      { "0", CERT_RDN_PRINTABLE_STRING,
-       { sizeof(bin9), bin9 }, L"abc\"def", FALSE },
+       { sizeof(bin9), bin9 }, L"abc\"def" },
      { "0", CERT_RDN_PRINTABLE_STRING,
-       { sizeof(bin10), bin10 }, L"abc'def", FALSE },
+       { sizeof(bin10), bin10 }, L"abc'def" },
      { "0", CERT_RDN_PRINTABLE_STRING,
-       { sizeof(bin11), bin11 }, L"abc, def", FALSE },
+       { sizeof(bin11), bin11 }, L"abc, def" },
      { "0", CERT_RDN_PRINTABLE_STRING,
-       { sizeof(bin12), bin12 }, L" abc ", FALSE },
+       { sizeof(bin12), bin12 }, L" abc " },
      { "0", CERT_RDN_PRINTABLE_STRING,
-       { sizeof(bin13), bin13 }, L"\"def\"", FALSE },
+       { sizeof(bin13), bin13 }, L"\"def\"" },
      { "0", CERT_RDN_PRINTABLE_STRING,
-       { sizeof(bin14), bin14 }, L"1;3", FALSE },
+       { sizeof(bin14), bin14 }, L"1;3" },
     };
-    DWORD i, ret;
+    unsigned int i;
+    DWORD ret, len;
     WCHAR buffer[2000];
     CERT_RDN_VALUE_BLOB blob = { 0, NULL };
 
@@ -245,14 +348,20 @@ static void test_CertRDNValueToStrW(void)
 
     for (i = 0; i < ARRAY_SIZE(attrs); i++)
     {
-        ret = CertRDNValueToStrW(attrs[i].dwValueType, &attrs[i].Value, buffer, ARRAY_SIZE(buffer));
-        todo_wine_if (attrs[i].todo)
-        {
-            ok(ret == lstrlenW(attrs[i].str) + 1,
-             "Expected length %d, got %ld\n", lstrlenW(attrs[i].str) + 1, ret);
-            ok(!lstrcmpW(buffer, attrs[i].str), "Expected %s, got %s\n",
-             wine_dbgstr_w(attrs[i].str), wine_dbgstr_w(buffer));
-        }
+        len = CertRDNValueToStrW(attrs[i].dwValueType, &attrs[i].Value, buffer, ARRAY_SIZE(buffer));
+        ok(len == lstrlenW(attrs[i].str) + 1,
+         "Expected length %d, got %ld\n", lstrlenW(attrs[i].str) + 1, ret);
+        ok(!lstrcmpW(buffer, attrs[i].str), "Expected %s, got %s\n",
+         wine_dbgstr_w(attrs[i].str), wine_dbgstr_w(buffer));
+        memset(buffer, 0xcc, sizeof(buffer));
+        ret = CertRDNValueToStrW(attrs[i].dwValueType, &attrs[i].Value, buffer, len - 1);
+        ok(ret == 1, "Unexpected ret %lu, expected 1, test %u.\n", ret, i);
+        ok(!buffer[0], "Unexpected value %#x, test %u.\n", buffer[0], i);
+        ok(buffer[1] == 0xcccc, "Unexpected value %#x, test %u.\n", buffer[1], i);
+        memset(buffer, 0xcc, sizeof(buffer));
+        ret = CertRDNValueToStrW(attrs[i].dwValueType, &attrs[i].Value, buffer, 0);
+        ok(ret == len, "Unexpected ret %lu, expected %lu, test %u.\n", ret, len, i);
+        ok(buffer[0] == 0xcccc, "Unexpected value %#x, test %u.\n", buffer[0], i);
     }
     blob.pbData = bin8;
     blob.cbData = sizeof(bin8);
@@ -264,24 +373,27 @@ static void test_CertRDNValueToStrW(void)
          wine_dbgstr_w(ePKIW), wine_dbgstr_w(buffer));
 }
 
-static void test_NameToStrConversionA(PCERT_NAME_BLOB pName, DWORD dwStrType,
- LPCSTR expected, BOOL todo)
+#define test_NameToStrConversionA(a, b, c) test_NameToStrConversionA_(__LINE__, a, b, c)
+static void test_NameToStrConversionA_(unsigned int line, PCERT_NAME_BLOB pName, DWORD dwStrType, LPCSTR expected)
 {
-    char buffer[2000] = { 0 };
-    DWORD i;
-
-    i = CertNameToStrA(X509_ASN_ENCODING, pName, dwStrType, NULL, 0);
-    todo_wine_if (todo)
-        ok(i == strlen(expected) + 1, "Expected %d chars, got %ld\n",
-         lstrlenA(expected) + 1, i);
-    i = CertNameToStrA(X509_ASN_ENCODING,pName, dwStrType, buffer,
-     sizeof(buffer));
-    todo_wine_if (todo)
-        ok(i == strlen(expected) + 1, "Expected %d chars, got %ld\n",
-         lstrlenA(expected) + 1, i);
-    todo_wine_if (todo)
-        ok(!strcmp(buffer, expected), "Expected %s, got %s\n", expected,
-         buffer);
+    char buffer[2000];
+    DWORD len, retlen;
+
+    len = CertNameToStrA(X509_ASN_ENCODING, pName, dwStrType, NULL, 0);
+    ok(len == strlen(expected) + 1, "line %u: Expected %d chars, got %ld.\n", line, lstrlenA(expected) + 1, len);
+    len = CertNameToStrA(X509_ASN_ENCODING,pName, dwStrType, buffer, sizeof(buffer));
+    ok(len == strlen(expected) + 1, "line %u: Expected %d chars, got %ld.\n",  line, lstrlenA(expected) + 1, len);
+    ok(!strcmp(buffer, expected), "line %u: Expected %s, got %s.\n", line, expected, buffer);
+
+    memset(buffer, 0xcc, sizeof(buffer));
+    retlen = CertNameToStrA(X509_ASN_ENCODING, pName, dwStrType, buffer, len - 1);
+    ok(retlen == 1, "line %u: expected 1, got %lu\n", line, retlen);
+    ok(!buffer[0], "line %u: string is not zero terminated.\n", line);
+
+    memset(buffer, 0xcc, sizeof(buffer));
+    retlen = CertNameToStrA(X509_ASN_ENCODING, pName, dwStrType, buffer, 0);
+    ok(retlen == len, "line %u: expected %lu chars, got %lu\n", line, len - 1, retlen);
+    ok((unsigned char)buffer[0] == 0xcc, "line %u: got %s\n", line, wine_dbgstr_a(buffer));
 }
 
 static BYTE encodedSimpleCN[] = {
@@ -354,98 +466,98 @@ static void test_CertNameToStrA(void)
          "Expected positive return and ERROR_SUCCESS, got %ld - %08lx\n",
          ret, GetLastError());
 
+        test_NameToStrConversionA(&context->pCertInfo->Issuer, CERT_SIMPLE_NAME_STR, issuerStr);
         test_NameToStrConversionA(&context->pCertInfo->Issuer,
-         CERT_SIMPLE_NAME_STR, issuerStr, FALSE);
-        test_NameToStrConversionA(&context->pCertInfo->Issuer,
-         CERT_SIMPLE_NAME_STR | CERT_NAME_STR_SEMICOLON_FLAG,
-         issuerStrSemicolon, FALSE);
+         CERT_SIMPLE_NAME_STR | CERT_NAME_STR_SEMICOLON_FLAG, issuerStrSemicolon);
         test_NameToStrConversionA(&context->pCertInfo->Issuer,
-         CERT_SIMPLE_NAME_STR | CERT_NAME_STR_CRLF_FLAG,
-         issuerStrCRLF, FALSE);
-        test_NameToStrConversionA(&context->pCertInfo->Subject,
-         CERT_OID_NAME_STR, subjectStr, FALSE);
+         CERT_SIMPLE_NAME_STR | CERT_NAME_STR_CRLF_FLAG, issuerStrCRLF);
+        test_NameToStrConversionA(&context->pCertInfo->Subject, CERT_OID_NAME_STR, subjectStr);
         test_NameToStrConversionA(&context->pCertInfo->Subject,
-         CERT_OID_NAME_STR | CERT_NAME_STR_SEMICOLON_FLAG,
-         subjectStrSemicolon, FALSE);
+         CERT_OID_NAME_STR | CERT_NAME_STR_SEMICOLON_FLAG, subjectStrSemicolon);
         test_NameToStrConversionA(&context->pCertInfo->Subject,
-         CERT_OID_NAME_STR | CERT_NAME_STR_CRLF_FLAG,
-         subjectStrCRLF, FALSE);
+         CERT_OID_NAME_STR | CERT_NAME_STR_CRLF_FLAG, subjectStrCRLF);
         test_NameToStrConversionA(&context->pCertInfo->Subject,
-         CERT_X500_NAME_STR, x500SubjectStr, FALSE);
+         CERT_X500_NAME_STR, x500SubjectStr);
         test_NameToStrConversionA(&context->pCertInfo->Subject,
          CERT_X500_NAME_STR | CERT_NAME_STR_SEMICOLON_FLAG | CERT_NAME_STR_REVERSE_FLAG,
-         x500SubjectStrSemicolonReverse, FALSE);
+         x500SubjectStrSemicolonReverse);
 
         CertFreeCertificateContext(context);
     }
     blob.pbData = encodedSimpleCN;
     blob.cbData = sizeof(encodedSimpleCN);
-    test_NameToStrConversionA(&blob, CERT_X500_NAME_STR, "CN=1", FALSE);
+    test_NameToStrConversionA(&blob, CERT_X500_NAME_STR, "CN=1");
     blob.pbData = encodedSingleQuotedCN;
     blob.cbData = sizeof(encodedSingleQuotedCN);
-    test_NameToStrConversionA(&blob, CERT_X500_NAME_STR, "CN='1'", FALSE);
-    test_NameToStrConversionA(&blob, CERT_SIMPLE_NAME_STR, "'1'", FALSE);
+    test_NameToStrConversionA(&blob, CERT_X500_NAME_STR, "CN='1'");
+    test_NameToStrConversionA(&blob, CERT_SIMPLE_NAME_STR, "'1'");
     blob.pbData = encodedSpacedCN;
     blob.cbData = sizeof(encodedSpacedCN);
-    test_NameToStrConversionA(&blob, CERT_X500_NAME_STR, "CN=\" 1 \"", FALSE);
-    test_NameToStrConversionA(&blob, CERT_SIMPLE_NAME_STR, "\" 1 \"", FALSE);
+    test_NameToStrConversionA(&blob, CERT_X500_NAME_STR, "CN=\" 1 \"");
+    test_NameToStrConversionA(&blob, CERT_SIMPLE_NAME_STR, "\" 1 \"");
     blob.pbData = encodedQuotedCN;
     blob.cbData = sizeof(encodedQuotedCN);
-    test_NameToStrConversionA(&blob, CERT_X500_NAME_STR, "CN=\"\"\"1\"\"\"",
-     FALSE);
-    test_NameToStrConversionA(&blob, CERT_SIMPLE_NAME_STR, "\"\"\"1\"\"\"",
-     FALSE);
+    test_NameToStrConversionA(&blob, CERT_X500_NAME_STR, "CN=\"\"\"1\"\"\"");
+    test_NameToStrConversionA(&blob, CERT_SIMPLE_NAME_STR, "\"\"\"1\"\"\"");
     blob.pbData = encodedMultipleAttrCN;
     blob.cbData = sizeof(encodedMultipleAttrCN);
-    test_NameToStrConversionA(&blob, CERT_X500_NAME_STR, "CN=\"1+2\"", FALSE);
-    test_NameToStrConversionA(&blob, CERT_SIMPLE_NAME_STR, "\"1+2\"", FALSE);
+    test_NameToStrConversionA(&blob, CERT_X500_NAME_STR, "CN=\"1+2\"");
+    test_NameToStrConversionA(&blob, CERT_SIMPLE_NAME_STR, "\"1+2\"");
     blob.pbData = encodedCommaCN;
     blob.cbData = sizeof(encodedCommaCN);
-    test_NameToStrConversionA(&blob, CERT_X500_NAME_STR, "CN=\"a,b\"", FALSE);
-    test_NameToStrConversionA(&blob, CERT_SIMPLE_NAME_STR, "\"a,b\"", FALSE);
+    test_NameToStrConversionA(&blob, CERT_X500_NAME_STR, "CN=\"a,b\"");
+    test_NameToStrConversionA(&blob, CERT_SIMPLE_NAME_STR, "\"a,b\"");
     blob.pbData = encodedEqualCN;
     blob.cbData = sizeof(encodedEqualCN);
-    test_NameToStrConversionA(&blob, CERT_X500_NAME_STR, "CN=\"a=b\"", FALSE);
-    test_NameToStrConversionA(&blob, CERT_SIMPLE_NAME_STR, "\"a=b\"", FALSE);
+    test_NameToStrConversionA(&blob, CERT_X500_NAME_STR, "CN=\"a=b\"");
+    test_NameToStrConversionA(&blob, CERT_SIMPLE_NAME_STR, "\"a=b\"");
     blob.pbData = encodedLessThanCN;
     blob.cbData = sizeof(encodedLessThanCN);
-    test_NameToStrConversionA(&blob, CERT_X500_NAME_STR, "CN=\"<\"", FALSE);
-    test_NameToStrConversionA(&blob, CERT_SIMPLE_NAME_STR, "\"<\"", FALSE);
+    test_NameToStrConversionA(&blob, CERT_X500_NAME_STR, "CN=\"<\"");
+    test_NameToStrConversionA(&blob, CERT_SIMPLE_NAME_STR, "\"<\"");
     blob.pbData = encodedGreaterThanCN;
     blob.cbData = sizeof(encodedGreaterThanCN);
-    test_NameToStrConversionA(&blob, CERT_X500_NAME_STR, "CN=\">\"", FALSE);
-    test_NameToStrConversionA(&blob, CERT_SIMPLE_NAME_STR, "\">\"", FALSE);
+    test_NameToStrConversionA(&blob, CERT_X500_NAME_STR, "CN=\">\"");
+    test_NameToStrConversionA(&blob, CERT_SIMPLE_NAME_STR, "\">\"");
     blob.pbData = encodedHashCN;
     blob.cbData = sizeof(encodedHashCN);
-    test_NameToStrConversionA(&blob, CERT_X500_NAME_STR, "CN=\"#\"", FALSE);
-    test_NameToStrConversionA(&blob, CERT_SIMPLE_NAME_STR, "\"#\"", FALSE);
+    test_NameToStrConversionA(&blob, CERT_X500_NAME_STR, "CN=\"#\"");
+    test_NameToStrConversionA(&blob, CERT_SIMPLE_NAME_STR, "\"#\"");
     blob.pbData = encodedSemiCN;
     blob.cbData = sizeof(encodedSemiCN);
-    test_NameToStrConversionA(&blob, CERT_X500_NAME_STR, "CN=\";\"", FALSE);
-    test_NameToStrConversionA(&blob, CERT_SIMPLE_NAME_STR, "\";\"", FALSE);
+    test_NameToStrConversionA(&blob, CERT_X500_NAME_STR, "CN=\";\"");
+    test_NameToStrConversionA(&blob, CERT_SIMPLE_NAME_STR, "\";\"");
     blob.pbData = encodedNewlineCN;
     blob.cbData = sizeof(encodedNewlineCN);
-    test_NameToStrConversionA(&blob, CERT_X500_NAME_STR, "CN=\"a\nb\"", FALSE);
-    test_NameToStrConversionA(&blob, CERT_SIMPLE_NAME_STR, "\"a\nb\"", FALSE);
+    test_NameToStrConversionA(&blob, CERT_X500_NAME_STR, "CN=\"a\nb\"");
+    test_NameToStrConversionA(&blob, CERT_SIMPLE_NAME_STR, "\"a\nb\"");
 }
 
-static void test_NameToStrConversionW(PCERT_NAME_BLOB pName, DWORD dwStrType,
- LPCWSTR expected, BOOL todo)
+#define test_NameToStrConversionW(a, b, c) test_NameToStrConversionW_(__LINE__, a, b, c)
+static void test_NameToStrConversionW_(unsigned int line, PCERT_NAME_BLOB pName, DWORD dwStrType, LPCWSTR expected)
 {
-    WCHAR buffer[2000] = { 0 };
-    DWORD i;
-
-    i = CertNameToStrW(X509_ASN_ENCODING,pName, dwStrType, NULL, 0);
-    todo_wine_if (todo)
-        ok(i == lstrlenW(expected) + 1, "Expected %d chars, got %ld\n",
-         lstrlenW(expected) + 1, i);
-    i = CertNameToStrW(X509_ASN_ENCODING,pName, dwStrType, buffer, ARRAY_SIZE(buffer));
-    todo_wine_if (todo)
-        ok(i == lstrlenW(expected) + 1, "Expected %d chars, got %ld\n",
-         lstrlenW(expected) + 1, i);
-    todo_wine_if (todo)
-        ok(!lstrcmpW(buffer, expected), "Expected %s, got %s\n",
-         wine_dbgstr_w(expected), wine_dbgstr_w(buffer));
+    DWORD len, retlen, expected_len;
+    WCHAR buffer[2000];
+
+    expected_len = wcslen(expected) + 1;
+    memset(buffer, 0xcc, sizeof(buffer));
+    len = CertNameToStrW(X509_ASN_ENCODING, pName, dwStrType, NULL, 0);
+    ok(len == expected_len, "line %u: expected %lu chars, got %lu\n", line, expected_len, len);
+    retlen = CertNameToStrW(X509_ASN_ENCODING, pName, dwStrType, buffer, ARRAY_SIZE(buffer));
+    ok(retlen == len, "line %u: expected %lu chars, got %lu.\n", line, len, retlen);
+    ok(!wcscmp(buffer, expected), "Expected %s, got %s\n", wine_dbgstr_w(expected), wine_dbgstr_w(buffer));
+
+    memset(buffer, 0xcc, sizeof(buffer));
+    retlen = CertNameToStrW(X509_ASN_ENCODING, pName, dwStrType, buffer, len - 1);
+    ok(retlen == len - 1, "line %u: expected %lu chars, got %lu\n", line, len - 1, retlen);
+    ok(!wcsncmp(buffer, expected, retlen - 1), "line %u: expected %s, got %s\n",
+            line, wine_dbgstr_w(expected), wine_dbgstr_w(buffer));
+    ok(!buffer[retlen - 1], "line %u: string is not zero terminated.\n", line);
+
+    memset(buffer, 0xcc, sizeof(buffer));
+    retlen = CertNameToStrW(X509_ASN_ENCODING, pName, dwStrType, buffer, 0);
+    ok(retlen == len, "line %u: expected %lu chars, got %lu\n", line, len - 1, retlen);
+    ok(buffer[0] == 0xcccc, "line %u: got %s\n", line, wine_dbgstr_w(buffer));
 }
 
 static void test_CertNameToStrW(void)
@@ -479,95 +591,79 @@ static void test_CertNameToStrW(void)
 
         test_NameToStrConversionW(&context->pCertInfo->Issuer,
          CERT_SIMPLE_NAME_STR,
-         L"US, Minnesota, Minneapolis, CodeWeavers, Wine Development, localhost, aric@codeweavers.com", FALSE);
+         L"US, Minnesota, Minneapolis, CodeWeavers, Wine Development, localhost, aric@codeweavers.com");
         test_NameToStrConversionW(&context->pCertInfo->Issuer,
          CERT_SIMPLE_NAME_STR | CERT_NAME_STR_SEMICOLON_FLAG,
-         L"US; Minnesota; Minneapolis; CodeWeavers; Wine Development; localhost; aric@codeweavers.com", FALSE);
+         L"US; Minnesota; Minneapolis; CodeWeavers; Wine Development; localhost; aric@codeweavers.com");
         test_NameToStrConversionW(&context->pCertInfo->Issuer,
          CERT_SIMPLE_NAME_STR | CERT_NAME_STR_CRLF_FLAG,
-         L"US\r\nMinnesota\r\nMinneapolis\r\nCodeWeavers\r\nWine Development\r\nlocalhost\r\naric@codeweavers.com",
-         FALSE);
+         L"US\r\nMinnesota\r\nMinneapolis\r\nCodeWeavers\r\nWine Development\r\nlocalhost\r\naric@codeweavers.com");
         test_NameToStrConversionW(&context->pCertInfo->Subject,
          CERT_OID_NAME_STR,
          L"2.5.4.6=US, 2.5.4.8=Minnesota, 2.5.4.7=Minneapolis, 2.5.4.10=CodeWeavers, 2.5.4.11=Wine Development,"
-          " 2.5.4.3=localhost, 1.2.840.113549.1.9.1=aric@codeweavers.com", FALSE);
+          " 2.5.4.3=localhost, 1.2.840.113549.1.9.1=aric@codeweavers.com");
         test_NameToStrConversionW(&context->pCertInfo->Subject,
          CERT_OID_NAME_STR | CERT_NAME_STR_SEMICOLON_FLAG,
          L"2.5.4.6=US; 2.5.4.8=Minnesota; 2.5.4.7=Minneapolis; 2.5.4.10=CodeWeavers; 2.5.4.11=Wine Development;"
-          " 2.5.4.3=localhost; 1.2.840.113549.1.9.1=aric@codeweavers.com", FALSE);
+          " 2.5.4.3=localhost; 1.2.840.113549.1.9.1=aric@codeweavers.com");
         test_NameToStrConversionW(&context->pCertInfo->Subject,
          CERT_OID_NAME_STR | CERT_NAME_STR_CRLF_FLAG,
          L"2.5.4.6=US\r\n2.5.4.8=Minnesota\r\n2.5.4.7=Minneapolis\r\n2.5.4.10=CodeWeavers\r\n2.5.4.11=Wine "
-          "Development\r\n2.5.4.3=localhost\r\n1.2.840.113549.1.9.1=aric@codeweavers.com", FALSE);
+          "Development\r\n2.5.4.3=localhost\r\n1.2.840.113549.1.9.1=aric@codeweavers.com");
         test_NameToStrConversionW(&context->pCertInfo->Subject,
          CERT_X500_NAME_STR | CERT_NAME_STR_SEMICOLON_FLAG | CERT_NAME_STR_REVERSE_FLAG,
          L"E=aric@codeweavers.com; CN=localhost; OU=Wine Development; O=CodeWeavers; L=Minneapolis; S=Minnesota; "
-          "C=US", FALSE);
+          "C=US");
 
         CertFreeCertificateContext(context);
     }
     blob.pbData = encodedSimpleCN;
     blob.cbData = sizeof(encodedSimpleCN);
-    test_NameToStrConversionW(&blob, CERT_X500_NAME_STR, L"CN=1", FALSE);
+    test_NameToStrConversionW(&blob, CERT_X500_NAME_STR, L"CN=1");
     blob.pbData = encodedSingleQuotedCN;
     blob.cbData = sizeof(encodedSingleQuotedCN);
-    test_NameToStrConversionW(&blob, CERT_X500_NAME_STR, L"CN='1'",
-     FALSE);
-    test_NameToStrConversionW(&blob, CERT_SIMPLE_NAME_STR,
-     L"'1'", FALSE);
+    test_NameToStrConversionW(&blob, CERT_X500_NAME_STR, L"CN='1'");
+    test_NameToStrConversionW(&blob, CERT_SIMPLE_NAME_STR, L"'1'");
     blob.pbData = encodedSpacedCN;
     blob.cbData = sizeof(encodedSpacedCN);
-    test_NameToStrConversionW(&blob, CERT_X500_NAME_STR, L"CN=\" 1 \"", FALSE);
-    test_NameToStrConversionW(&blob, CERT_SIMPLE_NAME_STR, L"\" 1 \"",
-     FALSE);
+    test_NameToStrConversionW(&blob, CERT_X500_NAME_STR, L"CN=\" 1 \"");
+    test_NameToStrConversionW(&blob, CERT_SIMPLE_NAME_STR, L"\" 1 \"");
     blob.pbData = encodedQuotedCN;
     blob.cbData = sizeof(encodedQuotedCN);
-    test_NameToStrConversionW(&blob, CERT_X500_NAME_STR, L"CN=\"\"\"1\"\"\"",
-     FALSE);
-    test_NameToStrConversionW(&blob, CERT_SIMPLE_NAME_STR, L"\"\"\"1\"\"\"",
-     FALSE);
+    test_NameToStrConversionW(&blob, CERT_X500_NAME_STR, L"CN=\"\"\"1\"\"\"");
+    test_NameToStrConversionW(&blob, CERT_SIMPLE_NAME_STR, L"\"\"\"1\"\"\"");
     blob.pbData = encodedMultipleAttrCN;
     blob.cbData = sizeof(encodedMultipleAttrCN);
-    test_NameToStrConversionW(&blob, CERT_X500_NAME_STR, L"CN=\"1+2\"",
-     FALSE);
-    test_NameToStrConversionW(&blob, CERT_SIMPLE_NAME_STR,
-     L"\"1+2\"", FALSE);
+    test_NameToStrConversionW(&blob, CERT_X500_NAME_STR, L"CN=\"1+2\"");
+    test_NameToStrConversionW(&blob, CERT_SIMPLE_NAME_STR, L"\"1+2\"");
     blob.pbData = encodedCommaCN;
     blob.cbData = sizeof(encodedCommaCN);
-    test_NameToStrConversionW(&blob, CERT_X500_NAME_STR, L"CN=\"a,b\"", FALSE);
-    test_NameToStrConversionW(&blob, CERT_SIMPLE_NAME_STR, L"\"a,b\"",
-     FALSE);
+    test_NameToStrConversionW(&blob, CERT_X500_NAME_STR, L"CN=\"a,b\"");
+    test_NameToStrConversionW(&blob, CERT_SIMPLE_NAME_STR, L"\"a,b\"");
     blob.pbData = encodedEqualCN;
     blob.cbData = sizeof(encodedEqualCN);
-    test_NameToStrConversionW(&blob, CERT_X500_NAME_STR, L"CN=\"a=b\"", FALSE);
-    test_NameToStrConversionW(&blob, CERT_SIMPLE_NAME_STR, L"\"a=b\"",
-     FALSE);
+    test_NameToStrConversionW(&blob, CERT_X500_NAME_STR, L"CN=\"a=b\"");
+    test_NameToStrConversionW(&blob, CERT_SIMPLE_NAME_STR, L"\"a=b\"");
     blob.pbData = encodedLessThanCN;
     blob.cbData = sizeof(encodedLessThanCN);
-    test_NameToStrConversionW(&blob, CERT_X500_NAME_STR, L"CN=\"<\"", FALSE);
-    test_NameToStrConversionW(&blob, CERT_SIMPLE_NAME_STR, L"\"<\"",
-     FALSE);
+    test_NameToStrConversionW(&blob, CERT_X500_NAME_STR, L"CN=\"<\"");
+    test_NameToStrConversionW(&blob, CERT_SIMPLE_NAME_STR, L"\"<\"");
     blob.pbData = encodedGreaterThanCN;
     blob.cbData = sizeof(encodedGreaterThanCN);
-    test_NameToStrConversionW(&blob, CERT_X500_NAME_STR, L"CN=\">\"",
-     FALSE);
-    test_NameToStrConversionW(&blob, CERT_SIMPLE_NAME_STR,
-     L"\">\"", FALSE);
+    test_NameToStrConversionW(&blob, CERT_X500_NAME_STR, L"CN=\">\"");
+    test_NameToStrConversionW(&blob, CERT_SIMPLE_NAME_STR, L"\">\"");
     blob.pbData = encodedHashCN;
     blob.cbData = sizeof(encodedHashCN);
-    test_NameToStrConversionW(&blob, CERT_X500_NAME_STR, L"CN=\"#\"", FALSE);
-    test_NameToStrConversionW(&blob, CERT_SIMPLE_NAME_STR, L"\"#\"",
-     FALSE);
+    test_NameToStrConversionW(&blob, CERT_X500_NAME_STR, L"CN=\"#\"");
+    test_NameToStrConversionW(&blob, CERT_SIMPLE_NAME_STR, L"\"#\"");
     blob.pbData = encodedSemiCN;
     blob.cbData = sizeof(encodedSemiCN);
-    test_NameToStrConversionW(&blob, CERT_X500_NAME_STR, L"CN=\";\"", FALSE);
-    test_NameToStrConversionW(&blob, CERT_SIMPLE_NAME_STR, L"\";\"",
-     FALSE);
+    test_NameToStrConversionW(&blob, CERT_X500_NAME_STR, L"CN=\";\"");
+    test_NameToStrConversionW(&blob, CERT_SIMPLE_NAME_STR, L"\";\"");
     blob.pbData = encodedNewlineCN;
     blob.cbData = sizeof(encodedNewlineCN);
-    test_NameToStrConversionW(&blob, CERT_X500_NAME_STR, L"CN=\"a\nb\"", FALSE);
-    test_NameToStrConversionW(&blob, CERT_SIMPLE_NAME_STR, L"\"a\nb\"",
-     FALSE);
+    test_NameToStrConversionW(&blob, CERT_X500_NAME_STR, L"CN=\"a\nb\"");
+    test_NameToStrConversionW(&blob, CERT_SIMPLE_NAME_STR, L"\"a\nb\"");
 }
 
 struct StrToNameA
@@ -747,153 +843,140 @@ static void test_CertStrToNameW(void)
     }
 }
 
-static void test_CertGetNameStringA(void)
+#define test_CertGetNameString_value(a, b, c, d, e) test_CertGetNameString_value_(__LINE__, a, b, c, d, e)
+static void test_CertGetNameString_value_(unsigned int line, PCCERT_CONTEXT context, DWORD type, DWORD flags,
+        void *type_para, const char *expected)
 {
+    DWORD len, retlen, expected_len;
+    WCHAR expectedW[512];
+    WCHAR strW[512];
+    char str[512];
+
+    expected_len = 0;
+    while(expected[expected_len])
+    {
+        while((expectedW[expected_len] = expected[expected_len]))
+            ++expected_len;
+        if (!(flags & CERT_NAME_SEARCH_ALL_NAMES_FLAG))
+            break;
+        expectedW[expected_len++] = 0;
+    }
+    expectedW[expected_len++] = 0;
+
+    len = CertGetNameStringA(context, type, flags, type_para, NULL, 0);
+    ok(len == expected_len, "line %u: unexpected length %ld, expected %ld.\n", line, len, expected_len);
+    memset(str, 0xcc, len);
+    retlen = CertGetNameStringA(context, type, flags, type_para, str, len);
+    ok(retlen == len, "line %u: unexpected len %lu, expected %lu.\n", line, retlen, len);
+    ok(!memcmp(str, expected, expected_len), "line %u: unexpected value %s.\n", line, debugstr_an(str, expected_len));
+    str[0] = str[1] = 0xcc;
+    retlen = CertGetNameStringA(context, type, flags, type_para, str, len - 1);
+    ok(retlen == 1, "line %u: Unexpected len %lu, expected 1.\n", line, retlen);
+    if (len == 1) return;
+    ok(!str[0], "line %u: unexpected str[0] %#x.\n", line, str[0]);
+    ok(str[1] == expected[1], "line %u: unexpected str[1] %#x.\n", line, str[1]);
+    ok(!memcmp(str + 1, expected + 1, len - 2),
+            "line %u: str %s, string data mismatch.\n", line, debugstr_a(str + 1));
+    retlen = CertGetNameStringA(context, type, flags, type_para, str, 0);
+    ok(retlen == len, "line %u: Unexpected len %lu, expected 1.\n", line, retlen);
+
+    memset(strW, 0xcc, len * sizeof(*strW));
+    retlen = CertGetNameStringW(context, type, flags, type_para, strW, len);
+    ok(retlen == expected_len, "line %u: unexpected len %lu, expected %lu.\n", line, retlen, expected_len);
+    ok(!memcmp(strW, expectedW, len * sizeof(*strW)), "line %u: unexpected value %s.\n", line, debugstr_wn(strW, len));
+    strW[0] = strW[1] = 0xcccc;
+    retlen = CertGetNameStringW(context, type, flags, type_para, strW, len - 1);
+    ok(retlen == len - 1, "line %u: unexpected len %lu, expected %lu.\n", line, retlen, len - 1);
+    if (flags & CERT_NAME_SEARCH_ALL_NAMES_FLAG)
+    {
+        ok(!memcmp(strW, expectedW, (retlen - 2) * sizeof(*strW)),
+                "line %u: str %s, string data mismatch.\n", line, debugstr_wn(strW, retlen - 2));
+        ok(!strW[retlen - 2], "line %u: string is not zero terminated.\n", line);
+        ok(!strW[retlen - 1], "line %u: string sequence is not zero terminated.\n", line);
+
+        retlen = CertGetNameStringW(context, type, flags, type_para, strW, 1);
+        ok(retlen == 1, "line %u: unexpected len %lu, expected %lu.\n", line, retlen, len - 1);
+        ok(!strW[retlen - 1], "line %u: string sequence is not zero terminated.\n", line);
+    }
+    else
+    {
+        ok(!memcmp(strW, expectedW, (retlen - 1) * sizeof(*strW)),
+                "line %u: str %s, string data mismatch.\n", line, debugstr_wn(strW, retlen - 1));
+        ok(!strW[retlen - 1], "line %u: string is not zero terminated.\n", line);
+    }
+    retlen = CertGetNameStringA(context, type, flags, type_para, NULL, len - 1);
+    ok(retlen == len, "line %u: unexpected len %lu, expected %lu\n", line, retlen, len);
+    retlen = CertGetNameStringW(context, type, flags, type_para, NULL, len - 1);
+    ok(retlen == len, "line %u: unexpected len %lu, expected %lu\n", line, retlen, len);
+}
+
+static void test_CertGetNameString(void)
+{
+    static const char aric[] = "aric@codeweavers.com";
+    static const char localhost[] = "localhost";
     PCCERT_CONTEXT context;
+    DWORD len, type;
 
     context = CertCreateCertificateContext(X509_ASN_ENCODING, cert,
      sizeof(cert));
-    ok(context != NULL, "CertCreateCertificateContext failed: %08lx\n",
-     GetLastError());
-    if (context)
-    {
-        static const char aric[] = "aric@codeweavers.com";
-        static const char localhost[] = "localhost";
-        DWORD len, type;
-        LPSTR str;
-
-        /* Bad string types/types missing from the cert */
-        len = CertGetNameStringA(NULL, 0, 0, NULL, NULL, 0);
-        ok(len == 1, "expected 1, got %ld\n", len);
-        len = CertGetNameStringA(context, 0, 0, NULL, NULL, 0);
-        ok(len == 1, "expected 1, got %ld\n", len);
-        len = CertGetNameStringA(context, CERT_NAME_URL_TYPE, 0, NULL, NULL,
-         0);
-        ok(len == 1, "expected 1, got %ld\n", len);
-
-        len = CertGetNameStringA(context, CERT_NAME_EMAIL_TYPE, 0, NULL, NULL,
-         0);
-        ok(len == strlen(aric) + 1, "unexpected length %ld\n", len);
-        str = HeapAlloc(GetProcessHeap(), 0, len);
-        if (str)
-        {
-            len = CertGetNameStringA(context, CERT_NAME_EMAIL_TYPE, 0, NULL,
-             str, len);
-            ok(!strcmp(str, aric), "unexpected value %s\n", str);
-            HeapFree(GetProcessHeap(), 0, str);
-        }
-
-        len = CertGetNameStringA(context, CERT_NAME_RDN_TYPE, 0, NULL, NULL,
-         0);
-        ok(len == strlen(issuerStr) + 1, "unexpected length %ld\n", len);
-        str = HeapAlloc(GetProcessHeap(), 0, len);
-        if (str)
-        {
-            len = CertGetNameStringA(context, CERT_NAME_RDN_TYPE, 0, NULL,
-             str, len);
-            ok(!strcmp(str, issuerStr), "unexpected value %s\n", str);
-            HeapFree(GetProcessHeap(), 0, str);
-        }
-        type = 0;
-        len = CertGetNameStringA(context, CERT_NAME_RDN_TYPE, 0, &type, NULL,
-         0);
-        ok(len == strlen(issuerStr) + 1, "unexpected length %ld\n", len);
-        str = HeapAlloc(GetProcessHeap(), 0, len);
-        if (str)
-        {
-            len = CertGetNameStringA(context, CERT_NAME_RDN_TYPE, 0, &type,
-             str, len);
-            ok(!strcmp(str, issuerStr), "unexpected value %s\n", str);
-            HeapFree(GetProcessHeap(), 0, str);
-        }
-        type = CERT_OID_NAME_STR;
-        len = CertGetNameStringA(context, CERT_NAME_RDN_TYPE, 0, &type, NULL,
-         0);
-        ok(len == strlen(subjectStr) + 1, "unexpected length %ld\n", len);
-        str = HeapAlloc(GetProcessHeap(), 0, len);
-        if (str)
-        {
-            len = CertGetNameStringA(context, CERT_NAME_RDN_TYPE, 0, &type,
-             str, len);
-            ok(!strcmp(str, subjectStr), "unexpected value %s\n", str);
-            HeapFree(GetProcessHeap(), 0, str);
-        }
-
-        len = CertGetNameStringA(context, CERT_NAME_ATTR_TYPE, 0, NULL, NULL,
-         0);
-        ok(len == strlen(aric) + 1, "unexpected length %ld\n", len);
-        str = HeapAlloc(GetProcessHeap(), 0, len);
-        if (str)
-        {
-            len = CertGetNameStringA(context, CERT_NAME_ATTR_TYPE, 0, NULL,
-             str, len);
-            ok(!strcmp(str, aric), "unexpected value %s\n", str);
-            HeapFree(GetProcessHeap(), 0, str);
-        }
-        len = CertGetNameStringA(context, CERT_NAME_ATTR_TYPE, 0,
-         (void *)szOID_RSA_emailAddr, NULL, 0);
-        ok(len == strlen(aric) + 1, "unexpected length %ld\n", len);
-        str = HeapAlloc(GetProcessHeap(), 0, len);
-        if (str)
-        {
-            len = CertGetNameStringA(context, CERT_NAME_ATTR_TYPE, 0,
-             (void *)szOID_RSA_emailAddr, str, len);
-            ok(!strcmp(str, aric), "unexpected value %s\n", str);
-            HeapFree(GetProcessHeap(), 0, str);
-        }
-        len = CertGetNameStringA(context, CERT_NAME_ATTR_TYPE, 0,
-         (void *)szOID_COMMON_NAME, NULL, 0);
-        ok(len == strlen(localhost) + 1, "unexpected length %ld\n", len);
-        str = HeapAlloc(GetProcessHeap(), 0, len);
-        if (str)
-        {
-            len = CertGetNameStringA(context, CERT_NAME_ATTR_TYPE, 0,
-             (void *)szOID_COMMON_NAME, str, len);
-            ok(!strcmp(str, localhost), "unexpected value %s\n", str);
-            HeapFree(GetProcessHeap(), 0, str);
-        }
-
-        len = CertGetNameStringA(context, CERT_NAME_SIMPLE_DISPLAY_TYPE, 0,
-         NULL, NULL, 0);
-        ok(len == strlen(localhost) + 1, "unexpected length %ld\n", len);
-        str = HeapAlloc(GetProcessHeap(), 0, len);
-        if (str)
-        {
-            len = CertGetNameStringA(context, CERT_NAME_SIMPLE_DISPLAY_TYPE,
-             0, NULL, str, len);
-            ok(!strcmp(str, localhost), "unexpected value %s\n", str);
-            HeapFree(GetProcessHeap(), 0, str);
-        }
-
-        len = CertGetNameStringA(context, CERT_NAME_FRIENDLY_DISPLAY_TYPE, 0,
-         NULL, NULL, 0);
-        ok(len == strlen(localhost) + 1, "unexpected length %ld\n", len);
-        str = HeapAlloc(GetProcessHeap(), 0, len);
-        if (str)
-        {
-            len = CertGetNameStringA(context, CERT_NAME_FRIENDLY_DISPLAY_TYPE,
-             0, NULL, str, len);
-            ok(!strcmp(str, localhost), "unexpected value %s\n", str);
-            HeapFree(GetProcessHeap(), 0, str);
-        }
-
-        len = CertGetNameStringA(context, CERT_NAME_DNS_TYPE, 0, NULL, NULL,
-         0);
-        ok(len == strlen(localhost) + 1, "unexpected length %ld\n", len);
-        if (len > 1)
-        {
-            str = HeapAlloc(GetProcessHeap(), 0, len);
-            if (str)
-            {
-                len = CertGetNameStringA(context, CERT_NAME_DNS_TYPE, 0, NULL,
-                 str, len);
-                ok(!strcmp(str, localhost), "unexpected value %s\n", str);
-                HeapFree(GetProcessHeap(), 0, str);
-            }
-        }
-
-        CertFreeCertificateContext(context);
-    }
+    ok(!!context, "CertCreateCertificateContext failed, err %lu\n", GetLastError());
+
+    /* Bad string types/types missing from the cert */
+    len = CertGetNameStringA(NULL, 0, 0, NULL, NULL, 0);
+    ok(len == 1, "expected 1, got %lu\n", len);
+    len = CertGetNameStringA(context, 0, 0, NULL, NULL, 0);
+    ok(len == 1, "expected 1, got %lu\n", len);
+    len = CertGetNameStringA(context, CERT_NAME_URL_TYPE, 0, NULL, NULL, 0);
+    ok(len == 1, "expected 1, got %lu\n", len);
+
+    len = CertGetNameStringW(NULL, 0, 0, NULL, NULL, 0);
+    ok(len == 1, "expected 1, got %lu\n", len);
+    len = CertGetNameStringW(context, 0, 0, NULL, NULL, 0);
+    ok(len == 1, "expected 1, got %lu\n", len);
+    len = CertGetNameStringW(context, CERT_NAME_URL_TYPE, 0, NULL, NULL, 0);
+    ok(len == 1, "expected 1, got %lu\n", len);
+
+    test_CertGetNameString_value(context, CERT_NAME_EMAIL_TYPE, 0, NULL, aric);
+    test_CertGetNameString_value(context, CERT_NAME_RDN_TYPE, 0, NULL, issuerStr);
+    type = 0;
+    test_CertGetNameString_value(context, CERT_NAME_RDN_TYPE, 0, &type, issuerStr);
+    type = CERT_OID_NAME_STR;
+    test_CertGetNameString_value(context, CERT_NAME_RDN_TYPE, 0, &type, subjectStr);
+    test_CertGetNameString_value(context, CERT_NAME_ATTR_TYPE, 0, NULL, aric);
+    test_CertGetNameString_value(context, CERT_NAME_ATTR_TYPE, 0, (void *)szOID_RSA_emailAddr, aric);
+    test_CertGetNameString_value(context, CERT_NAME_ATTR_TYPE, 0, (void *)szOID_COMMON_NAME, localhost);
+    test_CertGetNameString_value(context, CERT_NAME_SIMPLE_DISPLAY_TYPE, 0, NULL, localhost);
+    test_CertGetNameString_value(context, CERT_NAME_FRIENDLY_DISPLAY_TYPE, 0, NULL, localhost);
+    test_CertGetNameString_value(context, CERT_NAME_DNS_TYPE, 0, NULL, localhost);
+    test_CertGetNameString_value(context, CERT_NAME_DNS_TYPE, CERT_NAME_SEARCH_ALL_NAMES_FLAG, NULL, "localhost\0");
+    test_CertGetNameString_value(context, CERT_NAME_EMAIL_TYPE, CERT_NAME_SEARCH_ALL_NAMES_FLAG, NULL, "");
+    test_CertGetNameString_value(context, CERT_NAME_SIMPLE_DISPLAY_TYPE, CERT_NAME_SEARCH_ALL_NAMES_FLAG, NULL, "");
+
+    CertFreeCertificateContext(context);
+
+    ok(cert_v3[CERT_V3_SAN_OID_OFFSET] == 0x55, "Incorrect CERT_V3_SAN_OID_OFFSET.\n");
+    ok(cert_v3[CERT_V3_IAN_OID_OFFSET] == 0x55, "Incorrect CERT_V3_IAN_OID_OFFSET.\n");
+    cert_v3[CERT_V3_SAN_OID_OFFSET + 2] = 7; /* legacy OID_SUBJECT_ALT_NAME */
+    cert_v3[CERT_V3_IAN_OID_OFFSET + 2] = 8; /* legacy OID_ISSUER_ALT_NAME */
+    context = CertCreateCertificateContext(X509_ASN_ENCODING, cert_v3, sizeof(cert_v3));
+    ok(!!context, "CertCreateCertificateContext failed, err %lu\n", GetLastError());
+    test_CertGetNameString_value(context, CERT_NAME_DNS_TYPE, 0, NULL, "ex1.org");
+    test_CertGetNameString_value(context, CERT_NAME_DNS_TYPE, CERT_NAME_ISSUER_FLAG, NULL, "ex3.org");
+    CertFreeCertificateContext(context);
+
+    cert_v3[CERT_V3_SAN_OID_OFFSET + 2] = 17; /* OID_SUBJECT_ALT_NAME2 */
+    cert_v3[CERT_V3_IAN_OID_OFFSET + 2] = 18; /* OID_ISSUER_ALT_NAME2 */
+    context = CertCreateCertificateContext(X509_ASN_ENCODING, cert_v3, sizeof(cert_v3));
+    ok(!!context, "CertCreateCertificateContext failed, err %lu\n", GetLastError());
+    test_CertGetNameString_value(context, CERT_NAME_DNS_TYPE, 0, NULL, "ex1.org");
+    test_CertGetNameString_value(context, CERT_NAME_DNS_TYPE, CERT_NAME_ISSUER_FLAG, NULL, "ex3.org");
+    test_CertGetNameString_value(context, CERT_NAME_SIMPLE_DISPLAY_TYPE, 0, NULL, "server_cn.org");
+    test_CertGetNameString_value(context, CERT_NAME_ATTR_TYPE, 0, (void *)szOID_SUR_NAME, "");
+    test_CertGetNameString_value(context, CERT_NAME_DNS_TYPE, CERT_NAME_SEARCH_ALL_NAMES_FLAG,
+            NULL, "ex1.org\0*.ex2.org\0");
+    test_CertGetNameString_value(context, CERT_NAME_DNS_TYPE, CERT_NAME_SEARCH_ALL_NAMES_FLAG | CERT_NAME_ISSUER_FLAG,
+            NULL, "ex3.org\0*.ex4.org\0");
+    CertFreeCertificateContext(context);
 }
 
 START_TEST(str)
@@ -904,5 +987,5 @@ START_TEST(str)
     test_CertNameToStrW();
     test_CertStrToNameA();
     test_CertStrToNameW();
-    test_CertGetNameStringA();
+    test_CertGetNameString();
 }
diff --git a/dlls/crypt32/unixlib.c b/dlls/crypt32/unixlib.c
index 069cb049851..9a36d12f293 100644
--- wine/dlls/crypt32/unixlib.c
+++ wine/dlls/crypt32/unixlib.c
@@ -95,21 +95,7 @@ static NTSTATUS process_attach( void *args )
         setenv("GNUTLS_SYSTEM_PRIORITY_FILE", "/dev/null", 0);
     }
 
-if (1) { /* CROSSOVER HACK - bug 10151 */
-    const char *libgnutls_name_candidates[] = {SONAME_LIBGNUTLS,
-                                               "libgnutls.so.30",
-                                               "libgnutls.so.28",
-                                               "libgnutls-deb0.so.28",
-                                               "libgnutls.so.26",
-                                               NULL};
-    int i;
-    for (i=0; libgnutls_name_candidates[i] && !libgnutls_handle; i++)
-        libgnutls_handle = dlopen(libgnutls_name_candidates[i], RTLD_NOW);
-}
-else
-    libgnutls_handle = dlopen( SONAME_LIBGNUTLS, RTLD_NOW );
-
-    if (!libgnutls_handle)
+    if (!(libgnutls_handle = dlopen( SONAME_LIBGNUTLS, RTLD_NOW )))
     {
         ERR_(winediag)( "failed to load libgnutls, no support for pfx import/export\n" );
         return STATUS_DLL_NOT_FOUND;
diff --git a/dlls/cryptnet/cryptnet_main.c b/dlls/cryptnet/cryptnet_main.c
index 6654ef77c8c..19de1ed2d8e 100644
--- wine/dlls/cryptnet/cryptnet_main.c
+++ wine/dlls/cryptnet/cryptnet_main.c
@@ -1690,6 +1690,15 @@ static DWORD verify_cert_revocation_from_dist_points_ext(const CRYPT_DATA_BLOB *
     const CRL_CONTEXT *crl;
     DWORD timeout = 0;
 
+    if (!params || !params->pIssuerCert)
+    {
+        TRACE("no issuer certificate\n");
+        return CRYPT_E_REVOCATION_OFFLINE;
+    }
+
+    if (find_cached_revocation_status(&cert->pCertInfo->SerialNumber, time, status))
+        return status->dwError;
+
     if (!CRYPT_GetUrlFromCRLDistPointsExt(value, NULL, &url_array_size, NULL, NULL))
         return GetLastError();
 
@@ -1918,6 +1927,7 @@ static DWORD verify_signed_ocsp_response_info(const CERT_INFO *cert, const CERT_
     HCRYPTPROV prov = 0;
     HCRYPTHASH hash = 0;
     HCRYPTKEY key = 0;
+    DWORD algid;
 
     if (!CryptDecodeObjectEx(X509_ASN_ENCODING, OCSP_BASIC_SIGNED_RESPONSE, blob->pbData, blob->cbData,
                              CRYPT_DECODE_ALLOC_FLAG, NULL, &info, &size)) return GetLastError();
@@ -1925,7 +1935,7 @@ static DWORD verify_signed_ocsp_response_info(const CERT_INFO *cert, const CERT_
     if ((error = check_ocsp_response_info(cert, issuer, &info->ToBeSigned, &status))) goto done;
 
     alg = &info->SignatureInfo.SignatureAlgorithm;
-    if (!alg->pszObjId || strcmp(alg->pszObjId, szOID_RSA_SHA256RSA))
+    if (!alg->pszObjId || !(algid = CertOIDToAlgId(alg->pszObjId)))
     {
         FIXME("unhandled signature algorithm %s\n", debugstr_a(alg->pszObjId));
         error = CRYPT_E_NO_REVOCATION_CHECK;
@@ -1933,7 +1943,7 @@ static DWORD verify_signed_ocsp_response_info(const CERT_INFO *cert, const CERT_
     }
 
     if (!CryptAcquireContextW(&prov, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) goto done;
-    if (!CryptCreateHash(prov, CALG_SHA_256, 0, 0, &hash)) goto done;
+    if (!CryptCreateHash(prov, algid, 0, 0, &hash)) goto done;
     if (!CryptHashData(hash, info->ToBeSigned.pbData, info->ToBeSigned.cbData, 0)) goto done;
 
     sig = &info->SignatureInfo.Signature;
@@ -2136,22 +2146,19 @@ static DWORD verify_cert_revocation(const CERT_CONTEXT *cert, FILETIME *pTime,
     DWORD error = ERROR_SUCCESS;
     PCERT_EXTENSION ext;
 
-    if (find_cached_revocation_status(&cert->pCertInfo->SerialNumber, pTime, pRevStatus))
-        return pRevStatus->dwError;
-
-    if ((ext = CertFindExtension(szOID_CRL_DIST_POINTS,
-     cert->pCertInfo->cExtension, cert->pCertInfo->rgExtension)))
+    if ((ext = CertFindExtension(szOID_AUTHORITY_INFO_ACCESS, cert->pCertInfo->cExtension, cert->pCertInfo->rgExtension)))
     {
-        error = verify_cert_revocation_from_dist_points_ext(&ext->Value, cert,
-                pTime, dwFlags, pRevPara, pRevStatus);
+        error = verify_cert_revocation_from_aia_ext(&ext->Value, cert, pTime, dwFlags, pRevPara, pRevStatus);
+        TRACE("verify_cert_revocation_from_aia_ext() returned %08lx\n", error);
+        if (error == ERROR_SUCCESS || error == CRYPT_E_REVOKED) return error;
     }
-    else if ((ext = CertFindExtension(szOID_AUTHORITY_INFO_ACCESS,
-     cert->pCertInfo->cExtension, cert->pCertInfo->rgExtension)))
+    if ((ext = CertFindExtension(szOID_CRL_DIST_POINTS, cert->pCertInfo->cExtension, cert->pCertInfo->rgExtension)))
     {
-        error = verify_cert_revocation_from_aia_ext(&ext->Value, cert, pTime,
-                dwFlags, pRevPara, pRevStatus);
+        error = verify_cert_revocation_from_dist_points_ext(&ext->Value, cert, pTime, dwFlags, pRevPara, pRevStatus);
+        TRACE("verify_cert_revocation_from_dist_points_ext() returned %08lx\n", error);
+        if (error == ERROR_SUCCESS || error == CRYPT_E_REVOKED) return error;
     }
-    else
+    if (!ext)
     {
         if (pRevPara && pRevPara->hCrlStore && pRevPara->pIssuerCert)
         {
diff --git a/dlls/wintrust/softpub.c b/dlls/wintrust/softpub.c
index 53df5e7fe60..06b178a98b9 100644
--- wine/dlls/wintrust/softpub.c
+++ wine/dlls/wintrust/softpub.c
@@ -830,16 +830,93 @@ static DWORD WINTRUST_VerifySigner(CRYPT_PROVIDER_DATA *data, DWORD signerIdx)
     return err;
 }
 
+static void load_secondary_signatures(CRYPT_PROVIDER_DATA *data, HCRYPTMSG msg)
+{
+    CRYPT_PROVIDER_SIGSTATE *s = data->pSigState;
+    CRYPT_ATTRIBUTES *attrs;
+    unsigned int i, j;
+    DWORD size;
+
+    if (!CryptMsgGetParam(msg, CMSG_SIGNER_UNAUTH_ATTR_PARAM, 0, NULL, &size))
+        return;
+
+    if (!(attrs = data->psPfns->pfnAlloc(size)))
+    {
+        ERR("No memory.\n");
+        return;
+    }
+    if (!CryptMsgGetParam(msg, CMSG_SIGNER_UNAUTH_ATTR_PARAM, 0, attrs, &size))
+        goto done;
+
+    for (i = 0; i < attrs->cAttr; ++i)
+    {
+        if (strcmp(attrs->rgAttr[i].pszObjId, szOID_NESTED_SIGNATURE))
+            continue;
+
+        if (!(s->rhSecondarySigs = data->psPfns->pfnAlloc(attrs->rgAttr[i].cValue * sizeof(*s->rhSecondarySigs))))
+        {
+            ERR("No memory");
+            goto done;
+        }
+        s->cSecondarySigs = 0;
+        for (j = 0; j < attrs->rgAttr[i].cValue; ++j)
+        {
+            if (!(msg = CryptMsgOpenToDecode(X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, 0, 0, 0, NULL, NULL)))
+            {
+                ERR("Could not create crypt message.\n");
+                goto done;
+            }
+            if (!CryptMsgUpdate(msg, attrs->rgAttr[i].rgValue[j].pbData, attrs->rgAttr[i].rgValue[j].cbData, TRUE))
+            {
+                ERR("Could not update crypt message, err %lu.\n", GetLastError());
+                CryptMsgClose(msg);
+                goto done;
+            }
+            s->rhSecondarySigs[j] = msg;
+            ++s->cSecondarySigs;
+        }
+        break;
+    }
+done:
+    data->psPfns->pfnFree(attrs);
+}
+
 HRESULT WINAPI SoftpubLoadSignature(CRYPT_PROVIDER_DATA *data)
 {
-    DWORD err;
+    DWORD err = ERROR_SUCCESS;
 
     TRACE("(%p)\n", data);
 
     if (!data->padwTrustStepErrors)
         return S_FALSE;
 
-    if (data->hMsg)
+    if (data->pSigState)
+    {
+        /* We did not initialize this, probably an unsupported usage. */
+        FIXME("pSigState %p already initialized.\n", data->pSigState);
+    }
+    if (!(data->pSigState = data->psPfns->pfnAlloc(sizeof(*data->pSigState))))
+    {
+        err = ERROR_OUTOFMEMORY;
+    }
+    else
+    {
+        data->pSigState->cbStruct = sizeof(*data->pSigState);
+        data->pSigState->fSupportMultiSig = TRUE;
+        data->pSigState->dwCryptoPolicySupport = WSS_SIGTRUST_SUPPORT | WSS_OBJTRUST_SUPPORT | WSS_CERTTRUST_SUPPORT;
+        if (data->hMsg)
+        {
+            data->pSigState->hPrimarySig = CryptMsgDuplicate(data->hMsg);
+            load_secondary_signatures(data, data->pSigState->hPrimarySig);
+        }
+        if (data->pSigSettings)
+        {
+            if (data->pSigSettings->dwFlags & WSS_GET_SECONDARY_SIG_COUNT)
+                data->pSigSettings->cSecondarySigs = data->pSigState->cSecondarySigs;
+        }
+    }
+
+    if (!err && data->hMsg)
     {
         DWORD signerCount, size;
 
@@ -859,8 +936,7 @@ HRESULT WINAPI SoftpubLoadSignature(CRYPT_PROVIDER_DATA *data)
         else
             err = TRUST_E_NOSIGNATURE;
     }
-    else
-        err = ERROR_SUCCESS;
+
     if (err)
         data->padwTrustStepErrors[TRUSTERROR_STEP_FINAL_SIGPROV] = err;
     return !err ? S_OK : S_FALSE;
@@ -1375,6 +1451,13 @@ HRESULT WINAPI SoftpubCleanup(CRYPT_PROVIDER_DATA *data)
         data->psPfns->pfnFree(data->u.pPDSip->psIndirectData);
     }
 
+    if (WVT_ISINSTRUCT(CRYPT_PROVIDER_DATA, data->cbStruct, pSigState) && data->pSigState)
+    {
+        CryptMsgClose(data->pSigState->hPrimarySig);
+        for (i = 0; i < data->pSigState->cSecondarySigs; ++i)
+            CryptMsgClose(data->pSigState->rhSecondarySigs[i]);
+        data->psPfns->pfnFree(data->pSigState);
+    }
     CryptMsgClose(data->hMsg);
 
     if (data->fOpenedFile &&
diff --git a/dlls/wintrust/tests/softpub.c b/dlls/wintrust/tests/softpub.c
index 8195e6006b1..77e15b2feb4 100644
--- wine/dlls/wintrust/tests/softpub.c
+++ wine/dlls/wintrust/tests/softpub.c
@@ -1123,6 +1123,476 @@ static const BYTE SelfSignedFile64[] =
     0x9C,0x68,0x1A,0x5D,0x92,0xCD,0xD0,0x5F,0x02,0xA1,0x2C,0xD9,0x56,0x20,0x00,0x00
 };
 
+/* Self-signed 32 bit .exe, built with mingw-gcc, stripped, signed with signtool
+ * (certificates generated with a self-signed CA).
+ *
+ * small.c:
+ * int _start()
+ * {
+ *     return 0;
+ * }
+ *
+ * i686-w64-mingw32-gcc -s -nodefaultlibs -fno-PIC ./small.c -o sign_3certs.exe
+ * strip -R .idata -R .rdata -R .edata -R .eh_fram ./sign_3certs.exe
+ * signtool.exe sign /v /f cert1.pfx /fd SHA256 /t http://timestamp.digicert.com sign_3certs.exe
+ * signtool.exe sign /v /f cert2.pfx /as /fd SHA256 sign_3certs.exe
+ * signtool.exe sign /v /f cert3.pfx /as /fd SHA256 sign_3certs.exe */
+
+static const BYTE self_signed_3certs[] =
+{
+    0x4d,0x5a,0x90,0x00,0x03,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0xff,0xff,0x00,0x00,0xb8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x0e,0x1f,0xba,0x0e,0x00,0xb4,0x09,0xcd,
+    0x21,0xb8,0x01,0x4c,0xcd,0x21,0x54,0x68,0x69,0x73,0x20,0x70,0x72,0x6f,0x67,0x72,0x61,0x6d,0x20,0x63,0x61,0x6e,0x6e,0x6f,
+    0x74,0x20,0x62,0x65,0x20,0x72,0x75,0x6e,0x20,0x69,0x6e,0x20,0x44,0x4f,0x53,0x20,0x6d,0x6f,0x64,0x65,0x2e,0x0d,0x0d,0x0a,
+    0x24,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x45,0x00,0x00,0x4c,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0xe0,0x00,0x0e,0x03,0x0b,0x01,0x02,0x25,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x10,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x10,0x00,0x00,0x00,0x02,0x00,0x00,
+    0x04,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x02,0x00,0x00,
+    0x76,0x3e,0x00,0x00,0x03,0x00,0x40,0x01,0x00,0x00,0x20,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x10,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x14,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x48,0x26,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x2e,0x74,0x65,0x78,0x74,0x00,0x00,0x00,
+    0x1c,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x55,0x89,0xe5,0xb8,0x00,0x00,0x00,0x00,0x5d,0xc3,0x90,0x90,0xff,0xff,0xff,0xff,
+    0x00,0x00,0x00,0x00,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x48,0x26,0x00,0x00,0x00,0x02,0x02,0x00,
+    0x30,0x82,0x26,0x36,0x06,0x09,0x2a,0x86,0x48,0x86,0xf7,0x0d,0x01,0x07,0x02,0xa0,0x82,0x26,0x27,0x30,0x82,0x26,0x23,0x02,
+    0x01,0x01,0x31,0x0f,0x30,0x0d,0x06,0x09,0x60,0x86,0x48,0x01,0x65,0x03,0x04,0x02,0x01,0x05,0x00,0x30,0x5c,0x06,0x0a,0x2b,
+    0x06,0x01,0x04,0x01,0x82,0x37,0x02,0x01,0x04,0xa0,0x4e,0x30,0x4c,0x30,0x17,0x06,0x0a,0x2b,0x06,0x01,0x04,0x01,0x82,0x37,
+    0x02,0x01,0x0f,0x30,0x09,0x03,0x01,0x00,0xa0,0x04,0xa2,0x02,0x80,0x00,0x30,0x31,0x30,0x0d,0x06,0x09,0x60,0x86,0x48,0x01,
+    0x65,0x03,0x04,0x02,0x01,0x05,0x00,0x04,0x20,0xdd,0x8b,0xd7,0x29,0x3b,0xae,0x16,0xec,0xbb,0x81,0x80,0x55,0x15,0xd8,0x87,
+    0xa5,0x3e,0xeb,0x0b,0x74,0x59,0xb6,0x56,0xf1,0x0b,0x2e,0xe1,0xb4,0x42,0x4d,0x8b,0x18,0xa0,0x82,0x16,0x0c,0x30,0x82,0x03,
+    0x01,0x30,0x82,0x01,0xe9,0xa0,0x03,0x02,0x01,0x02,0x02,0x10,0xd1,0x73,0x97,0xaa,0xa7,0x3a,0x31,0xa2,0x44,0xc0,0x4b,0x40,
+    0x69,0x40,0x4b,0xfa,0x30,0x0d,0x06,0x09,0x2a,0x86,0x48,0x86,0xf7,0x0d,0x01,0x01,0x0b,0x05,0x00,0x30,0x12,0x31,0x10,0x30,
+    0x0e,0x06,0x03,0x55,0x04,0x03,0x13,0x07,0x54,0x65,0x73,0x74,0x20,0x43,0x41,0x30,0x1e,0x17,0x0d,0x32,0x32,0x30,0x39,0x33,
+    0x30,0x31,0x37,0x31,0x39,0x33,0x32,0x5a,0x17,0x0d,0x33,0x39,0x31,0x32,0x33,0x31,0x32,0x33,0x35,0x39,0x35,0x39,0x5a,0x30,
+    0x10,0x31,0x0e,0x30,0x0c,0x06,0x03,0x55,0x04,0x03,0x13,0x05,0x63,0x65,0x72,0x74,0x31,0x30,0x82,0x01,0x22,0x30,0x0d,0x06,
+    0x09,0x2a,0x86,0x48,0x86,0xf7,0x0d,0x01,0x01,0x01,0x05,0x00,0x03,0x82,0x01,0x0f,0x00,0x30,0x82,0x01,0x0a,0x02,0x82,0x01,
+    0x01,0x00,0xca,0x9c,0xd9,0xd4,0x25,0xb6,0x45,0x61,0x22,0x8d,0xdf,0xe9,0x11,0x0f,0xa1,0x7e,0x45,0xc5,0x0b,0xd0,0x42,0xfc,
+    0x1f,0x3e,0xce,0x20,0xfc,0x1b,0x37,0xe4,0x0d,0x06,0x83,0x1c,0x3a,0x71,0x0f,0x75,0xf5,0xe5,0x06,0x33,0x01,0x77,0xda,0xc5,
+    0xe9,0x2e,0xe3,0x37,0x1e,0x51,0x6e,0x08,0xe2,0x02,0xa1,0x8c,0x11,0xc6,0xfc,0x43,0xa2,0xf5,0x7d,0x74,0x5d,0x5a,0xcc,0x85,
+    0x27,0x38,0xd4,0xfa,0xad,0xd7,0xf9,0x77,0xe4,0xef,0xdd,0xb0,0xb1,0x3e,0xdc,0xf5,0x5d,0x7e,0x62,0xdf,0x16,0x01,0x88,0xcd,
+    0xb0,0xfa,0x06,0x24,0xd7,0xce,0xdc,0xe2,0x27,0xab,0xc3,0x0e,0x44,0x59,0x39,0x38,0xae,0x0a,0x5a,0xbd,0x5c,0xfd,0x11,0xed,
+    0x5e,0xb8,0xd3,0x09,0x9c,0x84,0x80,0x6f,0x38,0xdf,0xd2,0xed,0x12,0x33,0xc9,0x66,0x3e,0x77,0x95,0x40,0xca,0xbb,0x63,0xd8,
+    0x44,0x62,0x1d,0x60,0xc1,0x0d,0x92,0x18,0x68,0x4c,0xc7,0x26,0x83,0x5b,0x38,0x45,0xda,0x8d,0xe6,0x11,0xd0,0x08,0x79,0x0c,
+    0x13,0xb8,0xe0,0xab,0xf5,0x78,0xe2,0x45,0xfd,0x42,0x7f,0x33,0xab,0x6d,0x53,0x10,0xa3,0x02,0x3c,0xd3,0x6f,0xaf,0x50,0x2f,
+    0x20,0xfc,0x92,0xd1,0xab,0x68,0xe8,0x00,0xa0,0x1c,0x4b,0x6f,0x02,0x5a,0xf4,0x1a,0xf1,0x06,0x79,0xa1,0x34,0x8d,0x04,0x5c,
+    0x0d,0xfe,0x2d,0x3c,0x53,0xb6,0xae,0x80,0x7d,0x98,0xb9,0x02,0x60,0x15,0x2c,0xb2,0xe5,0xc7,0x9b,0xcf,0x78,0x53,0x37,0xd9,
+    0xbf,0x84,0x04,0xb0,0x61,0x1c,0xea,0x24,0x7b,0xf7,0xcd,0x71,0x45,0x1a,0x00,0x22,0x21,0xa9,0x02,0x03,0x01,0x00,0x01,0xa3,
+    0x55,0x30,0x53,0x30,0x0c,0x06,0x03,0x55,0x1d,0x13,0x01,0x01,0xff,0x04,0x02,0x30,0x00,0x30,0x43,0x06,0x03,0x55,0x1d,0x01,
+    0x04,0x3c,0x30,0x3a,0x80,0x10,0x88,0x17,0xf7,0x38,0x65,0x8b,0x78,0x78,0xf6,0x77,0xe3,0x25,0x47,0x54,0x33,0x4c,0xa1,0x14,
+    0x30,0x12,0x31,0x10,0x30,0x0e,0x06,0x03,0x55,0x04,0x03,0x13,0x07,0x54,0x65,0x73,0x74,0x20,0x43,0x41,0x82,0x10,0x2b,0x59,
+    0xb4,0xc7,0xe2,0xce,0x08,0x97,0x46,0x48,0x32,0x17,0x0f,0x97,0xc5,0x08,0x30,0x0d,0x06,0x09,0x2a,0x86,0x48,0x86,0xf7,0x0d,
+    0x01,0x01,0x0b,0x05,0x00,0x03,0x82,0x01,0x01,0x00,0x9d,0x05,0x0e,0xc5,0xa0,0x5e,0x47,0x18,0x31,0x60,0xf2,0x1b,0x37,0xa4,
+    0x89,0xf7,0x05,0x3e,0xea,0xc2,0x00,0x9f,0xcb,0xdd,0x28,0xba,0xc9,0x1f,0xfa,0x7a,0x9b,0x24,0x3d,0xb6,0x47,0x80,0xc1,0xa6,
+    0x67,0x4d,0x48,0x3d,0xe0,0x0b,0x32,0x6a,0xa7,0x93,0xf3,0x40,0x20,0x8a,0xff,0x0f,0x9a,0xe2,0x00,0x95,0xa3,0xb3,0x57,0xc7,
+    0x11,0xe1,0x28,0xc5,0x63,0x01,0xdf,0x4a,0xd2,0x37,0xb2,0x53,0x09,0x5c,0x4e,0x50,0x4e,0x14,0xb8,0x3e,0xb4,0x52,0xfe,0xa5,
+    0x5d,0x14,0x3f,0x07,0x4f,0xda,0x9a,0xb9,0xbe,0x40,0xc5,0x3b,0x90,0x54,0x03,0x2e,0x79,0x0e,0x9b,0xf7,0xa9,0x74,0xeb,0x7c,
+    0x6b,0x71,0x12,0xf2,0xce,0x9f,0xc0,0x3e,0x8a,0x09,0xa4,0x91,0x91,0x93,0x64,0x11,0xcc,0x96,0x7b,0xf9,0xac,0x65,0x6b,0xc3,
+    0x02,0x1d,0xf8,0x0c,0x82,0x72,0x04,0x19,0x05,0x06,0x33,0x44,0x48,0x4f,0x34,0x13,0x04,0x1e,0x6c,0x11,0xc0,0x7b,0x63,0x32,
+    0x1e,0xb3,0x4f,0x79,0xfe,0x9d,0xe6,0x3a,0xbe,0x8e,0xa7,0x5f,0x67,0x1d,0xae,0xad,0x58,0x0e,0x53,0xb8,0x15,0xe3,0x85,0x6e,
+    0x91,0xfe,0x2d,0x81,0x84,0xb9,0xc3,0x23,0x13,0xa0,0x3f,0x72,0xb7,0xb3,0x26,0xda,0x08,0xcf,0x10,0x65,0x1e,0xd5,0x3b,0xf4,
+    0x8f,0x18,0xe0,0xab,0xe7,0x5e,0xfc,0x62,0x9e,0x7e,0x54,0xf9,0x35,0x5a,0xf8,0xfa,0x1f,0x10,0x6f,0x63,0x3d,0xa2,0xe9,0x8a,
+    0xd6,0x49,0xc0,0x40,0x0b,0xa1,0x5e,0x83,0xb0,0x01,0xb6,0x03,0x66,0xa5,0x8a,0xb4,0x29,0x06,0xea,0x27,0x0c,0x28,0x88,0xf3,
+    0x38,0x5e,0x30,0x82,0x05,0x8d,0x30,0x82,0x04,0x75,0xa0,0x03,0x02,0x01,0x02,0x02,0x10,0x0e,0x9b,0x18,0x8e,0xf9,0xd0,0x2d,
+    0xe7,0xef,0xdb,0x50,0xe2,0x08,0x40,0x18,0x5a,0x30,0x0d,0x06,0x09,0x2a,0x86,0x48,0x86,0xf7,0x0d,0x01,0x01,0x0c,0x05,0x00,
+    0x30,0x65,0x31,0x0b,0x30,0x09,0x06,0x03,0x55,0x04,0x06,0x13,0x02,0x55,0x53,0x31,0x15,0x30,0x13,0x06,0x03,0x55,0x04,0x0a,
+    0x13,0x0c,0x44,0x69,0x67,0x69,0x43,0x65,0x72,0x74,0x20,0x49,0x6e,0x63,0x31,0x19,0x30,0x17,0x06,0x03,0x55,0x04,0x0b,0x13,
+    0x10,0x77,0x77,0x77,0x2e,0x64,0x69,0x67,0x69,0x63,0x65,0x72,0x74,0x2e,0x63,0x6f,0x6d,0x31,0x24,0x30,0x22,0x06,0x03,0x55,
+    0x04,0x03,0x13,0x1b,0x44,0x69,0x67,0x69,0x43,0x65,0x72,0x74,0x20,0x41,0x73,0x73,0x75,0x72,0x65,0x64,0x20,0x49,0x44,0x20,
+    0x52,0x6f,0x6f,0x74,0x20,0x43,0x41,0x30,0x1e,0x17,0x0d,0x32,0x32,0x30,0x38,0x30,0x31,0x30,0x30,0x30,0x30,0x30,0x30,0x5a,
+    0x17,0x0d,0x33,0x31,0x31,0x31,0x30,0x39,0x32,0x33,0x35,0x39,0x35,0x39,0x5a,0x30,0x62,0x31,0x0b,0x30,0x09,0x06,0x03,0x55,
+    0x04,0x06,0x13,0x02,0x55,0x53,0x31,0x15,0x30,0x13,0x06,0x03,0x55,0x04,0x0a,0x13,0x0c,0x44,0x69,0x67,0x69,0x43,0x65,0x72,
+    0x74,0x20,0x49,0x6e,0x63,0x31,0x19,0x30,0x17,0x06,0x03,0x55,0x04,0x0b,0x13,0x10,0x77,0x77,0x77,0x2e,0x64,0x69,0x67,0x69,
+    0x63,0x65,0x72,0x74,0x2e,0x63,0x6f,0x6d,0x31,0x21,0x30,0x1f,0x06,0x03,0x55,0x04,0x03,0x13,0x18,0x44,0x69,0x67,0x69,0x43,
+    0x65,0x72,0x74,0x20,0x54,0x72,0x75,0x73,0x74,0x65,0x64,0x20,0x52,0x6f,0x6f,0x74,0x20,0x47,0x34,0x30,0x82,0x02,0x22,0x30,
+    0x0d,0x06,0x09,0x2a,0x86,0x48,0x86,0xf7,0x0d,0x01,0x01,0x01,0x05,0x00,0x03,0x82,0x02,0x0f,0x00,0x30,0x82,0x02,0x0a,0x02,
+    0x82,0x02,0x01,0x00,0xbf,0xe6,0x90,0x73,0x68,0xde,0xbb,0xe4,0x5d,0x4a,0x3c,0x30,0x22,0x30,0x69,0x33,0xec,0xc2,0xa7,0x25,
+    0x2e,0xc9,0x21,0x3d,0xf2,0x8a,0xd8,0x59,0xc2,0xe1,0x29,0xa7,0x3d,0x58,0xab,0x76,0x9a,0xcd,0xae,0x7b,0x1b,0x84,0x0d,0xc4,
+    0x30,0x1f,0xf3,0x1b,0xa4,0x38,0x16,0xeb,0x56,0xc6,0x97,0x6d,0x1d,0xab,0xb2,0x79,0xf2,0xca,0x11,0xd2,0xe4,0x5f,0xd6,0x05,
+    0x3c,0x52,0x0f,0x52,0x1f,0xc6,0x9e,0x15,0xa5,0x7e,0xbe,0x9f,0xa9,0x57,0x16,0x59,0x55,0x72,0xaf,0x68,0x93,0x70,0xc2,0xb2,
+    0xba,0x75,0x99,0x6a,0x73,0x32,0x94,0xd1,0x10,0x44,0x10,0x2e,0xdf,0x82,0xf3,0x07,0x84,0xe6,0x74,0x3b,0x6d,0x71,0xe2,0x2d,
+    0x0c,0x1b,0xee,0x20,0xd5,0xc9,0x20,0x1d,0x63,0x29,0x2d,0xce,0xec,0x5e,0x4e,0xc8,0x93,0xf8,0x21,0x61,0x9b,0x34,0xeb,0x05,
+    0xc6,0x5e,0xec,0x5b,0x1a,0xbc,0xeb,0xc9,0xcf,0xcd,0xac,0x34,0x40,0x5f,0xb1,0x7a,0x66,0xee,0x77,0xc8,0x48,0xa8,0x66,0x57,
+    0x57,0x9f,0x54,0x58,0x8e,0x0c,0x2b,0xb7,0x4f,0xa7,0x30,0xd9,0x56,0xee,0xca,0x7b,0x5d,0xe3,0xad,0xc9,0x4f,0x5e,0xe5,0x35,
+    0xe7,0x31,0xcb,0xda,0x93,0x5e,0xdc,0x8e,0x8f,0x80,0xda,0xb6,0x91,0x98,0x40,0x90,0x79,0xc3,0x78,0xc7,0xb6,0xb1,0xc4,0xb5,
+    0x6a,0x18,0x38,0x03,0x10,0x8d,0xd8,0xd4,0x37,0xa4,0x2e,0x05,0x7d,0x88,0xf5,0x82,0x3e,0x10,0x91,0x70,0xab,0x55,0x82,0x41,
+    0x32,0xd7,0xdb,0x04,0x73,0x2a,0x6e,0x91,0x01,0x7c,0x21,0x4c,0xd4,0xbc,0xae,0x1b,0x03,0x75,0x5d,0x78,0x66,0xd9,0x3a,0x31,
+    0x44,0x9a,0x33,0x40,0xbf,0x08,0xd7,0x5a,0x49,0xa4,0xc2,0xe6,0xa9,0xa0,0x67,0xdd,0xa4,0x27,0xbc,0xa1,0x4f,0x39,0xb5,0x11,
+    0x58,0x17,0xf7,0x24,0x5c,0x46,0x8f,0x64,0xf7,0xc1,0x69,0x88,0x76,0x98,0x76,0x3d,0x59,0x5d,0x42,0x76,0x87,0x89,0x97,0x69,
+    0x7a,0x48,0xf0,0xe0,0xa2,0x12,0x1b,0x66,0x9a,0x74,0xca,0xde,0x4b,0x1e,0xe7,0x0e,0x63,0xae,0xe6,0xd4,0xef,0x92,0x92,0x3a,
+    0x9e,0x3d,0xdc,0x00,0xe4,0x45,0x25,0x89,0xb6,0x9a,0x44,0x19,0x2b,0x7e,0xc0,0x94,0xb4,0xd2,0x61,0x6d,0xeb,0x33,0xd9,0xc5,
+    0xdf,0x4b,0x04,0x00,0xcc,0x7d,0x1c,0x95,0xc3,0x8f,0xf7,0x21,0xb2,0xb2,0x11,0xb7,0xbb,0x7f,0xf2,0xd5,0x8c,0x70,0x2c,0x41,
+    0x60,0xaa,0xb1,0x63,0x18,0x44,0x95,0x1a,0x76,0x62,0x7e,0xf6,0x80,0xb0,0xfb,0xe8,0x64,0xa6,0x33,0xd1,0x89,0x07,0xe1,0xbd,
+    0xb7,0xe6,0x43,0xa4,0x18,0xb8,0xa6,0x77,0x01,0xe1,0x0f,0x94,0x0c,0x21,0x1d,0xb2,0x54,0x29,0x25,0x89,0x6c,0xe5,0x0e,0x52,
+    0x51,0x47,0x74,0xbe,0x26,0xac,0xb6,0x41,0x75,0xde,0x7a,0xac,0x5f,0x8d,0x3f,0xc9,0xbc,0xd3,0x41,0x11,0x12,0x5b,0xe5,0x10,
+    0x50,0xeb,0x31,0xc5,0xca,0x72,0x16,0x22,0x09,0xdf,0x7c,0x4c,0x75,0x3f,0x63,0xec,0x21,0x5f,0xc4,0x20,0x51,0x6b,0x6f,0xb1,
+    0xab,0x86,0x8b,0x4f,0xc2,0xd6,0x45,0x5f,0x9d,0x20,0xfc,0xa1,0x1e,0xc5,0xc0,0x8f,0xa2,0xb1,0x7e,0x0a,0x26,0x99,0xf5,0xe4,
+    0x69,0x2f,0x98,0x1d,0x2d,0xf5,0xd9,0xa9,0xb2,0x1d,0xe5,0x1b,0x02,0x03,0x01,0x00,0x01,0xa3,0x82,0x01,0x3a,0x30,0x82,0x01,
+    0x36,0x30,0x0f,0x06,0x03,0x55,0x1d,0x13,0x01,0x01,0xff,0x04,0x05,0x30,0x03,0x01,0x01,0xff,0x30,0x1d,0x06,0x03,0x55,0x1d,
+    0x0e,0x04,0x16,0x04,0x14,0xec,0xd7,0xe3,0x82,0xd2,0x71,0x5d,0x64,0x4c,0xdf,0x2e,0x67,0x3f,0xe7,0xba,0x98,0xae,0x1c,0x0f,
+    0x4f,0x30,0x1f,0x06,0x03,0x55,0x1d,0x23,0x04,0x18,0x30,0x16,0x80,0x14,0x45,0xeb,0xa2,0xaf,0xf4,0x92,0xcb,0x82,0x31,0x2d,
+    0x51,0x8b,0xa7,0xa7,0x21,0x9d,0xf3,0x6d,0xc8,0x0f,0x30,0x0e,0x06,0x03,0x55,0x1d,0x0f,0x01,0x01,0xff,0x04,0x04,0x03,0x02,
+    0x01,0x86,0x30,0x79,0x06,0x08,0x2b,0x06,0x01,0x05,0x05,0x07,0x01,0x01,0x04,0x6d,0x30,0x6b,0x30,0x24,0x06,0x08,0x2b,0x06,
+    0x01,0x05,0x05,0x07,0x30,0x01,0x86,0x18,0x68,0x74,0x74,0x70,0x3a,0x2f,0x2f,0x6f,0x63,0x73,0x70,0x2e,0x64,0x69,0x67,0x69,
+    0x63,0x65,0x72,0x74,0x2e,0x63,0x6f,0x6d,0x30,0x43,0x06,0x08,0x2b,0x06,0x01,0x05,0x05,0x07,0x30,0x02,0x86,0x37,0x68,0x74,
+    0x74,0x70,0x3a,0x2f,0x2f,0x63,0x61,0x63,0x65,0x72,0x74,0x73,0x2e,0x64,0x69,0x67,0x69,0x63,0x65,0x72,0x74,0x2e,0x63,0x6f,
+    0x6d,0x2f,0x44,0x69,0x67,0x69,0x43,0x65,0x72,0x74,0x41,0x73,0x73,0x75,0x72,0x65,0x64,0x49,0x44,0x52,0x6f,0x6f,0x74,0x43,
+    0x41,0x2e,0x63,0x72,0x74,0x30,0x45,0x06,0x03,0x55,0x1d,0x1f,0x04,0x3e,0x30,0x3c,0x30,0x3a,0xa0,0x38,0xa0,0x36,0x86,0x34,
+    0x68,0x74,0x74,0x70,0x3a,0x2f,0x2f,0x63,0x72,0x6c,0x33,0x2e,0x64,0x69,0x67,0x69,0x63,0x65,0x72,0x74,0x2e,0x63,0x6f,0x6d,
+    0x2f,0x44,0x69,0x67,0x69,0x43,0x65,0x72,0x74,0x41,0x73,0x73,0x75,0x72,0x65,0x64,0x49,0x44,0x52,0x6f,0x6f,0x74,0x43,0x41,
+    0x2e,0x63,0x72,0x6c,0x30,0x11,0x06,0x03,0x55,0x1d,0x20,0x04,0x0a,0x30,0x08,0x30,0x06,0x06,0x04,0x55,0x1d,0x20,0x00,0x30,
+    0x0d,0x06,0x09,0x2a,0x86,0x48,0x86,0xf7,0x0d,0x01,0x01,0x0c,0x05,0x00,0x03,0x82,0x01,0x01,0x00,0x70,0xa0,0xbf,0x43,0x5c,
+    0x55,0xe7,0x38,0x5f,0xa0,0xa3,0x74,0x1b,0x3d,0xb6,0x16,0xd7,0xf7,0xbf,0x57,0x07,0xbd,0x9a,0xac,0xa1,0x87,0x2c,0xec,0x85,
+    0x5e,0xa9,0x1a,0xbb,0x22,0xf8,0x87,0x1a,0x69,0x54,0x22,0xed,0xa4,0x88,0x77,0x6d,0xbd,0x1a,0x14,0xf4,0x13,0x4a,0x7a,0x2f,
+    0x2d,0xb7,0x38,0xef,0xf4,0xff,0x80,0xb9,0xf8,0xa1,0xf7,0xf2,0x72,0xde,0x24,0xbc,0x52,0x03,0xc8,0x4e,0xd0,0x2a,0xde,0xfa,
+    0x2d,0x56,0xcf,0xf9,0xf4,0xf7,0xac,0x30,0x7a,0x9a,0x8b,0xb2,0x5e,0xd4,0xcf,0xd1,0x43,0x44,0x9b,0x43,0x21,0xeb,0x96,0x72,
+    0xa1,0x48,0xb4,0x99,0xcb,0x9d,0x4f,0xa7,0x06,0x03,0x13,0x77,0x27,0x44,0xd4,0xe7,0x7f,0xe8,0x59,0xa8,0xf0,0xbf,0x2f,0x0b,
+    0xa6,0xe9,0xf2,0x34,0x3c,0xec,0xf7,0x03,0xc7,0x87,0xa8,0xd2,0x4c,0x40,0x19,0x35,0x46,0x6a,0x69,0x54,0xb0,0xb8,0xa1,0x56,
+    0x8e,0xec,0xa4,0xd5,0x3d,0xe8,0xb1,0xdc,0xfd,0x1c,0xd8,0xf4,0x77,0x5a,0x5c,0x54,0x8c,0x6f,0xef,0xa1,0x50,0x3d,0xfc,0x76,
+    0x09,0x68,0x84,0x9f,0x6f,0xca,0xdb,0x20,0x8d,0x35,0x60,0x1c,0x02,0x03,0xcb,0x20,0xb0,0xac,0x58,0xa0,0x0e,0x40,0x63,0xc5,
+    0x98,0x22,0xc1,0xb2,0x59,0xf5,0x55,0x6b,0xcf,0x27,0xab,0x6c,0x76,0xce,0x6f,0x23,0x2d,0xf4,0x7e,0x71,0x6a,0x23,0x6b,0x22,
+    0xff,0x12,0xb8,0x54,0x2d,0x27,0x7e,0xd8,0x3a,0xd9,0xf0,0xb6,0x87,0x96,0xfd,0x5b,0xd1,0x5c,0xac,0x18,0xc3,0x4d,0x9f,0x73,
+    0xb7,0x01,0xa9,0x9f,0x57,0xaa,0x5e,0x28,0xe2,0xb9,0x94,0x30,0x82,0x06,0xae,0x30,0x82,0x04,0x96,0xa0,0x03,0x02,0x01,0x02,
+    0x02,0x10,0x07,0x36,0x37,0xb7,0x24,0x54,0x7c,0xd8,0x47,0xac,0xfd,0x28,0x66,0x2a,0x5e,0x5b,0x30,0x0d,0x06,0x09,0x2a,0x86,
+    0x48,0x86,0xf7,0x0d,0x01,0x01,0x0b,0x05,0x00,0x30,0x62,0x31,0x0b,0x30,0x09,0x06,0x03,0x55,0x04,0x06,0x13,0x02,0x55,0x53,
+    0x31,0x15,0x30,0x13,0x06,0x03,0x55,0x04,0x0a,0x13,0x0c,0x44,0x69,0x67,0x69,0x43,0x65,0x72,0x74,0x20,0x49,0x6e,0x63,0x31,
+    0x19,0x30,0x17,0x06,0x03,0x55,0x04,0x0b,0x13,0x10,0x77,0x77,0x77,0x2e,0x64,0x69,0x67,0x69,0x63,0x65,0x72,0x74,0x2e,0x63,
+    0x6f,0x6d,0x31,0x21,0x30,0x1f,0x06,0x03,0x55,0x04,0x03,0x13,0x18,0x44,0x69,0x67,0x69,0x43,0x65,0x72,0x74,0x20,0x54,0x72,
+    0x75,0x73,0x74,0x65,0x64,0x20,0x52,0x6f,0x6f,0x74,0x20,0x47,0x34,0x30,0x1e,0x17,0x0d,0x32,0x32,0x30,0x33,0x32,0x33,0x30,
+    0x30,0x30,0x30,0x30,0x30,0x5a,0x17,0x0d,0x33,0x37,0x30,0x33,0x32,0x32,0x32,0x33,0x35,0x39,0x35,0x39,0x5a,0x30,0x63,0x31,
+    0x0b,0x30,0x09,0x06,0x03,0x55,0x04,0x06,0x13,0x02,0x55,0x53,0x31,0x17,0x30,0x15,0x06,0x03,0x55,0x04,0x0a,0x13,0x0e,0x44,
+    0x69,0x67,0x69,0x43,0x65,0x72,0x74,0x2c,0x20,0x49,0x6e,0x63,0x2e,0x31,0x3b,0x30,0x39,0x06,0x03,0x55,0x04,0x03,0x13,0x32,
+    0x44,0x69,0x67,0x69,0x43,0x65,0x72,0x74,0x20,0x54,0x72,0x75,0x73,0x74,0x65,0x64,0x20,0x47,0x34,0x20,0x52,0x53,0x41,0x34,
+    0x30,0x39,0x36,0x20,0x53,0x48,0x41,0x32,0x35,0x36,0x20,0x54,0x69,0x6d,0x65,0x53,0x74,0x61,0x6d,0x70,0x69,0x6e,0x67,0x20,
+    0x43,0x41,0x30,0x82,0x02,0x22,0x30,0x0d,0x06,0x09,0x2a,0x86,0x48,0x86,0xf7,0x0d,0x01,0x01,0x01,0x05,0x00,0x03,0x82,0x02,
+    0x0f,0x00,0x30,0x82,0x02,0x0a,0x02,0x82,0x02,0x01,0x00,0xc6,0x86,0x35,0x06,0x49,0xb3,0xc1,0x3d,0x72,0x49,0x51,0x55,0xc7,
+    0x25,0x03,0xc4,0xf2,0x91,0x37,0xa9,0x97,0x51,0xa1,0xd6,0xd2,0x83,0xd1,0x9e,0x4c,0xa2,0x6d,0xa0,0xb0,0xcc,0x83,0xf9,0x5a,
+    0xf6,0x11,0xa1,0x44,0x15,0x42,0x5f,0xa4,0x88,0xf3,0x68,0xfa,0x7d,0xf3,0x9c,0x89,0x0b,0x7f,0x9d,0x1f,0x9e,0x0f,0x33,0x1f,
+    0x50,0x13,0x0b,0x26,0x73,0x96,0x6d,0xf8,0x57,0xa8,0x02,0x7d,0xfd,0x43,0xb4,0x84,0xda,0x11,0xf1,0x73,0xb1,0xb3,0xee,0x2b,
+    0x80,0x84,0x8a,0x22,0x18,0xdf,0xeb,0xda,0x3d,0xc4,0x17,0x7f,0xab,0x19,0x2b,0x3e,0x42,0xdc,0x67,0x8e,0xea,0x51,0x3d,0xf0,
+    0xd6,0x56,0xd4,0xe7,0x28,0x2d,0xeb,0xd3,0xb1,0xb5,0x75,0xe7,0x1f,0x06,0x65,0x8d,0x94,0x29,0xd3,0xd9,0xec,0x69,0xdf,0xd9,
+    0x90,0x87,0x46,0x00,0x7b,0xdb,0x44,0x41,0x89,0xdc,0x7c,0x6a,0x57,0x7a,0xf0,0x37,0x79,0x9f,0x5d,0xac,0xcb,0xe8,0x84,0x64,
+    0xb4,0x52,0xf2,0x76,0x47,0xf7,0x61,0x83,0x19,0xdd,0x5f,0xb4,0x54,0x0b,0x21,0x68,0x6e,0x37,0x21,0xbb,0x40,0xac,0x5f,0xb2,
+    0xde,0x4a,0x7d,0xce,0xf5,0x39,0x12,0x67,0xef,0x0e,0xa5,0x63,0x6c,0xe4,0xa6,0xc5,0x1d,0xcd,0x36,0x0d,0x5c,0xd5,0xe6,0x1b,
+    0xa8,0xc1,0x64,0x74,0x40,0xa7,0xc0,0x72,0xc5,0xba,0x4e,0x1f,0xb1,0xb5,0x58,0x4d,0x79,0xfe,0xd7,0x8f,0x73,0x93,0xac,0x2c,
+    0x39,0xe2,0xa5,0x48,0xd6,0xf0,0xb0,0x31,0x13,0xa9,0x57,0x29,0x96,0x27,0x2e,0xf5,0x87,0xa6,0x8f,0x4e,0x76,0x15,0x55,0x26,
+    0x70,0x98,0x26,0x7f,0xa0,0x1a,0x47,0x20,0x43,0xe3,0x43,0x63,0x80,0x7b,0x75,0x6e,0x27,0x25,0x90,0x98,0x3a,0x38,0x11,0xb3,
+    0xf6,0xf6,0x9e,0xe6,0x3b,0x5b,0xec,0x81,0xde,0x22,0x14,0xd9,0x82,0x2a,0xc7,0x92,0xbf,0xa0,0xde,0xe3,0x3e,0xa2,0x73,0xfa,
+    0xe7,0x1f,0x5a,0x6c,0x94,0xf2,0x52,0x95,0x11,0x2b,0x58,0x74,0x40,0x28,0xab,0x73,0x43,0xce,0xdf,0x4a,0xa1,0x1c,0x6b,0x38,
+    0xc5,0x29,0xf3,0xca,0xaa,0x96,0x73,0x42,0x68,0x9f,0xb6,0x46,0xb3,0x9d,0x3a,0xa3,0xd5,0x03,0xe0,0xbf,0xf0,0xa2,0x3c,0xca,
+    0x42,0xdc,0x18,0x48,0x7f,0x14,0x34,0xcf,0xd2,0x4c,0xab,0xef,0x9b,0x3d,0xfe,0x0e,0xb8,0x64,0x2a,0xfa,0x75,0x28,0x24,0x41,
+    0xed,0x42,0xbf,0x05,0x9c,0x66,0x49,0x52,0x50,0xf4,0x51,0xf3,0x36,0x49,0x4d,0x8b,0x20,0xd2,0x2c,0x57,0x35,0x79,0x2b,0xa8,
+    0xf3,0x45,0x60,0xbc,0x23,0x8d,0x58,0xf7,0xdc,0x61,0xde,0x93,0xfe,0x39,0xc0,0xf9,0xb2,0x30,0xa5,0x4c,0xd7,0xe9,0x98,0x4a,
+    0x58,0x3e,0xd3,0x03,0x88,0xfe,0xb3,0x8f,0xd3,0x5e,0x4b,0x76,0x12,0x51,0x93,0xc9,0x8c,0x0c,0x3b,0x5b,0x8a,0x22,0xa8,0xc1,
+    0x26,0x08,0xf9,0x14,0x10,0x12,0x03,0x7d,0x5f,0x23,0xbb,0x64,0xe3,0x63,0xe0,0xa6,0xe1,0x3e,0xf6,0xc2,0x74,0xb2,0x3f,0x1e,
+    0x09,0x76,0xec,0xab,0x5d,0x46,0x75,0xe2,0x60,0xa3,0x58,0x09,0x01,0x28,0x00,0x0e,0x84,0x54,0xee,0xce,0xe9,0x5d,0xc8,0x5e,
+    0x30,0x12,0xbd,0x46,0x9e,0xb5,0xd3,0x76,0xb9,0xd2,0x0e,0x6b,0x99,0x0c,0xd2,0x33,0xb4,0xcd,0xb1,0x02,0x03,0x01,0x00,0x01,
+    0xa3,0x82,0x01,0x5d,0x30,0x82,0x01,0x59,0x30,0x12,0x06,0x03,0x55,0x1d,0x13,0x01,0x01,0xff,0x04,0x08,0x30,0x06,0x01,0x01,
+    0xff,0x02,0x01,0x00,0x30,0x1d,0x06,0x03,0x55,0x1d,0x0e,0x04,0x16,0x04,0x14,0xba,0x16,0xd9,0x6d,0x4d,0x85,0x2f,0x73,0x29,
+    0x76,0x9a,0x2f,0x75,0x8c,0x6a,0x20,0x8f,0x9e,0xc8,0x6f,0x30,0x1f,0x06,0x03,0x55,0x1d,0x23,0x04,0x18,0x30,0x16,0x80,0x14,
+    0xec,0xd7,0xe3,0x82,0xd2,0x71,0x5d,0x64,0x4c,0xdf,0x2e,0x67,0x3f,0xe7,0xba,0x98,0xae,0x1c,0x0f,0x4f,0x30,0x0e,0x06,0x03,
+    0x55,0x1d,0x0f,0x01,0x01,0xff,0x04,0x04,0x03,0x02,0x01,0x86,0x30,0x13,0x06,0x03,0x55,0x1d,0x25,0x04,0x0c,0x30,0x0a,0x06,
+    0x08,0x2b,0x06,0x01,0x05,0x05,0x07,0x03,0x08,0x30,0x77,0x06,0x08,0x2b,0x06,0x01,0x05,0x05,0x07,0x01,0x01,0x04,0x6b,0x30,
+    0x69,0x30,0x24,0x06,0x08,0x2b,0x06,0x01,0x05,0x05,0x07,0x30,0x01,0x86,0x18,0x68,0x74,0x74,0x70,0x3a,0x2f,0x2f,0x6f,0x63,
+    0x73,0x70,0x2e,0x64,0x69,0x67,0x69,0x63,0x65,0x72,0x74,0x2e,0x63,0x6f,0x6d,0x30,0x41,0x06,0x08,0x2b,0x06,0x01,0x05,0x05,
+    0x07,0x30,0x02,0x86,0x35,0x68,0x74,0x74,0x70,0x3a,0x2f,0x2f,0x63,0x61,0x63,0x65,0x72,0x74,0x73,0x2e,0x64,0x69,0x67,0x69,
+    0x63,0x65,0x72,0x74,0x2e,0x63,0x6f,0x6d,0x2f,0x44,0x69,0x67,0x69,0x43,0x65,0x72,0x74,0x54,0x72,0x75,0x73,0x74,0x65,0x64,
+    0x52,0x6f,0x6f,0x74,0x47,0x34,0x2e,0x63,0x72,0x74,0x30,0x43,0x06,0x03,0x55,0x1d,0x1f,0x04,0x3c,0x30,0x3a,0x30,0x38,0xa0,
+    0x36,0xa0,0x34,0x86,0x32,0x68,0x74,0x74,0x70,0x3a,0x2f,0x2f,0x63,0x72,0x6c,0x33,0x2e,0x64,0x69,0x67,0x69,0x63,0x65,0x72,
+    0x74,0x2e,0x63,0x6f,0x6d,0x2f,0x44,0x69,0x67,0x69,0x43,0x65,0x72,0x74,0x54,0x72,0x75,0x73,0x74,0x65,0x64,0x52,0x6f,0x6f,
+    0x74,0x47,0x34,0x2e,0x63,0x72,0x6c,0x30,0x20,0x06,0x03,0x55,0x1d,0x20,0x04,0x19,0x30,0x17,0x30,0x08,0x06,0x06,0x67,0x81,
+    0x0c,0x01,0x04,0x02,0x30,0x0b,0x06,0x09,0x60,0x86,0x48,0x01,0x86,0xfd,0x6c,0x07,0x01,0x30,0x0d,0x06,0x09,0x2a,0x86,0x48,
+    0x86,0xf7,0x0d,0x01,0x01,0x0b,0x05,0x00,0x03,0x82,0x02,0x01,0x00,0x7d,0x59,0x8e,0xc0,0x93,0xb6,0x6f,0x98,0xa9,0x44,0x22,
+    0x01,0x7e,0x66,0xd6,0xd8,0x21,0x42,0xe1,0xb0,0x18,0x2e,0x10,0x4d,0x13,0xcf,0x30,0x53,0xce,0xbf,0x18,0xfb,0xc7,0x50,0x5d,
+    0xe2,0x4b,0x29,0xfb,0x70,0x8a,0x0d,0xaa,0x29,0x69,0xfc,0x69,0xc1,0xcf,0x1d,0x07,0xe9,0x3e,0x60,0xc8,0xd8,0x0b,0xe5,0x5c,
+    0x5b,0xd7,0x6d,0x87,0xfa,0x84,0x20,0x25,0x34,0x31,0x67,0xcd,0xb6,0x12,0x96,0x6f,0xc4,0x50,0x4c,0x62,0x1d,0x0c,0x08,0x82,
+    0xa8,0x16,0xbd,0xa9,0x56,0xcf,0x15,0x73,0x8d,0x01,0x22,0x25,0xce,0x95,0x69,0x3f,0x47,0x77,0xfb,0x72,0x74,0x14,0xd7,0xff,
+    0xab,0x4f,0x8a,0x2c,0x7a,0xab,0x85,0xcd,0x43,0x5f,0xed,0x60,0xb6,0xaa,0x4f,0x91,0x66,0x9e,0x2c,0x9e,0xe0,0x8a,0xac,0xe5,
+    0xfd,0x8c,0xbc,0x64,0x26,0x87,0x6c,0x92,0xbd,0x9d,0x7c,0xd0,0x70,0x0a,0x7c,0xef,0xa8,0xbc,0x75,0x4f,0xba,0x5a,0xf7,0xa9,
+    0x10,0xb2,0x5d,0xe9,0xff,0x28,0x54,0x89,0xf0,0xd5,0x8a,0x71,0x76,0x65,0xda,0xcc,0xf0,0x72,0xa3,0x23,0xfa,0xc0,0x27,0x82,
+    0x44,0xae,0x99,0x27,0x1b,0xab,0x24,0x1e,0x26,0xc1,0xb7,0xde,0x2a,0xeb,0xf6,0x9e,0xb1,0x79,0x99,0x81,0xa3,0x56,0x86,0xab,
+    0x0a,0x45,0xc9,0xdf,0xc4,0x8d,0xa0,0xe7,0x98,0xfb,0xfb,0xa6,0x9d,0x72,0xaf,0xc4,0xc7,0xc1,0xc1,0x6a,0x71,0xd9,0xc6,0x13,
+    0x80,0x09,0xc4,0xb6,0x9f,0xcd,0x87,0x87,0x24,0xbb,0x4f,0xa3,0x49,0xb9,0x77,0x66,0x91,0xf1,0x72,0x9c,0xe9,0x4b,0x02,0x52,
+    0xa7,0x37,0x7e,0x93,0x53,0xac,0x3b,0x1d,0x08,0x49,0x0f,0x94,0xcd,0x39,0x7a,0xdd,0xff,0x25,0x63,0x99,0x27,0x2c,0x3d,0x3f,
+    0x6b,0xa7,0xf1,0x66,0xc3,0x41,0xcd,0x4f,0xb6,0x40,0x9b,0x21,0x21,0x40,0xd0,0xb7,0x13,0x24,0xcd,0xdc,0x1d,0x78,0x3a,0xe4,
+    0x9e,0xad,0xe5,0x34,0x71,0x92,0xd7,0x26,0x6b,0xe4,0x38,0x73,0xab,0xa6,0x01,0x4f,0xbd,0x3f,0x3b,0x78,0xad,0x4c,0xad,0xfb,
+    0xc4,0x95,0x7b,0xed,0x0a,0x5f,0x33,0x39,0x87,0x41,0x78,0x7a,0x38,0xe9,0x9c,0xe1,0xdd,0x23,0xfd,0x1d,0x28,0xd3,0xc7,0xf9,
+    0xe8,0xf1,0x98,0x5f,0xfb,0x2b,0xd8,0x7e,0xf2,0x46,0x9d,0x75,0x2c,0x1e,0x27,0x2c,0x26,0xdb,0x6f,0x15,0x7b,0x1e,0x19,0x8b,
+    0x36,0xb8,0x93,0xd4,0xe6,0xf2,0x17,0x99,0x59,0xca,0x70,0xf0,0x37,0xbf,0x98,0x00,0xdf,0x20,0x16,0x4f,0x27,0xfb,0x60,0x67,
+    0x16,0xa1,0x66,0xba,0xdd,0x55,0xc0,0x3a,0x29,0x86,0xb0,0x98,0xa0,0x2b,0xed,0x95,0x41,0xb7,0x3a,0xd5,0x15,0x98,0x31,0xb4,
+    0x62,0x09,0x0f,0x0a,0xbd,0x81,0xd9,0x13,0xfe,0xbf,0xa4,0xd1,0xf3,0x57,0xd9,0xbc,0x04,0xfa,0x82,0xde,0x32,0xdf,0x04,0x89,
+    0xf0,0x00,0xcd,0x5d,0xc2,0xf9,0xd0,0x23,0x7f,0x00,0x0b,0xe4,0x76,0x02,0x26,0xd9,0xf0,0x65,0x76,0x42,0xa6,0x29,0x87,0x09,
+    0x47,0x2b,0xe6,0x7f,0x1a,0xa4,0x85,0x0f,0xfc,0x98,0x96,0xf6,0x55,0x54,0x2b,0x1f,0x80,0xfa,0xc0,0xf2,0x0e,0x2b,0xe5,0xd6,
+    0xfb,0xa9,0x2f,0x44,0x15,0x4a,0xe7,0x13,0x0e,0x1d,0xdb,0x37,0x38,0x1a,0xa1,0x2b,0xf6,0xed,0xd6,0x7c,0xfc,0x30,0x82,0x06,
+    0xc0,0x30,0x82,0x04,0xa8,0xa0,0x03,0x02,0x01,0x02,0x02,0x10,0x0c,0x4d,0x69,0x72,0x4b,0x94,0xfa,0x3c,0x2a,0x4a,0x3d,0x29,
+    0x07,0x80,0x3d,0x5a,0x30,0x0d,0x06,0x09,0x2a,0x86,0x48,0x86,0xf7,0x0d,0x01,0x01,0x0b,0x05,0x00,0x30,0x63,0x31,0x0b,0x30,
+    0x09,0x06,0x03,0x55,0x04,0x06,0x13,0x02,0x55,0x53,0x31,0x17,0x30,0x15,0x06,0x03,0x55,0x04,0x0a,0x13,0x0e,0x44,0x69,0x67,
+    0x69,0x43,0x65,0x72,0x74,0x2c,0x20,0x49,0x6e,0x63,0x2e,0x31,0x3b,0x30,0x39,0x06,0x03,0x55,0x04,0x03,0x13,0x32,0x44,0x69,
+    0x67,0x69,0x43,0x65,0x72,0x74,0x20,0x54,0x72,0x75,0x73,0x74,0x65,0x64,0x20,0x47,0x34,0x20,0x52,0x53,0x41,0x34,0x30,0x39,
+    0x36,0x20,0x53,0x48,0x41,0x32,0x35,0x36,0x20,0x54,0x69,0x6d,0x65,0x53,0x74,0x61,0x6d,0x70,0x69,0x6e,0x67,0x20,0x43,0x41,
+    0x30,0x1e,0x17,0x0d,0x32,0x32,0x30,0x39,0x32,0x31,0x30,0x30,0x30,0x30,0x30,0x30,0x5a,0x17,0x0d,0x33,0x33,0x31,0x31,0x32,
+    0x31,0x32,0x33,0x35,0x39,0x35,0x39,0x5a,0x30,0x46,0x31,0x0b,0x30,0x09,0x06,0x03,0x55,0x04,0x06,0x13,0x02,0x55,0x53,0x31,
+    0x11,0x30,0x0f,0x06,0x03,0x55,0x04,0x0a,0x13,0x08,0x44,0x69,0x67,0x69,0x43,0x65,0x72,0x74,0x31,0x24,0x30,0x22,0x06,0x03,
+    0x55,0x04,0x03,0x13,0x1b,0x44,0x69,0x67,0x69,0x43,0x65,0x72,0x74,0x20,0x54,0x69,0x6d,0x65,0x73,0x74,0x61,0x6d,0x70,0x20,
+    0x32,0x30,0x32,0x32,0x20,0x2d,0x20,0x32,0x30,0x82,0x02,0x22,0x30,0x0d,0x06,0x09,0x2a,0x86,0x48,0x86,0xf7,0x0d,0x01,0x01,
+    0x01,0x05,0x00,0x03,0x82,0x02,0x0f,0x00,0x30,0x82,0x02,0x0a,0x02,0x82,0x02,0x01,0x00,0xcf,0xec,0xa5,0x26,0x3a,0xc6,0xa9,
+    0xf2,0x6b,0xbb,0x8d,0xc1,0x0d,0x9a,0xdb,0xa1,0xe8,0x14,0x85,0x74,0x33,0x1a,0x26,0xac,0xd0,0x1c,0x55,0x1e,0x1e,0x36,0x6d,
+    0xbc,0x92,0x55,0x0c,0x61,0xf4,0x9d,0x09,0x77,0x3d,0x15,0x96,0x08,0x2f,0x6b,0x64,0xa4,0xfd,0x06,0x83,0x16,0xd7,0x91,0x92,
+    0x38,0x1c,0x31,0x02,0x96,0xfb,0x72,0xb1,0x97,0x3a,0x55,0xaf,0x33,0xec,0x61,0x8a,0xe9,0xa6,0x28,0xdb,0x90,0x63,0x5c,0xbd,
+    0x89,0x53,0xe0,0x3a,0x2d,0x8c,0x87,0x42,0xae,0x26,0xa4,0xe4,0xbb,0x78,0x78,0xb9,0x7a,0x16,0xe1,0x56,0xc6,0xc0,0xba,0x64,
+    0x53,0xbb,0x2a,0x16,0xe7,0x50,0x48,0xbb,0x88,0x69,0x0c,0x88,0xc6,0xf1,0xbe,0xe0,0x2f,0x7d,0x3b,0xb1,0xca,0x53,0x8d,0x40,
+    0x83,0x1e,0xe7,0xcb,0x72,0x49,0x28,0x1e,0x4c,0x80,0x1e,0x85,0x56,0xe7,0x85,0xed,0xf2,0x61,0xbc,0xaa,0x3a,0x07,0x7d,0xf6,
+    0xab,0x6e,0xe5,0x66,0xdd,0xe2,0x5c,0xf5,0x2f,0xed,0x8d,0xd4,0x4d,0x95,0x84,0x68,0xe3,0x80,0xcb,0x6a,0x79,0xd1,0xd2,0x10,
+    0x91,0x46,0x29,0xeb,0x3e,0x26,0xf2,0xb4,0x8c,0xcd,0x4c,0xb9,0x66,0xc8,0xbb,0xaa,0x50,0x38,0x0d,0xe5,0x8c,0x94,0x5d,0x19,
+    0x5a,0xbf,0xf5,0x7b,0x40,0x6e,0x6f,0x16,0xa8,0x9a,0x9c,0x95,0x47,0x86,0x85,0x79,0x3e,0x0c,0x5e,0x66,0x8c,0x1a,0x0a,0x24,
+    0xbe,0x9c,0xaa,0xd2,0x9c,0xb6,0xf7,0x4f,0x6e,0x78,0xc4,0x28,0x3f,0xa3,0x1c,0x0f,0x50,0x06,0x37,0xba,0x08,0xd9,0x35,0xa6,
+    0xb5,0x1e,0xda,0x78,0x58,0x1d,0x39,0xe8,0xf8,0x4c,0x91,0x10,0x96,0x7e,0x4d,0xe1,0xdd,0xc2,0xad,0xa5,0x7e,0xf8,0x2d,0x1b,
+    0x1f,0xec,0x2b,0x46,0x18,0xa3,0x19,0xf6,0x39,0xf7,0xf5,0xc1,0x4f,0x71,0x2e,0x89,0x03,0x11,0xa2,0x4b,0xbb,0x98,0xbf,0xfa,
+    0x4f,0xe4,0x7b,0x36,0xef,0x06,0x44,0xe4,0x55,0xff,0x36,0xea,0xe5,0x7c,0x31,0xe7,0xf3,0xc2,0x52,0xc4,0xe6,0x16,0x7b,0x5a,
+    0x7e,0xa5,0x25,0x73,0xdb,0xc0,0x6a,0x99,0x21,0x2d,0x63,0xe5,0x59,0xf5,0x4d,0x2f,0x90,0x1f,0x27,0xb7,0xd2,0xab,0x14,0xe5,
+    0x38,0x66,0x87,0x51,0x08,0x6b,0xfb,0x53,0x43,0x39,0xd0,0x64,0xfa,0x56,0xcf,0xe0,0xf4,0x0a,0xe6,0x14,0x6d,0x64,0x78,0xbb,
+    0x98,0xfd,0x94,0xc3,0x73,0x21,0xf3,0x2f,0xc2,0x2e,0x20,0xd7,0x81,0xac,0xd3,0xf1,0x07,0xd4,0xe1,0xbd,0xd9,0x5d,0x4b,0x6e,
+    0x31,0x94,0x29,0x8b,0xe6,0x41,0xa4,0x65,0x94,0xc0,0x58,0xe5,0xe5,0x2e,0x29,0x90,0xa6,0xb7,0x61,0x64,0xfa,0xd9,0x20,0x6c,
+    0x18,0x51,0x60,0xba,0xa6,0x81,0x0f,0x09,0x25,0x53,0xf1,0xbf,0x3b,0xe9,0xab,0x07,0x0e,0x6a,0x07,0x39,0x62,0x19,0xc9,0xd6,
+    0x85,0x7f,0x13,0xd9,0x8d,0x79,0xcf,0x62,0xc5,0xec,0xe1,0x7b,0xb9,0xcc,0x67,0x13,0x07,0x9a,0xc1,0x78,0xed,0xc6,0x88,0xc8,
+    0xb0,0x6e,0x32,0x79,0xc7,0x0b,0x59,0x83,0x8d,0xc6,0xee,0xf5,0x2c,0x7c,0x7b,0x8e,0xcb,0x64,0x89,0xf1,0xb1,0xc4,0xb8,0xe7,
+    0x53,0x5e,0x5f,0x55,0xd2,0x7d,0x19,0x29,0x59,0x03,0x4e,0xfa,0x5d,0xea,0x45,0x73,0x1c,0x84,0x7e,0xd7,0xce,0xe2,0xd4,0x3a,
+    0x77,0x02,0x03,0x01,0x00,0x01,0xa3,0x82,0x01,0x8b,0x30,0x82,0x01,0x87,0x30,0x0e,0x06,0x03,0x55,0x1d,0x0f,0x01,0x01,0xff,
+    0x04,0x04,0x03,0x02,0x07,0x80,0x30,0x0c,0x06,0x03,0x55,0x1d,0x13,0x01,0x01,0xff,0x04,0x02,0x30,0x00,0x30,0x16,0x06,0x03,
+    0x55,0x1d,0x25,0x01,0x01,0xff,0x04,0x0c,0x30,0x0a,0x06,0x08,0x2b,0x06,0x01,0x05,0x05,0x07,0x03,0x08,0x30,0x20,0x06,0x03,
+    0x55,0x1d,0x20,0x04,0x19,0x30,0x17,0x30,0x08,0x06,0x06,0x67,0x81,0x0c,0x01,0x04,0x02,0x30,0x0b,0x06,0x09,0x60,0x86,0x48,
+    0x01,0x86,0xfd,0x6c,0x07,0x01,0x30,0x1f,0x06,0x03,0x55,0x1d,0x23,0x04,0x18,0x30,0x16,0x80,0x14,0xba,0x16,0xd9,0x6d,0x4d,
+    0x85,0x2f,0x73,0x29,0x76,0x9a,0x2f,0x75,0x8c,0x6a,0x20,0x8f,0x9e,0xc8,0x6f,0x30,0x1d,0x06,0x03,0x55,0x1d,0x0e,0x04,0x16,
+    0x04,0x14,0x62,0x8a,0xde,0xd0,0x61,0xfc,0x8f,0x31,0x14,0xed,0x97,0x0b,0xcd,0x3d,0x2a,0x94,0x14,0xdf,0x52,0x9c,0x30,0x5a,
+    0x06,0x03,0x55,0x1d,0x1f,0x04,0x53,0x30,0x51,0x30,0x4f,0xa0,0x4d,0xa0,0x4b,0x86,0x49,0x68,0x74,0x74,0x70,0x3a,0x2f,0x2f,
+    0x63,0x72,0x6c,0x33,0x2e,0x64,0x69,0x67,0x69,0x63,0x65,0x72,0x74,0x2e,0x63,0x6f,0x6d,0x2f,0x44,0x69,0x67,0x69,0x43,0x65,
+    0x72,0x74,0x54,0x72,0x75,0x73,0x74,0x65,0x64,0x47,0x34,0x52,0x53,0x41,0x34,0x30,0x39,0x36,0x53,0x48,0x41,0x32,0x35,0x36,
+    0x54,0x69,0x6d,0x65,0x53,0x74,0x61,0x6d,0x70,0x69,0x6e,0x67,0x43,0x41,0x2e,0x63,0x72,0x6c,0x30,0x81,0x90,0x06,0x08,0x2b,
+    0x06,0x01,0x05,0x05,0x07,0x01,0x01,0x04,0x81,0x83,0x30,0x81,0x80,0x30,0x24,0x06,0x08,0x2b,0x06,0x01,0x05,0x05,0x07,0x30,
+    0x01,0x86,0x18,0x68,0x74,0x74,0x70,0x3a,0x2f,0x2f,0x6f,0x63,0x73,0x70,0x2e,0x64,0x69,0x67,0x69,0x63,0x65,0x72,0x74,0x2e,
+    0x63,0x6f,0x6d,0x30,0x58,0x06,0x08,0x2b,0x06,0x01,0x05,0x05,0x07,0x30,0x02,0x86,0x4c,0x68,0x74,0x74,0x70,0x3a,0x2f,0x2f,
+    0x63,0x61,0x63,0x65,0x72,0x74,0x73,0x2e,0x64,0x69,0x67,0x69,0x63,0x65,0x72,0x74,0x2e,0x63,0x6f,0x6d,0x2f,0x44,0x69,0x67,
+    0x69,0x43,0x65,0x72,0x74,0x54,0x72,0x75,0x73,0x74,0x65,0x64,0x47,0x34,0x52,0x53,0x41,0x34,0x30,0x39,0x36,0x53,0x48,0x41,
+    0x32,0x35,0x36,0x54,0x69,0x6d,0x65,0x53,0x74,0x61,0x6d,0x70,0x69,0x6e,0x67,0x43,0x41,0x2e,0x63,0x72,0x74,0x30,0x0d,0x06,
+    0x09,0x2a,0x86,0x48,0x86,0xf7,0x0d,0x01,0x01,0x0b,0x05,0x00,0x03,0x82,0x02,0x01,0x00,0x55,0xaa,0x2a,0x1a,0xf3,0x46,0xf3,
+    0x78,0x57,0x37,0x30,0xfc,0x75,0xe3,0x4f,0xd6,0x85,0x23,0xf1,0xfc,0xf9,0x95,0x39,0x9b,0x25,0xe6,0xf7,0x72,0x8a,0x98,0xc3,
+    0x77,0xd4,0x64,0xfc,0x15,0xfb,0x36,0xc2,0x49,0x51,0x2c,0x78,0x88,0x63,0x55,0x09,0x46,0x39,0x00,0xfc,0x69,0xd4,0xca,0x9b,
+    0x29,0xfb,0xa3,0x3f,0xc0,0xc9,0x00,0x9b,0x13,0x1d,0xb0,0x98,0x89,0xdc,0x78,0xf2,0xcd,0x7c,0x85,0xcd,0x53,0x9d,0xaf,0x62,
+    0xe2,0x61,0x66,0xa3,0x14,0x2a,0x45,0x87,0x4a,0x98,0x42,0x2b,0x50,0xfc,0x1b,0xb5,0x9e,0x08,0x30,0x09,0xfa,0xe4,0x2d,0xd7,
+    0x09,0x89,0x79,0xf9,0x09,0xe6,0x88,0xce,0x7d,0x1b,0xb8,0x6a,0xa2,0x9b,0xc1,0x53,0x60,0x09,0xe8,0xa3,0xb8,0x9d,0xd7,0xad,
+    0x1f,0x1c,0xb8,0xec,0x98,0x41,0xf0,0xf6,0x0e,0x80,0xfb,0xe4,0xff,0xdf,0x9d,0x10,0xa7,0xeb,0x00,0xba,0x5f,0x4a,0x8f,0x1a,
+    0x3a,0x52,0xb4,0xea,0xbf,0x09,0x49,0x15,0x35,0x36,0x59,0x9a,0x0f,0x54,0xd2,0xb2,0x1b,0x7f,0x7e,0x5e,0x09,0xad,0x76,0x54,
+    0x8a,0x74,0x6d,0xca,0xd2,0x05,0x67,0x2b,0x76,0xeb,0xff,0x98,0xb2,0x26,0x95,0x38,0x19,0x88,0x44,0x14,0xe5,0x0a,0x59,0xa2,
+    0x6b,0xe7,0x22,0x3e,0x44,0x21,0xd2,0x3f,0x1c,0xc0,0x9b,0xed,0x7c,0x48,0xb2,0xd8,0x92,0x0c,0x91,0x4f,0x3c,0x66,0x94,0xaf,
+    0x5d,0x02,0x53,0xeb,0x9e,0xe2,0x9e,0xe4,0xd3,0x1f,0x86,0x01,0x64,0x9c,0x00,0xc2,0xe9,0x5a,0x74,0x75,0x0d,0x3d,0xe1,0x79,
+    0x88,0xbf,0x1c,0x01,0x97,0xc9,0x19,0x23,0x80,0xd7,0x36,0x5a,0x5f,0x96,0x16,0xb1,0x63,0x0c,0xc6,0x46,0x40,0x3b,0xce,0x5d,
+    0x35,0xd4,0x59,0x3e,0x43,0x9a,0x18,0xae,0xc3,0xc9,0xcb,0xc3,0xfb,0x9b,0x13,0x5f,0x6a,0xb5,0xc7,0xe0,0xf3,0x05,0xc3,0x59,
+    0xdf,0x27,0x62,0x2b,0xde,0x41,0xc9,0x53,0xb9,0xff,0x34,0x10,0x67,0xf6,0x26,0x32,0x98,0x7b,0xfe,0x5c,0x42,0x94,0x81,0x94,
+    0x82,0x9d,0xac,0x0a,0x8b,0xc6,0x4b,0x15,0x4a,0xd3,0x98,0x90,0x45,0x60,0x33,0x80,0xe0,0x23,0xde,0xf8,0x03,0xa4,0xf6,0x45,
+    0x47,0xe5,0xce,0xb8,0x03,0x42,0x47,0xe8,0x41,0x36,0x71,0x77,0xad,0xfd,0xa2,0xe8,0x97,0x74,0x4e,0x2e,0xda,0x1e,0x1d,0x8c,
+    0x5a,0xc8,0x1e,0x9a,0xd5,0xc2,0xf0,0xc6,0x22,0xa8,0x4f,0x9b,0xbd,0xd8,0x1c,0x9a,0x51,0xc4,0x2f,0x9a,0xf6,0x5f,0xa7,0x27,
+    0x97,0xba,0x96,0x2e,0x85,0x57,0xc0,0x60,0xe7,0x78,0x56,0x7f,0x6a,0xef,0xc2,0x95,0x9a,0x4b,0x11,0x02,0xc8,0x82,0x9c,0xc9,
+    0x1a,0x05,0x7c,0xba,0x71,0xb5,0x4e,0x7a,0x99,0x6c,0xf4,0xe8,0x9e,0xd4,0x5a,0x98,0xc8,0x9f,0xbf,0x8d,0xbb,0x18,0x5c,0x43,
+    0xf5,0xd0,0x2a,0xe8,0xe2,0x62,0xee,0x78,0x04,0xdb,0xbd,0xd1,0xfb,0x5b,0x0a,0xa8,0x70,0x7e,0xf0,0x97,0x84,0x78,0xe3,0x08,
+    0x03,0x5d,0x47,0x2c,0x63,0xa8,0x25,0x38,0x97,0x01,0xd2,0x3f,0x3a,0xda,0xe5,0xe5,0xf6,0xe6,0x9b,0xdc,0x7e,0x2c,0xcc,0xff,
+    0x17,0x4c,0x4d,0x00,0xa2,0xd8,0xd6,0x01,0x0e,0xb8,0x8b,0xee,0xe6,0xe0,0x72,0x55,0x89,0x2c,0x27,0x19,0x61,0xf6,0x77,0x01,
+    0x8c,0x31,0x82,0x0f,0x9d,0x30,0x82,0x0f,0x99,0x02,0x01,0x01,0x30,0x26,0x30,0x12,0x31,0x10,0x30,0x0e,0x06,0x03,0x55,0x04,
+    0x03,0x13,0x07,0x54,0x65,0x73,0x74,0x20,0x43,0x41,0x02,0x10,0xd1,0x73,0x97,0xaa,0xa7,0x3a,0x31,0xa2,0x44,0xc0,0x4b,0x40,
+    0x69,0x40,0x4b,0xfa,0x30,0x0d,0x06,0x09,0x60,0x86,0x48,0x01,0x65,0x03,0x04,0x02,0x01,0x05,0x00,0xa0,0x5e,0x30,0x10,0x06,
+    0x0a,0x2b,0x06,0x01,0x04,0x01,0x82,0x37,0x02,0x01,0x0c,0x31,0x02,0x30,0x00,0x30,0x19,0x06,0x09,0x2a,0x86,0x48,0x86,0xf7,
+    0x0d,0x01,0x09,0x03,0x31,0x0c,0x06,0x0a,0x2b,0x06,0x01,0x04,0x01,0x82,0x37,0x02,0x01,0x04,0x30,0x2f,0x06,0x09,0x2a,0x86,
+    0x48,0x86,0xf7,0x0d,0x01,0x09,0x04,0x31,0x22,0x04,0x20,0xcb,0xa1,0x2f,0x7b,0x0f,0x6a,0x14,0x06,0x26,0x77,0x7b,0xee,0xd1,
+    0x90,0x34,0x1c,0xa7,0xcd,0x94,0x65,0xe0,0xe4,0x24,0x12,0x0c,0x4e,0xa2,0x89,0xeb,0x2d,0xe5,0xbb,0x30,0x0d,0x06,0x09,0x2a,
+    0x86,0x48,0x86,0xf7,0x0d,0x01,0x01,0x01,0x05,0x00,0x04,0x82,0x01,0x00,0x73,0xb7,0xdf,0xb4,0xd2,0x60,0x31,0x2d,0x14,0x63,
+    0x71,0x87,0x5b,0xd9,0xee,0x66,0x85,0x88,0xbe,0x1e,0xc3,0x5e,0x30,0x25,0x62,0x05,0x66,0x6e,0x9b,0x51,0xaa,0x5b,0xee,0xed,
+    0xe4,0x4c,0x83,0x19,0x7e,0x7b,0x78,0xe0,0x04,0xb5,0xdb,0xb3,0x48,0xba,0xa3,0xa4,0x54,0xb2,0x3e,0xe4,0x99,0xf1,0xb2,0x6e,
+    0xb7,0x7a,0x44,0x76,0x11,0xb4,0x51,0xae,0xe3,0xec,0xc2,0x43,0x65,0xf5,0x95,0x1c,0x57,0x9e,0x4d,0x49,0x4d,0x4c,0xee,0x09,
+    0xdd,0xdb,0xab,0xf3,0x14,0x89,0xec,0x6e,0x94,0xd2,0xac,0xd8,0xed,0xe3,0xbb,0x8a,0xf0,0x05,0x9d,0x1d,0xbe,0x8b,0x7f,0x34,
+    0x63,0xe7,0x87,0x04,0x25,0x5a,0xff,0xc9,0xca,0xa9,0xab,0xd5,0xf2,0x16,0xf6,0x26,0x5d,0xf9,0xf9,0xbf,0xb4,0xce,0x86,0x55,
+    0xd4,0x95,0x91,0x1e,0x12,0x25,0x36,0x43,0x37,0x6e,0x93,0x14,0xf0,0x86,0xad,0xc6,0x7d,0x07,0x86,0xe5,0x18,0x4f,0x3d,0xe3,
+    0x92,0x67,0x7b,0x74,0xbf,0xa9,0x71,0x5a,0x49,0xcf,0xf5,0x60,0xf4,0x09,0x65,0x38,0xfd,0x13,0xe2,0x03,0x8a,0x84,0x17,0xc7,
+    0x83,0x7a,0xd5,0x42,0x95,0x47,0xd8,0x9d,0x76,0x52,0xb5,0xbc,0x11,0x63,0x78,0x53,0x66,0x0e,0x95,0xc8,0xd4,0xfa,0x6e,0x3d,
+    0x3b,0x1b,0x56,0xf2,0x98,0xc3,0x4c,0xc8,0xdc,0x1f,0x7e,0xa3,0x8b,0x1a,0x3b,0xa6,0x4d,0xed,0x70,0x75,0x55,0xcd,0x0c,0xf9,
+    0x4e,0xfb,0xa6,0x84,0xcb,0xbc,0xf5,0x28,0x89,0x2e,0x30,0x07,0x8f,0x1d,0x8d,0x10,0x03,0x20,0xe9,0xb0,0x56,0x53,0x9d,0xf9,
+    0x43,0xfb,0xba,0xb7,0x25,0x5d,0xa1,0x82,0x0d,0xe8,0x30,0x82,0x03,0x1c,0x06,0x09,0x2a,0x86,0x48,0x86,0xf7,0x0d,0x01,0x09,
+    0x06,0x31,0x82,0x03,0x0d,0x30,0x82,0x03,0x09,0x02,0x01,0x01,0x30,0x77,0x30,0x63,0x31,0x0b,0x30,0x09,0x06,0x03,0x55,0x04,
+    0x06,0x13,0x02,0x55,0x53,0x31,0x17,0x30,0x15,0x06,0x03,0x55,0x04,0x0a,0x13,0x0e,0x44,0x69,0x67,0x69,0x43,0x65,0x72,0x74,
+    0x2c,0x20,0x49,0x6e,0x63,0x2e,0x31,0x3b,0x30,0x39,0x06,0x03,0x55,0x04,0x03,0x13,0x32,0x44,0x69,0x67,0x69,0x43,0x65,0x72,
+    0x74,0x20,0x54,0x72,0x75,0x73,0x74,0x65,0x64,0x20,0x47,0x34,0x20,0x52,0x53,0x41,0x34,0x30,0x39,0x36,0x20,0x53,0x48,0x41,
+    0x32,0x35,0x36,0x20,0x54,0x69,0x6d,0x65,0x53,0x74,0x61,0x6d,0x70,0x69,0x6e,0x67,0x20,0x43,0x41,0x02,0x10,0x0c,0x4d,0x69,
+    0x72,0x4b,0x94,0xfa,0x3c,0x2a,0x4a,0x3d,0x29,0x07,0x80,0x3d,0x5a,0x30,0x0d,0x06,0x09,0x60,0x86,0x48,0x01,0x65,0x03,0x04,
+    0x02,0x01,0x05,0x00,0xa0,0x69,0x30,0x18,0x06,0x09,0x2a,0x86,0x48,0x86,0xf7,0x0d,0x01,0x09,0x03,0x31,0x0b,0x06,0x09,0x2a,
+    0x86,0x48,0x86,0xf7,0x0d,0x01,0x07,0x01,0x30,0x1c,0x06,0x09,0x2a,0x86,0x48,0x86,0xf7,0x0d,0x01,0x09,0x05,0x31,0x0f,0x17,
+    0x0d,0x32,0x32,0x30,0x39,0x33,0x30,0x31,0x37,0x35,0x33,0x34,0x33,0x5a,0x30,0x2f,0x06,0x09,0x2a,0x86,0x48,0x86,0xf7,0x0d,
+    0x01,0x09,0x04,0x31,0x22,0x04,0x20,0xbf,0x5c,0x03,0xc6,0x50,0xb0,0xde,0xd1,0x96,0x6d,0x74,0x64,0xa4,0xda,0x0f,0x51,0x71,
+    0x0f,0x5a,0x87,0x97,0x78,0x2e,0x17,0x99,0xc6,0xa2,0x7b,0xa7,0x9b,0x75,0xeb,0x30,0x0d,0x06,0x09,0x2a,0x86,0x48,0x86,0xf7,
+    0x0d,0x01,0x01,0x01,0x05,0x00,0x04,0x82,0x02,0x00,0x0e,0xb2,0xbf,0xf0,0xf2,0x35,0x55,0xc7,0x9d,0x49,0xce,0x0a,0xac,0x3a,
+    0x6a,0xd8,0x85,0xa0,0x2b,0x81,0x97,0x85,0xc2,0x16,0x4d,0x6d,0x77,0x72,0xdf,0x2e,0x0a,0x6b,0x2e,0xbd,0xd6,0xb4,0x66,0x22,
+    0x7b,0x43,0x1b,0x7e,0x7a,0x1b,0xdb,0x72,0xfb,0x1d,0xd5,0xe9,0x84,0x01,0xe1,0x64,0x15,0x05,0x0d,0xb5,0x85,0x1d,0x93,0xf0,
+    0xcf,0x72,0x77,0x07,0x30,0x82,0xa9,0x6e,0x9c,0x5d,0xc9,0x39,0xda,0x19,0x9b,0xca,0x34,0x05,0xf0,0xe4,0xd7,0x02,0xbe,0x8a,
+    0x5f,0x74,0x39,0xe6,0xe9,0xb4,0xdf,0x00,0x4a,0xeb,0xb4,0x0d,0xf6,0xb2,0x5b,0x7f,0x10,0xb1,0xef,0x05,0x53,0xfc,0x74,0x41,
+    0x5b,0x83,0xeb,0xf9,0x37,0x9f,0x03,0xc2,0x1a,0x98,0x13,0xc9,0x6c,0x1c,0xd8,0x82,0xd8,0xd7,0xbf,0x13,0x07,0x20,0xf9,0xf2,
+    0xea,0x96,0x46,0xb7,0x2d,0x51,0x2f,0xc3,0x40,0x12,0x3f,0x35,0xeb,0x88,0xfa,0x3c,0x66,0x30,0xd9,0x16,0xe2,0x4b,0x05,0x14,
+    0x11,0x07,0x9a,0x64,0xc5,0x92,0x01,0xec,0xdb,0x5d,0x01,0x91,0x08,0x4f,0x1e,0xec,0x12,0xdd,0x7d,0xa0,0x32,0x5a,0x84,0x2a,
+    0x7c,0xb9,0x25,0x34,0x57,0x12,0x0c,0x86,0x2d,0xcd,0x01,0x26,0x85,0x17,0x8c,0x7d,0x07,0x3f,0x2c,0x08,0xb6,0xac,0xc3,0xca,
+    0x72,0x17,0xfe,0x4c,0xef,0xbb,0x69,0x20,0x11,0x33,0x63,0xf8,0xca,0x0a,0xe1,0x8c,0xf5,0x31,0x4e,0x83,0x87,0xfb,0xa9,0xd2,
+    0x29,0x4b,0x82,0x84,0x27,0xfa,0x01,0x31,0x48,0xc1,0x25,0xe5,0x51,0x49,0xf5,0x52,0x60,0xdb,0x64,0x08,0x36,0xd2,0x2f,0x4e,
+    0x7a,0x5d,0x92,0xee,0x06,0xec,0xe4,0x3b,0x5d,0xdc,0xc3,0x49,0xa1,0x8e,0x96,0xa6,0x17,0x00,0x2d,0x0d,0xee,0x6e,0x88,0x16,
+    0x1e,0xea,0x9c,0x9b,0x55,0x9d,0xea,0x4a,0xa5,0xbb,0x54,0x33,0xaa,0x72,0x8c,0x5f,0xb7,0xe6,0x22,0xe9,0x1d,0xca,0xbc,0x6d,
+    0xdf,0x7b,0x68,0xb5,0x71,0x3b,0x9f,0xfd,0x2b,0x53,0x35,0xa6,0xbb,0x78,0xf2,0x5a,0x41,0x69,0x52,0x5c,0x47,0xdc,0xf0,0x3e,
+    0x06,0xef,0x60,0xb6,0xd3,0xb1,0x30,0xda,0x41,0xee,0x5a,0x2e,0x8e,0x24,0x0e,0x1e,0xcd,0x6c,0xa6,0x2e,0x9b,0x3c,0x77,0x02,
+    0x21,0x86,0x16,0x68,0xfc,0xd6,0x64,0x84,0x46,0x1e,0xd1,0xe6,0x86,0x6f,0xee,0x5f,0x5c,0xca,0xb6,0xc9,0x9b,0xb8,0x03,0x46,
+    0x1b,0x67,0x52,0x48,0x48,0x1c,0x07,0xad,0xbd,0x3c,0x2f,0x1b,0xd1,0xe3,0xb5,0xba,0x21,0x20,0x3b,0x6d,0xfb,0x30,0xa6,0x6d,
+    0x2d,0xd7,0xb0,0x67,0xa4,0x19,0x0f,0x38,0xff,0xb0,0xad,0xf0,0xc3,0xb3,0xd7,0x7c,0x92,0xa0,0xe8,0x9c,0x22,0x60,0x0f,0x88,
+    0x08,0xa7,0xf0,0xfa,0x90,0x45,0x2c,0x26,0xa6,0x88,0x25,0x24,0x7b,0x69,0x23,0x0b,0x20,0x04,0x89,0xd4,0x66,0x89,0x7d,0xb6,
+    0x50,0x0e,0xb3,0xfe,0xf9,0xd0,0x91,0x2b,0x1d,0x17,0x62,0x6d,0xad,0x8e,0xf9,0x52,0x63,0x8f,0xe9,0x93,0xe6,0xea,0xb8,0xe6,
+    0xce,0x0c,0x69,0xc9,0x47,0xd7,0x7e,0xb4,0x0d,0x49,0xbe,0xcb,0x05,0xe4,0xac,0x0b,0xd4,0xa1,0x6b,0x66,0x0f,0xff,0xe7,0x01,
+    0x5a,0x91,0x05,0xa8,0xc0,0x2b,0xda,0xe9,0x5c,0x18,0xfb,0xe3,0x4d,0x60,0x0f,0x34,0x19,0x68,0x30,0x82,0x0a,0xc4,0x06,0x0a,
+    0x2b,0x06,0x01,0x04,0x01,0x82,0x37,0x02,0x04,0x01,0x31,0x82,0x0a,0xb4,0x30,0x82,0x05,0x56,0x06,0x09,0x2a,0x86,0x48,0x86,
+    0xf7,0x0d,0x01,0x07,0x02,0xa0,0x82,0x05,0x47,0x30,0x82,0x05,0x43,0x02,0x01,0x01,0x31,0x0f,0x30,0x0d,0x06,0x09,0x60,0x86,
+    0x48,0x01,0x65,0x03,0x04,0x02,0x01,0x05,0x00,0x30,0x5c,0x06,0x0a,0x2b,0x06,0x01,0x04,0x01,0x82,0x37,0x02,0x01,0x04,0xa0,
+    0x4e,0x30,0x4c,0x30,0x17,0x06,0x0a,0x2b,0x06,0x01,0x04,0x01,0x82,0x37,0x02,0x01,0x0f,0x30,0x09,0x03,0x01,0x00,0xa0,0x04,
+    0xa2,0x02,0x80,0x00,0x30,0x31,0x30,0x0d,0x06,0x09,0x60,0x86,0x48,0x01,0x65,0x03,0x04,0x02,0x01,0x05,0x00,0x04,0x20,0xdd,
+    0x8b,0xd7,0x29,0x3b,0xae,0x16,0xec,0xbb,0x81,0x80,0x55,0x15,0xd8,0x87,0xa5,0x3e,0xeb,0x0b,0x74,0x59,0xb6,0x56,0xf1,0x0b,
+    0x2e,0xe1,0xb4,0x42,0x4d,0x8b,0x18,0xa0,0x82,0x03,0x05,0x30,0x82,0x03,0x01,0x30,0x82,0x01,0xe9,0xa0,0x03,0x02,0x01,0x02,
+    0x02,0x10,0x8d,0x01,0xec,0xa9,0x68,0x41,0x93,0x8f,0x40,0x42,0x93,0x4a,0x72,0x6b,0x03,0xcc,0x30,0x0d,0x06,0x09,0x2a,0x86,
+    0x48,0x86,0xf7,0x0d,0x01,0x01,0x0b,0x05,0x00,0x30,0x12,0x31,0x10,0x30,0x0e,0x06,0x03,0x55,0x04,0x03,0x13,0x07,0x54,0x65,
+    0x73,0x74,0x20,0x43,0x41,0x30,0x1e,0x17,0x0d,0x32,0x32,0x30,0x39,0x33,0x30,0x31,0x37,0x32,0x34,0x31,0x39,0x5a,0x17,0x0d,
+    0x33,0x39,0x31,0x32,0x33,0x31,0x32,0x33,0x35,0x39,0x35,0x39,0x5a,0x30,0x10,0x31,0x0e,0x30,0x0c,0x06,0x03,0x55,0x04,0x03,
+    0x13,0x05,0x63,0x65,0x72,0x74,0x33,0x30,0x82,0x01,0x22,0x30,0x0d,0x06,0x09,0x2a,0x86,0x48,0x86,0xf7,0x0d,0x01,0x01,0x01,
+    0x05,0x00,0x03,0x82,0x01,0x0f,0x00,0x30,0x82,0x01,0x0a,0x02,0x82,0x01,0x01,0x00,0xf4,0x21,0x90,0xec,0x4a,0x19,0xca,0xa7,
+    0x1f,0x25,0x80,0x0b,0x92,0x21,0x2d,0x53,0xb4,0x25,0xa3,0x37,0x40,0xae,0xce,0xf1,0x46,0xf6,0xda,0x21,0xd3,0x54,0x8e,0x02,
+    0x95,0xfe,0x37,0x3a,0xff,0xb9,0x36,0x88,0x70,0xf2,0x33,0x0c,0x5c,0x60,0x36,0xbf,0x8d,0x51,0xef,0x18,0x5d,0x47,0x68,0xbc,
+    0xda,0xd8,0xf8,0x94,0xaf,0xcf,0xa6,0x48,0x61,0x78,0x04,0xcd,0x73,0x03,0xa0,0x6c,0xdb,0x24,0x94,0x20,0x54,0xbb,0x19,0xf2,
+    0xb6,0xf9,0x0d,0xf4,0x31,0xbd,0x79,0xb5,0x98,0x12,0xc4,0x62,0x06,0xfb,0x16,0x08,0x51,0xa2,0xbf,0x12,0xcf,0x88,0xf4,0x4c,
+    0x26,0xec,0x80,0xc7,0xa7,0xeb,0x89,0x24,0x6a,0xe4,0x1e,0x3a,0x1d,0x4a,0x7c,0x42,0xaa,0x03,0x5e,0x47,0xde,0x21,0xc4,0x06,
+    0x86,0x57,0x0d,0xce,0xe0,0x27,0xf2,0x43,0x56,0x2a,0x60,0x1b,0x18,0xf5,0x03,0x91,0xa4,0xda,0x86,0x1c,0xcb,0x2c,0x2d,0x21,
+    0x54,0xc5,0xd8,0xe2,0xe2,0x02,0x19,0xb0,0x73,0xe0,0xf8,0x95,0x5c,0x4f,0x1d,0x8f,0xd2,0xe0,0x4a,0x7c,0x20,0x9e,0x29,0xec,
+    0x05,0x34,0xb0,0x4c,0x1a,0xaf,0x2a,0x01,0xf1,0x0f,0x26,0xdc,0x38,0x68,0x85,0xbd,0xc0,0x73,0xec,0x10,0x17,0x3a,0xd8,0x6d,
+    0x33,0x3b,0xab,0xd3,0x79,0x61,0x2c,0xac,0x11,0xe1,0x09,0x5e,0xe0,0x7b,0xd3,0xc0,0xb8,0xf8,0xb5,0x9a,0x20,0x68,0xa7,0xf0,
+    0x66,0x9b,0xc2,0xe8,0x83,0x14,0x7d,0x3c,0x7f,0x7a,0x85,0x95,0xc9,0x05,0x74,0xf4,0xee,0xa9,0x83,0x6a,0x55,0xa5,0x78,0xa8,
+    0xa8,0xb4,0x6d,0xb1,0xab,0x49,0x50,0xd1,0x02,0x03,0x01,0x00,0x01,0xa3,0x55,0x30,0x53,0x30,0x0c,0x06,0x03,0x55,0x1d,0x13,
+    0x01,0x01,0xff,0x04,0x02,0x30,0x00,0x30,0x43,0x06,0x03,0x55,0x1d,0x01,0x04,0x3c,0x30,0x3a,0x80,0x10,0x88,0x17,0xf7,0x38,
+    0x65,0x8b,0x78,0x78,0xf6,0x77,0xe3,0x25,0x47,0x54,0x33,0x4c,0xa1,0x14,0x30,0x12,0x31,0x10,0x30,0x0e,0x06,0x03,0x55,0x04,
+    0x03,0x13,0x07,0x54,0x65,0x73,0x74,0x20,0x43,0x41,0x82,0x10,0x2b,0x59,0xb4,0xc7,0xe2,0xce,0x08,0x97,0x46,0x48,0x32,0x17,
+    0x0f,0x97,0xc5,0x08,0x30,0x0d,0x06,0x09,0x2a,0x86,0x48,0x86,0xf7,0x0d,0x01,0x01,0x0b,0x05,0x00,0x03,0x82,0x01,0x01,0x00,
+    0x8e,0xe0,0xc9,0x58,0x24,0x1b,0x16,0x6a,0x8a,0x4f,0x67,0xac,0xd7,0x75,0x62,0x53,0x94,0xfc,0xeb,0x8b,0x36,0x2a,0x9f,0x9c,
+    0x8b,0x8f,0x60,0x42,0xdd,0x37,0x13,0x10,0x5f,0x5a,0x52,0xc8,0xee,0x51,0x92,0x18,0xaf,0x84,0x18,0x5f,0x27,0x69,0xf4,0xde,
+    0x22,0x4b,0x9c,0xaa,0x18,0x9e,0xde,0x04,0xc0,0xc4,0xfd,0x74,0x08,0x25,0x43,0xbf,0x00,0x1d,0xc2,0xd6,0xb2,0x4e,0xa4,0x4a,
+    0x73,0xa1,0xff,0x71,0x3d,0xa5,0xf1,0x21,0xcf,0x4d,0xb4,0x5c,0x55,0x54,0x6f,0x94,0x50,0x21,0xbb,0x85,0xcb,0x54,0xeb,0x07,
+    0xaf,0x74,0x62,0x21,0xf5,0x89,0x43,0xcb,0x10,0x62,0xd6,0xbe,0xc0,0x3a,0xb3,0x6b,0x9f,0x80,0xde,0xe0,0xc0,0x6e,0x8a,0x0a,
+    0xe7,0x1f,0x08,0x9b,0x89,0x38,0xc2,0x30,0xfa,0xd9,0xc2,0x8c,0xf7,0xbd,0xbd,0xd4,0x6b,0x99,0xbd,0x5f,0x0e,0xb1,0x76,0xd6,
+    0x5b,0x1f,0x1a,0xd7,0x27,0x5d,0x5b,0x19,0x1c,0x6d,0x5a,0x91,0x81,0x06,0x83,0x82,0x6d,0xaf,0x48,0x70,0x72,0x8b,0x7c,0x8e,
+    0x57,0xcd,0x35,0x5d,0x7d,0x96,0xe5,0x2d,0x31,0xd2,0xa9,0xf8,0xad,0x9d,0x13,0xb4,0x89,0x75,0x7e,0xbc,0x39,0x11,0x27,0x9d,
+    0xc3,0x7b,0xf1,0x40,0x2a,0x23,0xed,0x50,0xee,0x10,0x1b,0x97,0x13,0x71,0x1c,0x5a,0x7f,0x06,0xab,0x9b,0x51,0x2b,0x1f,0x85,
+    0x27,0x99,0x11,0x18,0x62,0x97,0xcb,0x08,0x24,0x6d,0xf5,0x08,0x56,0xb5,0x36,0x00,0xf3,0x6b,0x3d,0xa9,0x13,0xd3,0xcf,0x0c,
+    0x94,0x6f,0x9e,0x05,0x62,0xeb,0x9c,0x52,0x9d,0x0c,0x15,0x81,0x4d,0x7d,0xe3,0x2f,0x31,0x82,0x01,0xc4,0x30,0x82,0x01,0xc0,
+    0x02,0x01,0x01,0x30,0x26,0x30,0x12,0x31,0x10,0x30,0x0e,0x06,0x03,0x55,0x04,0x03,0x13,0x07,0x54,0x65,0x73,0x74,0x20,0x43,
+    0x41,0x02,0x10,0x8d,0x01,0xec,0xa9,0x68,0x41,0x93,0x8f,0x40,0x42,0x93,0x4a,0x72,0x6b,0x03,0xcc,0x30,0x0d,0x06,0x09,0x60,
+    0x86,0x48,0x01,0x65,0x03,0x04,0x02,0x01,0x05,0x00,0xa0,0x71,0x30,0x10,0x06,0x0a,0x2b,0x06,0x01,0x04,0x01,0x82,0x37,0x02,
+    0x01,0x0c,0x31,0x02,0x30,0x00,0x30,0x11,0x06,0x0a,0x2a,0x86,0x48,0x86,0xf7,0x0d,0x01,0x09,0x19,0x04,0x31,0x03,0x02,0x01,
+    0x02,0x30,0x19,0x06,0x09,0x2a,0x86,0x48,0x86,0xf7,0x0d,0x01,0x09,0x03,0x31,0x0c,0x06,0x0a,0x2b,0x06,0x01,0x04,0x01,0x82,
+    0x37,0x02,0x01,0x04,0x30,0x2f,0x06,0x09,0x2a,0x86,0x48,0x86,0xf7,0x0d,0x01,0x09,0x04,0x31,0x22,0x04,0x20,0xcb,0xa1,0x2f,
+    0x7b,0x0f,0x6a,0x14,0x06,0x26,0x77,0x7b,0xee,0xd1,0x90,0x34,0x1c,0xa7,0xcd,0x94,0x65,0xe0,0xe4,0x24,0x12,0x0c,0x4e,0xa2,
+    0x89,0xeb,0x2d,0xe5,0xbb,0x30,0x0d,0x06,0x09,0x2a,0x86,0x48,0x86,0xf7,0x0d,0x01,0x01,0x01,0x05,0x00,0x04,0x82,0x01,0x00,
+    0x68,0xfc,0x34,0xac,0x24,0xe1,0x93,0x00,0xec,0x8d,0x29,0xe1,0x32,0x03,0xe6,0x8a,0xd6,0x39,0x79,0x07,0x85,0x97,0xf4,0xb8,
+    0x0c,0xf1,0x24,0xa0,0x16,0x09,0x0c,0xf8,0x02,0x40,0x94,0xdb,0x19,0x7a,0x6f,0x91,0xee,0x24,0x36,0x77,0x32,0x02,0xb5,0xd1,
+    0xf9,0xe0,0xa2,0xdd,0xe0,0xe1,0x14,0x30,0x11,0xe1,0x25,0x02,0x0a,0x7c,0x10,0xdb,0xbd,0xb0,0x4e,0xbb,0x36,0xef,0x87,0xf0,
+    0x17,0x49,0x77,0x45,0xa0,0x9e,0x47,0x70,0x1a,0xe2,0x87,0x39,0x41,0x24,0x1c,0xe0,0x09,0xb0,0xe0,0xfa,0xc5,0xf3,0xba,0xba,
+    0x03,0x65,0x64,0xf9,0xa8,0x7d,0xe5,0x0e,0x84,0xc8,0xd1,0xe2,0xf5,0x44,0xa4,0x6f,0x33,0xac,0xbb,0x15,0x3b,0x0a,0x1a,0x04,
+    0x6e,0xc2,0x54,0xa7,0x78,0x77,0x7d,0x32,0x21,0x4d,0x0c,0x3f,0x7b,0x0a,0x61,0x18,0x58,0xdb,0x59,0x02,0x3f,0xcf,0xb2,0xd0,
+    0x5c,0xa5,0xea,0x96,0xd4,0x5c,0xd2,0x09,0xd3,0x18,0x61,0x73,0x6e,0x9f,0xdf,0xcb,0x17,0x4f,0xd1,0xc0,0xa2,0x2d,0x8b,0xf5,
+    0x46,0xdf,0xf8,0xb8,0x4f,0x47,0x98,0xf4,0x44,0xa6,0xa1,0x5b,0xcb,0xfa,0xc1,0x31,0x4e,0xc4,0x03,0xea,0x06,0x1b,0x9b,0x94,
+    0xa6,0xc8,0x1c,0x7a,0x69,0x3b,0x8d,0x8d,0x83,0x20,0x56,0x18,0xf1,0xe0,0xd2,0xfb,0xbc,0xaf,0xf7,0xdc,0x17,0x3b,0xcd,0xac,
+    0x2b,0x07,0x86,0xc6,0x7f,0x25,0xc3,0xa2,0x6c,0x7c,0x49,0xa9,0xc1,0xe2,0x5e,0x40,0x05,0xfb,0x2f,0xab,0xd5,0x98,0x3a,0x69,
+    0xbb,0x83,0x1c,0xbd,0xde,0x55,0xc0,0x74,0x71,0x8d,0xdb,0xc7,0x95,0xf4,0xf5,0xca,0x30,0x82,0x05,0x56,0x06,0x09,0x2a,0x86,
+    0x48,0x86,0xf7,0x0d,0x01,0x07,0x02,0xa0,0x82,0x05,0x47,0x30,0x82,0x05,0x43,0x02,0x01,0x01,0x31,0x0f,0x30,0x0d,0x06,0x09,
+    0x60,0x86,0x48,0x01,0x65,0x03,0x04,0x02,0x01,0x05,0x00,0x30,0x5c,0x06,0x0a,0x2b,0x06,0x01,0x04,0x01,0x82,0x37,0x02,0x01,
+    0x04,0xa0,0x4e,0x30,0x4c,0x30,0x17,0x06,0x0a,0x2b,0x06,0x01,0x04,0x01,0x82,0x37,0x02,0x01,0x0f,0x30,0x09,0x03,0x01,0x00,
+    0xa0,0x04,0xa2,0x02,0x80,0x00,0x30,0x31,0x30,0x0d,0x06,0x09,0x60,0x86,0x48,0x01,0x65,0x03,0x04,0x02,0x01,0x05,0x00,0x04,
+    0x20,0xdd,0x8b,0xd7,0x29,0x3b,0xae,0x16,0xec,0xbb,0x81,0x80,0x55,0x15,0xd8,0x87,0xa5,0x3e,0xeb,0x0b,0x74,0x59,0xb6,0x56,
+    0xf1,0x0b,0x2e,0xe1,0xb4,0x42,0x4d,0x8b,0x18,0xa0,0x82,0x03,0x05,0x30,0x82,0x03,0x01,0x30,0x82,0x01,0xe9,0xa0,0x03,0x02,
+    0x01,0x02,0x02,0x10,0xae,0xfb,0x3e,0x08,0x15,0xa4,0xe3,0xa7,0x4d,0x91,0x6a,0x85,0x68,0x5b,0x58,0xa1,0x30,0x0d,0x06,0x09,
+    0x2a,0x86,0x48,0x86,0xf7,0x0d,0x01,0x01,0x0b,0x05,0x00,0x30,0x12,0x31,0x10,0x30,0x0e,0x06,0x03,0x55,0x04,0x03,0x13,0x07,
+    0x54,0x65,0x73,0x74,0x20,0x43,0x41,0x30,0x1e,0x17,0x0d,0x32,0x32,0x30,0x39,0x33,0x30,0x31,0x37,0x32,0x33,0x30,0x33,0x5a,
+    0x17,0x0d,0x33,0x39,0x31,0x32,0x33,0x31,0x32,0x33,0x35,0x39,0x35,0x39,0x5a,0x30,0x10,0x31,0x0e,0x30,0x0c,0x06,0x03,0x55,
+    0x04,0x03,0x13,0x05,0x63,0x65,0x72,0x74,0x32,0x30,0x82,0x01,0x22,0x30,0x0d,0x06,0x09,0x2a,0x86,0x48,0x86,0xf7,0x0d,0x01,
+    0x01,0x01,0x05,0x00,0x03,0x82,0x01,0x0f,0x00,0x30,0x82,0x01,0x0a,0x02,0x82,0x01,0x01,0x00,0xca,0x01,0x2f,0x98,0x69,0x71,
+    0x64,0x63,0x56,0x38,0xd7,0xc4,0xad,0x64,0x02,0x34,0xd4,0x31,0xc2,0x27,0x5d,0xd7,0x8f,0x72,0xd0,0x70,0x95,0xd9,0x75,0x65,
+    0x2e,0x8c,0x5b,0x76,0xcd,0x54,0x3f,0xd9,0x0a,0xcc,0x3f,0x03,0x8f,0x74,0x2b,0x8c,0x3d,0x3d,0x4c,0xd3,0xaa,0x3c,0x97,0xf1,
+    0x44,0x46,0x57,0x92,0xa9,0xdd,0xd9,0xf0,0xc7,0x8b,0x39,0xf5,0x8d,0x28,0x41,0x18,0xaf,0xca,0x99,0xd1,0xf1,0xe4,0xab,0x93,
+    0x0a,0xb6,0xd4,0xad,0x2b,0x9f,0x60,0x27,0x4c,0xf2,0xc9,0x14,0xde,0xf2,0xc6,0xbe,0x82,0x14,0x83,0x65,0x13,0x9f,0x9c,0x8d,
+    0xfa,0xac,0x95,0x12,0x00,0xd0,0xa4,0x36,0x4d,0xf0,0x8f,0xfc,0x1a,0x43,0x47,0xc3,0xff,0xce,0x1b,0x24,0xd6,0xcf,0x63,0xd1,
+    0x41,0x23,0xb8,0x62,0x5f,0x31,0x4e,0x30,0x3f,0x63,0x64,0xff,0x72,0xb5,0x9d,0xe5,0xaa,0x22,0xbc,0x1d,0xb3,0x23,0xc9,0x16,
+    0x49,0x10,0xed,0x51,0x02,0xd2,0x90,0xc6,0x86,0x47,0x40,0x7e,0xf1,0xcf,0xc1,0x17,0xa0,0x72,0xaf,0x40,0xb1,0x23,0x3d,0x5a,
+    0xa1,0xf9,0xed,0xc8,0xb6,0x66,0xa7,0x94,0x39,0x09,0x03,0x6d,0x16,0x4e,0xc4,0x2a,0x4b,0x1f,0x5b,0x22,0x39,0xf7,0x60,0x1c,
+    0x71,0x65,0x4c,0x11,0x29,0x59,0x96,0x5e,0x9e,0xfe,0xaf,0x23,0xd1,0xe3,0x2c,0xce,0xd2,0x31,0x8c,0x80,0x29,0x6c,0x82,0x99,
+    0xe8,0x68,0xbd,0x7e,0x66,0xaa,0x35,0x0c,0xae,0x61,0xde,0x59,0x7d,0x5b,0x16,0x09,0x07,0x52,0x6a,0x14,0x26,0x3c,0x48,0x3e,
+    0x03,0xdb,0xd4,0x8a,0xea,0x0e,0x46,0x1a,0x24,0xbd,0x02,0x03,0x01,0x00,0x01,0xa3,0x55,0x30,0x53,0x30,0x0c,0x06,0x03,0x55,
+    0x1d,0x13,0x01,0x01,0xff,0x04,0x02,0x30,0x00,0x30,0x43,0x06,0x03,0x55,0x1d,0x01,0x04,0x3c,0x30,0x3a,0x80,0x10,0x88,0x17,
+    0xf7,0x38,0x65,0x8b,0x78,0x78,0xf6,0x77,0xe3,0x25,0x47,0x54,0x33,0x4c,0xa1,0x14,0x30,0x12,0x31,0x10,0x30,0x0e,0x06,0x03,
+    0x55,0x04,0x03,0x13,0x07,0x54,0x65,0x73,0x74,0x20,0x43,0x41,0x82,0x10,0x2b,0x59,0xb4,0xc7,0xe2,0xce,0x08,0x97,0x46,0x48,
+    0x32,0x17,0x0f,0x97,0xc5,0x08,0x30,0x0d,0x06,0x09,0x2a,0x86,0x48,0x86,0xf7,0x0d,0x01,0x01,0x0b,0x05,0x00,0x03,0x82,0x01,
+    0x01,0x00,0xd1,0x0d,0xdd,0x83,0x0c,0xd8,0xf9,0x0c,0x71,0xe3,0x2f,0x7c,0xc9,0xd7,0x8e,0x33,0x27,0xb6,0x6b,0x34,0x3c,0x41,
+    0xf0,0x13,0x03,0xd6,0x5a,0xe2,0x55,0x12,0x42,0x06,0x20,0x03,0xb1,0x74,0xc7,0xc0,0x08,0x00,0x21,0xbe,0x90,0xe7,0xfd,0xac,
+    0xe0,0x67,0x42,0xe7,0x53,0x86,0xcf,0x53,0x55,0x40,0xf1,0xbc,0xfc,0x87,0xab,0x67,0xb6,0x09,0xe1,0xf1,0xa2,0xce,0xf6,0xbf,
+    0xe6,0x1d,0x43,0x4f,0x41,0xf0,0xf5,0xc0,0xfa,0xc5,0xd2,0x14,0x2d,0xd9,0x23,0x8e,0x9c,0xeb,0x68,0xff,0x3c,0x5f,0x18,0xca,
+    0x4b,0x09,0xad,0xcd,0xbd,0x23,0x62,0x33,0x4e,0x02,0x10,0xf9,0xe3,0x68,0x6f,0x22,0xb0,0x86,0x0b,0x5a,0xbe,0xd3,0xee,0x8a,
+    0x0b,0x4c,0x92,0x9e,0x06,0x31,0x1f,0x95,0x4f,0xbf,0x27,0x7f,0x1f,0xcd,0xcc,0x9c,0x70,0xa1,0x51,0x07,0x7a,0x09,0x36,0x3f,
+    0x0a,0x2f,0x16,0x77,0x26,0x9b,0xb4,0xc9,0x1e,0x86,0xe3,0xb3,0xb7,0xc3,0xcc,0xf1,0x44,0x6e,0x2e,0xf4,0xc9,0x5b,0x23,0x08,
+    0x0a,0xc0,0xdb,0xc1,0x1a,0x37,0xb3,0xb1,0x91,0xce,0x24,0x26,0x56,0x7f,0x26,0x37,0x88,0xa0,0x02,0x37,0x6e,0x9c,0xca,0xc1,
+    0x8c,0x19,0x99,0xca,0x6c,0x9a,0x98,0x75,0x89,0xfc,0x6d,0x92,0xfc,0xb5,0x12,0x5b,0x29,0xb1,0x88,0x68,0x3b,0xef,0xf0,0xc0,
+    0x8f,0x82,0x5e,0x33,0xf9,0x67,0x6b,0xe8,0x60,0x1b,0x14,0xec,0x9c,0xdf,0x21,0x38,0xbb,0x0d,0x3f,0xd9,0xbc,0xd2,0x01,0x2a,
+    0x92,0x0c,0xc2,0x97,0x2e,0x12,0x22,0x54,0x76,0xeb,0x80,0x51,0x99,0x9d,0x0f,0x26,0x12,0xb7,0x31,0x82,0x01,0xc4,0x30,0x82,
+    0x01,0xc0,0x02,0x01,0x01,0x30,0x26,0x30,0x12,0x31,0x10,0x30,0x0e,0x06,0x03,0x55,0x04,0x03,0x13,0x07,0x54,0x65,0x73,0x74,
+    0x20,0x43,0x41,0x02,0x10,0xae,0xfb,0x3e,0x08,0x15,0xa4,0xe3,0xa7,0x4d,0x91,0x6a,0x85,0x68,0x5b,0x58,0xa1,0x30,0x0d,0x06,
+    0x09,0x60,0x86,0x48,0x01,0x65,0x03,0x04,0x02,0x01,0x05,0x00,0xa0,0x71,0x30,0x10,0x06,0x0a,0x2b,0x06,0x01,0x04,0x01,0x82,
+    0x37,0x02,0x01,0x0c,0x31,0x02,0x30,0x00,0x30,0x11,0x06,0x0a,0x2a,0x86,0x48,0x86,0xf7,0x0d,0x01,0x09,0x19,0x04,0x31,0x03,
+    0x02,0x01,0x01,0x30,0x19,0x06,0x09,0x2a,0x86,0x48,0x86,0xf7,0x0d,0x01,0x09,0x03,0x31,0x0c,0x06,0x0a,0x2b,0x06,0x01,0x04,
+    0x01,0x82,0x37,0x02,0x01,0x04,0x30,0x2f,0x06,0x09,0x2a,0x86,0x48,0x86,0xf7,0x0d,0x01,0x09,0x04,0x31,0x22,0x04,0x20,0xcb,
+    0xa1,0x2f,0x7b,0x0f,0x6a,0x14,0x06,0x26,0x77,0x7b,0xee,0xd1,0x90,0x34,0x1c,0xa7,0xcd,0x94,0x65,0xe0,0xe4,0x24,0x12,0x0c,
+    0x4e,0xa2,0x89,0xeb,0x2d,0xe5,0xbb,0x30,0x0d,0x06,0x09,0x2a,0x86,0x48,0x86,0xf7,0x0d,0x01,0x01,0x01,0x05,0x00,0x04,0x82,
+    0x01,0x00,0x26,0x76,0xb3,0xf2,0xc9,0xb1,0x73,0x13,0xb5,0xd2,0xc5,0xb7,0x01,0x5c,0xc6,0x94,0x38,0x9f,0xc7,0x57,0x56,0x95,
+    0xb0,0xf4,0x6d,0xc2,0xd4,0x6a,0xf1,0x4d,0x09,0xa1,0x51,0xa6,0x91,0xf0,0x0e,0x84,0xc0,0x2c,0x74,0xa3,0x97,0x1f,0x41,0xe0,
+    0x4a,0xfa,0x1a,0x78,0xa9,0xd5,0x3c,0x85,0x29,0x2b,0xaf,0xbb,0xc3,0x61,0x0d,0x50,0x20,0x20,0xf5,0x80,0x0d,0x6a,0x15,0x4b,
+    0x38,0x6c,0x55,0xd9,0xf9,0xd0,0x44,0x22,0x46,0x98,0xe6,0x07,0xd4,0xba,0x3d,0x9d,0x50,0xa7,0x8e,0x1f,0xa8,0x82,0x25,0x7e,
+    0x39,0xda,0xe1,0x49,0xc7,0x24,0x3f,0x31,0xfb,0x4b,0xba,0x75,0xdb,0x10,0x0a,0xbe,0xc5,0xad,0x3e,0x30,0x16,0x9b,0x15,0xbb,
+    0xc0,0x59,0xf2,0xf5,0x4f,0xf5,0x56,0xc6,0x28,0xd0,0x1e,0x7d,0x8f,0x2e,0x2b,0xb6,0x76,0x94,0x52,0x87,0x99,0xa3,0x66,0x3d,
+    0x94,0x0d,0x73,0xb0,0xd5,0xd4,0x76,0x5b,0x69,0x95,0x0a,0x16,0x4f,0x5c,0xf4,0x95,0x5b,0x42,0x45,0x04,0x5c,0x53,0xb7,0x1a,
+    0x61,0x6c,0x82,0xdc,0x95,0x94,0x38,0x64,0x34,0x01,0x98,0x2e,0xf8,0xcf,0xf8,0x66,0xae,0xba,0xf8,0x70,0x9e,0x9e,0xde,0xa2,
+    0x7f,0x56,0x8d,0xd9,0x6a,0x7b,0x41,0x02,0x46,0x05,0x5c,0xba,0xed,0x43,0x98,0x56,0x39,0x52,0xc0,0x0b,0x3c,0xe1,0x7d,0x1b,
+    0xf5,0xac,0x03,0x5b,0xbb,0x7a,0x65,0x80,0x4b,0xcb,0xb7,0x51,0xa7,0x19,0x8a,0x38,0x75,0x76,0x75,0xc2,0x1f,0x12,0xc4,0x68,
+    0x96,0xe0,0x89,0x9f,0x37,0x3d,0xab,0xfd,0x6b,0x03,0xb3,0xa1,0x51,0xf8,0x69,0x17,0xea,0xff,0x00,0x00,0x00,0x00,0x00,0x00,
+};
+
 static void call_winverify(WCHAR *pathW, LONG *status, BOOL hash_only)
 {
     static GUID WVTPolicyGUID = WINTRUST_ACTION_GENERIC_VERIFY_V2;
@@ -1312,6 +1782,116 @@ static void test_get_known_usages(void)
      "expected ERROR_INVALID_PARAMETER, got %ld\n", GetLastError());
 }
 
+static void test_multiple_signatures(void)
+{
+    static const BYTE serials[][16] =
+    {
+        { 0xfa, 0x4b, 0x40, 0x69, 0x40, 0x4b, 0xc0, 0x44, 0xa2, 0x31, 0x3a, 0xa7, 0xaa, 0x97, 0x73, 0xd1, },
+        { 0xcc, 0x03, 0x6b, 0x72, 0x4a, 0x93, 0x42, 0x40, 0x8f, 0x93, 0x41, 0x68, 0xa9, 0xec, 0x01, 0x8d, },
+        { 0xa1, 0x58, 0x5b, 0x68, 0x85, 0x6a, 0x91, 0x4d, 0xa7, 0xe3, 0xa4, 0x15, 0x08, 0x3e, 0xfb, 0xae, },
+    };
+    static GUID WVTPolicyGUID = WINTRUST_ACTION_GENERIC_VERIFY_V2;
+    WINTRUST_SIGNATURE_SETTINGS settings = { sizeof(settings) };
+    WINTRUST_FILE_INFO file_info = { sizeof(file_info) };
+    WINTRUST_DATA data = { sizeof(data) };
+    CRYPT_PROVIDER_DATA *prov;
+    WCHAR pathW[MAX_PATH];
+    CERT_INFO *cert_info;
+    unsigned int i;
+    BYTE buf[4096];
+    DWORD written;
+    LONG status;
+    HANDLE file;
+    DWORD size;
+    BOOL bret;
+
+    file = create_temp_file(pathW);
+    ok(file != INVALID_HANDLE_VALUE, "Failed to create temporary file.\n");
+    bret = WriteFile(file, self_signed_3certs, sizeof(self_signed_3certs), &written, NULL);
+    ok(bret, "Failed, err %lu.\n", GetLastError());
+    CloseHandle(file);
+
+    file_info.pcwszFilePath = pathW;
+    data.dwUIChoice = WTD_UI_NONE;
+    data.fdwRevocationChecks = WTD_REVOKE_NONE;
+    data.dwUnionChoice = WTD_CHOICE_FILE;
+    data.pFile = &file_info;
+    data.dwStateAction = WTD_STATEACTION_VERIFY;
+    data.dwProvFlags = 0;
+    data.pSignatureSettings = &settings;
+
+    settings.cSecondarySigs = 0xcccccccc;
+    settings.dwVerifiedSigIndex = 0xcccccccc;
+    status = WinVerifyTrust(NULL, &WVTPolicyGUID, &data);
+    todo_wine ok(status == CERT_E_UNTRUSTEDROOT || status == CERT_E_CHAINING, "Failed, ret %#lx\n", status);
+    ok(settings.cSecondarySigs == 0xcccccccc, "Got %lu.\n", settings.cSecondarySigs);
+    todo_wine ok(settings.dwVerifiedSigIndex == 2, "Got %lu.\n", settings.dwVerifiedSigIndex);
+
+    prov = (CRYPT_PROVIDER_DATA *)data.hWVTStateData;
+    ok(prov->cbStruct == sizeof(*prov), "Got size %lu.\n", prov->cbStruct);
+    ok(prov->csSigners == 1, "Got %lu.\n", prov->csSigners);
+    ok(prov->pSigSettings == &settings, "Got %p, expected %p.\n", prov->pSigSettings, &settings);
+    ok(!!prov->pSigState, "Got %p, expected %p.\n", prov->pSigSettings, &settings);
+    if (prov->cbStruct == sizeof(*prov) && prov->pSigState)
+    {
+        ok(prov->pSigState->cbStruct == sizeof(*prov->pSigState)
+                || broken(prov->pSigState->cbStruct == offsetof(CRYPT_PROVIDER_SIGSTATE, iAttemptCount)) /* Win7 */,
+                "Got %lu.\n", prov->pSigState->cbStruct);
+        ok(prov->pSigState->fSupportMultiSig, "Got %d.\n", prov->pSigState->fSupportMultiSig);
+        ok(prov->pSigState->dwCryptoPolicySupport == (WSS_SIGTRUST_SUPPORT | WSS_OBJTRUST_SUPPORT
+                | WSS_CERTTRUST_SUPPORT), "Got %#lx.\n", prov->pSigState->dwCryptoPolicySupport);
+        ok(prov->pSigState->cSecondarySigs == 2, "Got %lu.\n", prov->pSigState->cSecondarySigs);
+
+        size = sizeof(buf);
+        bret = CryptMsgGetParam(prov->pSigState->hPrimarySig, CMSG_SIGNER_CERT_INFO_PARAM, 0, buf, &size);
+        ok(bret, "Failed, err %#lx.\n", GetLastError());
+        cert_info = (CERT_INFO *)buf;
+        ok(cert_info->SerialNumber.cbData == sizeof(serials[0]), "Got %lu.\n", cert_info->SerialNumber.cbData);
+        ok(!memcmp(cert_info->SerialNumber.pbData, serials[0], sizeof(serials[0])), "Data does not match.\n");
+        for (i = 0; i < prov->pSigState->cSecondarySigs; ++i)
+        {
+            bret = CryptMsgGetParam(prov->pSigState->rhSecondarySigs[i], CMSG_SIGNER_CERT_INFO_PARAM, 0, buf, &size);
+            ok(bret, "Failed, err %#lx.\n", GetLastError());
+            ok(cert_info->SerialNumber.cbData == sizeof(serials[0]), "Got %lu.\n", cert_info->SerialNumber.cbData);
+            ok(!memcmp(cert_info->SerialNumber.pbData, serials[i + 1], sizeof(serials[0])), "Data does not match.\n");
+        }
+    }
+
+    data.dwStateAction = WTD_STATEACTION_CLOSE;
+    status = WinVerifyTrust(NULL, &WVTPolicyGUID, &data);
+    ok(status == S_OK, "Failed, ret %#lx\n", status);
+
+    data.dwStateAction = WTD_STATEACTION_VERIFY;
+    settings.dwFlags = WSS_GET_SECONDARY_SIG_COUNT;
+    settings.cSecondarySigs = 0xcccccccc;
+    settings.dwVerifiedSigIndex = 0xcccccccc;
+    status = WinVerifyTrust(NULL, &WVTPolicyGUID, &data);
+    todo_wine ok(status == CERT_E_UNTRUSTEDROOT || status == CERT_E_CHAINING, "Failed, ret %#lx\n", status);
+    ok(settings.cSecondarySigs == 2, "Got %lu.\n", settings.cSecondarySigs);
+    todo_wine ok(settings.dwVerifiedSigIndex == 2, "Got %lu.\n", settings.dwVerifiedSigIndex);
+
+    data.dwStateAction = WTD_STATEACTION_CLOSE;
+    status = WinVerifyTrust(NULL, &WVTPolicyGUID, &data);
+    ok(status == S_OK, "Failed, ret %#lx\n", status);
+
+    data.dwStateAction = WTD_STATEACTION_VERIFY;
+    settings.dwFlags = WSS_VERIFY_SPECIFIC | WSS_GET_SECONDARY_SIG_COUNT;
+    settings.cSecondarySigs = 0xcccccccc;
+    settings.dwVerifiedSigIndex = 0xcccccccc;
+    settings.dwIndex = 1;
+    status = WinVerifyTrust(NULL, &WVTPolicyGUID, &data);
+    todo_wine ok(status == CERT_E_UNTRUSTEDROOT || status == CERT_E_CHAINING, "Failed, ret %#lx\n", status);
+    ok(settings.cSecondarySigs == 2, "Got %lu.\n", settings.cSecondarySigs);
+    todo_wine ok(settings.dwVerifiedSigIndex == 1, "Got %lu.\n", settings.dwVerifiedSigIndex);
+    settings.dwIndex = 0;
+
+    data.dwStateAction = WTD_STATEACTION_CLOSE;
+    status = WinVerifyTrust(NULL, &WVTPolicyGUID, &data);
+    ok(status == S_OK, "Failed, ret %#lx\n", status);
+
+    DeleteFileW(pathW);
+}
+
 START_TEST(softpub)
 {
     InitFunctionPtrs();
@@ -1320,4 +1900,5 @@ START_TEST(softpub)
     test_wintrust();
     test_wintrust_digest();
     test_get_known_usages();
+    test_multiple_signatures();
 }
diff --git a/dlls/wintrust/wintrust_main.c b/dlls/wintrust/wintrust_main.c
index 33695008b24..925ae7ca85a 100644
--- wine/dlls/wintrust/wintrust_main.c
+++ wine/dlls/wintrust/wintrust_main.c
@@ -294,6 +294,10 @@ static LONG WINTRUST_DefaultVerify(HWND hwnd, GUID *actionID,
 
     data->hWVTStateData = provData;
     provData->pWintrustData = data;
+
+    if (WVT_ISINSTRUCT(WINTRUST_DATA, data->cbStruct, pSignatureSettings))
+        provData->pSigSettings = data->pSignatureSettings;
+
     if (hwnd == INVALID_HANDLE_VALUE)
         provData->hWndParent = GetDesktopWindow();
     else
diff --git a/include/wincrypt.h b/include/wincrypt.h
index db2c30c7d68..29735f6225d 100644
--- wine/include/wincrypt.h
+++ wine/include/wincrypt.h
@@ -21,8 +21,6 @@
 #ifndef __WINE_WINCRYPT_H
 #define __WINE_WINCRYPT_H
 
-#include "wine/winheader_enter.h"
-
 #ifdef __cplusplus
 extern "C" {
 #endif
@@ -1088,6 +1086,7 @@ typedef struct _CERT_CHAIN_POLICY_STATUS {
 #define CERT_CHAIN_POLICY_TRUST_TESTROOT_FLAG                    0x00004000
 #define CERT_CHAIN_POLICY_ALLOW_TESTROOT_FLAG                    0x00008000
 #define MICROSOFT_ROOT_CERT_CHAIN_POLICY_ENABLE_TEST_ROOT_FLAG   0x00010000
+#define MICROSOFT_ROOT_CERT_CHAIN_POLICY_CHECK_APPLICATION_ROOT_FLAG 0x00020000
 
 typedef struct _AUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_PARA {
     DWORD             cbSize;
@@ -3353,8 +3352,10 @@ typedef struct _CTL_FIND_SUBJECT_PARA
 #define CERT_NAME_URL_TYPE              7
 #define CERT_NAME_UPN_TYPE              8
 
-#define CERT_NAME_ISSUER_FLAG           0x00000001
-#define CERT_NAME_DISABLE_IE4_UTF8_FLAG 0x00010000
+#define CERT_NAME_ISSUER_FLAG              0x00000001
+#define CERT_NAME_SEARCH_ALL_NAMES_FLAG    0x00000002
+#define CERT_NAME_DISABLE_IE4_UTF8_FLAG    0x00010000
+#define CERT_NAME_STR_ENABLE_PUNYCODE_FLAG 0x00200000
 
 /* CryptFormatObject flags */
 #define CRYPT_FORMAT_STR_MULTI_LINE 0x0001
@@ -4695,6 +4696,4 @@ HRESULT WINAPI FindCertsByIssuer(PCERT_CHAIN pCertChains, DWORD *pcbCertChains,
 }
 #endif
 
-#include "wine/winheader_exit.h"
-
 #endif
diff --git a/include/wintrust.h b/include/wintrust.h
index 28df37c1626..eeb149822b4 100644
--- wine/include/wintrust.h
+++ wine/include/wintrust.h
@@ -19,8 +19,6 @@
 #ifndef __WINE_WINTRUST_H
 #define __WINE_WINTRUST_H
 
-#include "wine/winheader_enter.h"
-
 #include <wincrypt.h>
 
 
@@ -477,6 +475,8 @@ CRYPT_PROVIDER_SGNR * WINAPI WTHelperGetProvSignerFromChain(
 CRYPT_PROVIDER_DATA * WINAPI WTHelperProvDataFromStateData(HANDLE hStateData);
 CRYPT_PROVIDER_PRIVDATA * WINAPI WTHelperGetProvPrivateDataFromChain(CRYPT_PROVIDER_DATA *,GUID *);
 
+#define szOID_NESTED_SIGNATURE       "1.3.6.1.4.1.311.2.4.1"
+
 #define SPC_INDIRECT_DATA_OBJID      "1.3.6.1.4.1.311.2.1.4"
 #define SPC_SP_AGENCY_INFO_OBJID     "1.3.6.1.4.1.311.2.1.10"
 #define SPC_STATEMENT_TYPE_OBJID     "1.3.6.1.4.1.311.2.1.11"
@@ -664,6 +664,4 @@ typedef struct _WIN_TRUST_SUBJECT_FILE_AND_DISPLAY
 }
 #endif
 
-#include "wine/winheader_exit.h"
-
 #endif
-- 
2.39.2 (Apple Git-144)

diff --git a/configure b/configure
index 24f958073a0..cdf99fc287d 100755
--- wine/configure
+++ wine/configure
@@ -950,6 +950,7 @@ enable_amstream
 enable_apisetschema
 enable_apphelp
 enable_appwiz_cpl
+enable_atiadlxx
 enable_api_ms_win_core_psm_appnotify_l1_1_0
 enable_api_ms_win_power_base_l1_1_0
 enable_atl
@@ -21778,6 +21779,7 @@ wine_fn_config_makefile dlls/apisetschema enable_apisetschema
 wine_fn_config_makefile dlls/apphelp enable_apphelp
 wine_fn_config_makefile dlls/apphelp/tests enable_tests
 wine_fn_config_makefile dlls/appwiz.cpl enable_appwiz_cpl
+wine_fn_config_makefile dlls/atiadlxx enable_atiadlxx
 wine_fn_config_makefile dlls/api-ms-win-core-psm-appnotify-l1-1-0 enable_api_ms_win_core_psm_appnotify_l1_1_0
 wine_fn_config_makefile dlls/api-ms-win-power-base-l1-1-0 enable_api_ms_win_power_base_l1_1_0
 wine_fn_config_makefile dlls/atl enable_atl
diff --git a/configure.ac b/configure.ac
index 58063421cce..c05d5b6f539 100644
--- wine/configure.ac
+++ wine/configure.ac
@@ -2424,6 +2424,7 @@ WINE_CONFIG_MAKEFILE(dlls/apisetschema)
 WINE_CONFIG_MAKEFILE(dlls/apphelp)
 WINE_CONFIG_MAKEFILE(dlls/apphelp/tests)
 WINE_CONFIG_MAKEFILE(dlls/appwiz.cpl)
+WINE_CONFIG_MAKEFILE(dlls/atiadlxx)
 WINE_CONFIG_MAKEFILE(dlls/api-ms-win-power-base-l1-1-0)
 WINE_CONFIG_MAKEFILE(dlls/atl)
 WINE_CONFIG_MAKEFILE(dlls/atl/tests)
diff --git a/dlls/atiadlxx/Makefile.in b/dlls/atiadlxx/Makefile.in
new file mode 100644
index 00000000000..fd9b8abf626
--- /dev/null
+++ wine/dlls/atiadlxx/Makefile.in
@@ -0,0 +1,8 @@
+EXTRADEFS = -DWINE_NO_LONG_TYPES
+MODULE = atiadlxx.dll
+IMPORTS = dxgi
+
+EXTRADLLFLAGS = -mno-cygwin -Wb,--prefer-native
+
+C_SRCS = \
+	atiadlxx_main.c
diff --git a/dlls/atiadlxx/atiadlxx.spec b/dlls/atiadlxx/atiadlxx.spec
new file mode 100644
index 00000000000..1e447f38ded
--- /dev/null
+++ wine/dlls/atiadlxx/atiadlxx.spec
@@ -0,0 +1,1138 @@
+@ stub ADL2_ADC_CurrentProfileFromDrv_Get
+@ stub ADL2_ADC_Display_AdapterDeviceProfileEx_Get
+@ stub ADL2_ADC_DrvDataToProfile_Copy
+@ stub ADL2_ADC_FindClosestMode_Get
+@ stub ADL2_ADC_IsDevModeEqual_Get
+@ stub ADL2_ADC_Profile_Apply
+@ stub ADL2_APO_AudioDelayAdjustmentInfo_Get
+@ stub ADL2_APO_AudioDelay_Restore
+@ stub ADL2_APO_AudioDelay_Set
+@ stub ADL2_AdapterLimitation_Caps
+@ stub ADL2_AdapterX2_Caps
+@ stub ADL2_Adapter_AMDAndNonAMDDIsplayClone_Get
+@ stub ADL2_Adapter_ASICFamilyType_Get
+@ stub ADL2_Adapter_ASICInfo_Get
+@ stub ADL2_Adapter_Accessibility_Get
+@ stub ADL2_Adapter_AceDefaults_Restore
+@ stub ADL2_Adapter_Active_Get
+@ stub ADL2_Adapter_Active_Set
+@ stub ADL2_Adapter_Active_SetPrefer
+@ stub ADL2_Adapter_AdapterInfoX2_Get
+@ stub ADL2_Adapter_AdapterInfoX3_Get
+@ stub ADL2_Adapter_AdapterInfoX4_Get
+@ stub ADL2_Adapter_AdapterInfo_Get
+@ stub ADL2_Adapter_AdapterList_Disable
+@ stub ADL2_Adapter_AdapterLocationPath_Get
+@ stub ADL2_Adapter_Aspects_Get
+@ stub ADL2_Adapter_AudioChannelSplitConfiguration_Get
+@ stub ADL2_Adapter_AudioChannelSplit_Disable
+@ stub ADL2_Adapter_AudioChannelSplit_Enable
+@ stub ADL2_Adapter_BigSw_Info_Get
+@ stub ADL2_Adapter_BlackAndWhiteLevelSupport_Get
+@ stub ADL2_Adapter_BlackAndWhiteLevel_Get
+@ stub ADL2_Adapter_BlackAndWhiteLevel_Set
+@ stub ADL2_Adapter_BoardLayout_Get
+@ stub ADL2_Adapter_Caps
+@ stub ADL2_Adapter_ChipSetInfo_Get
+@ stub ADL2_Adapter_CloneTypes_Get
+@ stub ADL2_Adapter_ConfigMemory_Cap
+@ stub ADL2_Adapter_ConfigMemory_Get
+@ stub ADL2_Adapter_ConfigureState_Get
+@ stub ADL2_Adapter_ConnectionData_Get
+@ stub ADL2_Adapter_ConnectionData_Remove
+@ stub ADL2_Adapter_ConnectionData_Set
+@ stub ADL2_Adapter_ConnectionState_Get
+@ stub ADL2_Adapter_CrossDisplayPlatformInfo_Get
+@ stub ADL2_Adapter_CrossGPUClone_Disable
+@ stub ADL2_Adapter_CrossdisplayAdapterRole_Caps
+@ stub ADL2_Adapter_CrossdisplayInfoX2_Set
+@ stub ADL2_Adapter_CrossdisplayInfo_Get
+@ stub ADL2_Adapter_CrossdisplayInfo_Set
+@ stub ADL2_Adapter_CrossfireX2_Get
+@ stub ADL2_Adapter_Crossfire_Caps
+@ stub ADL2_Adapter_Crossfire_Get
+@ stub ADL2_Adapter_Crossfire_Set
+@ stub ADL2_Adapter_DefaultAudioChannelTable_Load
+@ stub ADL2_Adapter_Desktop_Caps
+@ stub ADL2_Adapter_Desktop_SupportedSLSGridTypes_Get
+@ stub ADL2_Adapter_DeviceID_Get
+@ stub ADL2_Adapter_DisplayAudioEndpoint_Enable
+@ stub ADL2_Adapter_DisplayAudioEndpoint_Mute
+@ stub ADL2_Adapter_DisplayAudioInfo_Get
+@ stub ADL2_Adapter_DisplayGTCCaps_Get
+@ stub ADL2_Adapter_Display_Caps
+@ stub ADL2_Adapter_DriverSettings_Get
+@ stub ADL2_Adapter_DriverSettings_Set
+@ stub ADL2_Adapter_ECC_ErrorInjection_Set
+@ stub ADL2_Adapter_ECC_ErrorRecords_Get
+@ stub ADL2_Adapter_EDC_ErrorInjection_Set
+@ stub ADL2_Adapter_EDC_ErrorRecords_Get
+@ stub ADL2_Adapter_EDIDManagement_Caps
+@ stub ADL2_Adapter_EmulationMode_Set
+@ stub ADL2_Adapter_ExtInfo_Get
+@ stub ADL2_Adapter_Feature_Caps
+@ stub ADL2_Adapter_FrameMetrics_Caps
+@ stub ADL2_Adapter_FrameMetrics_FrameDuration_Disable
+@ stub ADL2_Adapter_FrameMetrics_FrameDuration_Enable
+@ stub ADL2_Adapter_FrameMetrics_FrameDuration_Get
+@ stub ADL2_Adapter_FrameMetrics_FrameDuration_Start
+@ stub ADL2_Adapter_FrameMetrics_FrameDuration_Stop
+@ stub ADL2_Adapter_FrameMetrics_Get
+@ stub ADL2_Adapter_FrameMetrics_Start
+@ stub ADL2_Adapter_FrameMetrics_Stop
+@ stub ADL2_Adapter_Gamma_Get
+@ stub ADL2_Adapter_Gamma_Set
+@ stub ADL2_Adapter_Graphic_Core_Info_Get
+@ stub ADL2_Adapter_HBC_Caps
+@ stub ADL2_Adapter_HBM_ECC_UC_Check
+@ stub ADL2_Adapter_Headless_Get
+@ stub ADL2_Adapter_ID_Get
+@ stub ADL2_Adapter_IsGamingDriver_Info_Get
+@ stub ADL2_Adapter_LocalDisplayConfig_Get
+@ stub ADL2_Adapter_LocalDisplayConfig_Set
+@ stub ADL2_Adapter_LocalDisplayState_Get
+@ stub ADL2_Adapter_MVPU_Set
+@ stub ADL2_Adapter_MaxCursorSize_Get
+@ stub ADL2_Adapter_MemoryInfo2_Get
+@ stub ADL2_Adapter_MemoryInfo_Get
+@ stub ADL2_Adapter_MirabilisSupport_Get
+@ stub ADL2_Adapter_ModeSwitch
+@ stub ADL2_Adapter_ModeTimingOverride_Caps
+@ stub ADL2_Adapter_Modes_ReEnumerate
+@ stub ADL2_Adapter_NumberOfActivatableSources_Get
+@ stdcall ADL2_Adapter_NumberOfAdapters_Get(ptr ptr)
+@ stub ADL2_Adapter_ObservedClockInfo_Get
+@ stub ADL2_Adapter_PMLog_Start
+@ stub ADL2_Adapter_PMLog_Stop
+@ stub ADL2_Adapter_PMLog_Support_Get
+@ stub ADL2_Adapter_PreFlipPostProcessing_Disable
+@ stub ADL2_Adapter_PreFlipPostProcessing_Enable
+@ stub ADL2_Adapter_PreFlipPostProcessing_Get_Status
+@ stub ADL2_Adapter_PreFlipPostProcessing_Select_LUT_Algorithm
+@ stub ADL2_Adapter_PreFlipPostProcessing_Select_LUT_Buffer
+@ stub ADL2_Adapter_PreFlipPostProcessing_Unselect_LUT_Buffer
+@ stub ADL2_Adapter_Primary_Get
+@ stub ADL2_Adapter_Primary_Set
+@ stub ADL2_Adapter_RAS_ErrorInjection_Set
+@ stub ADL2_Adapter_RegValueInt_Get
+@ stub ADL2_Adapter_RegValueInt_Set
+@ stub ADL2_Adapter_RegValueString_Get
+@ stub ADL2_Adapter_RegValueString_Set
+@ stub ADL2_Adapter_SWInfo_Get
+@ stub ADL2_Adapter_Speed_Caps
+@ stub ADL2_Adapter_Speed_Get
+@ stub ADL2_Adapter_Speed_Set
+@ stub ADL2_Adapter_SupportedConnections_Get
+@ stub ADL2_Adapter_TRNG_Get
+@ stub ADL2_Adapter_Tear_Free_Cap
+@ stub ADL2_Adapter_VRAMUsage_Get
+@ stub ADL2_Adapter_VariBrightEnable_Set
+@ stub ADL2_Adapter_VariBrightLevel_Get
+@ stub ADL2_Adapter_VariBrightLevel_Set
+@ stub ADL2_Adapter_VariBright_Caps
+@ stub ADL2_Adapter_VerndorID_Int_get
+@ stub ADL2_Adapter_VideoBiosInfo_Get
+@ stub ADL2_Adapter_VideoTheaterModeInfo_Get
+@ stub ADL2_Adapter_VideoTheaterModeInfo_Set
+@ stub ADL2_Adapter_XConnectSupport_Get
+@ stub ADL2_ApplicationProfilesX2_AppInterceptionList_Set
+@ stub ADL2_ApplicationProfilesX2_AppStartStopInfo_Get
+@ stub ADL2_ApplicationProfiles_AppInterceptionList_Set
+@ stub ADL2_ApplicationProfiles_AppInterception_Set
+@ stub ADL2_ApplicationProfiles_AppStartStopInfo_Get
+@ stub ADL2_ApplicationProfiles_AppStartStop_Resume
+@ stub ADL2_ApplicationProfiles_Applications_Get
+@ stub ADL2_ApplicationProfiles_ConvertToCompact
+@ stub ADL2_ApplicationProfiles_DriverAreaPrivacy_Get
+@ stub ADL2_ApplicationProfiles_GetCustomization
+@ stub ADL2_ApplicationProfiles_HitListsX2_Get
+@ stub ADL2_ApplicationProfiles_HitListsX3_Get
+@ stub ADL2_ApplicationProfiles_HitLists_Get
+@ stub ADL2_ApplicationProfiles_ProfileApplicationX2_Assign
+@ stub ADL2_ApplicationProfiles_ProfileApplication_Assign
+@ stub ADL2_ApplicationProfiles_ProfileOfAnApplicationX2_Search
+@ stub ADL2_ApplicationProfiles_ProfileOfAnApplication_InMemorySearch
+@ stub ADL2_ApplicationProfiles_ProfileOfAnApplication_Search
+@ stub ADL2_ApplicationProfiles_Profile_Create
+@ stub ADL2_ApplicationProfiles_Profile_Exist
+@ stub ADL2_ApplicationProfiles_Profile_Remove
+@ stub ADL2_ApplicationProfiles_PropertyType_Get
+@ stub ADL2_ApplicationProfiles_Release_Get
+@ stub ADL2_ApplicationProfiles_RemoveApplication
+@ stub ADL2_ApplicationProfiles_StatusInfo_Get
+@ stub ADL2_ApplicationProfiles_System_Reload
+@ stub ADL2_ApplicationProfiles_User_Load
+@ stub ADL2_ApplicationProfiles_User_Unload
+@ stub ADL2_Audio_CurrentSampleRate_Get
+@ stub ADL2_AutoTuningResult_Get
+@ stub ADL2_BOOST_Settings_Get
+@ stub ADL2_BOOST_Settings_Set
+@ stub ADL2_Blockchain_BlockchainMode_Caps
+@ stub ADL2_Blockchain_BlockchainMode_Get
+@ stub ADL2_Blockchain_BlockchainMode_Set
+@ stub ADL2_Blockchain_Hashrate_Set
+@ stub ADL2_CDS_UnsafeMode_Set
+@ stub ADL2_CHILL_SettingsX2_Get
+@ stub ADL2_CHILL_SettingsX2_Set
+@ stub ADL2_CV_DongleSettings_Get
+@ stub ADL2_CV_DongleSettings_Reset
+@ stub ADL2_CV_DongleSettings_Set
+@ stub ADL2_Chill_Caps_Get
+@ stub ADL2_Chill_Settings_Get
+@ stub ADL2_Chill_Settings_Notify
+@ stub ADL2_Chill_Settings_Set
+@ stub ADL2_CustomFan_Caps
+@ stub ADL2_CustomFan_Get
+@ stub ADL2_CustomFan_Set
+@ stub ADL2_DELAG_Settings_Get
+@ stub ADL2_DELAG_Settings_Set
+@ stub ADL2_DFP_AllowOnlyCETimings_Get
+@ stub ADL2_DFP_AllowOnlyCETimings_Set
+@ stub ADL2_DFP_BaseAudioSupport_Get
+@ stub ADL2_DFP_GPUScalingEnable_Get
+@ stub ADL2_DFP_GPUScalingEnable_Set
+@ stub ADL2_DFP_HDMISupport_Get
+@ stub ADL2_DFP_MVPUAnalogSupport_Get
+@ stub ADL2_DFP_PixelFormat_Caps
+@ stub ADL2_DFP_PixelFormat_Get
+@ stub ADL2_DFP_PixelFormat_Set
+@ stub ADL2_DVRSupport_Get
+@ stub ADL2_Desktop_DOPP_Enable
+@ stub ADL2_Desktop_DOPP_EnableX2
+@ stub ADL2_Desktop_Detach
+@ stub ADL2_Desktop_Device_Create
+@ stub ADL2_Desktop_Device_Destroy
+@ stub ADL2_Desktop_ExclusiveModeX2_Get
+@ stub ADL2_Desktop_HardwareCursor_SetBitmap
+@ stub ADL2_Desktop_HardwareCursor_SetPosition
+@ stub ADL2_Desktop_HardwareCursor_Toggle
+@ stub ADL2_Desktop_PFPAComplete_Set
+@ stub ADL2_Desktop_PFPAState_Get
+@ stub ADL2_Desktop_PrimaryInfo_Get
+@ stub ADL2_Desktop_TextureState_Get
+@ stub ADL2_Desktop_Texture_Enable
+@ stub ADL2_Device_PMLog_Device_Create
+@ stub ADL2_Device_PMLog_Device_Destroy
+@ stub ADL2_DisplayScaling_Set
+@ stub ADL2_Display_AdapterID_Get
+@ stub ADL2_Display_AdjustCaps_Get
+@ stub ADL2_Display_AdjustmentCoherent_Get
+@ stub ADL2_Display_AdjustmentCoherent_Set
+@ stub ADL2_Display_AudioMappingInfo_Get
+@ stub ADL2_Display_AvivoColor_Get
+@ stub ADL2_Display_AvivoCurrentColor_Set
+@ stub ADL2_Display_AvivoDefaultColor_Set
+@ stub ADL2_Display_BackLight_Get
+@ stub ADL2_Display_BackLight_Set
+@ stub ADL2_Display_BezelOffsetSteppingSize_Get
+@ stub ADL2_Display_BezelOffset_Set
+@ stub ADL2_Display_BezelSupported_Validate
+@ stub ADL2_Display_Capabilities_Get
+@ stub ADL2_Display_ColorCaps_Get
+@ stub ADL2_Display_ColorDepth_Get
+@ stub ADL2_Display_ColorDepth_Set
+@ stub ADL2_Display_ColorTemperatureSourceDefault_Get
+@ stub ADL2_Display_ColorTemperatureSource_Get
+@ stub ADL2_Display_ColorTemperatureSource_Set
+@ stub ADL2_Display_Color_Get
+@ stub ADL2_Display_Color_Set
+@ stub ADL2_Display_ConnectedDisplays_Get
+@ stub ADL2_Display_ContainerID_Get
+@ stub ADL2_Display_ControllerOverlayAdjustmentCaps_Get
+@ stub ADL2_Display_ControllerOverlayAdjustmentData_Get
+@ stub ADL2_Display_ControllerOverlayAdjustmentData_Set
+@ stub ADL2_Display_CustomizedModeListNum_Get
+@ stub ADL2_Display_CustomizedModeList_Get
+@ stub ADL2_Display_CustomizedMode_Add
+@ stub ADL2_Display_CustomizedMode_Delete
+@ stub ADL2_Display_CustomizedMode_Validate
+@ stub ADL2_Display_DCE_Get
+@ stub ADL2_Display_DCE_Set
+@ stub ADL2_Display_DDCBlockAccess_Get
+@ stub ADL2_Display_DDCInfo2_Get
+@ stub ADL2_Display_DDCInfo_Get
+@ stub ADL2_Display_Deflicker_Get
+@ stub ADL2_Display_Deflicker_Set
+@ stub ADL2_Display_DeviceConfig_Get
+@ stub ADL2_Display_DisplayContent_Cap
+@ stub ADL2_Display_DisplayContent_Get
+@ stub ADL2_Display_DisplayContent_Set
+@ stub ADL2_Display_DisplayInfo_Get
+@ stub ADL2_Display_DisplayMapConfigX2_Set
+@ stub ADL2_Display_DisplayMapConfig_Get
+@ stub ADL2_Display_DisplayMapConfig_PossibleAddAndRemove
+@ stub ADL2_Display_DisplayMapConfig_Set
+@ stub ADL2_Display_DisplayMapConfig_Validate
+@ stub ADL2_Display_DitherState_Get
+@ stub ADL2_Display_DitherState_Set
+@ stub ADL2_Display_Downscaling_Caps
+@ stub ADL2_Display_DpMstAuxMsg_Get
+@ stub ADL2_Display_DpMstInfo_Get
+@ stub ADL2_Display_DummyVirtual_Destroy
+@ stub ADL2_Display_DummyVirtual_Get
+@ stub ADL2_Display_EdidData_Get
+@ stub ADL2_Display_EdidData_Set
+@ stub ADL2_Display_EnumDisplays_Get
+@ stub ADL2_Display_FilterSVideo_Get
+@ stub ADL2_Display_FilterSVideo_Set
+@ stub ADL2_Display_ForcibleDisplay_Get
+@ stub ADL2_Display_ForcibleDisplay_Set
+@ stub ADL2_Display_FormatsOverride_Get
+@ stub ADL2_Display_FormatsOverride_Set
+@ stub ADL2_Display_FreeSyncState_Get
+@ stub ADL2_Display_FreeSyncState_Set
+@ stub ADL2_Display_FreeSync_Cap
+@ stub ADL2_Display_GamutMapping_Get
+@ stub ADL2_Display_GamutMapping_Reset
+@ stub ADL2_Display_GamutMapping_Set
+@ stub ADL2_Display_Gamut_Caps
+@ stub ADL2_Display_Gamut_Get
+@ stub ADL2_Display_Gamut_Set
+@ stub ADL2_Display_HDCP_Get
+@ stub ADL2_Display_HDCP_Set
+@ stub ADL2_Display_HDRState_Get
+@ stub ADL2_Display_HDRState_Set
+@ stub ADL2_Display_ImageExpansion_Get
+@ stub ADL2_Display_ImageExpansion_Set
+@ stub ADL2_Display_InfoPacket_Get
+@ stub ADL2_Display_InfoPacket_Set
+@ stub ADL2_Display_IsVirtual_Get
+@ stub ADL2_Display_LCDRefreshRateCapability_Get
+@ stub ADL2_Display_LCDRefreshRateOptions_Get
+@ stub ADL2_Display_LCDRefreshRateOptions_Set
+@ stub ADL2_Display_LCDRefreshRate_Get
+@ stub ADL2_Display_LCDRefreshRate_Set
+@ stub ADL2_Display_Limits_Get
+@ stub ADL2_Display_MVPUCaps_Get
+@ stub ADL2_Display_MVPUStatus_Get
+@ stub ADL2_Display_ModeTimingOverrideInfo_Get
+@ stub ADL2_Display_ModeTimingOverrideListX2_Get
+@ stub ADL2_Display_ModeTimingOverrideListX3_Get
+@ stub ADL2_Display_ModeTimingOverrideList_Get
+@ stub ADL2_Display_ModeTimingOverrideX2_Get
+@ stub ADL2_Display_ModeTimingOverrideX2_Set
+@ stub ADL2_Display_ModeTimingOverrideX3_Get
+@ stub ADL2_Display_ModeTimingOverride_Delete
+@ stub ADL2_Display_ModeTimingOverride_Get
+@ stub ADL2_Display_ModeTimingOverride_Set
+@ stub ADL2_Display_Modes_Get
+@ stub ADL2_Display_Modes_Set
+@ stub ADL2_Display_Modes_X2_Get
+@ stub ADL2_Display_MonitorPowerState_Set
+@ stub ADL2_Display_NativeAUXChannel_Access
+@ stub ADL2_Display_NeedWorkaroundFor5Clone_Get
+@ stub ADL2_Display_NumberOfDisplays_Get
+@ stub ADL2_Display_ODClockConfig_Set
+@ stub ADL2_Display_ODClockInfo_Get
+@ stub ADL2_Display_Overlap_NotifyAdjustment
+@ stub ADL2_Display_Overlap_Set
+@ stub ADL2_Display_Overscan_Get
+@ stub ADL2_Display_Overscan_Set
+@ stub ADL2_Display_PixelFormatDefault_Get
+@ stub ADL2_Display_PixelFormat_Get
+@ stub ADL2_Display_PixelFormat_Set
+@ stub ADL2_Display_Position_Get
+@ stub ADL2_Display_Position_Set
+@ stub ADL2_Display_PossibleMapping_Get
+@ stub ADL2_Display_PossibleMode_Get
+@ stub ADL2_Display_PowerXpressActiveGPU_Get
+@ stub ADL2_Display_PowerXpressActiveGPU_Set
+@ stub ADL2_Display_PowerXpressActvieGPUR2_Get
+@ stub ADL2_Display_PowerXpressVersion_Get
+@ stub ADL2_Display_PowerXpress_AutoSwitchConfig_Get
+@ stub ADL2_Display_PowerXpress_AutoSwitchConfig_Set
+@ stub ADL2_Display_PreferredMode_Get
+@ stub ADL2_Display_PreservedAspectRatio_Get
+@ stub ADL2_Display_PreservedAspectRatio_Set
+@ stub ADL2_Display_Property_Get
+@ stub ADL2_Display_Property_Set
+@ stub ADL2_Display_RcDisplayAdjustment
+@ stub ADL2_Display_ReGammaCoefficients_Get
+@ stub ADL2_Display_ReGammaCoefficients_Set
+@ stub ADL2_Display_ReducedBlanking_Get
+@ stub ADL2_Display_ReducedBlanking_Set
+@ stub ADL2_Display_RegammaR1_Get
+@ stub ADL2_Display_RegammaR1_Set
+@ stub ADL2_Display_Regamma_Get
+@ stub ADL2_Display_Regamma_Set
+@ stub ADL2_Display_SLSBuilder_CommonMode_Get
+@ stub ADL2_Display_SLSBuilder_Create
+@ stub ADL2_Display_SLSBuilder_DisplaysCanBeNextCandidateInSLS_Get
+@ stub ADL2_Display_SLSBuilder_DisplaysCanBeNextCandidateToEnabled_Get
+@ stub ADL2_Display_SLSBuilder_Get
+@ stub ADL2_Display_SLSBuilder_IsActive_Notify
+@ stub ADL2_Display_SLSBuilder_MaxSLSLayoutSize_Get
+@ stub ADL2_Display_SLSBuilder_TimeOut_Get
+@ stub ADL2_Display_SLSBuilder_Update
+@ stub ADL2_Display_SLSGrid_Caps
+@ stub ADL2_Display_SLSMapConfigX2_Delete
+@ stub ADL2_Display_SLSMapConfigX2_Get
+@ stub ADL2_Display_SLSMapConfig_Create
+@ stub ADL2_Display_SLSMapConfig_Delete
+@ stub ADL2_Display_SLSMapConfig_Get
+@ stub ADL2_Display_SLSMapConfig_ImageCropType_Set
+@ stub ADL2_Display_SLSMapConfig_Rearrange
+@ stub ADL2_Display_SLSMapConfig_SetState
+@ stub ADL2_Display_SLSMapConfig_SupportedImageCropType_Get
+@ stub ADL2_Display_SLSMapConfig_Valid
+@ stub ADL2_Display_SLSMapIndexList_Get
+@ stub ADL2_Display_SLSMapIndex_Get
+@ stub ADL2_Display_SLSMiddleMode_Get
+@ stub ADL2_Display_SLSMiddleMode_Set
+@ stub ADL2_Display_SLSRecords_Get
+@ stub ADL2_Display_Sharpness_Caps
+@ stub ADL2_Display_Sharpness_Get
+@ stub ADL2_Display_Sharpness_Info_Get
+@ stub ADL2_Display_Sharpness_Set
+@ stub ADL2_Display_Size_Get
+@ stub ADL2_Display_Size_Set
+@ stub ADL2_Display_SourceContentAttribute_Get
+@ stub ADL2_Display_SourceContentAttribute_Set
+@ stub ADL2_Display_SplitDisplay_Caps
+@ stub ADL2_Display_SplitDisplay_Get
+@ stub ADL2_Display_SplitDisplay_RestoreDesktopConfiguration
+@ stub ADL2_Display_SplitDisplay_Set
+@ stub ADL2_Display_SupportedColorDepth_Get
+@ stub ADL2_Display_SupportedPixelFormat_Get
+@ stub ADL2_Display_SwitchingCapability_Get
+@ stub ADL2_Display_TVCaps_Get
+@ stub ADL2_Display_TargetTimingX2_Get
+@ stub ADL2_Display_TargetTiming_Get
+@ stub ADL2_Display_UnderScan_Auto_Get
+@ stub ADL2_Display_UnderScan_Auto_Set
+@ stub ADL2_Display_UnderscanState_Get
+@ stub ADL2_Display_UnderscanState_Set
+@ stub ADL2_Display_UnderscanSupport_Get
+@ stub ADL2_Display_Underscan_Get
+@ stub ADL2_Display_Underscan_Set
+@ stub ADL2_Display_Vector_Get
+@ stub ADL2_Display_ViewPort_Cap
+@ stub ADL2_Display_ViewPort_Get
+@ stub ADL2_Display_ViewPort_Set
+@ stub ADL2_Display_VirtualType_Get
+@ stub ADL2_Display_WriteAndReadI2C
+@ stub ADL2_Display_WriteAndReadI2CLargePayload
+@ stub ADL2_Display_WriteAndReadI2CRev_Get
+@ stub ADL2_ElmCompatibilityMode_Caps
+@ stub ADL2_ElmCompatibilityMode_Status_Get
+@ stub ADL2_ElmCompatibilityMode_Status_Set
+@ stub ADL2_ExclusiveModeGet
+@ stub ADL2_FPS_Caps
+@ stub ADL2_FPS_Settings_Get
+@ stub ADL2_FPS_Settings_Reset
+@ stub ADL2_FPS_Settings_Set
+@ stub ADL2_Feature_Settings_Get
+@ stub ADL2_Feature_Settings_Set
+@ stub ADL2_Flush_Driver_Data
+@ stub ADL2_GPUVMPageSize_Info_Get
+@ stub ADL2_GPUVMPageSize_Info_Set
+@ stub ADL2_GPUVerInfo_Get
+@ stub ADL2_GcnAsicInfo_Get
+@ stub ADL2_Graphics_IsDetachableGraphicsPlatform_Get
+@ stub ADL2_Graphics_IsGfx9AndAbove
+@ stub ADL2_Graphics_MantleVersion_Get
+@ stub ADL2_Graphics_Platform_Get
+@ stdcall ADL2_Graphics_VersionsX2_Get(ptr ptr)
+@ stub ADL2_Graphics_Versions_Get
+@ stub ADL2_Graphics_VulkanVersion_Get
+@ stub ADL2_HybridGraphicsGPU_Set
+@ stub ADL2_MGPUSLS_Status_Set
+@ stub ADL2_MMD_FeatureList_Get
+@ stub ADL2_MMD_FeatureValuesX2_Get
+@ stub ADL2_MMD_FeatureValuesX2_Set
+@ stub ADL2_MMD_FeatureValues_Get
+@ stub ADL2_MMD_FeatureValues_Set
+@ stub ADL2_MMD_FeaturesX2_Caps
+@ stub ADL2_MMD_Features_Caps
+@ stub ADL2_MMD_VideoAdjustInfo_Get
+@ stub ADL2_MMD_VideoAdjustInfo_Set
+@ stub ADL2_MMD_VideoColor_Caps
+@ stub ADL2_MMD_VideoColor_Get
+@ stub ADL2_MMD_VideoColor_Set
+@ stub ADL2_MMD_Video_Caps
+@ stub ADL2_Main_ControlX2_Create
+@ stdcall ADL2_Main_Control_Create(ptr long ptr)
+@ stub ADL2_Main_Control_Destroy
+@ stub ADL2_Main_Control_GetProcAddress
+@ stub ADL2_Main_Control_IsFunctionValid
+@ stub ADL2_Main_Control_Refresh
+@ stub ADL2_Main_LogDebug_Set
+@ stub ADL2_Main_LogError_Set
+@ stub ADL2_New_QueryPMLogData_Get
+@ stub ADL2_Overdrive5_CurrentActivity_Get
+@ stub ADL2_Overdrive5_FanSpeedInfo_Get
+@ stub ADL2_Overdrive5_FanSpeedToDefault_Set
+@ stub ADL2_Overdrive5_FanSpeed_Get
+@ stub ADL2_Overdrive5_FanSpeed_Set
+@ stub ADL2_Overdrive5_ODParameters_Get
+@ stub ADL2_Overdrive5_ODPerformanceLevels_Get
+@ stub ADL2_Overdrive5_ODPerformanceLevels_Set
+@ stub ADL2_Overdrive5_PowerControlAbsValue_Caps
+@ stub ADL2_Overdrive5_PowerControlAbsValue_Get
+@ stub ADL2_Overdrive5_PowerControlAbsValue_Set
+@ stub ADL2_Overdrive5_PowerControlInfo_Get
+@ stub ADL2_Overdrive5_PowerControl_Caps
+@ stub ADL2_Overdrive5_PowerControl_Get
+@ stub ADL2_Overdrive5_PowerControl_Set
+@ stub ADL2_Overdrive5_Temperature_Get
+@ stub ADL2_Overdrive5_ThermalDevices_Enum
+@ stub ADL2_Overdrive6_AdvancedFan_Caps
+@ stub ADL2_Overdrive6_CapabilitiesEx_Get
+@ stub ADL2_Overdrive6_Capabilities_Get
+@ stub ADL2_Overdrive6_ControlI2C
+@ stub ADL2_Overdrive6_CurrentPower_Get
+@ stub ADL2_Overdrive6_CurrentStatus_Get
+@ stub ADL2_Overdrive6_FanPWMLimitData_Get
+@ stub ADL2_Overdrive6_FanPWMLimitData_Set
+@ stub ADL2_Overdrive6_FanPWMLimitRangeInfo_Get
+@ stub ADL2_Overdrive6_FanSpeed_Get
+@ stub ADL2_Overdrive6_FanSpeed_Reset
+@ stub ADL2_Overdrive6_FanSpeed_Set
+@ stub ADL2_Overdrive6_FuzzyController_Caps
+@ stub ADL2_Overdrive6_MaxClockAdjust_Get
+@ stub ADL2_Overdrive6_PowerControlInfo_Get
+@ stub ADL2_Overdrive6_PowerControlInfo_Get_X2
+@ stub ADL2_Overdrive6_PowerControl_Caps
+@ stub ADL2_Overdrive6_PowerControl_Get
+@ stub ADL2_Overdrive6_PowerControl_Set
+@ stub ADL2_Overdrive6_StateEx_Get
+@ stub ADL2_Overdrive6_StateEx_Set
+@ stub ADL2_Overdrive6_StateInfo_Get
+@ stub ADL2_Overdrive6_State_Reset
+@ stub ADL2_Overdrive6_State_Set
+@ stub ADL2_Overdrive6_TargetTemperatureData_Get
+@ stub ADL2_Overdrive6_TargetTemperatureData_Set
+@ stub ADL2_Overdrive6_TargetTemperatureRangeInfo_Get
+@ stub ADL2_Overdrive6_TemperatureEx_Get
+@ stub ADL2_Overdrive6_Temperature_Get
+@ stub ADL2_Overdrive6_ThermalController_Caps
+@ stub ADL2_Overdrive6_ThermalLimitUnlock_Get
+@ stub ADL2_Overdrive6_ThermalLimitUnlock_Set
+@ stub ADL2_Overdrive6_VoltageControlInfo_Get
+@ stub ADL2_Overdrive6_VoltageControl_Get
+@ stub ADL2_Overdrive6_VoltageControl_Set
+@ stub ADL2_Overdrive8_Current_SettingX2_Get
+@ stub ADL2_Overdrive8_Current_SettingX3_Get
+@ stub ADL2_Overdrive8_Current_Setting_Get
+@ stub ADL2_Overdrive8_Init_SettingX2_Get
+@ stub ADL2_Overdrive8_Init_Setting_Get
+@ stub ADL2_Overdrive8_PMLogSenorRange_Caps
+@ stub ADL2_Overdrive8_PMLogSenorType_Support_Get
+@ stub ADL2_Overdrive8_PMLog_ShareMemory_Read
+@ stub ADL2_Overdrive8_PMLog_ShareMemory_Start
+@ stub ADL2_Overdrive8_PMLog_ShareMemory_Stop
+@ stub ADL2_Overdrive8_PMLog_ShareMemory_Support
+@ stub ADL2_Overdrive8_Setting_Set
+@ stub ADL2_OverdriveN_AutoWattman_Caps
+@ stub ADL2_OverdriveN_AutoWattman_Get
+@ stub ADL2_OverdriveN_AutoWattman_Set
+@ stub ADL2_OverdriveN_CapabilitiesX2_Get
+@ stub ADL2_OverdriveN_Capabilities_Get
+@ stub ADL2_OverdriveN_CountOfEvents_Get
+@ stub ADL2_OverdriveN_FanControl_Get
+@ stub ADL2_OverdriveN_FanControl_Set
+@ stub ADL2_OverdriveN_MemoryClocksX2_Get
+@ stub ADL2_OverdriveN_MemoryClocksX2_Set
+@ stub ADL2_OverdriveN_MemoryClocks_Get
+@ stub ADL2_OverdriveN_MemoryClocks_Set
+@ stub ADL2_OverdriveN_MemoryTimingLevel_Get
+@ stub ADL2_OverdriveN_MemoryTimingLevel_Set
+@ stub ADL2_OverdriveN_PerformanceStatus_Get
+@ stub ADL2_OverdriveN_PowerLimit_Get
+@ stub ADL2_OverdriveN_PowerLimit_Set
+@ stub ADL2_OverdriveN_SCLKAutoOverClock_Get
+@ stub ADL2_OverdriveN_SCLKAutoOverClock_Set
+@ stub ADL2_OverdriveN_SettingsExt_Get
+@ stub ADL2_OverdriveN_SettingsExt_Set
+@ stub ADL2_OverdriveN_SystemClocksX2_Get
+@ stub ADL2_OverdriveN_SystemClocksX2_Set
+@ stub ADL2_OverdriveN_SystemClocks_Get
+@ stub ADL2_OverdriveN_SystemClocks_Set
+@ stub ADL2_OverdriveN_Temperature_Get
+@ stub ADL2_OverdriveN_Test_Set
+@ stub ADL2_OverdriveN_ThrottleNotification_Get
+@ stub ADL2_OverdriveN_ZeroRPMFan_Get
+@ stub ADL2_OverdriveN_ZeroRPMFan_Set
+@ stub ADL2_Overdrive_Caps
+@ stub ADL2_PPLogSettings_Get
+@ stub ADL2_PPLogSettings_Set
+@ stub ADL2_PPW_Caps
+@ stub ADL2_PPW_Status_Get
+@ stub ADL2_PPW_Status_Set
+@ stub ADL2_PageMigration_Settings_Get
+@ stub ADL2_PageMigration_Settings_Set
+@ stub ADL2_PerGPU_GDEvent_Register
+@ stub ADL2_PerGPU_GDEvent_UnRegister
+@ stub ADL2_PerfTuning_Status_Get
+@ stub ADL2_PerfTuning_Status_Set
+@ stub ADL2_PerformanceTuning_Caps
+@ stub ADL2_PowerStates_Get
+@ stub ADL2_PowerXpress_AncillaryDevices_Get
+@ stub ADL2_PowerXpress_Config_Caps
+@ stub ADL2_PowerXpress_Configuration_Get
+@ stub ADL2_PowerXpress_ExtendedBatteryMode_Caps
+@ stub ADL2_PowerXpress_ExtendedBatteryMode_Get
+@ stub ADL2_PowerXpress_ExtendedBatteryMode_Set
+@ stub ADL2_PowerXpress_LongIdleDetect_Get
+@ stub ADL2_PowerXpress_LongIdleDetect_Set
+@ stub ADL2_PowerXpress_PowerControlMode_Get
+@ stub ADL2_PowerXpress_PowerControlMode_Set
+@ stub ADL2_PowerXpress_Scheme_Get
+@ stub ADL2_PowerXpress_Scheme_Set
+@ stub ADL2_RIS_Settings_Get
+@ stub ADL2_RIS_Settings_Set
+@ stub ADL2_RegisterEvent
+@ stub ADL2_RegisterEventX2
+@ stub ADL2_Remap
+@ stub ADL2_RemoteDisplay_Destroy
+@ stub ADL2_RemoteDisplay_Display_Acquire
+@ stub ADL2_RemoteDisplay_Display_Release
+@ stub ADL2_RemoteDisplay_Display_Release_All
+@ stub ADL2_RemoteDisplay_Hdcp20_Create
+@ stub ADL2_RemoteDisplay_Hdcp20_Destroy
+@ stub ADL2_RemoteDisplay_Hdcp20_Notify
+@ stub ADL2_RemoteDisplay_Hdcp20_Process
+@ stub ADL2_RemoteDisplay_IEPort_Set
+@ stub ADL2_RemoteDisplay_Initialize
+@ stub ADL2_RemoteDisplay_Nofitiation_Register
+@ stub ADL2_RemoteDisplay_Notification_UnRegister
+@ stub ADL2_RemoteDisplay_Support_Caps
+@ stub ADL2_RemoteDisplay_VirtualWirelessAdapter_InUse_Get
+@ stub ADL2_RemoteDisplay_VirtualWirelessAdapter_Info_Get
+@ stub ADL2_RemoteDisplay_VirtualWirelessAdapter_RadioState_Get
+@ stub ADL2_RemoteDisplay_VirtualWirelessAdapter_WPSSetting_Change
+@ stub ADL2_RemoteDisplay_VirtualWirelessAdapter_WPSSetting_Get
+@ stub ADL2_RemoteDisplay_WFDDeviceInfo_Get
+@ stub ADL2_RemoteDisplay_WFDDeviceName_Change
+@ stub ADL2_RemoteDisplay_WFDDevice_StatusInfo_Get
+@ stub ADL2_RemoteDisplay_WFDDiscover_Start
+@ stub ADL2_RemoteDisplay_WFDDiscover_Stop
+@ stub ADL2_RemoteDisplay_WFDLink_Connect
+@ stub ADL2_RemoteDisplay_WFDLink_Creation_Accept
+@ stub ADL2_RemoteDisplay_WFDLink_Disconnect
+@ stub ADL2_RemoteDisplay_WFDLink_WPS_Process
+@ stub ADL2_RemoteDisplay_WFDWDSPSettings_Set
+@ stub ADL2_RemoteDisplay_WirelessDisplayEnableDisable_Commit
+@ stub ADL2_RemotePlay_ControlFlags_Set
+@ stub ADL2_ScreenPoint_AudioMappingInfo_Get
+@ stub ADL2_Send
+@ stub ADL2_SendX2
+@ stub ADL2_Stereo3D_2DPackedFormat_Set
+@ stub ADL2_Stereo3D_3DCursorOffset_Get
+@ stub ADL2_Stereo3D_3DCursorOffset_Set
+@ stub ADL2_Stereo3D_CurrentFormat_Get
+@ stub ADL2_Stereo3D_Info_Get
+@ stub ADL2_Stereo3D_Modes_Get
+@ stub ADL2_SwitchableGraphics_Applications_Get
+@ stub ADL2_TV_Standard_Get
+@ stub ADL2_TV_Standard_Set
+@ stub ADL2_TurboSyncSupport_Get
+@ stub ADL2_UnRegisterEvent
+@ stub ADL2_UnRegisterEventX2
+@ stub ADL2_User_Settings_Notify
+@ stub ADL2_WS_Overdrive_Caps
+@ stub ADL2_Win_IsHybridAI
+@ stub ADL2_Workstation_8BitGrayscale_Get
+@ stub ADL2_Workstation_8BitGrayscale_Set
+@ stub ADL2_Workstation_AdapterNumOfGLSyncConnectors_Get
+@ stub ADL2_Workstation_Caps
+@ stub ADL2_Workstation_DeepBitDepthX2_Get
+@ stub ADL2_Workstation_DeepBitDepthX2_Set
+@ stub ADL2_Workstation_DeepBitDepth_Get
+@ stub ADL2_Workstation_DeepBitDepth_Set
+@ stub ADL2_Workstation_DisplayGLSyncMode_Get
+@ stub ADL2_Workstation_DisplayGLSyncMode_Set
+@ stub ADL2_Workstation_DisplayGenlockCapable_Get
+@ stub ADL2_Workstation_ECCData_Get
+@ stub ADL2_Workstation_ECCX2_Get
+@ stub ADL2_Workstation_ECC_Caps
+@ stub ADL2_Workstation_ECC_Get
+@ stub ADL2_Workstation_ECC_Set
+@ stub ADL2_Workstation_GLSyncCounters_Get
+@ stub ADL2_Workstation_GLSyncGenlockConfiguration_Get
+@ stub ADL2_Workstation_GLSyncGenlockConfiguration_Set
+@ stub ADL2_Workstation_GLSyncModuleDetect_Get
+@ stub ADL2_Workstation_GLSyncModuleInfo_Get
+@ stub ADL2_Workstation_GLSyncPortState_Get
+@ stub ADL2_Workstation_GLSyncPortState_Set
+@ stub ADL2_Workstation_GLSyncSupportedTopology_Get
+@ stub ADL2_Workstation_GlobalEDIDPersistence_Get
+@ stub ADL2_Workstation_GlobalEDIDPersistence_Set
+@ stub ADL2_Workstation_LoadBalancing_Caps
+@ stub ADL2_Workstation_LoadBalancing_Get
+@ stub ADL2_Workstation_LoadBalancing_Set
+@ stub ADL2_Workstation_RAS_ErrorCounts_Get
+@ stub ADL2_Workstation_RAS_ErrorCounts_Reset
+@ stub ADL2_Workstation_SDISegmentList_Get
+@ stub ADL2_Workstation_SDI_Caps
+@ stub ADL2_Workstation_SDI_Get
+@ stub ADL2_Workstation_SDI_Set
+@ stub ADL2_Workstation_Stereo_Get
+@ stub ADL2_Workstation_Stereo_Set
+@ stub ADL2_Workstation_UnsupportedDisplayModes_Enable
+@ stub ADL_ADC_CurrentProfileFromDrv_Get
+@ stub ADL_ADC_Display_AdapterDeviceProfileEx_Get
+@ stub ADL_ADC_DrvDataToProfile_Copy
+@ stub ADL_ADC_FindClosestMode_Get
+@ stub ADL_ADC_IsDevModeEqual_Get
+@ stub ADL_ADC_Profile_Apply
+@ stub ADL_APO_AudioDelayAdjustmentInfo_Get
+@ stub ADL_APO_AudioDelay_Restore
+@ stub ADL_APO_AudioDelay_Set
+@ stub ADL_AdapterLimitation_Caps
+@ stub ADL_AdapterX2_Caps
+@ stdcall ADL_Adapter_ASICFamilyType_Get(long ptr ptr)
+@ stub ADL_Adapter_ASICInfo_Get
+@ stub ADL_Adapter_Accessibility_Get
+@ stub ADL_Adapter_Active_Get
+@ stub ADL_Adapter_Active_Set
+@ stub ADL_Adapter_Active_SetPrefer
+@ stub ADL_Adapter_AdapterInfoX2_Get
+@ stdcall ADL_Adapter_AdapterInfo_Get(ptr long)
+@ stub ADL_Adapter_AdapterList_Disable
+@ stub ADL_Adapter_Aspects_Get
+@ stub ADL_Adapter_AudioChannelSplitConfiguration_Get
+@ stub ADL_Adapter_AudioChannelSplit_Disable
+@ stub ADL_Adapter_AudioChannelSplit_Enable
+@ stub ADL_Adapter_BigSw_Info_Get
+@ stub ADL_Adapter_BlackAndWhiteLevelSupport_Get
+@ stub ADL_Adapter_BlackAndWhiteLevel_Get
+@ stub ADL_Adapter_BlackAndWhiteLevel_Set
+@ stub ADL_Adapter_BoardLayout_Get
+@ stub ADL_Adapter_Caps
+@ stub ADL_Adapter_ChipSetInfo_Get
+@ stub ADL_Adapter_ConfigMemory_Cap
+@ stub ADL_Adapter_ConfigMemory_Get
+@ stub ADL_Adapter_ConfigureState_Get
+@ stub ADL_Adapter_ConnectionData_Get
+@ stub ADL_Adapter_ConnectionData_Remove
+@ stub ADL_Adapter_ConnectionData_Set
+@ stub ADL_Adapter_ConnectionState_Get
+@ stub ADL_Adapter_CrossDisplayPlatformInfo_Get
+@ stub ADL_Adapter_CrossdisplayAdapterRole_Caps
+@ stub ADL_Adapter_CrossdisplayInfoX2_Set
+@ stub ADL_Adapter_CrossdisplayInfo_Get
+@ stub ADL_Adapter_CrossdisplayInfo_Set
+@ stub ADL_Adapter_CrossfireX2_Get
+@ stdcall ADL_Adapter_Crossfire_Caps(long ptr ptr ptr)
+@ stdcall ADL_Adapter_Crossfire_Get(long ptr ptr)
+@ stub ADL_Adapter_Crossfire_Set
+@ stub ADL_Adapter_DefaultAudioChannelTable_Load
+@ stub ADL_Adapter_DisplayAudioEndpoint_Enable
+@ stub ADL_Adapter_DisplayAudioEndpoint_Mute
+@ stub ADL_Adapter_DisplayAudioInfo_Get
+@ stub ADL_Adapter_DisplayGTCCaps_Get
+@ stub ADL_Adapter_Display_Caps
+@ stub ADL_Adapter_DriverSettings_Get
+@ stub ADL_Adapter_DriverSettings_Set
+@ stub ADL_Adapter_EDIDManagement_Caps
+@ stub ADL_Adapter_EmulationMode_Set
+@ stub ADL_Adapter_ExtInfo_Get
+@ stub ADL_Adapter_Gamma_Get
+@ stub ADL_Adapter_Gamma_Set
+@ stub ADL_Adapter_ID_Get
+@ stub ADL_Adapter_LocalDisplayConfig_Get
+@ stub ADL_Adapter_LocalDisplayConfig_Set
+@ stub ADL_Adapter_LocalDisplayState_Get
+@ stub ADL_Adapter_MaxCursorSize_Get
+@ stub ADL_Adapter_MemoryInfo2_Get
+@ stdcall ADL_Adapter_MemoryInfo_Get(long ptr)
+@ stub ADL_Adapter_MirabilisSupport_Get
+@ stub ADL_Adapter_ModeSwitch
+@ stub ADL_Adapter_ModeTimingOverride_Caps
+@ stub ADL_Adapter_Modes_ReEnumerate
+@ stub ADL_Adapter_NumberOfActivatableSources_Get
+@ stdcall ADL_Adapter_NumberOfAdapters_Get(ptr)
+@ stdcall ADL_Adapter_ObservedClockInfo_Get(long ptr ptr)
+@ stub ADL_Adapter_ObservedGameClockInfo_Get
+@ stub ADL_Adapter_Primary_Get
+@ stub ADL_Adapter_Primary_Set
+@ stub ADL_Adapter_RegValueInt_Get
+@ stub ADL_Adapter_RegValueInt_Set
+@ stub ADL_Adapter_RegValueString_Get
+@ stub ADL_Adapter_RegValueString_Set
+@ stub ADL_Adapter_SWInfo_Get
+@ stub ADL_Adapter_Speed_Caps
+@ stub ADL_Adapter_Speed_Get
+@ stub ADL_Adapter_Speed_Set
+@ stub ADL_Adapter_SupportedConnections_Get
+@ stub ADL_Adapter_Tear_Free_Cap
+@ stub ADL_Adapter_VariBrightEnable_Set
+@ stub ADL_Adapter_VariBrightLevel_Get
+@ stub ADL_Adapter_VariBrightLevel_Set
+@ stub ADL_Adapter_VariBright_Caps
+@ stub ADL_Adapter_VideoBiosInfo_Get
+@ stub ADL_Adapter_VideoTheaterModeInfo_Get
+@ stub ADL_Adapter_VideoTheaterModeInfo_Set
+@ stub ADL_ApplicationProfiles_Applications_Get
+@ stub ADL_ApplicationProfiles_ConvertToCompact
+@ stub ADL_ApplicationProfiles_DriverAreaPrivacy_Get
+@ stub ADL_ApplicationProfiles_GetCustomization
+@ stub ADL_ApplicationProfiles_HitListsX2_Get
+@ stub ADL_ApplicationProfiles_HitLists_Get
+@ stub ADL_ApplicationProfiles_ProfileApplicationX2_Assign
+@ stub ADL_ApplicationProfiles_ProfileApplication_Assign
+@ stub ADL_ApplicationProfiles_ProfileOfAnApplicationX2_Search
+@ stub ADL_ApplicationProfiles_ProfileOfAnApplication_InMemorySearch
+@ stub ADL_ApplicationProfiles_ProfileOfAnApplication_Search
+@ stub ADL_ApplicationProfiles_Profile_Create
+@ stub ADL_ApplicationProfiles_Profile_Exist
+@ stub ADL_ApplicationProfiles_Profile_Remove
+@ stub ADL_ApplicationProfiles_PropertyType_Get
+@ stub ADL_ApplicationProfiles_Release_Get
+@ stub ADL_ApplicationProfiles_RemoveApplication
+@ stub ADL_ApplicationProfiles_StatusInfo_Get
+@ stub ADL_ApplicationProfiles_System_Reload
+@ stub ADL_ApplicationProfiles_User_Load
+@ stub ADL_ApplicationProfiles_User_Unload
+@ stub ADL_Audio_CurrentSampleRate_Get
+@ stub ADL_CDS_UnsafeMode_Set
+@ stub ADL_CV_DongleSettings_Get
+@ stub ADL_CV_DongleSettings_Reset
+@ stub ADL_CV_DongleSettings_Set
+@ stub ADL_DFP_AllowOnlyCETimings_Get
+@ stub ADL_DFP_AllowOnlyCETimings_Set
+@ stub ADL_DFP_BaseAudioSupport_Get
+@ stub ADL_DFP_GPUScalingEnable_Get
+@ stub ADL_DFP_GPUScalingEnable_Set
+@ stub ADL_DFP_HDMISupport_Get
+@ stub ADL_DFP_MVPUAnalogSupport_Get
+@ stub ADL_DFP_PixelFormat_Caps
+@ stub ADL_DFP_PixelFormat_Get
+@ stub ADL_DFP_PixelFormat_Set
+@ stub ADL_DisplayScaling_Set
+@ stub ADL_Display_AdapterID_Get
+@ stub ADL_Display_AdjustCaps_Get
+@ stub ADL_Display_AdjustmentCoherent_Get
+@ stub ADL_Display_AdjustmentCoherent_Set
+@ stub ADL_Display_AudioMappingInfo_Get
+@ stub ADL_Display_AvivoColor_Get
+@ stub ADL_Display_AvivoCurrentColor_Set
+@ stub ADL_Display_AvivoDefaultColor_Set
+@ stub ADL_Display_BackLight_Get
+@ stub ADL_Display_BackLight_Set
+@ stub ADL_Display_BezelOffsetSteppingSize_Get
+@ stub ADL_Display_BezelOffset_Set
+@ stub ADL_Display_BezelSupported_Validate
+@ stub ADL_Display_Capabilities_Get
+@ stub ADL_Display_ColorCaps_Get
+@ stub ADL_Display_ColorDepth_Get
+@ stub ADL_Display_ColorDepth_Set
+@ stub ADL_Display_ColorTemperatureSource_Get
+@ stub ADL_Display_ColorTemperatureSource_Set
+@ stub ADL_Display_Color_Get
+@ stub ADL_Display_Color_Set
+@ stub ADL_Display_ConnectedDisplays_Get
+@ stub ADL_Display_ContainerID_Get
+@ stub ADL_Display_ControllerOverlayAdjustmentCaps_Get
+@ stub ADL_Display_ControllerOverlayAdjustmentData_Get
+@ stub ADL_Display_ControllerOverlayAdjustmentData_Set
+@ stub ADL_Display_CurrentPixelClock_Get
+@ stub ADL_Display_CustomizedModeListNum_Get
+@ stub ADL_Display_CustomizedModeList_Get
+@ stub ADL_Display_CustomizedMode_Add
+@ stub ADL_Display_CustomizedMode_Delete
+@ stub ADL_Display_CustomizedMode_Validate
+@ stub ADL_Display_DCE_Get
+@ stub ADL_Display_DCE_Set
+@ stub ADL_Display_DDCBlockAccess_Get
+@ stub ADL_Display_DDCInfo2_Get
+@ stub ADL_Display_DDCInfo_Get
+@ stub ADL_Display_Deflicker_Get
+@ stub ADL_Display_Deflicker_Set
+@ stub ADL_Display_DeviceConfig_Get
+@ stub ADL_Display_DisplayContent_Cap
+@ stub ADL_Display_DisplayContent_Get
+@ stub ADL_Display_DisplayContent_Set
+@ stdcall ADL_Display_DisplayInfo_Get(long long ptr long)
+@ stdcall ADL_Display_DisplayMapConfig_Get(long ptr ptr ptr ptr long)
+@ stub ADL_Display_DisplayMapConfig_PossibleAddAndRemove
+@ stub ADL_Display_DisplayMapConfig_Set
+@ stub ADL_Display_DisplayMapConfig_Validate
+@ stub ADL_Display_DitherState_Get
+@ stub ADL_Display_DitherState_Set
+@ stub ADL_Display_Downscaling_Caps
+@ stub ADL_Display_DpMstInfo_Get
+@ stub ADL_Display_EdidData_Get
+@ stub ADL_Display_EdidData_Set
+@ stub ADL_Display_EnumDisplays_Get
+@ stub ADL_Display_FilterSVideo_Get
+@ stub ADL_Display_FilterSVideo_Set
+@ stub ADL_Display_ForcibleDisplay_Get
+@ stub ADL_Display_ForcibleDisplay_Set
+@ stub ADL_Display_FormatsOverride_Get
+@ stub ADL_Display_FormatsOverride_Set
+@ stub ADL_Display_FreeSyncState_Get
+@ stub ADL_Display_FreeSyncState_Set
+@ stub ADL_Display_FreeSync_Cap
+@ stub ADL_Display_GamutMapping_Get
+@ stub ADL_Display_GamutMapping_Reset
+@ stub ADL_Display_GamutMapping_Set
+@ stub ADL_Display_Gamut_Caps
+@ stub ADL_Display_Gamut_Get
+@ stub ADL_Display_Gamut_Set
+@ stub ADL_Display_ImageExpansion_Get
+@ stub ADL_Display_ImageExpansion_Set
+@ stub ADL_Display_InfoPacket_Get
+@ stub ADL_Display_InfoPacket_Set
+@ stub ADL_Display_LCDRefreshRateCapability_Get
+@ stub ADL_Display_LCDRefreshRateOptions_Get
+@ stub ADL_Display_LCDRefreshRateOptions_Set
+@ stub ADL_Display_LCDRefreshRate_Get
+@ stub ADL_Display_LCDRefreshRate_Set
+@ stub ADL_Display_Limits_Get
+@ stub ADL_Display_MVPUCaps_Get
+@ stub ADL_Display_MVPUStatus_Get
+@ stub ADL_Display_ModeTimingOverrideInfo_Get
+@ stub ADL_Display_ModeTimingOverrideListX2_Get
+@ stub ADL_Display_ModeTimingOverrideList_Get
+@ stub ADL_Display_ModeTimingOverrideX2_Get
+@ stub ADL_Display_ModeTimingOverride_Delete
+@ stub ADL_Display_ModeTimingOverride_Get
+@ stub ADL_Display_ModeTimingOverride_Set
+@ stub ADL_Display_Modes_Get
+@ stub ADL_Display_Modes_Set
+@ stub ADL_Display_MonitorPowerState_Set
+@ stub ADL_Display_NativeAUXChannel_Access
+@ stub ADL_Display_NeedWorkaroundFor5Clone_Get
+@ stub ADL_Display_NumberOfDisplays_Get
+@ stub ADL_Display_ODClockConfig_Set
+@ stub ADL_Display_ODClockInfo_Get
+@ stub ADL_Display_Overlap_Set
+@ stub ADL_Display_Overscan_Get
+@ stub ADL_Display_Overscan_Set
+@ stub ADL_Display_PixelClockAllowableRange_Set
+@ stub ADL_Display_PixelClockCaps_Get
+@ stub ADL_Display_PixelFormat_Get
+@ stub ADL_Display_PixelFormat_Set
+@ stub ADL_Display_Position_Get
+@ stub ADL_Display_Position_Set
+@ stub ADL_Display_PossibleMapping_Get
+@ stub ADL_Display_PossibleMode_Get
+@ stub ADL_Display_PowerXpressActiveGPU_Get
+@ stub ADL_Display_PowerXpressActiveGPU_Set
+@ stub ADL_Display_PowerXpressActvieGPUR2_Get
+@ stub ADL_Display_PowerXpressVersion_Get
+@ stub ADL_Display_PowerXpress_AutoSwitchConfig_Get
+@ stub ADL_Display_PowerXpress_AutoSwitchConfig_Set
+@ stub ADL_Display_PreservedAspectRatio_Get
+@ stub ADL_Display_PreservedAspectRatio_Set
+@ stub ADL_Display_Property_Get
+@ stub ADL_Display_Property_Set
+@ stub ADL_Display_RcDisplayAdjustment
+@ stub ADL_Display_ReGammaCoefficients_Get
+@ stub ADL_Display_ReGammaCoefficients_Set
+@ stub ADL_Display_ReducedBlanking_Get
+@ stub ADL_Display_ReducedBlanking_Set
+@ stub ADL_Display_RegammaR1_Get
+@ stub ADL_Display_RegammaR1_Set
+@ stub ADL_Display_Regamma_Get
+@ stub ADL_Display_Regamma_Set
+@ stub ADL_Display_SLSGrid_Caps
+@ stub ADL_Display_SLSMapConfigX2_Get
+@ stub ADL_Display_SLSMapConfig_Create
+@ stub ADL_Display_SLSMapConfig_Delete
+@ stub ADL_Display_SLSMapConfig_Get
+@ stub ADL_Display_SLSMapConfig_Rearrange
+@ stub ADL_Display_SLSMapConfig_SetState
+@ stub ADL_Display_SLSMapIndexList_Get
+@ stub ADL_Display_SLSMapIndex_Get
+@ stub ADL_Display_SLSMiddleMode_Get
+@ stub ADL_Display_SLSMiddleMode_Set
+@ stub ADL_Display_SLSRecords_Get
+@ stub ADL_Display_Sharpness_Caps
+@ stub ADL_Display_Sharpness_Get
+@ stub ADL_Display_Sharpness_Info_Get
+@ stub ADL_Display_Sharpness_Set
+@ stub ADL_Display_Size_Get
+@ stub ADL_Display_Size_Set
+@ stub ADL_Display_SourceContentAttribute_Get
+@ stub ADL_Display_SourceContentAttribute_Set
+@ stub ADL_Display_SplitDisplay_Caps
+@ stub ADL_Display_SplitDisplay_Get
+@ stub ADL_Display_SplitDisplay_RestoreDesktopConfiguration
+@ stub ADL_Display_SplitDisplay_Set
+@ stub ADL_Display_SupportedColorDepth_Get
+@ stub ADL_Display_SupportedPixelFormat_Get
+@ stub ADL_Display_SwitchingCapability_Get
+@ stub ADL_Display_TVCaps_Get
+@ stub ADL_Display_TargetTiming_Get
+@ stub ADL_Display_UnderScan_Auto_Get
+@ stub ADL_Display_UnderScan_Auto_Set
+@ stub ADL_Display_Underscan_Get
+@ stub ADL_Display_Underscan_Set
+@ stub ADL_Display_Vector_Get
+@ stub ADL_Display_ViewPort_Cap
+@ stub ADL_Display_ViewPort_Get
+@ stub ADL_Display_ViewPort_Set
+@ stub ADL_Display_WriteAndReadI2C
+@ stub ADL_Display_WriteAndReadI2CLargePayload
+@ stub ADL_Display_WriteAndReadI2CRev_Get
+@ stub ADL_Flush_Driver_Data
+@ stdcall ADL_Graphics_Platform_Get(ptr)
+@ stdcall ADL_Graphics_Versions_Get(ptr)
+@ stub ADL_MMD_FeatureList_Get
+@ stub ADL_MMD_FeatureValuesX2_Get
+@ stub ADL_MMD_FeatureValuesX2_Set
+@ stub ADL_MMD_FeatureValues_Get
+@ stub ADL_MMD_FeatureValues_Set
+@ stub ADL_MMD_FeaturesX2_Caps
+@ stub ADL_MMD_Features_Caps
+@ stub ADL_MMD_VideoAdjustInfo_Get
+@ stub ADL_MMD_VideoAdjustInfo_Set
+@ stub ADL_MMD_VideoColor_Caps
+@ stub ADL_MMD_VideoColor_Get
+@ stub ADL_MMD_VideoColor_Set
+@ stub ADL_MMD_Video_Caps
+@ stub ADL_Main_ControlX2_Create
+@ stdcall ADL_Main_Control_Create(ptr long)
+@ stdcall ADL_Main_Control_Destroy()
+@ stub ADL_Main_Control_GetProcAddress
+@ stub ADL_Main_Control_IsFunctionValid
+@ stub ADL_Main_Control_Refresh
+@ stub ADL_Main_LogDebug_Set
+@ stub ADL_Main_LogError_Set
+@ stub ADL_Overdrive5_CurrentActivity_Get
+@ stub ADL_Overdrive5_FanSpeedInfo_Get
+@ stub ADL_Overdrive5_FanSpeedToDefault_Set
+@ stub ADL_Overdrive5_FanSpeed_Get
+@ stub ADL_Overdrive5_FanSpeed_Set
+@ stub ADL_Overdrive5_ODParameters_Get
+@ stub ADL_Overdrive5_ODPerformanceLevels_Get
+@ stub ADL_Overdrive5_ODPerformanceLevels_Set
+@ stub ADL_Overdrive5_PowerControlAbsValue_Caps
+@ stub ADL_Overdrive5_PowerControlAbsValue_Get
+@ stub ADL_Overdrive5_PowerControlAbsValue_Set
+@ stub ADL_Overdrive5_PowerControlInfo_Get
+@ stub ADL_Overdrive5_PowerControl_Caps
+@ stub ADL_Overdrive5_PowerControl_Get
+@ stub ADL_Overdrive5_PowerControl_Set
+@ stub ADL_Overdrive5_Temperature_Get
+@ stub ADL_Overdrive5_ThermalDevices_Enum
+@ stub ADL_Overdrive6_AdvancedFan_Caps
+@ stub ADL_Overdrive6_CapabilitiesEx_Get
+@ stub ADL_Overdrive6_Capabilities_Get
+@ stub ADL_Overdrive6_CurrentStatus_Get
+@ stub ADL_Overdrive6_FanPWMLimitData_Get
+@ stub ADL_Overdrive6_FanPWMLimitData_Set
+@ stub ADL_Overdrive6_FanPWMLimitRangeInfo_Get
+@ stub ADL_Overdrive6_FanSpeed_Get
+@ stub ADL_Overdrive6_FanSpeed_Reset
+@ stub ADL_Overdrive6_FanSpeed_Set
+@ stub ADL_Overdrive6_FuzzyController_Caps
+@ stub ADL_Overdrive6_MaxClockAdjust_Get
+@ stub ADL_Overdrive6_PowerControlInfo_Get
+@ stub ADL_Overdrive6_PowerControl_Caps
+@ stub ADL_Overdrive6_PowerControl_Get
+@ stub ADL_Overdrive6_PowerControl_Set
+@ stub ADL_Overdrive6_StateEx_Get
+@ stub ADL_Overdrive6_StateEx_Set
+@ stub ADL_Overdrive6_StateInfo_Get
+@ stub ADL_Overdrive6_State_Reset
+@ stub ADL_Overdrive6_State_Set
+@ stub ADL_Overdrive6_TargetTemperatureData_Get
+@ stub ADL_Overdrive6_TargetTemperatureData_Set
+@ stub ADL_Overdrive6_TargetTemperatureRangeInfo_Get
+@ stub ADL_Overdrive6_Temperature_Get
+@ stub ADL_Overdrive6_ThermalController_Caps
+@ stub ADL_Overdrive6_ThermalLimitUnlock_Get
+@ stub ADL_Overdrive6_ThermalLimitUnlock_Set
+@ stub ADL_Overdrive6_VoltageControlInfo_Get
+@ stub ADL_Overdrive6_VoltageControl_Get
+@ stub ADL_Overdrive6_VoltageControl_Set
+@ stub ADL_Overdrive_Caps
+@ stub ADL_PowerXpress_AncillaryDevices_Get
+@ stub ADL_PowerXpress_Config_Caps
+@ stub ADL_PowerXpress_ExtendedBatteryMode_Caps
+@ stub ADL_PowerXpress_ExtendedBatteryMode_Get
+@ stub ADL_PowerXpress_ExtendedBatteryMode_Set
+@ stub ADL_PowerXpress_LongIdleDetect_Get
+@ stub ADL_PowerXpress_LongIdleDetect_Set
+@ stub ADL_PowerXpress_PowerControlMode_Get
+@ stub ADL_PowerXpress_PowerControlMode_Set
+@ stub ADL_PowerXpress_Scheme_Get
+@ stub ADL_PowerXpress_Scheme_Set
+@ stub ADL_Remap
+@ stub ADL_RemoteDisplay_Destroy
+@ stub ADL_RemoteDisplay_Display_Acquire
+@ stub ADL_RemoteDisplay_Display_Release
+@ stub ADL_RemoteDisplay_Display_Release_All
+@ stub ADL_RemoteDisplay_Hdcp20_Create
+@ stub ADL_RemoteDisplay_Hdcp20_Destroy
+@ stub ADL_RemoteDisplay_Hdcp20_Notify
+@ stub ADL_RemoteDisplay_Hdcp20_Process
+@ stub ADL_RemoteDisplay_IEPort_Set
+@ stub ADL_RemoteDisplay_Initialize
+@ stub ADL_RemoteDisplay_Nofitiation_Register
+@ stub ADL_RemoteDisplay_Notification_UnRegister
+@ stub ADL_RemoteDisplay_Support_Caps
+@ stub ADL_RemoteDisplay_VirtualWirelessAdapter_InUse_Get
+@ stub ADL_RemoteDisplay_VirtualWirelessAdapter_Info_Get
+@ stub ADL_RemoteDisplay_VirtualWirelessAdapter_RadioState_Get
+@ stub ADL_RemoteDisplay_VirtualWirelessAdapter_WPSSetting_Change
+@ stub ADL_RemoteDisplay_VirtualWirelessAdapter_WPSSetting_Get
+@ stub ADL_RemoteDisplay_WFDDeviceInfo_Get
+@ stub ADL_RemoteDisplay_WFDDeviceName_Change
+@ stub ADL_RemoteDisplay_WFDDevice_StatusInfo_Get
+@ stub ADL_RemoteDisplay_WFDDiscover_Start
+@ stub ADL_RemoteDisplay_WFDDiscover_Stop
+@ stub ADL_RemoteDisplay_WFDLink_Connect
+@ stub ADL_RemoteDisplay_WFDLink_Creation_Accept
+@ stub ADL_RemoteDisplay_WFDLink_Disconnect
+@ stub ADL_RemoteDisplay_WFDLink_WPS_Process
+@ stub ADL_RemoteDisplay_WFDWDSPSettings_Set
+@ stub ADL_RemoteDisplay_WirelessDisplayEnableDisable_Commit
+@ stub ADL_ScreenPoint_AudioMappingInfo_Get
+@ stub ADL_Stereo3D_2DPackedFormat_Set
+@ stub ADL_Stereo3D_3DCursorOffset_Get
+@ stub ADL_Stereo3D_3DCursorOffset_Set
+@ stub ADL_Stereo3D_CurrentFormat_Get
+@ stub ADL_Stereo3D_Info_Get
+@ stub ADL_Stereo3D_Modes_Get
+@ stub ADL_TV_Standard_Get
+@ stub ADL_TV_Standard_Set
+@ stub ADL_Win_IsHybridAI
+@ stub ADL_Workstation_8BitGrayscale_Get
+@ stub ADL_Workstation_8BitGrayscale_Set
+@ stub ADL_Workstation_AdapterNumOfGLSyncConnectors_Get
+@ stub ADL_Workstation_Caps
+@ stub ADL_Workstation_DeepBitDepthX2_Get
+@ stub ADL_Workstation_DeepBitDepthX2_Set
+@ stub ADL_Workstation_DeepBitDepth_Get
+@ stub ADL_Workstation_DeepBitDepth_Set
+@ stub ADL_Workstation_DisplayGLSyncMode_Get
+@ stub ADL_Workstation_DisplayGLSyncMode_Set
+@ stub ADL_Workstation_DisplayGenlockCapable_Get
+@ stub ADL_Workstation_ECCData_Get
+@ stub ADL_Workstation_ECCX2_Get
+@ stub ADL_Workstation_ECC_Caps
+@ stub ADL_Workstation_ECC_Get
+@ stub ADL_Workstation_ECC_Set
+@ stub ADL_Workstation_GLSyncCounters_Get
+@ stub ADL_Workstation_GLSyncGenlockConfiguration_Get
+@ stub ADL_Workstation_GLSyncGenlockConfiguration_Set
+@ stub ADL_Workstation_GLSyncModuleDetect_Get
+@ stub ADL_Workstation_GLSyncModuleInfo_Get
+@ stub ADL_Workstation_GLSyncPortState_Get
+@ stub ADL_Workstation_GLSyncPortState_Set
+@ stub ADL_Workstation_GLSyncSupportedTopology_Get
+@ stub ADL_Workstation_GlobalEDIDPersistence_Get
+@ stub ADL_Workstation_GlobalEDIDPersistence_Set
+@ stub ADL_Workstation_LoadBalancing_Caps
+@ stub ADL_Workstation_LoadBalancing_Get
+@ stub ADL_Workstation_LoadBalancing_Set
+@ stub ADL_Workstation_RAS_Get_Error_Counts
+@ stub ADL_Workstation_RAS_Get_Features
+@ stub ADL_Workstation_RAS_Reset_Error_Counts
+@ stub ADL_Workstation_RAS_Set_Features
+@ stub ADL_Workstation_SDISegmentList_Get
+@ stub ADL_Workstation_SDI_Caps
+@ stub ADL_Workstation_SDI_Get
+@ stub ADL_Workstation_SDI_Set
+@ stub ADL_Workstation_Stereo_Get
+@ stub ADL_Workstation_Stereo_Set
+@ stub ADL_Workstation_UnsupportedDisplayModes_Enable
+@ stub AmdPowerXpressRequestHighPerformance
+@ stub Desktop_Detach
+@ stub Send
+@ stub SendX2
diff --git a/dlls/atiadlxx/atiadlxx_main.c b/dlls/atiadlxx/atiadlxx_main.c
new file mode 100644
index 00000000000..21dfbe71096
--- /dev/null
+++ wine/dlls/atiadlxx/atiadlxx_main.c
@@ -0,0 +1,493 @@
+/* Headers: https://github.com/GPUOpen-LibrariesAndSDKs/display-library */
+
+#include <stdarg.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+#define COBJMACROS
+#include "windef.h"
+#include "winbase.h"
+#include "winuser.h"
+#include "objbase.h"
+#include "initguid.h"
+#include "wine/debug.h"
+
+#include "dxgi.h"
+
+#define MAX_GPUS 64
+#define VENDOR_AMD 0x1002
+
+#define ADL_OK                            0
+#define ADL_ERR                          -1
+#define ADL_ERR_INVALID_PARAM            -3
+#define ADL_ERR_INVALID_ADL_IDX          -5
+#define ADL_ERR_NOT_SUPPORTED            -8
+#define ADL_ERR_NULL_POINTER             -9
+
+#define ADL_DISPLAY_DISPLAYINFO_DISPLAYCONNECTED            0x00000001
+#define ADL_DISPLAY_DISPLAYINFO_DISPLAYMAPPED               0x00000002
+#define ADL_DISPLAY_DISPLAYINFO_MASK 0x31fff
+
+#define ADL_ASIC_DISCRETE    (1 << 0)
+#define ADL_ASIC_MASK        0xAF
+
+enum ADLPlatForm
+{
+    GRAPHICS_PLATFORM_DESKTOP  = 0,
+    GRAPHICS_PLATFORM_MOBILE   = 1
+};
+#define GRAPHICS_PLATFORM_UNKNOWN -1
+
+
+static IDXGIFactory *dxgi_factory;
+
+WINE_DEFAULT_DEBUG_CHANNEL(atiadlxx);
+
+BOOL WINAPI DllMain(HINSTANCE instance, DWORD reason, void *reserved)
+{
+    TRACE("(%p, %u, %p)\n", instance, reason, reserved);
+
+    switch (reason)
+    {
+    case DLL_PROCESS_ATTACH:
+        DisableThreadLibraryCalls(instance);
+        break;
+    }
+
+    return TRUE;
+}
+
+typedef void *(CALLBACK *ADL_MAIN_MALLOC_CALLBACK)(int);
+typedef void *ADL_CONTEXT_HANDLE;
+
+ADL_MAIN_MALLOC_CALLBACK adl_malloc;
+#define ADL_MAX_PATH 256
+
+typedef struct ADLVersionsInfo
+{
+    char strDriverVer[ADL_MAX_PATH];
+    char strCatalystVersion[ADL_MAX_PATH];
+    char strCatalystWebLink[ADL_MAX_PATH];
+} ADLVersionsInfo, *LPADLVersionsInfo;
+
+typedef struct ADLVersionsInfoX2
+{
+    char strDriverVer[ADL_MAX_PATH];
+    char strCatalystVersion[ADL_MAX_PATH];
+    char strCrimsonVersion[ADL_MAX_PATH];
+    char strCatalystWebLink[ADL_MAX_PATH];
+} ADLVersionsInfoX2, *LPADLVersionsInfoX2;
+
+typedef struct ADLAdapterInfo {
+    int iSize;
+    int iAdapterIndex;
+    char strUDID[ADL_MAX_PATH];
+    int iBusNumber;
+    int iDeviceNumber;
+    int iFunctionNumber;
+    int iVendorID;
+    char strAdapterName[ADL_MAX_PATH];
+    char strDisplayName[ADL_MAX_PATH];
+    int iPresent;
+    int iExist;
+    char strDriverPath[ADL_MAX_PATH];
+    char strDriverPathExt[ADL_MAX_PATH];
+    char strPNPString[ADL_MAX_PATH];
+    int iOSDisplayIndex;
+} ADLAdapterInfo, *LPADLAdapterInfo;
+
+typedef struct ADLDisplayID
+{
+    int iDisplayLogicalIndex;
+    int iDisplayPhysicalIndex;
+    int iDisplayLogicalAdapterIndex;
+    int iDisplayPhysicalAdapterIndex;
+} ADLDisplayID, *LPADLDisplayID;
+
+typedef struct ADLDisplayInfo
+{
+    ADLDisplayID displayID;
+    int  iDisplayControllerIndex;
+    char strDisplayName[ADL_MAX_PATH];
+    char strDisplayManufacturerName[ADL_MAX_PATH];
+    int  iDisplayType;
+    int  iDisplayOutputType;
+    int  iDisplayConnector;
+    int  iDisplayInfoMask;
+    int  iDisplayInfoValue;
+} ADLDisplayInfo, *LPADLDisplayInfo;
+
+typedef struct ADLCrossfireComb
+{
+    int iNumLinkAdapter;
+    int iAdaptLink[3];
+} ADLCrossfireComb;
+
+typedef struct ADLCrossfireInfo
+{
+  int iErrorCode;
+  int iState;
+  int iSupported;
+} ADLCrossfireInfo;
+
+typedef struct ADLMemoryInfo
+{
+    long long iMemorySize;
+    char strMemoryType[ADL_MAX_PATH];
+    long long iMemoryBandwidth;
+} ADLMemoryInfo, *LPADLMemoryInfo;
+
+typedef struct ADLDisplayTarget
+{
+    ADLDisplayID displayID;
+    int iDisplayMapIndex;
+    int iDisplayTargetMask;
+    int iDisplayTargetValue;
+} ADLDisplayTarget, *LPADLDisplayTarget;
+
+typedef struct ADLMode
+{
+    int iAdapterIndex;
+    ADLDisplayID displayID;
+    int iXPos;
+    int iYPos;
+    int iXRes;
+    int iYRes;
+    int iColourDepth;
+    float fRefreshRate;
+    int iOrientation;
+    int iModeFlag;
+    int iModeMask;
+    int iModeValue;
+} ADLMode, *LPADLMode;
+
+typedef struct ADLDisplayMap
+{
+    int iDisplayMapIndex;
+    ADLMode displayMode;
+    int iNumDisplayTarget;
+    int iFirstDisplayTargetArrayIndex;
+    int iDisplayMapMask;
+    int iDisplayMapValue;
+} ADLDisplayMap, *LPADLDisplayMap;
+
+static const ADLVersionsInfo version = {
+    "22.20.19.16-221003a-384125E-AMD-Software-Adrenalin-Edition",
+    "",
+    "http://support.amd.com/drivers/xml/driver_09_us.xml",
+};
+
+static const ADLVersionsInfoX2 version2 = {
+    "22.20.19.16-221003a-384125E-AMD-Software-Adrenalin-Edition",
+    "",
+    "22.10.1",
+    "http://support.amd.com/drivers/xml/driver_09_us.xml",
+};
+
+int WINAPI ADL2_Main_Control_Create(ADL_MAIN_MALLOC_CALLBACK cb, int arg, ADL_CONTEXT_HANDLE *ptr)
+{
+    FIXME("cb %p, arg %d, ptr %p stub!\n", cb, arg, ptr);
+    return ADL_OK;
+}
+
+int WINAPI ADL_Main_Control_Create(ADL_MAIN_MALLOC_CALLBACK cb, int arg)
+{
+    FIXME("cb %p, arg %d stub!\n", cb, arg);
+    adl_malloc = cb;
+
+
+    if (SUCCEEDED(CreateDXGIFactory(&IID_IDXGIFactory, (void**) &dxgi_factory)))
+        return ADL_OK;
+    else
+        return ADL_ERR;
+}
+
+int WINAPI ADL_Main_Control_Destroy(void)
+{
+    FIXME("stub!\n");
+
+    if (dxgi_factory != NULL)
+        IUnknown_Release(dxgi_factory);
+
+    return ADL_OK;
+}
+
+int WINAPI ADL2_Adapter_NumberOfAdapters_Get(ADL_CONTEXT_HANDLE *ptr, int *count)
+{
+    FIXME("ptr %p, count %p stub!\n", ptr, count);
+
+    *count = 0;
+
+    return ADL_OK;
+}
+
+int WINAPI ADL2_Graphics_VersionsX2_Get(ADL_CONTEXT_HANDLE *ptr, ADLVersionsInfoX2 *ver)
+{
+    FIXME("ptr %p, ver %p stub!\n", ptr, ver);
+    memcpy(ver, &version2, sizeof(version2));
+    return ADL_OK;
+}
+
+int WINAPI ADL_Graphics_Versions_Get(ADLVersionsInfo *ver)
+{
+    FIXME("ver %p stub!\n", ver);
+    memcpy(ver, &version, sizeof(version));
+    return ADL_OK;
+}
+
+int WINAPI ADL_Adapter_NumberOfAdapters_Get(int *count)
+{
+    IDXGIAdapter *adapter;
+
+    FIXME("count %p stub!\n", count);
+
+    *count = 0;
+    while (SUCCEEDED(IDXGIFactory_EnumAdapters(dxgi_factory, *count, &adapter)))
+    {
+        (*count)++;
+        IUnknown_Release(adapter);
+    }
+
+    TRACE("*count = %d\n", *count);
+    return ADL_OK;
+}
+
+static int get_adapter_desc(int adapter_index, DXGI_ADAPTER_DESC *desc)
+{
+    IDXGIAdapter *adapter;
+    HRESULT hr;
+
+    if (FAILED(IDXGIFactory_EnumAdapters(dxgi_factory, adapter_index, &adapter)))
+        return ADL_ERR;
+
+    hr = IDXGIAdapter_GetDesc(adapter, desc);
+
+    IUnknown_Release(adapter);
+
+    return SUCCEEDED(hr) ? ADL_OK : ADL_ERR;
+}
+
+/* yep, seriously */
+static int convert_vendor_id(int id)
+{
+    char str[16];
+    snprintf(str, ARRAY_SIZE(str), "%x", id);
+    return atoi(str);
+}
+
+int WINAPI ADL_Adapter_AdapterInfo_Get(ADLAdapterInfo *adapters, int input_size)
+{
+    int count, i;
+    DXGI_ADAPTER_DESC adapter_desc;
+
+    FIXME("adapters %p, input_size %d, stub!\n", adapters, input_size);
+
+    ADL_Adapter_NumberOfAdapters_Get(&count);
+
+    if (!adapters) return ADL_ERR_INVALID_PARAM;
+    if (input_size != count * sizeof(ADLAdapterInfo)) return ADL_ERR_INVALID_PARAM;
+
+    memset(adapters, 0, input_size);
+
+    for (i = 0; i < count; i++)
+    {
+        adapters[i].iSize = sizeof(ADLAdapterInfo);
+        adapters[i].iAdapterIndex = i;
+
+        if (get_adapter_desc(i, &adapter_desc) != ADL_OK)
+            return ADL_ERR;
+
+        adapters[i].iVendorID = convert_vendor_id(adapter_desc.VendorId);
+    }
+
+    return ADL_OK;
+}
+
+int WINAPI ADL_Display_DisplayInfo_Get(int adapter_index, int *num_displays, ADLDisplayInfo **info, int force_detect)
+{
+    IDXGIAdapter *adapter;
+    IDXGIOutput *output;
+    int i;
+
+    FIXME("adapter %d, num_displays %p, info %p stub!\n", adapter_index, num_displays, info);
+
+    if (info == NULL || num_displays == NULL) return ADL_ERR_NULL_POINTER;
+
+    if (FAILED(IDXGIFactory_EnumAdapters(dxgi_factory, adapter_index, &adapter)))
+        return ADL_ERR_INVALID_PARAM;
+
+    *num_displays = 0;
+
+    while (SUCCEEDED(IDXGIAdapter_EnumOutputs(adapter, *num_displays, &output)))
+    {
+        (*num_displays)++;
+        IUnknown_Release(output);
+    }
+
+    IUnknown_Release(adapter);
+
+    if (*num_displays == 0)
+        return ADL_OK;
+
+    *info = adl_malloc(*num_displays * sizeof(**info));
+    memset(*info, 0, *num_displays * sizeof(**info));
+
+    for (i = 0; i < *num_displays; i++)
+    {
+        (*info)[i].displayID.iDisplayLogicalIndex = i;
+        (*info)[i].iDisplayInfoValue = ADL_DISPLAY_DISPLAYINFO_DISPLAYCONNECTED | ADL_DISPLAY_DISPLAYINFO_DISPLAYMAPPED;
+        (*info)[i].iDisplayInfoMask = (*info)[i].iDisplayInfoValue;
+    }
+
+    return ADL_OK;
+}
+
+int WINAPI ADL_Adapter_Crossfire_Caps(int adapter_index, int *preffered, int *num_comb, ADLCrossfireComb** comb)
+{
+    FIXME("adapter %d, preffered %p, num_comb %p, comb %p stub!\n", adapter_index, preffered, num_comb, comb);
+    return ADL_ERR;
+}
+
+int WINAPI ADL_Adapter_Crossfire_Get(int adapter_index, ADLCrossfireComb *comb, ADLCrossfireInfo *info)
+{
+    FIXME("adapter %d, comb %p, info %p, stub!\n", adapter_index, comb, info);
+    return ADL_ERR;
+}
+
+int WINAPI ADL_Adapter_ASICFamilyType_Get(int adapter_index, int *asic_type, int *valids)
+{
+    DXGI_ADAPTER_DESC adapter_desc;
+
+    FIXME("adapter %d, asic_type %p, valids %p, stub!\n", adapter_index, asic_type, valids);
+
+    if (asic_type == NULL || valids == NULL)
+        return  ADL_ERR_NULL_POINTER;
+
+    if (get_adapter_desc(adapter_index, &adapter_desc) != ADL_OK)
+        return ADL_ERR_INVALID_ADL_IDX;
+
+    if (adapter_desc.VendorId != VENDOR_AMD)
+        return ADL_ERR_NOT_SUPPORTED;
+
+    *asic_type = ADL_ASIC_DISCRETE;
+    *valids = ADL_ASIC_MASK;
+
+    return ADL_OK;
+}
+
+static int get_max_clock(const char *clock, int default_value)
+{
+    char path[MAX_PATH], line[256];
+    FILE *file;
+    int drm_card, value = 0;
+
+    for (drm_card = 0; drm_card < MAX_GPUS; drm_card++)
+    {
+        sprintf(path, "/sys/class/drm/card%d/device/pp_dpm_%s", drm_card, clock);
+        file = fopen(path, "r");
+
+        if (file == NULL)
+            continue;
+
+        while (fgets(line, sizeof(line), file) != NULL)
+        {
+            char *number;
+
+            number = strchr(line, ' ');
+            if (number == NULL)
+            {
+                WARN("pp_dpm_%s file has unexpected format\n", clock);
+                break;
+            }
+
+            number++;
+            value = max(strtol(number, NULL, 0), value);
+        }
+    }
+
+    if (value != 0)
+        return value;
+
+    return default_value;
+}
+
+/* documented in the "Linux Specific APIs" section, present and used on Windows */
+/* the name and documentation suggests that this returns current freqs, but it's actually max */
+int WINAPI ADL_Adapter_ObservedClockInfo_Get(int adapter_index, int *core_clock, int *memory_clock)
+{
+    DXGI_ADAPTER_DESC adapter_desc;
+
+    FIXME("adapter %d, core_clock %p, memory_clock %p, stub!\n", adapter_index, core_clock, memory_clock);
+
+    if (core_clock == NULL || memory_clock == NULL) return ADL_ERR;
+    if (get_adapter_desc(adapter_index, &adapter_desc) != ADL_OK) return ADL_ERR;
+    if (adapter_desc.VendorId != VENDOR_AMD) return ADL_ERR_INVALID_ADL_IDX;
+
+    /* default values based on RX580 */
+    *core_clock = get_max_clock("sclk", 1350);
+    *memory_clock = get_max_clock("mclk", 2000);
+
+    TRACE("*core_clock: %i, *memory_clock %i\n", *core_clock, *memory_clock);
+
+    return ADL_OK;
+}
+
+/* documented in the "Linux Specific APIs" section, present and used on Windows */
+int WINAPI ADL_Adapter_MemoryInfo_Get(int adapter_index, ADLMemoryInfo *mem_info)
+{
+    DXGI_ADAPTER_DESC adapter_desc;
+
+    FIXME("adapter %d, mem_info %p stub!\n", adapter_index, mem_info);
+
+    if (mem_info == NULL) return ADL_ERR_NULL_POINTER;
+    if (get_adapter_desc(adapter_index, &adapter_desc) != ADL_OK) return ADL_ERR_INVALID_ADL_IDX;
+    if (adapter_desc.VendorId != VENDOR_AMD) return ADL_ERR;
+
+    mem_info->iMemorySize = adapter_desc.DedicatedVideoMemory;
+    mem_info->iMemoryBandwidth = 256000; /* not exposed on Linux, probably needs a lookup table */
+
+    TRACE("iMemoryBandwidth %s, iMemorySize %s\n",
+            wine_dbgstr_longlong(mem_info->iMemoryBandwidth),
+            wine_dbgstr_longlong(mem_info->iMemorySize));
+    return ADL_OK;
+}
+
+int WINAPI ADL_Graphics_Platform_Get(int *platform)
+{
+    DXGI_ADAPTER_DESC adapter_desc;
+    int count, i;
+
+    FIXME("platform %p, stub!\n", platform);
+
+    *platform = GRAPHICS_PLATFORM_UNKNOWN;
+
+    ADL_Adapter_NumberOfAdapters_Get(&count);
+
+    for (i = 0; i < count; i ++)
+    {
+        if (get_adapter_desc(i, &adapter_desc) != ADL_OK)
+            continue;
+
+        if (adapter_desc.VendorId == VENDOR_AMD)
+            *platform = GRAPHICS_PLATFORM_DESKTOP;
+    }
+
+    /* NOTE: The real value can be obtained by doing:
+     * 1. ioctl(DRM_AMDGPU_INFO) with AMDGPU_INFO_DEV_INFO - dev_info.ids_flags & AMDGPU_IDS_FLAGS_FUSION
+     * 2. VkPhysicalDeviceType() if we ever want to use Vulkan directly
+     */
+
+    return ADL_OK;
+}
+
+
+int WINAPI ADL_Display_DisplayMapConfig_Get(int adapter_index, int *display_map_count, ADLDisplayMap **display_maps,
+        int *display_target_count, ADLDisplayTarget **display_targets, int options)
+{
+    FIXME("adapter_index %d, display_map_count %p, display_maps %p, "
+            "display_target_count %p, display_targets %p, options %d stub.\n",
+            adapter_index, display_map_count, display_maps, display_target_count,
+            display_targets, options);
+
+    return ADL_ERR;
+}
-- 
2.39.2 (Apple Git-144)

diff --git a/dlls/windows.gaming.input/Makefile.in b/dlls/windows.gaming.input/Makefile.in
index 1e0ce5c360c..3ec3dd0d864 100644
--- wine/dlls/windows.gaming.input/Makefile.in
+++ wine/dlls/windows.gaming.input/Makefile.in
@@ -2,13 +2,19 @@ MODULE = windows.gaming.input.dll
 IMPORTS = combase uuid user32 dinput8 setupapi hid
 
 C_SRCS = \
+	async.c \
+	condition_effect.c \
+	constant_effect.c \
 	controller.c \
 	event_handlers.c \
+	force_feedback.c \
 	gamepad.c \
 	main.c \
 	manager.c \
+	periodic_effect.c \
 	provider.c \
 	racing_wheel.c \
+	ramp_effect.c \
 	vector.c
 
 IDL_SRCS = \
diff --git a/dlls/windows.gaming.input/async.c b/dlls/windows.gaming.input/async.c
new file mode 100644
index 00000000000..862886195ba
--- /dev/null
+++ wine/dlls/windows.gaming.input/async.c
@@ -0,0 +1,647 @@
+/* WinRT Windows.Gaming.Input implementation
+ *
+ * Copyright 2022 Bernhard Kölbl for CodeWeavers
+ * Copyright 2022 Rémi Bernon for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "private.h"
+#include "provider.h"
+
+#include "wine/debug.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(input);
+
+#define Closed 4
+#define HANDLER_NOT_SET ((void *)~(ULONG_PTR)0)
+
+struct async_info
+{
+    IWineAsyncInfoImpl IWineAsyncInfoImpl_iface;
+    IAsyncInfo IAsyncInfo_iface;
+    IInspectable *IInspectable_outer;
+    LONG ref;
+
+    async_operation_callback callback;
+    TP_WORK *async_run_work;
+    IUnknown *invoker;
+    IUnknown *param;
+
+    CRITICAL_SECTION cs;
+    IWineAsyncOperationCompletedHandler *handler;
+    PROPVARIANT result;
+    AsyncStatus status;
+    HRESULT hr;
+};
+
+static inline struct async_info *impl_from_IWineAsyncInfoImpl( IWineAsyncInfoImpl *iface )
+{
+    return CONTAINING_RECORD( iface, struct async_info, IWineAsyncInfoImpl_iface );
+}
+
+static HRESULT WINAPI async_impl_QueryInterface( IWineAsyncInfoImpl *iface, REFIID iid, void **out )
+{
+    struct async_info *impl = impl_from_IWineAsyncInfoImpl( iface );
+
+    TRACE( "iface %p, iid %s, out %p.\n", iface, debugstr_guid( iid ), out );
+
+    if (IsEqualGUID( iid, &IID_IUnknown ) ||
+        IsEqualGUID( iid, &IID_IInspectable ) ||
+        IsEqualGUID( iid, &IID_IAgileObject ) ||
+        IsEqualGUID( iid, &IID_IWineAsyncInfoImpl ))
+    {
+        IInspectable_AddRef( (*out = &impl->IWineAsyncInfoImpl_iface) );
+        return S_OK;
+    }
+
+    if (IsEqualGUID( iid, &IID_IAsyncInfo ))
+    {
+        IInspectable_AddRef( (*out = &impl->IAsyncInfo_iface) );
+        return S_OK;
+    }
+
+    FIXME( "%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid( iid ) );
+    *out = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI async_impl_AddRef( IWineAsyncInfoImpl *iface )
+{
+    struct async_info *impl = impl_from_IWineAsyncInfoImpl( iface );
+    ULONG ref = InterlockedIncrement( &impl->ref );
+    TRACE( "iface %p, ref %lu.\n", iface, ref );
+    return ref;
+}
+
+static ULONG WINAPI async_impl_Release( IWineAsyncInfoImpl *iface )
+{
+    struct async_info *impl = impl_from_IWineAsyncInfoImpl( iface );
+    ULONG ref = InterlockedDecrement( &impl->ref );
+    TRACE( "iface %p, ref %lu.\n", iface, ref );
+
+    if (!ref)
+    {
+        if (impl->handler && impl->handler != HANDLER_NOT_SET) IWineAsyncOperationCompletedHandler_Release( impl->handler );
+        IAsyncInfo_Close( &impl->IAsyncInfo_iface );
+        if (impl->param) IUnknown_Release( impl->param );
+        if (impl->invoker) IUnknown_Release( impl->invoker );
+        impl->cs.DebugInfo->Spare[0] = 0;
+        DeleteCriticalSection( &impl->cs );
+        free( impl );
+    }
+
+    return ref;
+}
+
+static HRESULT WINAPI async_impl_put_Completed( IWineAsyncInfoImpl *iface, IWineAsyncOperationCompletedHandler *handler )
+{
+    struct async_info *impl = impl_from_IWineAsyncInfoImpl( iface );
+    HRESULT hr = S_OK;
+
+    TRACE( "iface %p, handler %p.\n", iface, handler );
+
+    EnterCriticalSection( &impl->cs );
+    if (impl->status == Closed) hr = E_ILLEGAL_METHOD_CALL;
+    else if (impl->handler != HANDLER_NOT_SET) hr = E_ILLEGAL_DELEGATE_ASSIGNMENT;
+    else if ((impl->handler = handler))
+    {
+        IWineAsyncOperationCompletedHandler_AddRef( impl->handler );
+
+        if (impl->status > Started)
+        {
+            IInspectable *operation = impl->IInspectable_outer;
+            AsyncStatus status = impl->status;
+            impl->handler = NULL; /* Prevent concurrent invoke. */
+            LeaveCriticalSection( &impl->cs );
+
+            IWineAsyncOperationCompletedHandler_Invoke( handler, operation, status );
+            IWineAsyncOperationCompletedHandler_Release( handler );
+
+            return S_OK;
+        }
+    }
+    LeaveCriticalSection( &impl->cs );
+
+    return hr;
+}
+
+static HRESULT WINAPI async_impl_get_Completed( IWineAsyncInfoImpl *iface, IWineAsyncOperationCompletedHandler **handler )
+{
+    struct async_info *impl = impl_from_IWineAsyncInfoImpl( iface );
+    HRESULT hr = S_OK;
+
+    TRACE( "iface %p, handler %p.\n", iface, handler );
+
+    EnterCriticalSection( &impl->cs );
+    if (impl->status == Closed) hr = E_ILLEGAL_METHOD_CALL;
+    if (impl->handler == NULL || impl->handler == HANDLER_NOT_SET) *handler = NULL;
+    else IWineAsyncOperationCompletedHandler_AddRef( (*handler = impl->handler) );
+    LeaveCriticalSection( &impl->cs );
+
+    return hr;
+}
+
+static HRESULT WINAPI async_impl_get_Result( IWineAsyncInfoImpl *iface, PROPVARIANT *result )
+{
+    struct async_info *impl = impl_from_IWineAsyncInfoImpl( iface );
+    HRESULT hr = E_ILLEGAL_METHOD_CALL;
+
+    TRACE( "iface %p, result %p.\n", iface, result );
+
+    EnterCriticalSection( &impl->cs );
+    if (impl->status == Completed || impl->status == Error)
+    {
+        PropVariantCopy( result, &impl->result );
+        hr = impl->hr;
+    }
+    LeaveCriticalSection( &impl->cs );
+
+    return hr;
+}
+
+static HRESULT WINAPI async_impl_Start( IWineAsyncInfoImpl *iface )
+{
+    struct async_info *impl = impl_from_IWineAsyncInfoImpl( iface );
+
+    TRACE( "iface %p.\n", iface );
+
+    /* keep the async alive in the callback */
+    IInspectable_AddRef( impl->IInspectable_outer );
+    SubmitThreadpoolWork( impl->async_run_work );
+
+    return S_OK;
+}
+
+static const struct IWineAsyncInfoImplVtbl async_impl_vtbl =
+{
+    /* IUnknown methods */
+    async_impl_QueryInterface,
+    async_impl_AddRef,
+    async_impl_Release,
+    /* IWineAsyncInfoImpl */
+    async_impl_put_Completed,
+    async_impl_get_Completed,
+    async_impl_get_Result,
+    async_impl_Start,
+};
+
+DEFINE_IINSPECTABLE_OUTER( async_info, IAsyncInfo, struct async_info, IInspectable_outer )
+
+static HRESULT WINAPI async_info_get_Id( IAsyncInfo *iface, UINT32 *id )
+{
+    struct async_info *impl = impl_from_IAsyncInfo( iface );
+    HRESULT hr = S_OK;
+
+    TRACE( "iface %p, id %p.\n", iface, id );
+
+    EnterCriticalSection( &impl->cs );
+    if (impl->status == Closed) hr = E_ILLEGAL_METHOD_CALL;
+    *id = 1;
+    LeaveCriticalSection( &impl->cs );
+
+    return hr;
+}
+
+static HRESULT WINAPI async_info_get_Status( IAsyncInfo *iface, AsyncStatus *status )
+{
+    struct async_info *impl = impl_from_IAsyncInfo( iface );
+    HRESULT hr = S_OK;
+
+    TRACE( "iface %p, status %p.\n", iface, status );
+
+    EnterCriticalSection( &impl->cs );
+    if (impl->status == Closed) hr = E_ILLEGAL_METHOD_CALL;
+    *status = impl->status;
+    LeaveCriticalSection( &impl->cs );
+
+    return hr;
+}
+
+static HRESULT WINAPI async_info_get_ErrorCode( IAsyncInfo *iface, HRESULT *error_code )
+{
+    struct async_info *impl = impl_from_IAsyncInfo( iface );
+    HRESULT hr = S_OK;
+
+    TRACE( "iface %p, error_code %p.\n", iface, error_code );
+
+    EnterCriticalSection( &impl->cs );
+    if (impl->status == Closed) *error_code = hr = E_ILLEGAL_METHOD_CALL;
+    else *error_code = impl->hr;
+    LeaveCriticalSection( &impl->cs );
+
+    return hr;
+}
+
+static HRESULT WINAPI async_info_Cancel( IAsyncInfo *iface )
+{
+    struct async_info *impl = impl_from_IAsyncInfo( iface );
+    HRESULT hr = S_OK;
+
+    TRACE( "iface %p.\n", iface );
+
+    EnterCriticalSection( &impl->cs );
+    if (impl->status == Closed) hr = E_ILLEGAL_METHOD_CALL;
+    else if (impl->status == Started) impl->status = Canceled;
+    LeaveCriticalSection( &impl->cs );
+
+    return hr;
+}
+
+static HRESULT WINAPI async_info_Close( IAsyncInfo *iface )
+{
+    struct async_info *impl = impl_from_IAsyncInfo( iface );
+    HRESULT hr = S_OK;
+
+    TRACE( "iface %p.\n", iface );
+
+    EnterCriticalSection( &impl->cs );
+    if (impl->status == Started)
+        hr = E_ILLEGAL_STATE_CHANGE;
+    else if (impl->status != Closed)
+    {
+        CloseThreadpoolWork( impl->async_run_work );
+        impl->async_run_work = NULL;
+        impl->status = Closed;
+    }
+    LeaveCriticalSection( &impl->cs );
+
+    return hr;
+}
+
+static const struct IAsyncInfoVtbl async_info_vtbl =
+{
+    /* IUnknown methods */
+    async_info_QueryInterface,
+    async_info_AddRef,
+    async_info_Release,
+    /* IInspectable methods */
+    async_info_GetIids,
+    async_info_GetRuntimeClassName,
+    async_info_GetTrustLevel,
+    /* IAsyncInfo */
+    async_info_get_Id,
+    async_info_get_Status,
+    async_info_get_ErrorCode,
+    async_info_Cancel,
+    async_info_Close,
+};
+
+static void CALLBACK async_info_callback( TP_CALLBACK_INSTANCE *instance, void *iface, TP_WORK *work )
+{
+    struct async_info *impl = impl_from_IWineAsyncInfoImpl( iface );
+    IInspectable *operation = impl->IInspectable_outer;
+    PROPVARIANT result;
+    HRESULT hr;
+
+    hr = impl->callback( impl->invoker, impl->param, &result );
+
+    EnterCriticalSection( &impl->cs );
+    if (impl->status != Closed) impl->status = FAILED(hr) ? Error : Completed;
+    PropVariantCopy( &impl->result, &result );
+    impl->hr = hr;
+
+    if (impl->handler != NULL && impl->handler != HANDLER_NOT_SET)
+    {
+        IWineAsyncOperationCompletedHandler *handler = impl->handler;
+        AsyncStatus status = impl->status;
+        impl->handler = NULL; /* Prevent concurrent invoke. */
+        LeaveCriticalSection( &impl->cs );
+
+        IWineAsyncOperationCompletedHandler_Invoke( handler, operation, status );
+        IWineAsyncOperationCompletedHandler_Release( handler );
+    }
+    else LeaveCriticalSection( &impl->cs );
+
+    /* release refcount acquired in Start */
+    IInspectable_Release( operation );
+
+    PropVariantClear( &result );
+}
+
+static HRESULT async_info_create( IUnknown *invoker, IUnknown *param, async_operation_callback callback,
+                                  IInspectable *outer, IWineAsyncInfoImpl **out )
+{
+    struct async_info *impl;
+
+    if (!(impl = calloc( 1, sizeof(struct async_info) ))) return E_OUTOFMEMORY;
+    impl->IWineAsyncInfoImpl_iface.lpVtbl = &async_impl_vtbl;
+    impl->IAsyncInfo_iface.lpVtbl = &async_info_vtbl;
+    impl->IInspectable_outer = outer;
+    impl->ref = 1;
+
+    impl->callback = callback;
+    impl->handler = HANDLER_NOT_SET;
+    impl->status = Started;
+    if (!(impl->async_run_work = CreateThreadpoolWork( async_info_callback, &impl->IWineAsyncInfoImpl_iface, NULL )))
+        return HRESULT_FROM_WIN32( GetLastError() );
+
+    if ((impl->invoker = invoker)) IUnknown_AddRef( impl->invoker );
+    if ((impl->param = param)) IUnknown_AddRef( impl->param );
+
+    InitializeCriticalSection( &impl->cs );
+    impl->cs.DebugInfo->Spare[0] = (DWORD_PTR)( __FILE__ ": async_info.cs" );
+
+    *out = &impl->IWineAsyncInfoImpl_iface;
+    return S_OK;
+}
+
+struct async_bool
+{
+    IAsyncOperation_boolean IAsyncOperation_boolean_iface;
+    IWineAsyncInfoImpl *IWineAsyncInfoImpl_inner;
+    LONG ref;
+};
+
+static inline struct async_bool *impl_from_IAsyncOperation_boolean( IAsyncOperation_boolean *iface )
+{
+    return CONTAINING_RECORD( iface, struct async_bool, IAsyncOperation_boolean_iface );
+}
+
+static HRESULT WINAPI async_bool_QueryInterface( IAsyncOperation_boolean *iface, REFIID iid, void **out )
+{
+    struct async_bool *impl = impl_from_IAsyncOperation_boolean( iface );
+
+    TRACE( "iface %p, iid %s, out %p.\n", iface, debugstr_guid( iid ), out );
+
+    if (IsEqualGUID( iid, &IID_IUnknown ) ||
+        IsEqualGUID( iid, &IID_IInspectable ) ||
+        IsEqualGUID( iid, &IID_IAgileObject ) ||
+        IsEqualGUID( iid, &IID_IAsyncOperation_boolean ))
+    {
+        IInspectable_AddRef( (*out = &impl->IAsyncOperation_boolean_iface) );
+        return S_OK;
+    }
+
+    return IWineAsyncInfoImpl_QueryInterface( impl->IWineAsyncInfoImpl_inner, iid, out );
+}
+
+static ULONG WINAPI async_bool_AddRef( IAsyncOperation_boolean *iface )
+{
+    struct async_bool *impl = impl_from_IAsyncOperation_boolean( iface );
+    ULONG ref = InterlockedIncrement( &impl->ref );
+    TRACE( "iface %p, ref %lu.\n", iface, ref );
+    return ref;
+}
+
+static ULONG WINAPI async_bool_Release( IAsyncOperation_boolean *iface )
+{
+    struct async_bool *impl = impl_from_IAsyncOperation_boolean( iface );
+    ULONG ref = InterlockedDecrement( &impl->ref );
+    TRACE( "iface %p, ref %lu.\n", iface, ref );
+
+    if (!ref)
+    {
+        /* guard against re-entry if inner releases an outer iface */
+        InterlockedIncrement( &impl->ref );
+        IWineAsyncInfoImpl_Release( impl->IWineAsyncInfoImpl_inner );
+        free( impl );
+    }
+
+    return ref;
+}
+
+static HRESULT WINAPI async_bool_GetIids( IAsyncOperation_boolean *iface, ULONG *iid_count, IID **iids )
+{
+    FIXME( "iface %p, iid_count %p, iids %p stub!\n", iface, iid_count, iids );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI async_bool_GetRuntimeClassName( IAsyncOperation_boolean *iface, HSTRING *class_name )
+{
+    return WindowsCreateString( L"Windows.Foundation.IAsyncOperation`1<Boolean>",
+                                ARRAY_SIZE(L"Windows.Foundation.IAsyncOperation`1<Boolean>"),
+                                class_name );
+}
+
+static HRESULT WINAPI async_bool_GetTrustLevel( IAsyncOperation_boolean *iface, TrustLevel *trust_level )
+{
+    FIXME( "iface %p, trust_level %p stub!\n", iface, trust_level );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI async_bool_put_Completed( IAsyncOperation_boolean *iface, IAsyncOperationCompletedHandler_boolean *bool_handler )
+{
+    IWineAsyncOperationCompletedHandler *handler = (IWineAsyncOperationCompletedHandler *)bool_handler;
+    struct async_bool *impl = impl_from_IAsyncOperation_boolean( iface );
+    TRACE( "iface %p, handler %p.\n", iface, handler );
+    return IWineAsyncInfoImpl_put_Completed( impl->IWineAsyncInfoImpl_inner, (IWineAsyncOperationCompletedHandler *)handler );
+}
+
+static HRESULT WINAPI async_bool_get_Completed( IAsyncOperation_boolean *iface, IAsyncOperationCompletedHandler_boolean **bool_handler )
+{
+    IWineAsyncOperationCompletedHandler **handler = (IWineAsyncOperationCompletedHandler **)bool_handler;
+    struct async_bool *impl = impl_from_IAsyncOperation_boolean( iface );
+    TRACE( "iface %p, handler %p.\n", iface, handler );
+    return IWineAsyncInfoImpl_get_Completed( impl->IWineAsyncInfoImpl_inner, (IWineAsyncOperationCompletedHandler **)handler );
+}
+
+static HRESULT WINAPI async_bool_GetResults( IAsyncOperation_boolean *iface, BOOLEAN *results )
+{
+    struct async_bool *impl = impl_from_IAsyncOperation_boolean( iface );
+    PROPVARIANT result = {.vt = VT_BOOL};
+    HRESULT hr;
+
+    TRACE( "iface %p, results %p.\n", iface, results );
+
+    hr = IWineAsyncInfoImpl_get_Result( impl->IWineAsyncInfoImpl_inner, &result );
+
+    *results = result.boolVal;
+    PropVariantClear( &result );
+    return hr;
+}
+
+static const struct IAsyncOperation_booleanVtbl async_bool_vtbl =
+{
+    /* IUnknown methods */
+    async_bool_QueryInterface,
+    async_bool_AddRef,
+    async_bool_Release,
+    /* IInspectable methods */
+    async_bool_GetIids,
+    async_bool_GetRuntimeClassName,
+    async_bool_GetTrustLevel,
+    /* IAsyncOperation<boolean> */
+    async_bool_put_Completed,
+    async_bool_get_Completed,
+    async_bool_GetResults,
+};
+
+HRESULT async_operation_boolean_create( IUnknown *invoker, IUnknown *param, async_operation_callback callback,
+                                        IAsyncOperation_boolean **out )
+{
+    struct async_bool *impl;
+    HRESULT hr;
+
+    *out = NULL;
+    if (!(impl = calloc( 1, sizeof(*impl) ))) return E_OUTOFMEMORY;
+    impl->IAsyncOperation_boolean_iface.lpVtbl = &async_bool_vtbl;
+    impl->ref = 1;
+
+    if (FAILED(hr = async_info_create( invoker, param, callback, (IInspectable *)&impl->IAsyncOperation_boolean_iface, &impl->IWineAsyncInfoImpl_inner )) ||
+        FAILED(hr = IWineAsyncInfoImpl_Start( impl->IWineAsyncInfoImpl_inner )))
+    {
+        if (impl->IWineAsyncInfoImpl_inner) IWineAsyncInfoImpl_Release( impl->IWineAsyncInfoImpl_inner );
+        free( impl );
+        return hr;
+    }
+
+    *out = &impl->IAsyncOperation_boolean_iface;
+    TRACE( "created IAsyncOperation_boolean %p\n", *out );
+    return S_OK;
+}
+
+struct async_result
+{
+    IAsyncOperation_ForceFeedbackLoadEffectResult IAsyncOperation_ForceFeedbackLoadEffectResult_iface;
+    IWineAsyncInfoImpl *IWineAsyncInfoImpl_inner;
+    LONG ref;
+};
+
+static inline struct async_result *impl_from_IAsyncOperation_ForceFeedbackLoadEffectResult( IAsyncOperation_ForceFeedbackLoadEffectResult *iface )
+{
+    return CONTAINING_RECORD( iface, struct async_result, IAsyncOperation_ForceFeedbackLoadEffectResult_iface );
+}
+
+static HRESULT WINAPI async_result_QueryInterface( IAsyncOperation_ForceFeedbackLoadEffectResult *iface, REFIID iid, void **out )
+{
+    struct async_result *impl = impl_from_IAsyncOperation_ForceFeedbackLoadEffectResult( iface );
+
+    TRACE( "iface %p, iid %s, out %p.\n", iface, debugstr_guid( iid ), out );
+
+    if (IsEqualGUID( iid, &IID_IUnknown ) ||
+        IsEqualGUID( iid, &IID_IInspectable ) ||
+        IsEqualGUID( iid, &IID_IAgileObject ) ||
+        IsEqualGUID( iid, &IID_IAsyncOperation_ForceFeedbackLoadEffectResult ))
+    {
+        IInspectable_AddRef( (*out = &impl->IAsyncOperation_ForceFeedbackLoadEffectResult_iface) );
+        return S_OK;
+    }
+
+    return IWineAsyncInfoImpl_QueryInterface( impl->IWineAsyncInfoImpl_inner, iid, out );
+}
+
+static ULONG WINAPI async_result_AddRef( IAsyncOperation_ForceFeedbackLoadEffectResult *iface )
+{
+    struct async_result *impl = impl_from_IAsyncOperation_ForceFeedbackLoadEffectResult( iface );
+    ULONG ref = InterlockedIncrement( &impl->ref );
+    TRACE( "iface %p, ref %lu.\n", iface, ref );
+    return ref;
+}
+
+static ULONG WINAPI async_result_Release( IAsyncOperation_ForceFeedbackLoadEffectResult *iface )
+{
+    struct async_result *impl = impl_from_IAsyncOperation_ForceFeedbackLoadEffectResult( iface );
+    ULONG ref = InterlockedDecrement( &impl->ref );
+    TRACE( "iface %p, ref %lu.\n", iface, ref );
+
+    if (!ref)
+    {
+        /* guard against re-entry if inner releases an outer iface */
+        InterlockedIncrement( &impl->ref );
+        IWineAsyncInfoImpl_Release( impl->IWineAsyncInfoImpl_inner );
+        free( impl );
+    }
+
+    return ref;
+}
+
+static HRESULT WINAPI async_result_GetIids( IAsyncOperation_ForceFeedbackLoadEffectResult *iface, ULONG *iid_count, IID **iids )
+{
+    FIXME( "iface %p, iid_count %p, iids %p stub!\n", iface, iid_count, iids );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI async_result_GetRuntimeClassName( IAsyncOperation_ForceFeedbackLoadEffectResult *iface, HSTRING *class_name )
+{
+    return WindowsCreateString( L"Windows.Foundation.IAsyncOperation`1<Windows.Gaming.Input.ForceFeedback.ForceFeedbackLoadEffectResult>",
+                                ARRAY_SIZE(L"Windows.Foundation.IAsyncOperation`1<Windows.Gaming.Input.ForceFeedback.ForceFeedbackLoadEffectResult>"),
+                                class_name );
+}
+
+static HRESULT WINAPI async_result_GetTrustLevel( IAsyncOperation_ForceFeedbackLoadEffectResult *iface, TrustLevel *trust_level )
+{
+    FIXME( "iface %p, trust_level %p stub!\n", iface, trust_level );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI async_result_put_Completed( IAsyncOperation_ForceFeedbackLoadEffectResult *iface, IAsyncOperationCompletedHandler_ForceFeedbackLoadEffectResult *handler )
+{
+    struct async_result *impl = impl_from_IAsyncOperation_ForceFeedbackLoadEffectResult( iface );
+    TRACE( "iface %p, handler %p.\n", iface, handler );
+    return IWineAsyncInfoImpl_put_Completed( impl->IWineAsyncInfoImpl_inner, (IWineAsyncOperationCompletedHandler *)handler );
+}
+
+static HRESULT WINAPI async_result_get_Completed( IAsyncOperation_ForceFeedbackLoadEffectResult *iface, IAsyncOperationCompletedHandler_ForceFeedbackLoadEffectResult **handler )
+{
+    struct async_result *impl = impl_from_IAsyncOperation_ForceFeedbackLoadEffectResult( iface );
+    TRACE( "iface %p, handler %p.\n", iface, handler );
+    return IWineAsyncInfoImpl_get_Completed( impl->IWineAsyncInfoImpl_inner, (IWineAsyncOperationCompletedHandler **)handler );
+}
+
+static HRESULT WINAPI async_result_GetResults( IAsyncOperation_ForceFeedbackLoadEffectResult *iface, ForceFeedbackLoadEffectResult *results )
+{
+    struct async_result *impl = impl_from_IAsyncOperation_ForceFeedbackLoadEffectResult( iface );
+    PROPVARIANT result = {.vt = VT_UI4};
+    HRESULT hr;
+
+    TRACE( "iface %p, results %p.\n", iface, results );
+
+    hr = IWineAsyncInfoImpl_get_Result( impl->IWineAsyncInfoImpl_inner, &result );
+
+    *results = result.ulVal;
+    PropVariantClear( &result );
+    return hr;
+}
+
+static const struct IAsyncOperation_ForceFeedbackLoadEffectResultVtbl async_result_vtbl =
+{
+    /* IUnknown methods */
+    async_result_QueryInterface,
+    async_result_AddRef,
+    async_result_Release,
+    /* IInspectable methods */
+    async_result_GetIids,
+    async_result_GetRuntimeClassName,
+    async_result_GetTrustLevel,
+    /* IAsyncOperation<ForceFeedbackLoadEffectResult> */
+    async_result_put_Completed,
+    async_result_get_Completed,
+    async_result_GetResults,
+};
+
+HRESULT async_operation_effect_result_create( IUnknown *invoker, IUnknown *param, async_operation_callback callback,
+                                              IAsyncOperation_ForceFeedbackLoadEffectResult **out )
+{
+    struct async_result *impl;
+    HRESULT hr;
+
+    *out = NULL;
+    if (!(impl = calloc( 1, sizeof(*impl) ))) return E_OUTOFMEMORY;
+    impl->IAsyncOperation_ForceFeedbackLoadEffectResult_iface.lpVtbl = &async_result_vtbl;
+    impl->ref = 1;
+
+    if (FAILED(hr = async_info_create( invoker, param, callback, (IInspectable *)&impl->IAsyncOperation_ForceFeedbackLoadEffectResult_iface, &impl->IWineAsyncInfoImpl_inner )) ||
+        FAILED(hr = IWineAsyncInfoImpl_Start( impl->IWineAsyncInfoImpl_inner )))
+    {
+        if (impl->IWineAsyncInfoImpl_inner) IWineAsyncInfoImpl_Release( impl->IWineAsyncInfoImpl_inner );
+        free( impl );
+        return hr;
+    }
+
+    *out = &impl->IAsyncOperation_ForceFeedbackLoadEffectResult_iface;
+    TRACE( "created IAsyncOperation_ForceFeedbackLoadEffectResult %p\n", *out );
+    return S_OK;
+}
diff --git a/dlls/windows.gaming.input/classes.idl b/dlls/windows.gaming.input/classes.idl
index ca3bd5d8dd7..3172def88f5 100644
--- wine/dlls/windows.gaming.input/classes.idl
+++ wine/dlls/windows.gaming.input/classes.idl
@@ -29,6 +29,7 @@ import "asyncinfo.idl";
 import "eventtoken.idl";
 import "windowscontracts.idl";
 import "windows.foundation.idl";
+import "windows.foundation.numerics.idl";
 import "windows.devices.haptics.idl";
 import "windows.gaming.input.forcefeedback.idl";
 import "windows.system.idl";
@@ -36,4 +37,5 @@ import "windows.devices.power.idl";
 
 #define DO_NO_IMPORTS
 #include "windows.gaming.input.idl"
+#include "windows.gaming.ui.idl"
 #include "windows.gaming.input.custom.idl"
diff --git a/dlls/windows.gaming.input/condition_effect.c b/dlls/windows.gaming.input/condition_effect.c
new file mode 100644
index 00000000000..c3a5a1fcd8b
--- /dev/null
+++ wine/dlls/windows.gaming.input/condition_effect.c
@@ -0,0 +1,288 @@
+/* WinRT Windows.Gaming.Input implementation
+ *
+ * Copyright 2022 Rémi Bernon for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "private.h"
+#include "provider.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(input);
+
+struct condition_effect
+{
+    IConditionForceEffect IConditionForceEffect_iface;
+    IWineForceFeedbackEffectImpl *IWineForceFeedbackEffectImpl_inner;
+    LONG ref;
+
+    ConditionForceEffectKind kind;
+};
+
+static inline struct condition_effect *impl_from_IConditionForceEffect( IConditionForceEffect *iface )
+{
+    return CONTAINING_RECORD( iface, struct condition_effect, IConditionForceEffect_iface );
+}
+
+static HRESULT WINAPI effect_QueryInterface( IConditionForceEffect *iface, REFIID iid, void **out )
+{
+    struct condition_effect *impl = impl_from_IConditionForceEffect( iface );
+
+    TRACE( "iface %p, iid %s, out %p.\n", iface, debugstr_guid( iid ), out );
+
+    if (IsEqualGUID( iid, &IID_IUnknown ) ||
+        IsEqualGUID( iid, &IID_IInspectable ) ||
+        IsEqualGUID( iid, &IID_IAgileObject ) ||
+        IsEqualGUID( iid, &IID_IConditionForceEffect ))
+    {
+        IInspectable_AddRef( (*out = &impl->IConditionForceEffect_iface) );
+        return S_OK;
+    }
+
+    return IWineForceFeedbackEffectImpl_QueryInterface( impl->IWineForceFeedbackEffectImpl_inner, iid, out );
+}
+
+static ULONG WINAPI effect_AddRef( IConditionForceEffect *iface )
+{
+    struct condition_effect *impl = impl_from_IConditionForceEffect( iface );
+    ULONG ref = InterlockedIncrement( &impl->ref );
+    TRACE( "iface %p increasing refcount to %lu.\n", iface, ref );
+    return ref;
+}
+
+static ULONG WINAPI effect_Release( IConditionForceEffect *iface )
+{
+    struct condition_effect *impl = impl_from_IConditionForceEffect( iface );
+    ULONG ref = InterlockedDecrement( &impl->ref );
+
+    TRACE( "iface %p decreasing refcount to %lu.\n", iface, ref );
+
+    if (!ref)
+    {
+        /* guard against re-entry if inner releases an outer iface */
+        InterlockedIncrement( &impl->ref );
+        IWineForceFeedbackEffectImpl_Release( impl->IWineForceFeedbackEffectImpl_inner );
+        free( impl );
+    }
+
+    return ref;
+}
+
+static HRESULT WINAPI effect_GetIids( IConditionForceEffect *iface, ULONG *iid_count, IID **iids )
+{
+    FIXME( "iface %p, iid_count %p, iids %p stub!\n", iface, iid_count, iids );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI effect_GetRuntimeClassName( IConditionForceEffect *iface, HSTRING *class_name )
+{
+    return WindowsCreateString( RuntimeClass_Windows_Gaming_Input_ForceFeedback_ConditionForceEffect,
+                                ARRAY_SIZE(RuntimeClass_Windows_Gaming_Input_ForceFeedback_ConditionForceEffect),
+                                class_name );
+}
+
+static HRESULT WINAPI effect_GetTrustLevel( IConditionForceEffect *iface, TrustLevel *trust_level )
+{
+    FIXME( "iface %p, trust_level %p stub!\n", iface, trust_level );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI effect_get_Kind( IConditionForceEffect *iface, ConditionForceEffectKind *kind )
+{
+    struct condition_effect *impl = impl_from_IConditionForceEffect( iface );
+    TRACE( "iface %p, kind %p.\n", iface, kind );
+    *kind = impl->kind;
+    return S_OK;
+}
+
+static HRESULT WINAPI effect_SetParameters( IConditionForceEffect *iface, Vector3 direction, FLOAT positive_coeff, FLOAT negative_coeff,
+                                            FLOAT max_positive_magnitude, FLOAT max_negative_magnitude, FLOAT deadzone, FLOAT bias )
+{
+    struct condition_effect *impl = impl_from_IConditionForceEffect( iface );
+    WineForceFeedbackEffectParameters params =
+    {
+        .condition =
+        {
+            .type = WineForceFeedbackEffectType_Condition + impl->kind,
+            .direction = direction,
+            .positive_coeff = positive_coeff,
+            .negative_coeff = negative_coeff,
+            .max_positive_magnitude = max_positive_magnitude,
+            .max_negative_magnitude = max_negative_magnitude,
+            .deadzone = deadzone,
+            .bias = bias,
+        },
+    };
+
+    TRACE( "iface %p, direction %s, positive_coeff %f, negative_coeff %f, max_positive_magnitude %f, max_negative_magnitude %f, deadzone %f, bias %f.\n",
+           iface, debugstr_vector3( &direction ), positive_coeff, negative_coeff, max_positive_magnitude, max_negative_magnitude, deadzone, bias );
+
+    return IWineForceFeedbackEffectImpl_put_Parameters( impl->IWineForceFeedbackEffectImpl_inner, params, NULL );
+}
+
+static const struct IConditionForceEffectVtbl effect_vtbl =
+{
+    effect_QueryInterface,
+    effect_AddRef,
+    effect_Release,
+    /* IInspectable methods */
+    effect_GetIids,
+    effect_GetRuntimeClassName,
+    effect_GetTrustLevel,
+    /* IConditionForceEffect methods */
+    effect_get_Kind,
+    effect_SetParameters,
+};
+
+struct condition_factory
+{
+    IActivationFactory IActivationFactory_iface;
+    IConditionForceEffectFactory IConditionForceEffectFactory_iface;
+    LONG ref;
+};
+
+static inline struct condition_factory *impl_from_IActivationFactory( IActivationFactory *iface )
+{
+    return CONTAINING_RECORD( iface, struct condition_factory, IActivationFactory_iface );
+}
+
+static HRESULT WINAPI activation_QueryInterface( IActivationFactory *iface, REFIID iid, void **out )
+{
+    struct condition_factory *impl = impl_from_IActivationFactory( iface );
+
+    TRACE( "iface %p, iid %s, out %p.\n", iface, debugstr_guid( iid ), out );
+
+    if (IsEqualGUID( iid, &IID_IUnknown ) ||
+        IsEqualGUID( iid, &IID_IInspectable ) ||
+        IsEqualGUID( iid, &IID_IAgileObject ) ||
+        IsEqualGUID( iid, &IID_IActivationFactory ))
+    {
+        IInspectable_AddRef( (*out = &impl->IActivationFactory_iface) );
+        return S_OK;
+    }
+
+    if (IsEqualGUID( iid, &IID_IConditionForceEffectFactory ))
+    {
+        IInspectable_AddRef( (*out = &impl->IConditionForceEffectFactory_iface) );
+        return S_OK;
+    }
+
+    FIXME( "%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid( iid ) );
+    *out = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI activation_AddRef( IActivationFactory *iface )
+{
+    struct condition_factory *impl = impl_from_IActivationFactory( iface );
+    ULONG ref = InterlockedIncrement( &impl->ref );
+    TRACE( "iface %p increasing refcount to %lu.\n", iface, ref );
+    return ref;
+}
+
+static ULONG WINAPI activation_Release( IActivationFactory *iface )
+{
+    struct condition_factory *impl = impl_from_IActivationFactory( iface );
+    ULONG ref = InterlockedDecrement( &impl->ref );
+    TRACE( "iface %p decreasing refcount to %lu.\n", iface, ref );
+    return ref;
+}
+
+static HRESULT WINAPI activation_GetIids( IActivationFactory *iface, ULONG *iid_count, IID **iids )
+{
+    FIXME( "iface %p, iid_count %p, iids %p stub!\n", iface, iid_count, iids );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI activation_GetRuntimeClassName( IActivationFactory *iface, HSTRING *class_name )
+{
+    FIXME( "iface %p, class_name %p stub!\n", iface, class_name );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI activation_GetTrustLevel( IActivationFactory *iface, TrustLevel *trust_level )
+{
+    FIXME( "iface %p, trust_level %p stub!\n", iface, trust_level );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI activation_ActivateInstance( IActivationFactory *iface, IInspectable **instance )
+{
+    FIXME( "iface %p, instance %p stub!\n", iface, instance );
+    return E_NOTIMPL;
+}
+
+static const struct IActivationFactoryVtbl activation_vtbl =
+{
+    activation_QueryInterface,
+    activation_AddRef,
+    activation_Release,
+    /* IInspectable methods */
+    activation_GetIids,
+    activation_GetRuntimeClassName,
+    activation_GetTrustLevel,
+    /* IActivationFactory methods */
+    activation_ActivateInstance,
+};
+
+DEFINE_IINSPECTABLE( factory, IConditionForceEffectFactory, struct condition_factory, IActivationFactory_iface )
+
+static HRESULT WINAPI factory_CreateInstance( IConditionForceEffectFactory *iface, enum ConditionForceEffectKind kind, IForceFeedbackEffect **out )
+{
+    enum WineForceFeedbackEffectType type = WineForceFeedbackEffectType_Condition + kind;
+    struct condition_effect *impl;
+    HRESULT hr;
+
+    TRACE( "iface %p, kind %u, out %p.\n", iface, kind, out );
+
+    if (!(impl = calloc( 1, sizeof(struct condition_effect) ))) return E_OUTOFMEMORY;
+    impl->IConditionForceEffect_iface.lpVtbl = &effect_vtbl;
+    impl->ref = 1;
+    impl->kind = kind;
+
+    if (FAILED(hr = force_feedback_effect_create( type, (IInspectable *)&impl->IConditionForceEffect_iface, &impl->IWineForceFeedbackEffectImpl_inner )) ||
+        FAILED(hr = IConditionForceEffect_QueryInterface( &impl->IConditionForceEffect_iface, &IID_IForceFeedbackEffect, (void **)out )))
+    {
+        if (impl->IWineForceFeedbackEffectImpl_inner) IWineForceFeedbackEffectImpl_Release( impl->IWineForceFeedbackEffectImpl_inner );
+        free( impl );
+        return hr;
+    }
+
+    IConditionForceEffect_Release( &impl->IConditionForceEffect_iface );
+    TRACE( "created ConditionForceEffect %p\n", *out );
+    return S_OK;
+}
+
+static const struct IConditionForceEffectFactoryVtbl factory_vtbl =
+{
+    factory_QueryInterface,
+    factory_AddRef,
+    factory_Release,
+    /* IInspectable methods */
+    factory_GetIids,
+    factory_GetRuntimeClassName,
+    factory_GetTrustLevel,
+    /* IConditionForceEffectFactory methods */
+    factory_CreateInstance,
+};
+
+static struct condition_factory condition_statics =
+{
+    {&activation_vtbl},
+    {&factory_vtbl},
+    1,
+};
+
+IInspectable *condition_effect_factory = (IInspectable *)&condition_statics.IActivationFactory_iface;
diff --git a/dlls/windows.gaming.input/constant_effect.c b/dlls/windows.gaming.input/constant_effect.c
new file mode 100644
index 00000000000..15763b30d67
--- /dev/null
+++ wine/dlls/windows.gaming.input/constant_effect.c
@@ -0,0 +1,275 @@
+/* WinRT Windows.Gaming.Input implementation
+ *
+ * Copyright 2022 Rémi Bernon for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "private.h"
+#include "provider.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(input);
+
+struct constant_effect
+{
+    IConstantForceEffect IConstantForceEffect_iface;
+    IWineForceFeedbackEffectImpl *IWineForceFeedbackEffectImpl_inner;
+    LONG ref;
+};
+
+static inline struct constant_effect *impl_from_IConstantForceEffect( IConstantForceEffect *iface )
+{
+    return CONTAINING_RECORD( iface, struct constant_effect, IConstantForceEffect_iface );
+}
+
+static HRESULT WINAPI effect_QueryInterface( IConstantForceEffect *iface, REFIID iid, void **out )
+{
+    struct constant_effect *impl = impl_from_IConstantForceEffect( iface );
+
+    TRACE( "iface %p, iid %s, out %p.\n", iface, debugstr_guid( iid ), out );
+
+    if (IsEqualGUID( iid, &IID_IUnknown ) ||
+        IsEqualGUID( iid, &IID_IInspectable ) ||
+        IsEqualGUID( iid, &IID_IAgileObject ) ||
+        IsEqualGUID( iid, &IID_IConstantForceEffect ))
+    {
+        IInspectable_AddRef( (*out = &impl->IConstantForceEffect_iface) );
+        return S_OK;
+    }
+
+    return IWineForceFeedbackEffectImpl_QueryInterface( impl->IWineForceFeedbackEffectImpl_inner, iid, out );
+}
+
+static ULONG WINAPI effect_AddRef( IConstantForceEffect *iface )
+{
+    struct constant_effect *impl = impl_from_IConstantForceEffect( iface );
+    ULONG ref = InterlockedIncrement( &impl->ref );
+    TRACE( "iface %p increasing refcount to %lu.\n", iface, ref );
+    return ref;
+}
+
+static ULONG WINAPI effect_Release( IConstantForceEffect *iface )
+{
+    struct constant_effect *impl = impl_from_IConstantForceEffect( iface );
+    ULONG ref = InterlockedDecrement( &impl->ref );
+
+    TRACE( "iface %p decreasing refcount to %lu.\n", iface, ref );
+
+    if (!ref)
+    {
+        /* guard against re-entry if inner releases an outer iface */
+        InterlockedIncrement( &impl->ref );
+        IWineForceFeedbackEffectImpl_Release( impl->IWineForceFeedbackEffectImpl_inner );
+        free( impl );
+    }
+
+    return ref;
+}
+
+static HRESULT WINAPI effect_GetIids( IConstantForceEffect *iface, ULONG *iid_count, IID **iids )
+{
+    FIXME( "iface %p, iid_count %p, iids %p stub!\n", iface, iid_count, iids );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI effect_GetRuntimeClassName( IConstantForceEffect *iface, HSTRING *class_name )
+{
+    return WindowsCreateString( RuntimeClass_Windows_Gaming_Input_ForceFeedback_ConstantForceEffect,
+                                ARRAY_SIZE(RuntimeClass_Windows_Gaming_Input_ForceFeedback_ConstantForceEffect),
+                                class_name );
+}
+
+static HRESULT WINAPI effect_GetTrustLevel( IConstantForceEffect *iface, TrustLevel *trust_level )
+{
+    FIXME( "iface %p, trust_level %p stub!\n", iface, trust_level );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI effect_SetParameters( IConstantForceEffect *iface, Vector3 direction, TimeSpan duration )
+{
+    WineForceFeedbackEffectParameters params =
+    {
+        .constant =
+        {
+            .type = WineForceFeedbackEffectType_Constant,
+            .direction = direction,
+            .duration = duration,
+            .repeat_count = 1,
+            .gain = 1.,
+        },
+    };
+    struct constant_effect *impl = impl_from_IConstantForceEffect( iface );
+
+    TRACE( "iface %p, direction %s, duration %I64u.\n", iface, debugstr_vector3( &direction ), duration.Duration );
+
+    return IWineForceFeedbackEffectImpl_put_Parameters( impl->IWineForceFeedbackEffectImpl_inner, params, NULL );
+}
+
+static HRESULT WINAPI effect_SetParametersWithEnvelope( IConstantForceEffect *iface, Vector3 direction, FLOAT attack_gain,
+                                                        FLOAT sustain_gain, FLOAT release_gain, TimeSpan start_delay,
+                                                        TimeSpan attack_duration, TimeSpan sustain_duration,
+                                                        TimeSpan release_duration, UINT32 repeat_count )
+{
+    WineForceFeedbackEffectParameters params =
+    {
+        .constant =
+        {
+            .type = WineForceFeedbackEffectType_Constant,
+            .direction = direction,
+            .duration = {attack_duration.Duration + sustain_duration.Duration + release_duration.Duration},
+            .start_delay = start_delay,
+            .repeat_count = repeat_count,
+            .gain = sustain_gain,
+        },
+    };
+    WineForceFeedbackEffectEnvelope envelope =
+    {
+        .attack_gain = attack_gain,
+        .release_gain = release_gain,
+        .attack_duration = attack_duration,
+        .release_duration = release_duration,
+    };
+    struct constant_effect *impl = impl_from_IConstantForceEffect( iface );
+
+    TRACE( "iface %p, direction %s, attack_gain %f, sustain_gain %f, release_gain %f, start_delay %I64u, attack_duration %I64u, "
+           "sustain_duration %I64u, release_duration %I64u, repeat_count %u.\n", iface, debugstr_vector3( &direction ),
+           attack_gain, sustain_gain, release_gain, start_delay.Duration, attack_duration.Duration, sustain_duration.Duration,
+           release_duration.Duration, repeat_count );
+
+    return IWineForceFeedbackEffectImpl_put_Parameters( impl->IWineForceFeedbackEffectImpl_inner, params, &envelope );
+}
+
+static const struct IConstantForceEffectVtbl effect_vtbl =
+{
+    effect_QueryInterface,
+    effect_AddRef,
+    effect_Release,
+    /* IInspectable methods */
+    effect_GetIids,
+    effect_GetRuntimeClassName,
+    effect_GetTrustLevel,
+    /* IConstantForceEffect methods */
+    effect_SetParameters,
+    effect_SetParametersWithEnvelope,
+};
+
+struct constant_factory
+{
+    IActivationFactory IActivationFactory_iface;
+    LONG ref;
+};
+
+static inline struct constant_factory *impl_from_IActivationFactory( IActivationFactory *iface )
+{
+    return CONTAINING_RECORD( iface, struct constant_factory, IActivationFactory_iface );
+}
+
+static HRESULT WINAPI activation_QueryInterface( IActivationFactory *iface, REFIID iid, void **out )
+{
+    struct constant_factory *impl = impl_from_IActivationFactory( iface );
+
+    TRACE( "iface %p, iid %s, out %p.\n", iface, debugstr_guid( iid ), out );
+
+    if (IsEqualGUID( iid, &IID_IUnknown ) ||
+        IsEqualGUID( iid, &IID_IInspectable ) ||
+        IsEqualGUID( iid, &IID_IAgileObject ) ||
+        IsEqualGUID( iid, &IID_IActivationFactory ))
+    {
+        IInspectable_AddRef( (*out = &impl->IActivationFactory_iface) );
+        return S_OK;
+    }
+
+    FIXME( "%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid( iid ) );
+    *out = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI activation_AddRef( IActivationFactory *iface )
+{
+    struct constant_factory *impl = impl_from_IActivationFactory( iface );
+    ULONG ref = InterlockedIncrement( &impl->ref );
+    TRACE( "iface %p increasing refcount to %lu.\n", iface, ref );
+    return ref;
+}
+
+static ULONG WINAPI activation_Release( IActivationFactory *iface )
+{
+    struct constant_factory *impl = impl_from_IActivationFactory( iface );
+    ULONG ref = InterlockedDecrement( &impl->ref );
+    TRACE( "iface %p decreasing refcount to %lu.\n", iface, ref );
+    return ref;
+}
+
+static HRESULT WINAPI activation_GetIids( IActivationFactory *iface, ULONG *iid_count, IID **iids )
+{
+    FIXME( "iface %p, iid_count %p, iids %p stub!\n", iface, iid_count, iids );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI activation_GetRuntimeClassName( IActivationFactory *iface, HSTRING *class_name )
+{
+    FIXME( "iface %p, class_name %p stub!\n", iface, class_name );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI activation_GetTrustLevel( IActivationFactory *iface, TrustLevel *trust_level )
+{
+    FIXME( "iface %p, trust_level %p stub!\n", iface, trust_level );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI activation_ActivateInstance( IActivationFactory *iface, IInspectable **instance )
+{
+    struct constant_effect *impl;
+    HRESULT hr;
+
+    TRACE( "iface %p, instance %p.\n", iface, instance );
+
+    if (!(impl = calloc( 1, sizeof(struct constant_effect) ))) return E_OUTOFMEMORY;
+    impl->IConstantForceEffect_iface.lpVtbl = &effect_vtbl;
+    impl->ref = 1;
+
+    if (FAILED(hr = force_feedback_effect_create( WineForceFeedbackEffectType_Constant, (IInspectable *)&impl->IConstantForceEffect_iface,
+                                                  &impl->IWineForceFeedbackEffectImpl_inner )))
+    {
+        free( impl );
+        return hr;
+    }
+
+    *instance = (IInspectable *)&impl->IConstantForceEffect_iface;
+    TRACE( "created ConstantForceEffect %p\n", *instance );
+    return S_OK;
+}
+
+static const struct IActivationFactoryVtbl activation_vtbl =
+{
+    activation_QueryInterface,
+    activation_AddRef,
+    activation_Release,
+    /* IInspectable methods */
+    activation_GetIids,
+    activation_GetRuntimeClassName,
+    activation_GetTrustLevel,
+    /* IActivationFactory methods */
+    activation_ActivateInstance,
+};
+
+static struct constant_factory constant_statics =
+{
+    {&activation_vtbl},
+    1,
+};
+
+IInspectable *constant_effect_factory = (IInspectable *)&constant_statics.IActivationFactory_iface;
diff --git a/dlls/windows.gaming.input/controller.c b/dlls/windows.gaming.input/controller.c
index 03a3ae398cf..bd3d441c445 100644
--- wine/dlls/windows.gaming.input/controller.c
+++ wine/dlls/windows.gaming.input/controller.c
@@ -99,7 +99,7 @@ static HRESULT WINAPI controller_QueryInterface( IGameControllerImpl *iface, REF
         return S_OK;
     }
 
-    WARN( "%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid( iid ) );
+    FIXME( "%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid( iid ) );
     *out = NULL;
     return E_NOINTERFACE;
 }
@@ -229,8 +229,32 @@ static HRESULT WINAPI raw_controller_get_ButtonCount( IRawGameController *iface,
 
 static HRESULT WINAPI raw_controller_get_ForceFeedbackMotors( IRawGameController *iface, IVectorView_ForceFeedbackMotor **value )
 {
-    FIXME( "iface %p, value %p stub!\n", iface, value );
-    return E_NOTIMPL;
+    static const struct vector_iids iids =
+    {
+        .vector = &IID_IVector_ForceFeedbackMotor,
+        .view = &IID_IVectorView_ForceFeedbackMotor,
+        .iterable = &IID_IIterable_ForceFeedbackMotor,
+        .iterator = &IID_IIterator_ForceFeedbackMotor,
+    };
+    struct controller *impl = impl_from_IRawGameController( iface );
+    IVector_ForceFeedbackMotor *vector;
+    IForceFeedbackMotor *motor;
+    HRESULT hr;
+
+    TRACE( "iface %p, value %p\n", iface, value );
+
+    if (FAILED(hr = vector_create( &iids, (void **)&vector ))) return hr;
+
+    if (SUCCEEDED(IWineGameControllerProvider_get_ForceFeedbackMotor( impl->wine_provider, &motor )) && motor)
+    {
+        hr = IVector_ForceFeedbackMotor_Append( vector, motor );
+        IForceFeedbackMotor_Release( motor );
+    }
+
+    if (SUCCEEDED(hr)) hr = IVector_ForceFeedbackMotor_GetView( vector, value );
+    IVector_ForceFeedbackMotor_Release( vector );
+
+    return hr;
 }
 
 static HRESULT WINAPI raw_controller_get_HardwareProductId( IRawGameController *iface, UINT16 *value )
diff --git a/dlls/windows.gaming.input/force_feedback.c b/dlls/windows.gaming.input/force_feedback.c
new file mode 100644
index 00000000000..f7a233b46d4
--- /dev/null
+++ wine/dlls/windows.gaming.input/force_feedback.c
@@ -0,0 +1,801 @@
+/* WinRT Windows.Gaming.Input implementation
+ *
+ * Copyright 2022 Rémi Bernon for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "private.h"
+
+#include "math.h"
+
+#include "ddk/hidsdi.h"
+#include "dinput.h"
+#include "hidusage.h"
+#include "provider.h"
+
+#include "wine/debug.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(input);
+
+struct effect
+{
+    IWineForceFeedbackEffectImpl IWineForceFeedbackEffectImpl_iface;
+    IForceFeedbackEffect IForceFeedbackEffect_iface;
+    IInspectable *IInspectable_outer;
+    LONG ref;
+
+    CRITICAL_SECTION cs;
+    IDirectInputEffect *effect;
+
+    GUID type;
+    DWORD axes[3];
+    LONG directions[3];
+    ULONG repeat_count;
+    DICONSTANTFORCE constant_force;
+    DIRAMPFORCE ramp_force;
+    DICONDITION condition;
+    DIPERIODIC periodic;
+    DIENVELOPE envelope;
+    DIEFFECT params;
+};
+
+static inline struct effect *impl_from_IWineForceFeedbackEffectImpl( IWineForceFeedbackEffectImpl *iface )
+{
+    return CONTAINING_RECORD( iface, struct effect, IWineForceFeedbackEffectImpl_iface );
+}
+
+static HRESULT WINAPI effect_impl_QueryInterface( IWineForceFeedbackEffectImpl *iface, REFIID iid, void **out )
+{
+    struct effect *impl = impl_from_IWineForceFeedbackEffectImpl( iface );
+
+    TRACE( "iface %p, iid %s, out %p.\n", iface, debugstr_guid( iid ), out );
+
+    if (IsEqualGUID( iid, &IID_IUnknown ) ||
+        IsEqualGUID( iid, &IID_IInspectable ) ||
+        IsEqualGUID( iid, &IID_IAgileObject ) ||
+        IsEqualGUID( iid, &IID_IWineForceFeedbackEffectImpl ))
+    {
+        IWineForceFeedbackEffectImpl_AddRef( (*out = &impl->IWineForceFeedbackEffectImpl_iface) );
+        return S_OK;
+    }
+
+    if (IsEqualGUID( iid, &IID_IForceFeedbackEffect ))
+    {
+        IInspectable_AddRef( (*out = &impl->IForceFeedbackEffect_iface) );
+        return S_OK;
+    }
+
+    FIXME( "%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid( iid ) );
+    *out = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI effect_impl_AddRef( IWineForceFeedbackEffectImpl *iface )
+{
+    struct effect *impl = impl_from_IWineForceFeedbackEffectImpl( iface );
+    ULONG ref = InterlockedIncrement( &impl->ref );
+    TRACE( "iface %p increasing refcount to %lu.\n", iface, ref );
+    return ref;
+}
+
+static ULONG WINAPI effect_impl_Release( IWineForceFeedbackEffectImpl *iface )
+{
+    struct effect *impl = impl_from_IWineForceFeedbackEffectImpl( iface );
+    ULONG ref = InterlockedDecrement( &impl->ref );
+
+    TRACE( "iface %p decreasing refcount to %lu.\n", iface, ref );
+
+    if (!ref)
+    {
+        if (impl->effect) IDirectInputEffect_Release( impl->effect );
+        impl->cs.DebugInfo->Spare[0] = 0;
+        DeleteCriticalSection( &impl->cs );
+        free( impl );
+    }
+
+    return ref;
+}
+
+static HRESULT WINAPI effect_impl_put_Parameters( IWineForceFeedbackEffectImpl *iface, WineForceFeedbackEffectParameters params,
+                                                  WineForceFeedbackEffectEnvelope *envelope )
+{
+    struct effect *impl = impl_from_IWineForceFeedbackEffectImpl( iface );
+    DWORD count = 0;
+    HRESULT hr;
+
+    TRACE( "iface %p, params %p, envelope %p.\n", iface, &params, envelope );
+
+    EnterCriticalSection( &impl->cs );
+    switch (params.type)
+    {
+    case WineForceFeedbackEffectType_Constant:
+        impl->repeat_count = params.constant.repeat_count;
+        impl->constant_force.lMagnitude = round( params.constant.gain * params.constant.direction.X * 10000 );
+        impl->params.dwDuration = params.constant.duration.Duration / 10;
+        impl->params.dwStartDelay = params.constant.start_delay.Duration / 10;
+        if (impl->axes[count] == DIJOFS_X) impl->directions[count++] = round( -params.constant.direction.X * 10000 );
+        if (impl->axes[count] == DIJOFS_Y) impl->directions[count++] = round( -params.constant.direction.Y * 10000 );
+        if (impl->axes[count] == DIJOFS_Z) impl->directions[count++] = round( -params.constant.direction.Z * 10000 );
+        break;
+
+    case WineForceFeedbackEffectType_Ramp:
+        impl->repeat_count = params.ramp.repeat_count;
+        impl->ramp_force.lStart = round( params.ramp.gain * params.ramp.start_vector.X * 10000 );
+        impl->ramp_force.lEnd = round( params.ramp.gain * params.ramp.end_vector.X * 10000 );
+        impl->params.dwDuration = params.ramp.duration.Duration / 10;
+        impl->params.dwStartDelay = params.ramp.start_delay.Duration / 10;
+        if (impl->axes[count] == DIJOFS_X) impl->directions[count++] = round( -params.ramp.start_vector.X * 10000 );
+        if (impl->axes[count] == DIJOFS_Y) impl->directions[count++] = round( -params.ramp.start_vector.Y * 10000 );
+        if (impl->axes[count] == DIJOFS_Z) impl->directions[count++] = round( -params.ramp.start_vector.Z * 10000 );
+        break;
+
+    case WineForceFeedbackEffectType_Periodic_SineWave:
+    case WineForceFeedbackEffectType_Periodic_TriangleWave:
+    case WineForceFeedbackEffectType_Periodic_SquareWave:
+    case WineForceFeedbackEffectType_Periodic_SawtoothWaveDown:
+    case WineForceFeedbackEffectType_Periodic_SawtoothWaveUp:
+        impl->repeat_count = params.periodic.repeat_count;
+        impl->periodic.dwMagnitude = round( params.periodic.gain * 10000 );
+        impl->periodic.dwPeriod = 1000000 / params.periodic.frequency;
+        impl->periodic.dwPhase = round( params.periodic.phase * 36000 );
+        impl->periodic.lOffset = round( params.periodic.bias * 10000 );
+        impl->params.dwDuration = params.periodic.duration.Duration / 10;
+        impl->params.dwStartDelay = params.periodic.start_delay.Duration / 10;
+        if (impl->axes[count] == DIJOFS_X) impl->directions[count++] = round( -params.periodic.direction.X * 10000 );
+        if (impl->axes[count] == DIJOFS_Y) impl->directions[count++] = round( -params.periodic.direction.Y * 10000 );
+        if (impl->axes[count] == DIJOFS_Z) impl->directions[count++] = round( -params.periodic.direction.Z * 10000 );
+        break;
+
+    case WineForceFeedbackEffectType_Condition_Spring:
+    case WineForceFeedbackEffectType_Condition_Damper:
+    case WineForceFeedbackEffectType_Condition_Inertia:
+    case WineForceFeedbackEffectType_Condition_Friction:
+        impl->repeat_count = 1;
+        impl->condition.lPositiveCoefficient = round( atan( params.condition.positive_coeff ) / M_PI_2 * 10000 );
+        impl->condition.lNegativeCoefficient = round( atan( params.condition.negative_coeff ) / M_PI_2 * 10000 );
+        impl->condition.dwPositiveSaturation = round( params.condition.max_positive_magnitude * 10000 );
+        impl->condition.dwNegativeSaturation = round( params.condition.max_negative_magnitude * 10000 );
+        impl->condition.lDeadBand = round( params.condition.deadzone * 10000 );
+        impl->condition.lOffset = round( params.condition.bias * 10000 );
+        impl->params.dwDuration = -1;
+        impl->params.dwStartDelay = 0;
+        if (impl->axes[count] == DIJOFS_X) impl->directions[count++] = round( params.condition.direction.X * 10000 );
+        if (impl->axes[count] == DIJOFS_Y) impl->directions[count++] = round( params.condition.direction.Y * 10000 );
+        if (impl->axes[count] == DIJOFS_Z) impl->directions[count++] = round( params.condition.direction.Z * 10000 );
+        break;
+    }
+
+    if (!envelope) impl->params.lpEnvelope = NULL;
+    else
+    {
+        impl->envelope.dwAttackTime = envelope->attack_duration.Duration / 10;
+        impl->envelope.dwAttackLevel = round( envelope->attack_gain * 10000 );
+        impl->envelope.dwFadeTime = impl->params.dwDuration - envelope->release_duration.Duration / 10;
+        impl->envelope.dwFadeLevel = round( envelope->release_gain * 10000 );
+        impl->params.lpEnvelope = &impl->envelope;
+    }
+
+    if (!impl->effect) hr = S_OK;
+    else hr = IDirectInputEffect_SetParameters( impl->effect, &impl->params, DIEP_ALLPARAMS & ~DIEP_AXES );
+    LeaveCriticalSection( &impl->cs );
+
+    return hr;
+}
+
+static const struct IWineForceFeedbackEffectImplVtbl effect_impl_vtbl =
+{
+    effect_impl_QueryInterface,
+    effect_impl_AddRef,
+    effect_impl_Release,
+    /* IWineForceFeedbackEffectImpl methods */
+    effect_impl_put_Parameters,
+};
+
+DEFINE_IINSPECTABLE_OUTER( effect, IForceFeedbackEffect, struct effect, IInspectable_outer )
+
+static HRESULT WINAPI effect_get_Gain( IForceFeedbackEffect *iface, DOUBLE *value )
+{
+    struct effect *impl = impl_from_IForceFeedbackEffect( iface );
+
+    TRACE( "iface %p, value %p.\n", iface, value );
+
+    EnterCriticalSection( &impl->cs );
+    *value = impl->params.dwGain / 10000.;
+    LeaveCriticalSection( &impl->cs );
+
+    return S_OK;
+}
+
+static HRESULT WINAPI effect_put_Gain( IForceFeedbackEffect *iface, DOUBLE value )
+{
+    struct effect *impl = impl_from_IForceFeedbackEffect( iface );
+    HRESULT hr;
+
+    TRACE( "iface %p, value %f.\n", iface, value );
+
+    EnterCriticalSection( &impl->cs );
+    impl->params.dwGain = round( value * 10000 );
+    if (!impl->effect) hr = S_FALSE;
+    else hr = IDirectInputEffect_SetParameters( impl->effect, &impl->params, DIEP_GAIN );
+    LeaveCriticalSection( &impl->cs );
+
+    return hr;
+}
+
+static HRESULT WINAPI effect_get_State( IForceFeedbackEffect *iface, ForceFeedbackEffectState *value )
+{
+    struct effect *impl = impl_from_IForceFeedbackEffect( iface );
+    DWORD status;
+    HRESULT hr;
+
+    TRACE( "iface %p, value %p.\n", iface, value );
+
+    EnterCriticalSection( &impl->cs );
+    if (!impl->effect)
+        *value = ForceFeedbackEffectState_Stopped;
+    else if (FAILED(hr = IDirectInputEffect_GetEffectStatus( impl->effect, &status )))
+        *value = ForceFeedbackEffectState_Faulted;
+    else
+    {
+        if (status == DIEGES_PLAYING) *value = ForceFeedbackEffectState_Running;
+        else *value = ForceFeedbackEffectState_Stopped;
+    }
+    LeaveCriticalSection( &impl->cs );
+
+    return S_OK;
+}
+
+static HRESULT WINAPI effect_Start( IForceFeedbackEffect *iface )
+{
+    struct effect *impl = impl_from_IForceFeedbackEffect( iface );
+    HRESULT hr = E_UNEXPECTED;
+    DWORD flags = 0;
+
+    TRACE( "iface %p.\n", iface );
+
+    EnterCriticalSection( &impl->cs );
+    if (impl->effect) hr = IDirectInputEffect_Start( impl->effect, impl->repeat_count, flags );
+    LeaveCriticalSection( &impl->cs );
+
+    return hr;
+}
+
+static HRESULT WINAPI effect_Stop( IForceFeedbackEffect *iface )
+{
+    struct effect *impl = impl_from_IForceFeedbackEffect( iface );
+    HRESULT hr = E_UNEXPECTED;
+
+    TRACE( "iface %p.\n", iface );
+
+    EnterCriticalSection( &impl->cs );
+    if (impl->effect) hr = IDirectInputEffect_Stop( impl->effect );
+    LeaveCriticalSection( &impl->cs );
+
+    return hr;
+}
+
+static const struct IForceFeedbackEffectVtbl effect_vtbl =
+{
+    effect_QueryInterface,
+    effect_AddRef,
+    effect_Release,
+    /* IInspectable methods */
+    effect_GetIids,
+    effect_GetRuntimeClassName,
+    effect_GetTrustLevel,
+    /* IForceFeedbackEffect methods */
+    effect_get_Gain,
+    effect_put_Gain,
+    effect_get_State,
+    effect_Start,
+    effect_Stop,
+};
+
+HRESULT force_feedback_effect_create( enum WineForceFeedbackEffectType type, IInspectable *outer, IWineForceFeedbackEffectImpl **out )
+{
+    struct effect *impl;
+
+    TRACE( "outer %p, out %p\n", outer, out );
+
+    if (!(impl = calloc( 1, sizeof(*impl) ))) return E_OUTOFMEMORY;
+    impl->IWineForceFeedbackEffectImpl_iface.lpVtbl = &effect_impl_vtbl;
+    impl->IForceFeedbackEffect_iface.lpVtbl = &effect_vtbl;
+    impl->IInspectable_outer = outer;
+    impl->ref = 1;
+
+    switch (type)
+    {
+    case WineForceFeedbackEffectType_Constant:
+        impl->type = GUID_ConstantForce;
+        impl->params.lpvTypeSpecificParams = &impl->constant_force;
+        impl->params.cbTypeSpecificParams = sizeof(impl->constant_force);
+        break;
+
+    case WineForceFeedbackEffectType_Ramp:
+        impl->type = GUID_RampForce;
+        impl->params.lpvTypeSpecificParams = &impl->ramp_force;
+        impl->params.cbTypeSpecificParams = sizeof(impl->ramp_force);
+        break;
+
+    case WineForceFeedbackEffectType_Periodic_SineWave:
+        impl->type = GUID_Sine;
+        goto WineForceFeedbackEffectType_Periodic;
+    case WineForceFeedbackEffectType_Periodic_TriangleWave:
+        impl->type = GUID_Triangle;
+        goto WineForceFeedbackEffectType_Periodic;
+    case WineForceFeedbackEffectType_Periodic_SquareWave:
+        impl->type = GUID_Square;
+        goto WineForceFeedbackEffectType_Periodic;
+    case WineForceFeedbackEffectType_Periodic_SawtoothWaveDown:
+        impl->type = GUID_SawtoothDown;
+        goto WineForceFeedbackEffectType_Periodic;
+    case WineForceFeedbackEffectType_Periodic_SawtoothWaveUp:
+        impl->type = GUID_SawtoothUp;
+        goto WineForceFeedbackEffectType_Periodic;
+    WineForceFeedbackEffectType_Periodic:
+        impl->params.lpvTypeSpecificParams = &impl->periodic;
+        impl->params.cbTypeSpecificParams = sizeof(impl->periodic);
+        break;
+
+    case WineForceFeedbackEffectType_Condition_Spring:
+        impl->type = GUID_Spring;
+        goto WineForceFeedbackEffectType_Condition;
+    case WineForceFeedbackEffectType_Condition_Damper:
+        impl->type = GUID_Damper;
+        goto WineForceFeedbackEffectType_Condition;
+    case WineForceFeedbackEffectType_Condition_Inertia:
+        impl->type = GUID_Inertia;
+        goto WineForceFeedbackEffectType_Condition;
+    case WineForceFeedbackEffectType_Condition_Friction:
+        impl->type = GUID_Friction;
+        goto WineForceFeedbackEffectType_Condition;
+    WineForceFeedbackEffectType_Condition:
+        impl->params.lpvTypeSpecificParams = &impl->condition;
+        impl->params.cbTypeSpecificParams = sizeof(impl->condition);
+        break;
+    }
+
+    impl->envelope.dwSize = sizeof(DIENVELOPE);
+    impl->params.dwSize = sizeof(DIEFFECT);
+    impl->params.rgdwAxes = impl->axes;
+    impl->params.rglDirection = impl->directions;
+    impl->params.dwTriggerButton = -1;
+    impl->params.dwGain = 10000;
+    impl->params.dwFlags = DIEFF_CARTESIAN|DIEFF_OBJECTOFFSETS;
+    impl->params.cAxes = -1;
+    impl->axes[0] = DIJOFS_X;
+    impl->axes[1] = DIJOFS_Y;
+    impl->axes[2] = DIJOFS_Z;
+
+    InitializeCriticalSection( &impl->cs );
+    impl->cs.DebugInfo->Spare[0] = (DWORD_PTR)( __FILE__ ": effect.cs" );
+
+    *out = &impl->IWineForceFeedbackEffectImpl_iface;
+    TRACE( "created ForceFeedbackEffect %p\n", *out );
+    return S_OK;
+}
+
+struct motor
+{
+    IForceFeedbackMotor IForceFeedbackMotor_iface;
+    LONG ref;
+
+    IDirectInputDevice8W *device;
+};
+
+static inline struct motor *impl_from_IForceFeedbackMotor( IForceFeedbackMotor *iface )
+{
+    return CONTAINING_RECORD( iface, struct motor, IForceFeedbackMotor_iface );
+}
+
+static HRESULT WINAPI motor_QueryInterface( IForceFeedbackMotor *iface, REFIID iid, void **out )
+{
+    struct motor *impl = impl_from_IForceFeedbackMotor( iface );
+
+    TRACE( "iface %p, iid %s, out %p.\n", iface, debugstr_guid( iid ), out );
+
+    if (IsEqualGUID( iid, &IID_IUnknown ) ||
+        IsEqualGUID( iid, &IID_IInspectable ) ||
+        IsEqualGUID( iid, &IID_IAgileObject ) ||
+        IsEqualGUID( iid, &IID_IForceFeedbackMotor ))
+    {
+        IInspectable_AddRef( (*out = &impl->IForceFeedbackMotor_iface) );
+        return S_OK;
+    }
+
+    FIXME( "%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid( iid ) );
+    *out = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI motor_AddRef( IForceFeedbackMotor *iface )
+{
+    struct motor *impl = impl_from_IForceFeedbackMotor( iface );
+    ULONG ref = InterlockedIncrement( &impl->ref );
+    TRACE( "iface %p increasing refcount to %lu.\n", iface, ref );
+    return ref;
+}
+
+static ULONG WINAPI motor_Release( IForceFeedbackMotor *iface )
+{
+    struct motor *impl = impl_from_IForceFeedbackMotor( iface );
+    ULONG ref = InterlockedDecrement( &impl->ref );
+
+    TRACE( "iface %p decreasing refcount to %lu.\n", iface, ref );
+
+    if (!ref)
+    {
+        IDirectInputDevice8_Release( impl->device );
+        free( impl );
+    }
+
+    return ref;
+}
+
+static HRESULT WINAPI motor_GetIids( IForceFeedbackMotor *iface, ULONG *iid_count, IID **iids )
+{
+    FIXME( "iface %p, iid_count %p, iids %p stub!\n", iface, iid_count, iids );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI motor_GetRuntimeClassName( IForceFeedbackMotor *iface, HSTRING *class_name )
+{
+    return WindowsCreateString( RuntimeClass_Windows_Gaming_Input_ForceFeedback_ForceFeedbackMotor,
+                                ARRAY_SIZE(RuntimeClass_Windows_Gaming_Input_ForceFeedback_ForceFeedbackMotor),
+                                class_name );
+}
+
+static HRESULT WINAPI motor_GetTrustLevel( IForceFeedbackMotor *iface, TrustLevel *trust_level )
+{
+    FIXME( "iface %p, trust_level %p stub!\n", iface, trust_level );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI motor_get_AreEffectsPaused( IForceFeedbackMotor *iface, BOOLEAN *value )
+{
+    struct motor *impl = impl_from_IForceFeedbackMotor( iface );
+    DWORD state;
+    HRESULT hr;
+
+    TRACE( "iface %p, value %p.\n", iface, value );
+
+    if (FAILED(hr = IDirectInputDevice8_GetForceFeedbackState( impl->device, &state ))) *value = FALSE;
+    else *value = (state & DIGFFS_PAUSED);
+
+    return hr;
+}
+
+static HRESULT WINAPI motor_get_MasterGain( IForceFeedbackMotor *iface, double *value )
+{
+    struct motor *impl = impl_from_IForceFeedbackMotor( iface );
+    DIPROPDWORD gain =
+    {
+        .diph =
+        {
+            .dwSize = sizeof(DIPROPDWORD),
+            .dwHeaderSize = sizeof(DIPROPHEADER),
+            .dwHow = DIPH_DEVICE,
+        },
+    };
+    HRESULT hr;
+
+    TRACE( "iface %p, value %p.\n", iface, value );
+
+    if (FAILED(hr = IDirectInputDevice8_GetProperty( impl->device, DIPROP_FFGAIN, &gain.diph ))) *value = 1.;
+    else *value = gain.dwData / 10000.;
+
+    return hr;
+}
+
+static HRESULT WINAPI motor_put_MasterGain( IForceFeedbackMotor *iface, double value )
+{
+    struct motor *impl = impl_from_IForceFeedbackMotor( iface );
+    DIPROPDWORD gain =
+    {
+        .diph =
+        {
+            .dwSize = sizeof(DIPROPDWORD),
+            .dwHeaderSize = sizeof(DIPROPHEADER),
+            .dwHow = DIPH_DEVICE,
+        },
+    };
+
+    TRACE( "iface %p, value %f.\n", iface, value );
+
+    gain.dwData = 10000 * value;
+    return IDirectInputDevice8_SetProperty( impl->device, DIPROP_FFGAIN, &gain.diph );
+}
+
+static HRESULT WINAPI motor_get_IsEnabled( IForceFeedbackMotor *iface, BOOLEAN *value )
+{
+    struct motor *impl = impl_from_IForceFeedbackMotor( iface );
+    DWORD state;
+    HRESULT hr;
+
+    TRACE( "iface %p, value %p.\n", iface, value );
+
+    if (FAILED(hr = IDirectInputDevice8_GetForceFeedbackState( impl->device, &state ))) *value = FALSE;
+    else *value = !(state & DIGFFS_ACTUATORSOFF);
+
+    return hr;
+}
+
+static BOOL CALLBACK check_ffb_axes( const DIDEVICEOBJECTINSTANCEW *obj, void *args )
+{
+    ForceFeedbackEffectAxes *value = args;
+
+    if (obj->dwType & DIDFT_FFACTUATOR)
+    {
+        if (IsEqualIID( &obj->guidType, &GUID_XAxis )) *value |= ForceFeedbackEffectAxes_X;
+        else if (IsEqualIID( &obj->guidType, &GUID_YAxis )) *value |= ForceFeedbackEffectAxes_Y;
+        else if (IsEqualIID( &obj->guidType, &GUID_ZAxis )) *value |= ForceFeedbackEffectAxes_Z;
+    }
+
+    return DIENUM_CONTINUE;
+}
+
+static HRESULT WINAPI motor_get_SupportedAxes( IForceFeedbackMotor *iface, enum ForceFeedbackEffectAxes *value )
+{
+    struct motor *impl = impl_from_IForceFeedbackMotor( iface );
+    HRESULT hr;
+
+    TRACE( "iface %p, value %p.\n", iface, value );
+
+    *value = ForceFeedbackEffectAxes_None;
+    if (FAILED(hr = IDirectInputDevice8_EnumObjects( impl->device, check_ffb_axes, value, DIDFT_AXIS )))
+        *value = ForceFeedbackEffectAxes_None;
+
+    return hr;
+}
+
+static HRESULT WINAPI motor_load_effect_async( IUnknown *invoker, IUnknown *param, PROPVARIANT *result )
+{
+    struct effect *effect = impl_from_IForceFeedbackEffect( (IForceFeedbackEffect *)param );
+    IForceFeedbackMotor *motor = (IForceFeedbackMotor *)invoker;
+    struct motor *impl = impl_from_IForceFeedbackMotor( motor );
+    ForceFeedbackEffectAxes supported_axes = 0;
+    IDirectInputEffect *dinput_effect;
+    HRESULT hr;
+
+    EnterCriticalSection( &effect->cs );
+
+    if (FAILED(hr = IForceFeedbackMotor_get_SupportedAxes( motor, &supported_axes )))
+    {
+        WARN( "get_SupportedAxes for motor %p returned %#lx\n", motor, hr );
+        effect->params.cAxes = 0;
+    }
+    else if (effect->params.cAxes == -1)
+    {
+        DWORD count = 0;
+
+        /* initialize axis mapping and re-map directions that were set with the initial mapping */
+        if (supported_axes & ForceFeedbackEffectAxes_X)
+        {
+            effect->directions[count] = effect->directions[0];
+            effect->axes[count++] = DIJOFS_X;
+        }
+        if (supported_axes & ForceFeedbackEffectAxes_Y)
+        {
+            effect->directions[count] = effect->directions[1];
+            effect->axes[count++] = DIJOFS_Y;
+        }
+        if (supported_axes & ForceFeedbackEffectAxes_Z)
+        {
+            effect->directions[count] = effect->directions[2];
+            effect->axes[count++] = DIJOFS_Z;
+        }
+
+        effect->params.cAxes = count;
+    }
+
+    if (SUCCEEDED(hr = IDirectInputDevice8_CreateEffect( impl->device, &effect->type, &effect->params,
+                                                         &dinput_effect, NULL )))
+    {
+        if (effect->effect) IDirectInputEffect_Release( effect->effect );
+        effect->effect = dinput_effect;
+        IDirectInputEffect_AddRef( effect->effect );
+    }
+
+    LeaveCriticalSection( &effect->cs );
+
+    result->vt = VT_UI4;
+    if (SUCCEEDED(hr)) result->ulVal = ForceFeedbackLoadEffectResult_Succeeded;
+    else if (hr == DIERR_DEVICEFULL) result->ulVal = ForceFeedbackLoadEffectResult_EffectStorageFull;
+    else result->ulVal = ForceFeedbackLoadEffectResult_EffectNotSupported;
+
+    return hr;
+}
+
+static HRESULT WINAPI motor_LoadEffectAsync( IForceFeedbackMotor *iface, IForceFeedbackEffect *effect,
+                                             IAsyncOperation_ForceFeedbackLoadEffectResult **async_op )
+{
+    TRACE( "iface %p, effect %p, async_op %p.\n", iface, effect, async_op );
+    return async_operation_effect_result_create( (IUnknown *)iface, (IUnknown *)effect, motor_load_effect_async, async_op );
+}
+
+static HRESULT WINAPI motor_PauseAllEffects( IForceFeedbackMotor *iface )
+{
+    struct motor *impl = impl_from_IForceFeedbackMotor( iface );
+
+    TRACE( "iface %p.\n", iface );
+
+    return IDirectInputDevice8_SendForceFeedbackCommand( impl->device, DISFFC_PAUSE );
+}
+
+static HRESULT WINAPI motor_ResumeAllEffects( IForceFeedbackMotor *iface )
+{
+    struct motor *impl = impl_from_IForceFeedbackMotor( iface );
+
+    TRACE( "iface %p.\n", iface );
+
+    return IDirectInputDevice8_SendForceFeedbackCommand( impl->device, DISFFC_CONTINUE );
+}
+
+static HRESULT WINAPI motor_StopAllEffects( IForceFeedbackMotor *iface )
+{
+    struct motor *impl = impl_from_IForceFeedbackMotor( iface );
+
+    TRACE( "iface %p.\n", iface );
+
+    return IDirectInputDevice8_SendForceFeedbackCommand( impl->device, DISFFC_STOPALL );
+}
+
+static HRESULT WINAPI motor_try_disable_async( IUnknown *invoker, IUnknown *param, PROPVARIANT *result )
+{
+    struct motor *impl = impl_from_IForceFeedbackMotor( (IForceFeedbackMotor *)invoker );
+    HRESULT hr;
+
+    hr = IDirectInputDevice8_SendForceFeedbackCommand( impl->device, DISFFC_SETACTUATORSOFF );
+    result->vt = VT_BOOL;
+    result->boolVal = SUCCEEDED(hr);
+
+    return hr;
+}
+
+static HRESULT WINAPI motor_TryDisableAsync( IForceFeedbackMotor *iface, IAsyncOperation_boolean **async_op )
+{
+    TRACE( "iface %p, async_op %p.\n", iface, async_op );
+    return async_operation_boolean_create( (IUnknown *)iface, NULL, motor_try_disable_async, async_op );
+}
+
+static HRESULT WINAPI motor_try_enable_async( IUnknown *invoker, IUnknown *param, PROPVARIANT *result )
+{
+    struct motor *impl = impl_from_IForceFeedbackMotor( (IForceFeedbackMotor *)invoker );
+    HRESULT hr;
+
+    hr = IDirectInputDevice8_SendForceFeedbackCommand( impl->device, DISFFC_SETACTUATORSON );
+    result->vt = VT_BOOL;
+    result->boolVal = SUCCEEDED(hr);
+
+    return hr;
+}
+
+static HRESULT WINAPI motor_TryEnableAsync( IForceFeedbackMotor *iface, IAsyncOperation_boolean **async_op )
+{
+    TRACE( "iface %p, async_op %p.\n", iface, async_op );
+    return async_operation_boolean_create( (IUnknown *)iface, NULL, motor_try_enable_async, async_op );
+}
+
+static HRESULT WINAPI motor_try_reset_async( IUnknown *invoker, IUnknown *param, PROPVARIANT *result )
+{
+    struct motor *impl = impl_from_IForceFeedbackMotor( (IForceFeedbackMotor *)invoker );
+    HRESULT hr;
+
+    hr = IDirectInputDevice8_SendForceFeedbackCommand( impl->device, DISFFC_RESET );
+    result->vt = VT_BOOL;
+    result->boolVal = SUCCEEDED(hr);
+
+    return hr;
+}
+
+static HRESULT WINAPI motor_TryResetAsync( IForceFeedbackMotor *iface, IAsyncOperation_boolean **async_op )
+{
+    TRACE( "iface %p, async_op %p.\n", iface, async_op );
+    return async_operation_boolean_create( (IUnknown *)iface, NULL, motor_try_reset_async, async_op );
+}
+
+static HRESULT WINAPI motor_unload_effect_async( IUnknown *iface, IUnknown *param, PROPVARIANT *result )
+{
+    struct effect *effect = impl_from_IForceFeedbackEffect( (IForceFeedbackEffect *)param );
+    IDirectInputEffect *dinput_effect;
+    HRESULT hr;
+
+    EnterCriticalSection( &effect->cs );
+    dinput_effect = effect->effect;
+    effect->effect = NULL;
+    LeaveCriticalSection( &effect->cs );
+
+    if (!dinput_effect) hr = S_OK;
+    else
+    {
+        hr = IDirectInputEffect_Unload( dinput_effect );
+        IDirectInputEffect_Release( dinput_effect );
+    }
+
+    result->vt = VT_BOOL;
+    result->boolVal = SUCCEEDED(hr);
+    return hr;
+}
+
+static HRESULT WINAPI motor_TryUnloadEffectAsync( IForceFeedbackMotor *iface, IForceFeedbackEffect *effect,
+                                                  IAsyncOperation_boolean **async_op )
+{
+    struct effect *impl = impl_from_IForceFeedbackEffect( (IForceFeedbackEffect *)effect );
+    HRESULT hr = S_OK;
+
+    TRACE( "iface %p, effect %p, async_op %p.\n", iface, effect, async_op );
+
+    EnterCriticalSection( &impl->cs );
+    if (!impl->effect) hr = E_FAIL;
+    LeaveCriticalSection( &impl->cs );
+    if (FAILED(hr)) return hr;
+
+    return async_operation_boolean_create( (IUnknown *)iface, (IUnknown *)effect, motor_unload_effect_async, async_op );
+}
+
+static const struct IForceFeedbackMotorVtbl motor_vtbl =
+{
+    motor_QueryInterface,
+    motor_AddRef,
+    motor_Release,
+    /* IInspectable methods */
+    motor_GetIids,
+    motor_GetRuntimeClassName,
+    motor_GetTrustLevel,
+    /* IForceFeedbackMotor methods */
+    motor_get_AreEffectsPaused,
+    motor_get_MasterGain,
+    motor_put_MasterGain,
+    motor_get_IsEnabled,
+    motor_get_SupportedAxes,
+    motor_LoadEffectAsync,
+    motor_PauseAllEffects,
+    motor_ResumeAllEffects,
+    motor_StopAllEffects,
+    motor_TryDisableAsync,
+    motor_TryEnableAsync,
+    motor_TryResetAsync,
+    motor_TryUnloadEffectAsync,
+};
+
+HRESULT force_feedback_motor_create( IDirectInputDevice8W *device, IForceFeedbackMotor **out )
+{
+    struct motor *impl;
+    HRESULT hr;
+
+    TRACE( "device %p, out %p\n", device, out );
+
+    if (FAILED(hr = IDirectInputDevice8_Unacquire( device ))) goto failed;
+    if (FAILED(hr = IDirectInputDevice8_SetCooperativeLevel( device, GetDesktopWindow(), DISCL_BACKGROUND | DISCL_EXCLUSIVE ))) goto failed;
+    if (FAILED(hr = IDirectInputDevice8_Acquire( device ))) goto failed;
+
+    if (!(impl = calloc( 1, sizeof(*impl) ))) return E_OUTOFMEMORY;
+    impl->IForceFeedbackMotor_iface.lpVtbl = &motor_vtbl;
+    impl->ref = 1;
+
+    IDirectInputDevice_AddRef( device );
+    impl->device = device;
+
+    *out = &impl->IForceFeedbackMotor_iface;
+    TRACE( "created ForceFeedbackMotor %p\n", *out );
+    return S_OK;
+
+failed:
+    IDirectInputDevice8_SetCooperativeLevel( device, 0, DISCL_BACKGROUND | DISCL_NONEXCLUSIVE );
+    IDirectInputDevice8_Acquire( device );
+    WARN( "Failed to acquire device exclusively, hr %#lx\n", hr );
+    return hr;
+}
diff --git a/dlls/windows.gaming.input/gamepad.c b/dlls/windows.gaming.input/gamepad.c
index 0c38fb5cd1a..8dab9a62d09 100644
--- wine/dlls/windows.gaming.input/gamepad.c
+++ wine/dlls/windows.gaming.input/gamepad.c
@@ -61,6 +61,7 @@ struct gamepad
     IGameControllerImpl IGameControllerImpl_iface;
     IGameControllerInputSink IGameControllerInputSink_iface;
     IGamepad IGamepad_iface;
+    IGamepad2 IGamepad2_iface;
     IGameController *IGameController_outer;
     LONG ref;
 
@@ -99,7 +100,13 @@ static HRESULT WINAPI controller_QueryInterface( IGameControllerImpl *iface, REF
         return S_OK;
     }
 
-    WARN( "%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid( iid ) );
+    if (IsEqualGUID( iid, &IID_IGamepad2 ))
+    {
+        IInspectable_AddRef( (*out = &impl->IGamepad2_iface) );
+        return S_OK;
+    }
+
+    FIXME( "%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid( iid ) );
     *out = NULL;
     return E_NOINTERFACE;
 }
@@ -330,6 +337,28 @@ static const struct IGamepadVtbl gamepad_vtbl =
     gamepad_GetCurrentReading,
 };
 
+DEFINE_IINSPECTABLE_OUTER( gamepad2, IGamepad2, struct gamepad, IGameController_outer )
+
+static HRESULT WINAPI gamepad2_GetButtonLabel(IGamepad2 *iface, GamepadButtons button, GameControllerButtonLabel *value)
+{
+    FIXME( "iface %p, button %#x, value %p stub!\n", iface, button, value );
+    *value = GameControllerButtonLabel_None;
+    return S_OK;
+}
+
+static const struct IGamepad2Vtbl gamepad2_vtbl =
+{
+    gamepad2_QueryInterface,
+    gamepad2_AddRef,
+    gamepad2_Release,
+    /* IInspectable methods */
+    gamepad2_GetIids,
+    gamepad2_GetRuntimeClassName,
+    gamepad2_GetTrustLevel,
+    /* IGamepad2 methods */
+    gamepad2_GetButtonLabel,
+};
+
 struct gamepad_statics
 {
     IActivationFactory IActivationFactory_iface;
@@ -542,6 +571,7 @@ static HRESULT WINAPI controller_factory_CreateGameController( ICustomGameContro
     impl->IGameControllerImpl_iface.lpVtbl = &controller_vtbl;
     impl->IGameControllerInputSink_iface.lpVtbl = &input_sink_vtbl;
     impl->IGamepad_iface.lpVtbl = &gamepad_vtbl;
+    impl->IGamepad2_iface.lpVtbl = &gamepad2_vtbl;
     impl->ref = 1;
 
     TRACE( "created Gamepad %p\n", impl );
diff --git a/dlls/windows.gaming.input/main.c b/dlls/windows.gaming.input/main.c
index 21808d9c2ad..a20630cd20b 100644
--- wine/dlls/windows.gaming.input/main.c
+++ wine/dlls/windows.gaming.input/main.c
@@ -185,6 +185,15 @@ HRESULT WINAPI DllGetActivationFactory( HSTRING class_str, IActivationFactory **
     if (!wcscmp( buffer, RuntimeClass_Windows_Gaming_Input_Custom_GameControllerFactoryManager ))
         IGameControllerFactoryManagerStatics2_QueryInterface( manager_factory, &IID_IActivationFactory, (void **)factory );
 
+    if (!wcscmp( buffer, RuntimeClass_Windows_Gaming_Input_ForceFeedback_ConstantForceEffect ))
+        IInspectable_QueryInterface( constant_effect_factory, &IID_IActivationFactory, (void **)factory );
+    if (!wcscmp( buffer, RuntimeClass_Windows_Gaming_Input_ForceFeedback_RampForceEffect ))
+        IInspectable_QueryInterface( ramp_effect_factory, &IID_IActivationFactory, (void **)factory );
+    if (!wcscmp( buffer, RuntimeClass_Windows_Gaming_Input_ForceFeedback_PeriodicForceEffect ))
+        IInspectable_QueryInterface( periodic_effect_factory, &IID_IActivationFactory, (void **)factory );
+    if (!wcscmp( buffer, RuntimeClass_Windows_Gaming_Input_ForceFeedback_ConditionForceEffect ))
+        IInspectable_QueryInterface( condition_effect_factory, &IID_IActivationFactory, (void **)factory );
+
     if (*factory) return S_OK;
     return CLASS_E_CLASSNOTAVAILABLE;
 }
diff --git a/dlls/windows.gaming.input/periodic_effect.c b/dlls/windows.gaming.input/periodic_effect.c
new file mode 100644
index 00000000000..8633a8fb9b9
--- /dev/null
+++ wine/dlls/windows.gaming.input/periodic_effect.c
@@ -0,0 +1,326 @@
+/* WinRT Windows.Gaming.Input implementation
+ *
+ * Copyright 2022 Rémi Bernon for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "private.h"
+#include "provider.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(input);
+
+struct periodic_effect
+{
+    IPeriodicForceEffect IPeriodicForceEffect_iface;
+    IWineForceFeedbackEffectImpl *IWineForceFeedbackEffectImpl_inner;
+    LONG ref;
+
+    PeriodicForceEffectKind kind;
+};
+
+static inline struct periodic_effect *impl_from_IPeriodicForceEffect( IPeriodicForceEffect *iface )
+{
+    return CONTAINING_RECORD( iface, struct periodic_effect, IPeriodicForceEffect_iface );
+}
+
+static HRESULT WINAPI effect_QueryInterface( IPeriodicForceEffect *iface, REFIID iid, void **out )
+{
+    struct periodic_effect *impl = impl_from_IPeriodicForceEffect( iface );
+
+    TRACE( "iface %p, iid %s, out %p.\n", iface, debugstr_guid( iid ), out );
+
+    if (IsEqualGUID( iid, &IID_IUnknown ) ||
+        IsEqualGUID( iid, &IID_IInspectable ) ||
+        IsEqualGUID( iid, &IID_IAgileObject ) ||
+        IsEqualGUID( iid, &IID_IPeriodicForceEffect ))
+    {
+        IInspectable_AddRef( (*out = &impl->IPeriodicForceEffect_iface) );
+        return S_OK;
+    }
+
+    return IWineForceFeedbackEffectImpl_QueryInterface( impl->IWineForceFeedbackEffectImpl_inner, iid, out );
+}
+
+static ULONG WINAPI effect_AddRef( IPeriodicForceEffect *iface )
+{
+    struct periodic_effect *impl = impl_from_IPeriodicForceEffect( iface );
+    ULONG ref = InterlockedIncrement( &impl->ref );
+    TRACE( "iface %p increasing refcount to %lu.\n", iface, ref );
+    return ref;
+}
+
+static ULONG WINAPI effect_Release( IPeriodicForceEffect *iface )
+{
+    struct periodic_effect *impl = impl_from_IPeriodicForceEffect( iface );
+    ULONG ref = InterlockedDecrement( &impl->ref );
+
+    TRACE( "iface %p decreasing refcount to %lu.\n", iface, ref );
+
+    if (!ref)
+    {
+        /* guard against re-entry if inner releases an outer iface */
+        InterlockedIncrement( &impl->ref );
+        IWineForceFeedbackEffectImpl_Release( impl->IWineForceFeedbackEffectImpl_inner );
+        free( impl );
+    }
+
+    return ref;
+}
+
+static HRESULT WINAPI effect_GetIids( IPeriodicForceEffect *iface, ULONG *iid_count, IID **iids )
+{
+    FIXME( "iface %p, iid_count %p, iids %p stub!\n", iface, iid_count, iids );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI effect_GetRuntimeClassName( IPeriodicForceEffect *iface, HSTRING *class_name )
+{
+    return WindowsCreateString( RuntimeClass_Windows_Gaming_Input_ForceFeedback_PeriodicForceEffect,
+                                ARRAY_SIZE(RuntimeClass_Windows_Gaming_Input_ForceFeedback_PeriodicForceEffect),
+                                class_name );
+}
+
+static HRESULT WINAPI effect_GetTrustLevel( IPeriodicForceEffect *iface, TrustLevel *trust_level )
+{
+    FIXME( "iface %p, trust_level %p stub!\n", iface, trust_level );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI effect_get_Kind( IPeriodicForceEffect *iface, PeriodicForceEffectKind *kind )
+{
+    struct periodic_effect *impl = impl_from_IPeriodicForceEffect( iface );
+    TRACE( "iface %p, kind %p.\n", iface, kind );
+    *kind = impl->kind;
+    return S_OK;
+}
+
+static HRESULT WINAPI effect_SetParameters( IPeriodicForceEffect *iface, Vector3 direction, FLOAT frequency, FLOAT phase,
+                                            FLOAT bias, TimeSpan duration )
+{
+    struct periodic_effect *impl = impl_from_IPeriodicForceEffect( iface );
+    WineForceFeedbackEffectParameters params =
+    {
+        .periodic =
+        {
+            .type = WineForceFeedbackEffectType_Periodic_SquareWave + impl->kind,
+            .direction = direction,
+            .frequency = frequency,
+            .phase = phase,
+            .bias = bias,
+            .duration = duration,
+            .repeat_count = 1,
+            .gain = 1.,
+        },
+    };
+
+    TRACE( "iface %p, direction %s, frequency %f, phase %f, bias %f, duration %I64u.\n", iface,
+           debugstr_vector3( &direction ), frequency, phase, bias, duration.Duration );
+
+    return IWineForceFeedbackEffectImpl_put_Parameters( impl->IWineForceFeedbackEffectImpl_inner, params, NULL );
+}
+
+static HRESULT WINAPI effect_SetParametersWithEnvelope( IPeriodicForceEffect *iface, Vector3 direction, FLOAT frequency, FLOAT phase, FLOAT bias,
+                                                        FLOAT attack_gain, FLOAT sustain_gain, FLOAT release_gain, TimeSpan start_delay,
+                                                        TimeSpan attack_duration, TimeSpan sustain_duration,
+                                                        TimeSpan release_duration, UINT32 repeat_count )
+{
+    struct periodic_effect *impl = impl_from_IPeriodicForceEffect( iface );
+    WineForceFeedbackEffectParameters params =
+    {
+        .periodic =
+        {
+            .type = WineForceFeedbackEffectType_Periodic_SquareWave + impl->kind,
+            .direction = direction,
+            .frequency = frequency,
+            .phase = phase,
+            .bias = bias,
+            .duration = {attack_duration.Duration + sustain_duration.Duration + release_duration.Duration},
+            .start_delay = start_delay,
+            .repeat_count = repeat_count,
+            .gain = sustain_gain,
+        },
+    };
+    WineForceFeedbackEffectEnvelope envelope =
+    {
+        .attack_gain = attack_gain,
+        .release_gain = release_gain,
+        .attack_duration = attack_duration,
+        .release_duration = release_duration,
+    };
+
+    TRACE( "iface %p, direction %s, frequency %f, phase %f, bias %f, attack_gain %f, sustain_gain %f, release_gain %f, start_delay %I64u, "
+           "attack_duration %I64u, sustain_duration %I64u, release_duration %I64u, repeat_count %u.\n", iface, debugstr_vector3( &direction ),
+           frequency, phase, bias, attack_gain, sustain_gain, release_gain, start_delay.Duration, attack_duration.Duration, sustain_duration.Duration,
+           release_duration.Duration, repeat_count );
+
+    return IWineForceFeedbackEffectImpl_put_Parameters( impl->IWineForceFeedbackEffectImpl_inner, params, &envelope );
+}
+
+static const struct IPeriodicForceEffectVtbl effect_vtbl =
+{
+    effect_QueryInterface,
+    effect_AddRef,
+    effect_Release,
+    /* IInspectable methods */
+    effect_GetIids,
+    effect_GetRuntimeClassName,
+    effect_GetTrustLevel,
+    /* IPeriodicForceEffect methods */
+    effect_get_Kind,
+    effect_SetParameters,
+    effect_SetParametersWithEnvelope,
+};
+
+struct periodic_factory
+{
+    IActivationFactory IActivationFactory_iface;
+    IPeriodicForceEffectFactory IPeriodicForceEffectFactory_iface;
+    LONG ref;
+};
+
+static inline struct periodic_factory *impl_from_IActivationFactory( IActivationFactory *iface )
+{
+    return CONTAINING_RECORD( iface, struct periodic_factory, IActivationFactory_iface );
+}
+
+static HRESULT WINAPI activation_QueryInterface( IActivationFactory *iface, REFIID iid, void **out )
+{
+    struct periodic_factory *impl = impl_from_IActivationFactory( iface );
+
+    TRACE( "iface %p, iid %s, out %p.\n", iface, debugstr_guid( iid ), out );
+
+    if (IsEqualGUID( iid, &IID_IUnknown ) ||
+        IsEqualGUID( iid, &IID_IInspectable ) ||
+        IsEqualGUID( iid, &IID_IAgileObject ) ||
+        IsEqualGUID( iid, &IID_IActivationFactory ))
+    {
+        IInspectable_AddRef( (*out = &impl->IActivationFactory_iface) );
+        return S_OK;
+    }
+
+    if (IsEqualGUID( iid, &IID_IPeriodicForceEffectFactory ))
+    {
+        IInspectable_AddRef( (*out = &impl->IPeriodicForceEffectFactory_iface) );
+        return S_OK;
+    }
+
+    FIXME( "%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid( iid ) );
+    *out = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI activation_AddRef( IActivationFactory *iface )
+{
+    struct periodic_factory *impl = impl_from_IActivationFactory( iface );
+    ULONG ref = InterlockedIncrement( &impl->ref );
+    TRACE( "iface %p increasing refcount to %lu.\n", iface, ref );
+    return ref;
+}
+
+static ULONG WINAPI activation_Release( IActivationFactory *iface )
+{
+    struct periodic_factory *impl = impl_from_IActivationFactory( iface );
+    ULONG ref = InterlockedDecrement( &impl->ref );
+    TRACE( "iface %p decreasing refcount to %lu.\n", iface, ref );
+    return ref;
+}
+
+static HRESULT WINAPI activation_GetIids( IActivationFactory *iface, ULONG *iid_count, IID **iids )
+{
+    FIXME( "iface %p, iid_count %p, iids %p stub!\n", iface, iid_count, iids );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI activation_GetRuntimeClassName( IActivationFactory *iface, HSTRING *class_name )
+{
+    FIXME( "iface %p, class_name %p stub!\n", iface, class_name );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI activation_GetTrustLevel( IActivationFactory *iface, TrustLevel *trust_level )
+{
+    FIXME( "iface %p, trust_level %p stub!\n", iface, trust_level );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI activation_ActivateInstance( IActivationFactory *iface, IInspectable **instance )
+{
+    FIXME( "iface %p, instance %p stub!\n", iface, instance );
+    return E_NOTIMPL;
+}
+
+static const struct IActivationFactoryVtbl activation_vtbl =
+{
+    activation_QueryInterface,
+    activation_AddRef,
+    activation_Release,
+    /* IInspectable methods */
+    activation_GetIids,
+    activation_GetRuntimeClassName,
+    activation_GetTrustLevel,
+    /* IActivationFactory methods */
+    activation_ActivateInstance,
+};
+
+DEFINE_IINSPECTABLE( factory, IPeriodicForceEffectFactory, struct periodic_factory, IActivationFactory_iface )
+
+static HRESULT WINAPI factory_CreateInstance( IPeriodicForceEffectFactory *iface, enum PeriodicForceEffectKind kind, IForceFeedbackEffect **out )
+{
+    enum WineForceFeedbackEffectType type = WineForceFeedbackEffectType_Periodic + kind;
+    struct periodic_effect *impl;
+    HRESULT hr;
+
+    TRACE( "iface %p, kind %u, out %p.\n", iface, kind, out );
+
+    if (!(impl = calloc( 1, sizeof(struct periodic_effect) ))) return E_OUTOFMEMORY;
+    impl->IPeriodicForceEffect_iface.lpVtbl = &effect_vtbl;
+    impl->ref = 1;
+    impl->kind = kind;
+
+    if (FAILED(hr = force_feedback_effect_create( type, (IInspectable *)&impl->IPeriodicForceEffect_iface, &impl->IWineForceFeedbackEffectImpl_inner )) ||
+        FAILED(hr = IPeriodicForceEffect_QueryInterface( &impl->IPeriodicForceEffect_iface, &IID_IForceFeedbackEffect, (void **)out )))
+    {
+        if (impl->IWineForceFeedbackEffectImpl_inner) IWineForceFeedbackEffectImpl_Release( impl->IWineForceFeedbackEffectImpl_inner );
+        free( impl );
+        return hr;
+    }
+
+    IPeriodicForceEffect_Release( &impl->IPeriodicForceEffect_iface );
+    TRACE( "created PeriodicForceEffect %p\n", *out );
+    return S_OK;
+}
+
+static const struct IPeriodicForceEffectFactoryVtbl factory_vtbl =
+{
+    factory_QueryInterface,
+    factory_AddRef,
+    factory_Release,
+    /* IInspectable methods */
+    factory_GetIids,
+    factory_GetRuntimeClassName,
+    factory_GetTrustLevel,
+    /* IPeriodicForceEffectFactory methods */
+    factory_CreateInstance,
+};
+
+static struct periodic_factory periodic_statics =
+{
+    {&activation_vtbl},
+    {&factory_vtbl},
+    1,
+};
+
+IInspectable *periodic_effect_factory = (IInspectable *)&periodic_statics.IActivationFactory_iface;
diff --git a/dlls/windows.gaming.input/private.h b/dlls/windows.gaming.input/private.h
index 58b2040d3de..f53d5b5bc37 100644
--- wine/dlls/windows.gaming.input/private.h
+++ wine/dlls/windows.gaming.input/private.h
@@ -25,11 +25,13 @@
 #include "winbase.h"
 #include "winstring.h"
 #include "objbase.h"
+#include "dinput.h"
 
 #include "activation.h"
 
 #define WIDL_using_Windows_Foundation
 #define WIDL_using_Windows_Foundation_Collections
+#define WIDL_using_Windows_Foundation_Numerics
 #include "windows.foundation.h"
 #define WIDL_using_Windows_Devices_Power
 #define WIDL_using_Windows_Gaming_Input
@@ -37,13 +39,20 @@
 #define WIDL_using_Windows_Gaming_Input_ForceFeedback
 #include "windows.gaming.input.custom.h"
 
+#include "wine/debug.h"
 #include "wine/list.h"
 
+#include "provider.h"
+
 extern HINSTANCE windows_gaming_input;
 extern ICustomGameControllerFactory *controller_factory;
 extern ICustomGameControllerFactory *gamepad_factory;
 extern ICustomGameControllerFactory *racing_wheel_factory;
 extern IGameControllerFactoryManagerStatics2 *manager_factory;
+extern IInspectable *constant_effect_factory;
+extern IInspectable *ramp_effect_factory;
+extern IInspectable *periodic_effect_factory;
+extern IInspectable *condition_effect_factory;
 
 struct vector_iids
 {
@@ -64,6 +73,15 @@ extern HRESULT event_handlers_append( struct list *list, IEventHandler_IInspecta
 extern HRESULT event_handlers_remove( struct list *list, EventRegistrationToken *token );
 extern void event_handlers_notify( struct list *list, IInspectable *element );
 
+extern HRESULT force_feedback_motor_create( IDirectInputDevice8W *device, IForceFeedbackMotor **out );
+extern HRESULT force_feedback_effect_create( enum WineForceFeedbackEffectType type, IInspectable *outer, IWineForceFeedbackEffectImpl **out );
+
+typedef HRESULT (WINAPI *async_operation_callback)( IUnknown *invoker, IUnknown *param, PROPVARIANT *result );
+extern HRESULT async_operation_boolean_create( IUnknown *invoker, IUnknown *param, async_operation_callback callback,
+                                               IAsyncOperation_boolean **out );
+extern HRESULT async_operation_effect_result_create( IUnknown *invoker, IUnknown *param, async_operation_callback callback,
+                                                     IAsyncOperation_ForceFeedbackLoadEffectResult **out );
+
 #define DEFINE_IINSPECTABLE_( pfx, iface_type, impl_type, impl_from, iface_mem, expr )             \
     static inline impl_type *impl_from( iface_type *iface )                                        \
     {                                                                                              \
@@ -103,3 +121,9 @@ extern void event_handlers_notify( struct list *list, IInspectable *element );
     DEFINE_IINSPECTABLE_( pfx, iface_type, impl_type, impl_from_##iface_type, iface_type##_iface, &impl->base_iface )
 #define DEFINE_IINSPECTABLE_OUTER( pfx, iface_type, impl_type, outer_iface )                       \
     DEFINE_IINSPECTABLE_( pfx, iface_type, impl_type, impl_from_##iface_type, iface_type##_iface, impl->outer_iface )
+
+static inline const char *debugstr_vector3( const Vector3 *vector )
+{
+    if (!vector) return "(null)";
+    return wine_dbg_sprintf( "[%f, %f, %f]", vector->X, vector->Y, vector->Z );
+}
diff --git a/dlls/windows.gaming.input/provider.c b/dlls/windows.gaming.input/provider.c
index 69098e8abb6..d0472727224 100644
--- wine/dlls/windows.gaming.input/provider.c
+++ wine/dlls/windows.gaming.input/provider.c
@@ -141,21 +141,37 @@ static HRESULT WINAPI wine_provider_GetTrustLevel( IWineGameControllerProvider *
     return E_NOTIMPL;
 }
 
+static BOOL CALLBACK count_ffb_axes( const DIDEVICEOBJECTINSTANCEW *obj, void *args )
+{
+    DWORD *count = args;
+    if (obj->dwType & DIDFT_FFACTUATOR) (*count)++;
+    return DIENUM_CONTINUE;
+}
+
 static HRESULT WINAPI wine_provider_get_Type( IWineGameControllerProvider *iface, WineGameControllerType *value )
 {
     struct provider *impl = impl_from_IWineGameControllerProvider( iface );
     DIDEVICEINSTANCEW instance = {.dwSize = sizeof(DIDEVICEINSTANCEW)};
+    const WCHAR *tmp;
     HRESULT hr;
 
     TRACE( "iface %p, value %p.\n", iface, value );
 
     if (FAILED(hr = IDirectInputDevice8_GetDeviceInfo( impl->dinput_device, &instance ))) return hr;
 
-    switch (GET_DIDEVICE_TYPE( instance.dwDevType ))
+    if ((tmp = wcschr( impl->device_path + 8, '#' )) && !wcsnicmp( tmp - 6, L"&XI_", 4 ))
+        *value = WineGameControllerType_Gamepad;
+    else switch (GET_DIDEVICE_TYPE( instance.dwDevType ))
     {
     case DI8DEVTYPE_DRIVING: *value = WineGameControllerType_RacingWheel; break;
-    case DI8DEVTYPE_GAMEPAD: *value = WineGameControllerType_Gamepad; break;
-    default: *value = WineGameControllerType_Joystick; break;
+    default:
+    {
+        DWORD count = 0;
+        hr = IDirectInputDevice8_EnumObjects( impl->dinput_device, count_ffb_axes, &count, DIDFT_AXIS );
+        if (SUCCEEDED(hr) && count == 1) *value = WineGameControllerType_RacingWheel;
+        else *value = WineGameControllerType_Joystick;
+        break;
+    }
     }
 
     return S_OK;
@@ -212,7 +228,7 @@ static HRESULT WINAPI wine_provider_get_State( IWineGameControllerProvider *ifac
     if (FAILED(hr = IDirectInputDevice8_GetDeviceState( impl->dinput_device, sizeof(state), &state )))
     {
         WARN( "Failed to read device state, hr %#lx\n", hr );
-        return hr;
+        return S_OK;
     }
 
     i = ARRAY_SIZE(state.rgbButtons);
@@ -315,6 +331,21 @@ static HRESULT WINAPI wine_provider_put_Vibration( IWineGameControllerProvider *
     return S_OK;
 }
 
+static HRESULT WINAPI wine_provider_get_ForceFeedbackMotor( IWineGameControllerProvider *iface, IForceFeedbackMotor **value )
+{
+    struct provider *impl = impl_from_IWineGameControllerProvider( iface );
+    DIDEVCAPS caps = {.dwSize = sizeof(DIDEVCAPS)};
+    HRESULT hr;
+
+    TRACE( "iface %p, value %p.\n", iface, value );
+
+    if (SUCCEEDED(hr = IDirectInputDevice8_GetCapabilities( impl->dinput_device, &caps )) && (caps.dwFlags & DIDC_FORCEFEEDBACK))
+        return force_feedback_motor_create( impl->dinput_device, value );
+
+    *value = NULL;
+    return S_OK;
+}
+
 static const struct IWineGameControllerProviderVtbl wine_provider_vtbl =
 {
     wine_provider_QueryInterface,
@@ -332,6 +363,7 @@ static const struct IWineGameControllerProviderVtbl wine_provider_vtbl =
     wine_provider_get_State,
     wine_provider_get_Vibration,
     wine_provider_put_Vibration,
+    wine_provider_get_ForceFeedbackMotor,
 };
 
 DEFINE_IINSPECTABLE( game_provider, IGameControllerProvider, struct provider, IWineGameControllerProvider_iface )
@@ -556,7 +588,7 @@ void provider_create( const WCHAR *device_path )
 
     EnterCriticalSection( &provider_cs );
     LIST_FOR_EACH_ENTRY( entry, &provider_list, struct provider, entry )
-        if ((found = !wcscmp( entry->device_path, device_path ))) break;
+        if ((found = !wcsicmp( entry->device_path, device_path ))) break;
     if (!found) list_add_tail( &provider_list, &impl->entry );
     LeaveCriticalSection( &provider_cs );
 
@@ -576,11 +608,12 @@ void provider_remove( const WCHAR *device_path )
 
     EnterCriticalSection( &provider_cs );
     LIST_FOR_EACH_ENTRY( entry, &provider_list, struct provider, entry )
-        if ((found = !wcscmp( entry->device_path, device_path ))) break;
+        if ((found = !wcsicmp( entry->device_path, device_path ))) break;
     if (found) list_remove( &entry->entry );
     LeaveCriticalSection( &provider_cs );
 
-    if (found)
+    if (!found) WARN( "provider not found for device %s\n", debugstr_w( device_path ) );
+    else
     {
         provider = &entry->IGameControllerProvider_iface;
         manager_on_provider_removed( provider );
diff --git a/dlls/windows.gaming.input/provider.idl b/dlls/windows.gaming.input/provider.idl
index 865a149eaa5..e7b6e96b8aa 100644
--- wine/dlls/windows.gaming.input/provider.idl
+++ wine/dlls/windows.gaming.input/provider.idl
@@ -22,6 +22,7 @@
 #pragma winrt ns_prefix
 #endif
 
+import "propidl.idl";
 import "inspectable.idl";
 import "asyncinfo.idl";
 import "eventtoken.idl";
@@ -29,14 +30,25 @@ import "windowscontracts.idl";
 import "windows.foundation.idl";
 import "windows.gaming.input.idl";
 import "windows.gaming.input.custom.idl";
+import "windows.gaming.input.forcefeedback.idl";
 
 namespace Windows.Gaming.Input.Custom {
     typedef enum WineGameControllerType WineGameControllerType;
+    typedef enum WineForceFeedbackEffectType WineForceFeedbackEffectType;
     typedef struct WineGameControllerState WineGameControllerState;
     typedef struct WineGameControllerVibration WineGameControllerVibration;
+    typedef struct WineConditionEffectParameters WineConditionEffectParameters;
+    typedef struct WineConstantEffectParameters WineConstantEffectParameters;
+    typedef struct WineRampEffectParameters WineRampEffectParameters;
+    typedef struct WinePeriodicEffectParameters WinePeriodicEffectParameters;
+    typedef struct WineForceFeedbackEffectEnvelope WineForceFeedbackEffectEnvelope;
+    typedef union WineForceFeedbackEffectParameters WineForceFeedbackEffectParameters;
     interface IWineGameControllerProvider;
     runtimeclass WineGameControllerProvider;
 
+    /* type-pruning version of AsyncOperationCompletedHandler<T> */
+    delegate HRESULT WineAsyncOperationCompletedHandler([in] IInspectable *async, [in] AsyncStatus status);
+
     enum WineGameControllerType
     {
         Joystick = 0,
@@ -44,6 +56,27 @@ namespace Windows.Gaming.Input.Custom {
         RacingWheel = 2,
     };
 
+    enum WineForceFeedbackEffectType
+    {
+        Constant = 1,
+        Ramp = 2,
+
+        Periodic = 10,
+        /* same order as PeriodicForceEffectKind */
+        Periodic_SquareWave = 10,
+        Periodic_SineWave = 11,
+        Periodic_TriangleWave = 12,
+        Periodic_SawtoothWaveUp = 13,
+        Periodic_SawtoothWaveDown = 14,
+
+        Condition = 20,
+        /* same order as ConditionForceEffectKind */
+        Condition_Spring = 20,
+        Condition_Damper = 21,
+        Condition_Inertia = 22,
+        Condition_Friction = 23,
+    };
+
     struct WineGameControllerState
     {
         UINT64 timestamp;
@@ -60,6 +93,69 @@ namespace Windows.Gaming.Input.Custom {
         UINT16 right;
     };
 
+    struct WineConditionEffectParameters
+    {
+        WineForceFeedbackEffectType type;
+        Windows.Foundation.Numerics.Vector3 direction;
+        FLOAT positive_coeff;
+        FLOAT negative_coeff;
+        FLOAT max_positive_magnitude;
+        FLOAT max_negative_magnitude;
+        FLOAT deadzone;
+        FLOAT bias;
+    };
+
+    struct WineConstantEffectParameters
+    {
+        WineForceFeedbackEffectType type;
+        Windows.Foundation.Numerics.Vector3 direction;
+        Windows.Foundation.TimeSpan duration;
+        Windows.Foundation.TimeSpan start_delay;
+        UINT32 repeat_count;
+        FLOAT gain;
+    };
+
+    struct WineRampEffectParameters
+    {
+        WineForceFeedbackEffectType type;
+        Windows.Foundation.Numerics.Vector3 start_vector;
+        Windows.Foundation.Numerics.Vector3 end_vector;
+        Windows.Foundation.TimeSpan duration;
+        Windows.Foundation.TimeSpan start_delay;
+        UINT32 repeat_count;
+        FLOAT gain;
+    };
+
+    struct WinePeriodicEffectParameters
+    {
+        WineForceFeedbackEffectType type;
+        Windows.Foundation.Numerics.Vector3 direction;
+        Windows.Foundation.TimeSpan duration;
+        Windows.Foundation.TimeSpan start_delay;
+        UINT32 repeat_count;
+        FLOAT frequency;
+        FLOAT phase;
+        FLOAT bias;
+        FLOAT gain;
+    };
+
+    struct WineForceFeedbackEffectEnvelope
+    {
+        FLOAT attack_gain;
+        FLOAT release_gain;
+        Windows.Foundation.TimeSpan attack_duration;
+        Windows.Foundation.TimeSpan release_duration;
+    };
+
+    union WineForceFeedbackEffectParameters
+    {
+        WineForceFeedbackEffectType type;
+        WineConditionEffectParameters condition;
+        WineConstantEffectParameters constant;
+        WineRampEffectParameters ramp;
+        WinePeriodicEffectParameters periodic;
+    };
+
     [
         uuid(06e58977-7684-4dc5-bad1-cda52a4aa06d)
     ]
@@ -85,6 +181,29 @@ namespace Windows.Gaming.Input.Custom {
         [propget] HRESULT State([out, retval] WineGameControllerState *state);
         [propget] HRESULT Vibration([out, retval] WineGameControllerVibration *vibration);
         [propput] HRESULT Vibration([in] WineGameControllerVibration vibration);
+
+        [propget] HRESULT ForceFeedbackMotor([out, retval] Windows.Gaming.Input.ForceFeedback.ForceFeedbackMotor **motor);
+    }
+
+    [
+        uuid(27833469-7760-417e-adbe-e011a66e16ee)
+    ]
+    interface IWineForceFeedbackEffectImpl : IUnknown
+        requires Windows.Gaming.Input.ForceFeedback.IForceFeedbackEffect
+    {
+        [propput] HRESULT Parameters([in] WineForceFeedbackEffectParameters parameters,
+                                     [in, optional] WineForceFeedbackEffectEnvelope *envelope);
+    }
+
+    [
+        uuid(83f377ee-c799-11ec-9d64-0242ac120002)
+    ]
+    interface IWineAsyncInfoImpl : IUnknown
+    {
+        [propput] HRESULT Completed([in] WineAsyncOperationCompletedHandler *handler);
+        [propget] HRESULT Completed([out, retval] WineAsyncOperationCompletedHandler **handler);
+        [propget] HRESULT Result([out, retval] PROPVARIANT *result);
+        HRESULT Start();
     }
 
     [
diff --git a/dlls/windows.gaming.input/racing_wheel.c b/dlls/windows.gaming.input/racing_wheel.c
index b4635d03153..d646ca26c03 100644
--- wine/dlls/windows.gaming.input/racing_wheel.c
+++ wine/dlls/windows.gaming.input/racing_wheel.c
@@ -99,7 +99,7 @@ static HRESULT WINAPI controller_QueryInterface( IGameControllerImpl *iface, REF
         return S_OK;
     }
 
-    WARN( "%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid( iid ) );
+    FIXME( "%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid( iid ) );
     *out = NULL;
     return E_NOINTERFACE;
 }
@@ -245,8 +245,11 @@ static HRESULT WINAPI racing_wheel_get_MaxWheelAngle( IRacingWheel *iface, DOUBL
 
 static HRESULT WINAPI racing_wheel_get_WheelMotor( IRacingWheel *iface, IForceFeedbackMotor **value )
 {
-    FIXME( "iface %p, value %p stub!\n", iface, value );
-    return E_NOTIMPL;
+    struct racing_wheel *impl = impl_from_IRacingWheel( iface );
+
+    TRACE( "iface %p, value %p\n", iface, value );
+
+    return IWineGameControllerProvider_get_ForceFeedbackMotor( impl->wine_provider, value );
 }
 
 static HRESULT WINAPI racing_wheel_GetButtonLabel( IRacingWheel *iface, enum RacingWheelButtons button,
diff --git a/dlls/windows.gaming.input/ramp_effect.c b/dlls/windows.gaming.input/ramp_effect.c
new file mode 100644
index 00000000000..fadcf151c04
--- /dev/null
+++ wine/dlls/windows.gaming.input/ramp_effect.c
@@ -0,0 +1,278 @@
+/* WinRT Windows.Gaming.Input implementation
+ *
+ * Copyright 2022 Rémi Bernon for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "private.h"
+#include "provider.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(input);
+
+struct ramp_effect
+{
+    IRampForceEffect IRampForceEffect_iface;
+    IWineForceFeedbackEffectImpl *IWineForceFeedbackEffectImpl_inner;
+    LONG ref;
+};
+
+static inline struct ramp_effect *impl_from_IRampForceEffect( IRampForceEffect *iface )
+{
+    return CONTAINING_RECORD( iface, struct ramp_effect, IRampForceEffect_iface );
+}
+
+static HRESULT WINAPI effect_QueryInterface( IRampForceEffect *iface, REFIID iid, void **out )
+{
+    struct ramp_effect *impl = impl_from_IRampForceEffect( iface );
+
+    TRACE( "iface %p, iid %s, out %p.\n", iface, debugstr_guid( iid ), out );
+
+    if (IsEqualGUID( iid, &IID_IUnknown ) ||
+        IsEqualGUID( iid, &IID_IInspectable ) ||
+        IsEqualGUID( iid, &IID_IAgileObject ) ||
+        IsEqualGUID( iid, &IID_IRampForceEffect ))
+    {
+        IInspectable_AddRef( (*out = &impl->IRampForceEffect_iface) );
+        return S_OK;
+    }
+
+    return IWineForceFeedbackEffectImpl_QueryInterface( impl->IWineForceFeedbackEffectImpl_inner, iid, out );
+}
+
+static ULONG WINAPI effect_AddRef( IRampForceEffect *iface )
+{
+    struct ramp_effect *impl = impl_from_IRampForceEffect( iface );
+    ULONG ref = InterlockedIncrement( &impl->ref );
+    TRACE( "iface %p increasing refcount to %lu.\n", iface, ref );
+    return ref;
+}
+
+static ULONG WINAPI effect_Release( IRampForceEffect *iface )
+{
+    struct ramp_effect *impl = impl_from_IRampForceEffect( iface );
+    ULONG ref = InterlockedDecrement( &impl->ref );
+
+    TRACE( "iface %p decreasing refcount to %lu.\n", iface, ref );
+
+    if (!ref)
+    {
+        /* guard against re-entry if inner releases an outer iface */
+        InterlockedIncrement( &impl->ref );
+        IWineForceFeedbackEffectImpl_Release( impl->IWineForceFeedbackEffectImpl_inner );
+        free( impl );
+    }
+
+    return ref;
+}
+
+static HRESULT WINAPI effect_GetIids( IRampForceEffect *iface, ULONG *iid_count, IID **iids )
+{
+    FIXME( "iface %p, iid_count %p, iids %p stub!\n", iface, iid_count, iids );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI effect_GetRuntimeClassName( IRampForceEffect *iface, HSTRING *class_name )
+{
+    return WindowsCreateString( RuntimeClass_Windows_Gaming_Input_ForceFeedback_RampForceEffect,
+                                ARRAY_SIZE(RuntimeClass_Windows_Gaming_Input_ForceFeedback_RampForceEffect),
+                                class_name );
+}
+
+static HRESULT WINAPI effect_GetTrustLevel( IRampForceEffect *iface, TrustLevel *trust_level )
+{
+    FIXME( "iface %p, trust_level %p stub!\n", iface, trust_level );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI effect_SetParameters( IRampForceEffect *iface, Vector3 start_vector, Vector3 end_vector, TimeSpan duration )
+{
+    WineForceFeedbackEffectParameters params =
+    {
+        .ramp =
+        {
+            .type = WineForceFeedbackEffectType_Ramp,
+            .start_vector = start_vector,
+            .end_vector = end_vector,
+            .duration = duration,
+            .repeat_count = 1,
+            .gain = 1.,
+        },
+    };
+    struct ramp_effect *impl = impl_from_IRampForceEffect( iface );
+
+    TRACE( "iface %p, start_vector %s, end_vector %s, duration %I64u.\n", iface,
+           debugstr_vector3( &start_vector ), debugstr_vector3( &end_vector ), duration.Duration );
+
+    return IWineForceFeedbackEffectImpl_put_Parameters( impl->IWineForceFeedbackEffectImpl_inner, params, NULL );
+}
+
+static HRESULT WINAPI effect_SetParametersWithEnvelope( IRampForceEffect *iface, Vector3 start_vector, Vector3 end_vector, FLOAT attack_gain,
+                                                        FLOAT sustain_gain, FLOAT release_gain, TimeSpan start_delay,
+                                                        TimeSpan attack_duration, TimeSpan sustain_duration,
+                                                        TimeSpan release_duration, UINT32 repeat_count )
+{
+    WineForceFeedbackEffectParameters params =
+    {
+        .ramp =
+        {
+            .type = WineForceFeedbackEffectType_Ramp,
+            .start_vector = start_vector,
+            .end_vector = end_vector,
+            .duration = {attack_duration.Duration + sustain_duration.Duration + release_duration.Duration},
+            .start_delay = start_delay,
+            .repeat_count = repeat_count,
+            .gain = sustain_gain,
+        },
+    };
+    WineForceFeedbackEffectEnvelope envelope =
+    {
+        .attack_gain = attack_gain,
+        .release_gain = release_gain,
+        .attack_duration = attack_duration,
+        .release_duration = release_duration,
+    };
+    struct ramp_effect *impl = impl_from_IRampForceEffect( iface );
+
+    TRACE( "iface %p, start_vector %s, end_vector %s, attack_gain %f, sustain_gain %f, release_gain %f, start_delay %I64u, attack_duration %I64u, "
+           "sustain_duration %I64u, release_duration %I64u, repeat_count %u.\n", iface, debugstr_vector3( &start_vector ), debugstr_vector3( &end_vector ),
+           attack_gain, sustain_gain, release_gain, start_delay.Duration, attack_duration.Duration, sustain_duration.Duration,
+           release_duration.Duration, repeat_count );
+
+    return IWineForceFeedbackEffectImpl_put_Parameters( impl->IWineForceFeedbackEffectImpl_inner, params, &envelope );
+}
+
+static const struct IRampForceEffectVtbl effect_vtbl =
+{
+    effect_QueryInterface,
+    effect_AddRef,
+    effect_Release,
+    /* IInspectable methods */
+    effect_GetIids,
+    effect_GetRuntimeClassName,
+    effect_GetTrustLevel,
+    /* IRampForceEffect methods */
+    effect_SetParameters,
+    effect_SetParametersWithEnvelope,
+};
+
+struct ramp_factory
+{
+    IActivationFactory IActivationFactory_iface;
+    LONG ref;
+};
+
+static inline struct ramp_factory *impl_from_IActivationFactory( IActivationFactory *iface )
+{
+    return CONTAINING_RECORD( iface, struct ramp_factory, IActivationFactory_iface );
+}
+
+static HRESULT WINAPI activation_QueryInterface( IActivationFactory *iface, REFIID iid, void **out )
+{
+    struct ramp_factory *impl = impl_from_IActivationFactory( iface );
+
+    TRACE( "iface %p, iid %s, out %p.\n", iface, debugstr_guid( iid ), out );
+
+    if (IsEqualGUID( iid, &IID_IUnknown ) ||
+        IsEqualGUID( iid, &IID_IInspectable ) ||
+        IsEqualGUID( iid, &IID_IAgileObject ) ||
+        IsEqualGUID( iid, &IID_IActivationFactory ))
+    {
+        IInspectable_AddRef( (*out = &impl->IActivationFactory_iface) );
+        return S_OK;
+    }
+
+    FIXME( "%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid( iid ) );
+    *out = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI activation_AddRef( IActivationFactory *iface )
+{
+    struct ramp_factory *impl = impl_from_IActivationFactory( iface );
+    ULONG ref = InterlockedIncrement( &impl->ref );
+    TRACE( "iface %p increasing refcount to %lu.\n", iface, ref );
+    return ref;
+}
+
+static ULONG WINAPI activation_Release( IActivationFactory *iface )
+{
+    struct ramp_factory *impl = impl_from_IActivationFactory( iface );
+    ULONG ref = InterlockedDecrement( &impl->ref );
+    TRACE( "iface %p decreasing refcount to %lu.\n", iface, ref );
+    return ref;
+}
+
+static HRESULT WINAPI activation_GetIids( IActivationFactory *iface, ULONG *iid_count, IID **iids )
+{
+    FIXME( "iface %p, iid_count %p, iids %p stub!\n", iface, iid_count, iids );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI activation_GetRuntimeClassName( IActivationFactory *iface, HSTRING *class_name )
+{
+    FIXME( "iface %p, class_name %p stub!\n", iface, class_name );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI activation_GetTrustLevel( IActivationFactory *iface, TrustLevel *trust_level )
+{
+    FIXME( "iface %p, trust_level %p stub!\n", iface, trust_level );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI activation_ActivateInstance( IActivationFactory *iface, IInspectable **instance )
+{
+    struct ramp_effect *impl;
+    HRESULT hr;
+
+    TRACE( "iface %p, instance %p.\n", iface, instance );
+
+    if (!(impl = calloc( 1, sizeof(struct ramp_effect) ))) return E_OUTOFMEMORY;
+    impl->IRampForceEffect_iface.lpVtbl = &effect_vtbl;
+    impl->ref = 1;
+
+    if (FAILED(hr = force_feedback_effect_create( WineForceFeedbackEffectType_Ramp, (IInspectable *)&impl->IRampForceEffect_iface,
+                                                  &impl->IWineForceFeedbackEffectImpl_inner )))
+    {
+        free( impl );
+        return hr;
+    }
+
+    *instance = (IInspectable *)&impl->IRampForceEffect_iface;
+    TRACE( "created RampForceEffect %p\n", *instance );
+    return S_OK;
+}
+
+static const struct IActivationFactoryVtbl activation_vtbl =
+{
+    activation_QueryInterface,
+    activation_AddRef,
+    activation_Release,
+    /* IInspectable methods */
+    activation_GetIids,
+    activation_GetRuntimeClassName,
+    activation_GetTrustLevel,
+    /* IActivationFactory methods */
+    activation_ActivateInstance,
+};
+
+static struct ramp_factory ramp_statics =
+{
+    {&activation_vtbl},
+    1,
+};
+
+IInspectable *ramp_effect_factory = (IInspectable *)&ramp_statics.IActivationFactory_iface;
diff --git a/dlls/windows.gaming.input/vector.c b/dlls/windows.gaming.input/vector.c
index db1a9057682..8958b07c0f2 100644
--- wine/dlls/windows.gaming.input/vector.c
+++ wine/dlls/windows.gaming.input/vector.c
@@ -54,7 +54,7 @@ static HRESULT WINAPI iterator_QueryInterface( IIterator_IInspectable *iface, RE
         return S_OK;
     }
 
-    WARN( "%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid( iid ) );
+    FIXME( "%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid( iid ) );
     *out = NULL;
     return E_NOINTERFACE;
 }
@@ -189,7 +189,7 @@ static HRESULT WINAPI vector_view_QueryInterface( IVectorView_IInspectable *ifac
         return S_OK;
     }
 
-    WARN( "%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid( iid ) );
+    FIXME( "%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid( iid ) );
     *out = NULL;
     return E_NOINTERFACE;
 }
@@ -384,7 +384,7 @@ static HRESULT WINAPI vector_QueryInterface( IVector_IInspectable *iface, REFIID
         return S_OK;
     }
 
-    WARN( "%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid( iid ) );
+    FIXME( "%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid( iid ) );
     *out = NULL;
     return E_NOINTERFACE;
 }
diff --git a/include/Makefile.in b/include/Makefile.in
index 19d0088e431..cade5bb49dd 100644
--- wine/include/Makefile.in
+++ wine/include/Makefile.in
@@ -788,8 +788,10 @@ SOURCES = \
 	windows.foundation.collections.idl \
 	windows.foundation.idl \
 	windows.foundation.metadata.idl \
+	windows.foundation.numerics.idl \
 	windows.gaming.input.custom.idl \
 	windows.gaming.input.forcefeedback.idl \
+	windows.gaming.ui.idl \
 	windows.gaming.input.idl \
 	windows.globalization.idl \
 	windows.h \
diff --git a/include/windows.foundation.numerics.idl b/include/windows.foundation.numerics.idl
new file mode 100644
index 00000000000..eca99ca29bc
--- /dev/null
+++ wine/include/windows.foundation.numerics.idl
@@ -0,0 +1,39 @@
+/*
+ * Copyright 2022 Rémi Bernon for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifdef __WIDL__
+#pragma winrt ns_prefix
+#endif
+
+import "inspectable.idl";
+import "asyncinfo.idl";
+import "eventtoken.idl";
+import "windowscontracts.idl";
+import "windows.foundation.idl";
+
+namespace Windows.Foundation.Numerics {
+    typedef struct Vector3 Vector3;
+
+    [contract(Windows.Foundation.UniversalApiContract, 1.0)]
+    struct Vector3
+    {
+        FLOAT X;
+        FLOAT Y;
+        FLOAT Z;
+    };
+}
diff --git a/include/windows.gaming.input.forcefeedback.idl b/include/windows.gaming.input.forcefeedback.idl
index 432b60a5592..82fb083b34b 100644
--- wine/include/windows.gaming.input.forcefeedback.idl
+++ wine/include/windows.gaming.input.forcefeedback.idl
@@ -20,23 +20,41 @@
 #pragma winrt ns_prefix
 #endif
 
+#ifndef DO_NO_IMPORTS
 import "inspectable.idl";
 import "asyncinfo.idl";
 import "eventtoken.idl";
 import "windowscontracts.idl";
 import "windows.foundation.idl";
+import "windows.foundation.numerics.idl";
+#endif
 
 namespace Windows.Gaming.Input.ForceFeedback {
     typedef enum ForceFeedbackEffectAxes ForceFeedbackEffectAxes;
     typedef enum ForceFeedbackEffectState ForceFeedbackEffectState;
     typedef enum ForceFeedbackLoadEffectResult ForceFeedbackLoadEffectResult;
+    typedef enum PeriodicForceEffectKind PeriodicForceEffectKind;
+    typedef enum ConditionForceEffectKind ConditionForceEffectKind;
     interface IForceFeedbackEffect;
+    interface IPeriodicForceEffect;
+    interface IPeriodicForceEffectFactory;
+    interface IConditionForceEffect;
+    interface IConditionForceEffectFactory;
+    interface IConstantForceEffect;
+    interface IRampForceEffect;
     runtimeclass ForceFeedbackMotor;
+    runtimeclass PeriodicForceEffect;
+    runtimeclass ConditionForceEffect;
+    runtimeclass ConstantForceEffect;
+    runtimeclass RampForceEffect;
 
     declare {
         interface Windows.Foundation.AsyncOperationCompletedHandler<Windows.Gaming.Input.ForceFeedback.ForceFeedbackLoadEffectResult>;
         interface Windows.Foundation.IAsyncOperation<Windows.Gaming.Input.ForceFeedback.ForceFeedbackLoadEffectResult>;
+        interface Windows.Foundation.Collections.IIterator<Windows.Gaming.Input.ForceFeedback.ForceFeedbackMotor *>;
+        interface Windows.Foundation.Collections.IIterable<Windows.Gaming.Input.ForceFeedback.ForceFeedbackMotor *>;
         interface Windows.Foundation.Collections.IVectorView<Windows.Gaming.Input.ForceFeedback.ForceFeedbackMotor *>;
+        interface Windows.Foundation.Collections.IVector<Windows.Gaming.Input.ForceFeedback.ForceFeedbackMotor *>;
     }
 
     [
@@ -68,6 +86,25 @@ namespace Windows.Gaming.Input.ForceFeedback {
         EffectNotSupported = 2
     };
 
+    [contract(Windows.Foundation.UniversalApiContract, 3.0)]
+    enum PeriodicForceEffectKind
+    {
+        SquareWave       = 0,
+        SineWave         = 1,
+        TriangleWave     = 2,
+        SawtoothWaveUp   = 3,
+        SawtoothWaveDown = 4,
+    };
+
+    [contract(Windows.Foundation.UniversalApiContract, 3.0)]
+    enum ConditionForceEffectKind
+    {
+        Spring   = 0,
+        Damper   = 1,
+        Inertia  = 2,
+        Friction = 3,
+    };
+
     [
         contract(Windows.Foundation.UniversalApiContract, 3.0),
         uuid(a17fba0c-2ae4-48c2-8063-eabd0777cb89)
@@ -105,6 +142,91 @@ namespace Windows.Gaming.Input.ForceFeedback {
                                      [out, retval] Windows.Foundation.IAsyncOperation<boolean> **async_op);
     }
 
+    [
+        contract(Windows.Foundation.UniversalApiContract, 3.0),
+        exclusiveto(Windows.Gaming.Input.ForceFeedback.PeriodicForceEffect),
+        uuid(5c5138d7-fc75-4d52-9a0a-efe4cab5fe64)
+    ]
+    interface IPeriodicForceEffect : IInspectable
+        requires Windows.Gaming.Input.ForceFeedback.IForceFeedbackEffect
+    {
+        [propget] HRESULT Kind([out, retval] Windows.Gaming.Input.ForceFeedback.PeriodicForceEffectKind *value);
+        HRESULT SetParameters([in] Windows.Foundation.Numerics.Vector3 vector, [in] FLOAT frequency, [in] FLOAT phase,
+                              [in] FLOAT bias, [in] Windows.Foundation.TimeSpan duration);
+        HRESULT SetParametersWithEnvelope([in] Windows.Foundation.Numerics.Vector3 vector, [in] FLOAT frequency, [in] FLOAT phase,
+                                          [in] FLOAT bias, [in] FLOAT attack_gain, [in] FLOAT sustain_gain, [in] FLOAT release_gain,
+                                          [in] Windows.Foundation.TimeSpan start_delay, [in] Windows.Foundation.TimeSpan attack_duration,
+                                          [in] Windows.Foundation.TimeSpan sustain_duration, [in] Windows.Foundation.TimeSpan release_duration,
+                                          [in] UINT32 repeat_count);
+    }
+
+    [
+        contract(Windows.Foundation.UniversalApiContract, 3.0),
+        exclusiveto(Windows.Gaming.Input.ForceFeedback.PeriodicForceEffect),
+        uuid(6f62eb1a-9851-477b-b318-35ecaa15070f)
+    ]
+    interface IPeriodicForceEffectFactory : IInspectable
+    {
+        HRESULT CreateInstance([in] Windows.Gaming.Input.ForceFeedback.PeriodicForceEffectKind kind,
+                               [out, retval] Windows.Gaming.Input.ForceFeedback.PeriodicForceEffect **value);
+    }
+
+    [
+        contract(Windows.Foundation.UniversalApiContract, 3.0),
+        exclusiveto(Windows.Gaming.Input.ForceFeedback.ConditionForceEffect),
+        uuid(32d1ea68-3695-4e69-85c0-cd1944189140)
+    ]
+    interface IConditionForceEffect : IInspectable
+        requires Windows.Gaming.Input.ForceFeedback.IForceFeedbackEffect
+    {
+        [propget] HRESULT Kind([out, retval] Windows.Gaming.Input.ForceFeedback.ConditionForceEffectKind *value);
+        HRESULT SetParameters([in] Windows.Foundation.Numerics.Vector3 direction, [in] FLOAT positive_coeff,
+                              [in] FLOAT negative_coeff, [in] FLOAT max_positive_magnitude, [in] FLOAT max_negative_magnitude,
+                              [in] FLOAT deadzone, [in] FLOAT bias);
+    }
+
+    [
+        contract(Windows.Foundation.UniversalApiContract, 3.0),
+        exclusiveto(Windows.Gaming.Input.ForceFeedback.ConditionForceEffect),
+        uuid(91a99264-1810-4eb6-a773-bfd3b8cddbab)
+    ]
+    interface IConditionForceEffectFactory : IInspectable
+    {
+        HRESULT CreateInstance([in] Windows.Gaming.Input.ForceFeedback.ConditionForceEffectKind kind,
+                               [out, retval] Windows.Gaming.Input.ForceFeedback.ConditionForceEffect **value);
+    }
+
+    [
+        contract(Windows.Foundation.UniversalApiContract, 3.0),
+        exclusiveto(Windows.Gaming.Input.ForceFeedback.ConstantForceEffect),
+        uuid(9bfa0140-f3c7-415c-b068-0f068734bce0)
+    ]
+    interface IConstantForceEffect : IInspectable
+        requires Windows.Gaming.Input.ForceFeedback.IForceFeedbackEffect
+    {
+        HRESULT SetParameters([in] Windows.Foundation.Numerics.Vector3 vector, [in] Windows.Foundation.TimeSpan duration);
+        HRESULT SetParametersWithEnvelope([in] Windows.Foundation.Numerics.Vector3 vector, [in] FLOAT attack_gain,
+                                          [in] FLOAT sustain_gain, [in] FLOAT release_gain, [in] Windows.Foundation.TimeSpan start_delay,
+                                          [in] Windows.Foundation.TimeSpan attack_duration, [in] Windows.Foundation.TimeSpan sustain_duration,
+                                          [in] Windows.Foundation.TimeSpan release_duration, [in] UINT32 repeat_count);
+    }
+
+    [
+        contract(Windows.Foundation.UniversalApiContract, 3.0),
+        exclusiveto(Windows.Gaming.Input.ForceFeedback.RampForceEffect),
+        uuid(f1f81259-1ca6-4080-b56d-b43f3354d052)
+    ]
+    interface IRampForceEffect : IInspectable
+        requires Windows.Gaming.Input.ForceFeedback.IForceFeedbackEffect
+    {
+        HRESULT SetParameters([in] Windows.Foundation.Numerics.Vector3 start_vector, [in] Windows.Foundation.Numerics.Vector3 end_vector,
+                              [in] Windows.Foundation.TimeSpan duration);
+        HRESULT SetParametersWithEnvelope([in] Windows.Foundation.Numerics.Vector3 start_vector, [in] Windows.Foundation.Numerics.Vector3 end_vector,
+                                          [in] FLOAT attack_gain, [in] FLOAT sustain_gain, [in] FLOAT release_gain, [in] Windows.Foundation.TimeSpan start_delay,
+                                          [in] Windows.Foundation.TimeSpan attack_duration, [in] Windows.Foundation.TimeSpan sustain_duration,
+                                          [in] Windows.Foundation.TimeSpan release_duration, [in] UINT32 repeat_count);
+    }
+
     [
         contract(Windows.Foundation.UniversalApiContract, 3.0),
         marshaling_behavior(agile),
@@ -114,4 +236,52 @@ namespace Windows.Gaming.Input.ForceFeedback {
     {
         [default] interface Windows.Gaming.Input.ForceFeedback.IForceFeedbackMotor;
     }
+
+    [
+        activatable(Windows.Gaming.Input.ForceFeedback.IPeriodicForceEffectFactory, Windows.Foundation.UniversalApiContract, 3.0),
+        contract(Windows.Foundation.UniversalApiContract, 3.0),
+        marshaling_behavior(agile),
+        threading(both)
+    ]
+    runtimeclass PeriodicForceEffect
+    {
+        [default] interface Windows.Gaming.Input.ForceFeedback.IForceFeedbackEffect;
+        interface Windows.Gaming.Input.ForceFeedback.IPeriodicForceEffect;
+    }
+
+    [
+        activatable(Windows.Gaming.Input.ForceFeedback.IConditionForceEffectFactory, Windows.Foundation.UniversalApiContract, 3.0),
+        contract(Windows.Foundation.UniversalApiContract, 3.0),
+        marshaling_behavior(agile),
+        threading(both)
+    ]
+    runtimeclass ConditionForceEffect
+    {
+        [default] interface Windows.Gaming.Input.ForceFeedback.IForceFeedbackEffect;
+        interface Windows.Gaming.Input.ForceFeedback.IConditionForceEffect;
+    }
+
+    [
+        activatable(Windows.Foundation.UniversalApiContract, 3.0),
+        contract(Windows.Foundation.UniversalApiContract, 3.0),
+        marshaling_behavior(agile),
+        threading(both)
+    ]
+    runtimeclass ConstantForceEffect
+    {
+        [default] interface Windows.Gaming.Input.ForceFeedback.IForceFeedbackEffect;
+        interface Windows.Gaming.Input.ForceFeedback.IConstantForceEffect;
+    }
+
+    [
+        activatable(Windows.Foundation.UniversalApiContract, 3.0),
+        contract(Windows.Foundation.UniversalApiContract, 3.0),
+        marshaling_behavior(agile),
+        threading(both)
+    ]
+    runtimeclass RampForceEffect
+    {
+        [default] interface Windows.Gaming.Input.ForceFeedback.IForceFeedbackEffect;
+        interface Windows.Gaming.Input.ForceFeedback.IRampForceEffect;
+    }
 }
diff --git a/include/windows.gaming.input.idl b/include/windows.gaming.input.idl
index fdae3aa70b1..5fc5265247d 100644
--- wine/include/windows.gaming.input.idl
+++ wine/include/windows.gaming.input.idl
@@ -446,6 +446,19 @@ namespace Windows.Gaming.Input {
         HRESULT GetCurrentReading([out, retval] Windows.Gaming.Input.GamepadReading *value);
     }
 
+    [
+        contract(Windows.Foundation.UniversalApiContract, 3.0),
+        exclusiveto(Windows.Gaming.Input.Gamepad),
+        uuid(3c1689bd-5915-4245-b0c0-c89fae0308ff)
+    ]
+    interface IGamepad2 : IInspectable
+        requires Windows.Gaming.Input.IGamepad,
+                 Windows.Gaming.Input.IGameController
+    {
+        HRESULT GetButtonLabel([in] Windows.Gaming.Input.GamepadButtons button,
+                               [out, retval] Windows.Gaming.Input.GameControllerButtonLabel *value);
+    }
+
     [
         contract(Windows.Foundation.UniversalApiContract, 3.0),
         exclusiveto(Windows.Gaming.Input.RacingWheel),
diff --git a/include/windows.gaming.ui.idl b/include/windows.gaming.ui.idl
new file mode 100644
index 00000000000..730f5dd90f7
--- /dev/null
+++ wine/include/windows.gaming.ui.idl
@@ -0,0 +1,61 @@
+/*
+ * Copyright 2022 Paul Gofman for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifdef __WIDL__
+#pragma winrt ns_prefix
+#endif
+
+#ifndef DO_NO_IMPORTS
+import "inspectable.idl";
+import "eventtoken.idl";
+import "windowscontracts.idl";
+import "windows.foundation.idl";
+#endif
+
+namespace Windows.Gaming.UI {
+    runtimeclass GameBar;
+
+    declare {
+        interface Windows.Foundation.EventHandler<IInspectable *>;
+    }
+
+    [
+        contract(Windows.Foundation.UniversalApiContract, 2.0),
+        exclusiveto(Windows.Gaming.UI.GameBar),
+        uuid(1db9a292-cc78-4173-be45-b61e67283ea7)
+    ]
+    interface IGameBarStatics : IInspectable
+    {
+        [eventadd] HRESULT VisibilityChanged([in] Windows.Foundation.EventHandler<IInspectable *> *handler, [out, retval] EventRegistrationToken *token);
+        [eventremove] HRESULT VisibilityChanged([in] EventRegistrationToken token);
+        [eventadd] HRESULT IsInputRedirectedChanged([in] Windows.Foundation.EventHandler<IInspectable *> *handler, [out, retval] EventRegistrationToken *token);
+        [eventremove] HRESULT IsInputRedirectedChanged([in] EventRegistrationToken token);
+        [propget] HRESULT Visible([out] [retval] boolean* value);
+        [propget] HRESULT IsInputRedirected([out] [retval] boolean* value);
+    }
+
+    [
+        contract(Windows.Foundation.UniversalApiContract, 2.0),
+        marshaling_behavior(agile),
+        static(Windows.Gaming.UI.IGameBarStatics, Windows.Foundation.UniversalApiContract, 2.0),
+        threading(both)
+    ]
+    runtimeclass GameBar
+    {
+    }
+}
-- 
2.39.2 (Apple Git-144)

diff --git a/dlls/advapi32/advapi.c b/dlls/advapi32/advapi.c
index 6497ea22f4e..f7d6e973252 100644
--- wine/dlls/advapi32/advapi.c
+++ wine/dlls/advapi32/advapi.c
@@ -32,6 +32,7 @@
 #include "winerror.h"
 #include "wincred.h"
 #include "wct.h"
+#include "perflib.h"
 
 #include "wine/debug.h"
 
@@ -334,3 +335,50 @@ BOOL WINAPI GetThreadWaitChain(HWCT handle, DWORD_PTR ctx, DWORD flags, DWORD th
     SetLastError(ERROR_NOT_SUPPORTED);
     return FALSE;
 }
+
+ULONG WINAPI PerfCloseQueryHandle( HANDLE query )
+{
+    FIXME( "query %p stub.\n", query );
+
+    return ERROR_SUCCESS;
+}
+
+ULONG WINAPI PerfOpenQueryHandle( const WCHAR *machine, HANDLE *query )
+{
+    FIXME( "machine %s, query %p.\n", debugstr_w(machine), query );
+
+    if (!query) return ERROR_INVALID_PARAMETER;
+    *query = (HANDLE)0xdeadbeef;
+
+    return ERROR_SUCCESS;
+}
+
+ULONG WINAPI PerfAddCounters( HANDLE query, PERF_COUNTER_IDENTIFIER *id, DWORD size )
+{
+    FIXME( "query %p, id %p, size %lu stub.\n", query, id, size );
+
+    if (!id || size < sizeof(*id) || id->Size < sizeof(*id)) return ERROR_INVALID_PARAMETER;
+
+    id->Status = ERROR_WMI_GUID_NOT_FOUND;
+    return ERROR_SUCCESS;
+}
+
+ULONG WINAPI PerfQueryCounterData( HANDLE query, PERF_DATA_HEADER *data, DWORD data_size, DWORD *size_needed )
+{
+    FIXME( "query %p, data %p, data_size %lu, size_needed %p stub.\n", query, data, data_size, size_needed );
+
+    if (!size_needed) return ERROR_INVALID_PARAMETER;
+
+    *size_needed = sizeof(PERF_DATA_HEADER);
+
+    if (!data || data_size < sizeof(PERF_DATA_HEADER)) return ERROR_NOT_ENOUGH_MEMORY;
+
+    data->dwTotalSize = sizeof(PERF_DATA_HEADER);
+    data->dwNumCounters = 0;
+    QueryPerformanceCounter( (LARGE_INTEGER *)&data->PerfTimeStamp );
+    QueryPerformanceFrequency( (LARGE_INTEGER *)&data->PerfFreq );
+    GetSystemTimeAsFileTime( (FILETIME *)&data->PerfTime100NSec );
+    FileTimeToSystemTime( (FILETIME *)&data->PerfTime100NSec, &data->SystemTime );
+
+    return ERROR_SUCCESS;
+}
diff --git a/dlls/advapi32/advapi32.spec b/dlls/advapi32/advapi32.spec
index 3b5f587d40e..1c3f59bb7ee 100644
--- wine/dlls/advapi32/advapi32.spec
+++ wine/dlls/advapi32/advapi32.spec
@@ -553,8 +553,8 @@
 @ stdcall -ret64 -import OpenTraceW(ptr)
 # @ stub OperationEnd
 # @ stub OperationStart
-# @ stub PerfAddCounters
-# @ stub PerfCloseQueryHandle
+@ stdcall PerfAddCounters(long ptr long)
+@ stdcall PerfCloseQueryHandle(long)
 @ stdcall -import PerfCreateInstance(long ptr wstr long)
 # @ stub PerfDecrementULongCounterValue
 # @ stub PerfDecrementULongLongCounterValue
@@ -564,8 +564,8 @@
 # @ stub PerfEnumerateCounterSetInstances
 # @ stub PerfIncrementULongCounterValue
 # @ stub PerfIncrementULongLongCounterValue
-# @ stub PerfOpenQueryHandle
-# @ stub PerfQueryCounterData
+@ stdcall PerfOpenQueryHandle(wstr ptr)
+@ stdcall PerfQueryCounterData(long ptr long ptr)
 # @ stub PerfQueryCounterInfo
 # @ stub PerfQueryCounterSetRegistrationInfo
 # @ stub PerfQueryInstance
diff --git a/dlls/advapi32/tests/perf.c b/dlls/advapi32/tests/perf.c
index fc07a09d327..34b6e952842 100644
--- wine/dlls/advapi32/tests/perf.c
+++ wine/dlls/advapi32/tests/perf.c
@@ -25,9 +25,31 @@
 #include "winerror.h"
 #include "perflib.h"
 #include "winperf.h"
+#include "winternl.h"
 
 #include "wine/test.h"
 
+#include "initguid.h"
+
+#define DEFINE_FUNCTION(name) static typeof(name) *p##name;
+DEFINE_FUNCTION(PerfCloseQueryHandle);
+DEFINE_FUNCTION(PerfOpenQueryHandle);
+DEFINE_FUNCTION(PerfAddCounters);
+DEFINE_FUNCTION(PerfQueryCounterData);
+#undef DEFINE_FUNCTION
+
+static void init_functions(void)
+{
+    HANDLE hadvapi = GetModuleHandleA("advapi32.dll");
+
+#define GET_FUNCTION(name) p##name = (void *)GetProcAddress(hadvapi, #name)
+    GET_FUNCTION(PerfCloseQueryHandle);
+    GET_FUNCTION(PerfOpenQueryHandle);
+    GET_FUNCTION(PerfAddCounters);
+    GET_FUNCTION(PerfQueryCounterData);
+#undef GET_FUNCTION
+}
+
 static ULONG WINAPI test_provider_callback(ULONG code, void *buffer, ULONG size)
 {
     ok(0, "Provider callback called.\n");
@@ -188,7 +210,94 @@ void test_provider_init(void)
     ok(!ret, "Got unexpected ret %lu.\n", ret);
 }
 
+DEFINE_GUID(TestCounterGUID, 0x12345678, 0x1234, 0x5678, 0x12, 0x34, 0x11, 0x11, 0x22, 0x22, 0x33, 0x33);
+
+static ULONG64 trunc_nttime_ms(ULONG64 t)
+{
+    return (t / 10000) * 10000;
+}
+
+static void test_perf_counters(void)
+{
+    LARGE_INTEGER freq, qpc1, qpc2, nttime1, nttime2, systime;
+    char buffer[sizeof(PERF_COUNTER_IDENTIFIER) + 8];
+    PERF_COUNTER_IDENTIFIER *counter_id;
+    PERF_DATA_HEADER dh;
+    HANDLE query;
+    DWORD size;
+    ULONG ret;
+
+    if (!pPerfOpenQueryHandle)
+    {
+        win_skip("PerfOpenQueryHandle not found.\n");
+        return;
+    }
+
+    ret = pPerfOpenQueryHandle(NULL, NULL);
+    ok(ret == ERROR_INVALID_PARAMETER, "got ret %lu.\n", ret);
+    ret = pPerfOpenQueryHandle(NULL, &query);
+    ok(!ret, "got ret %lu.\n", ret);
+
+    counter_id = (PERF_COUNTER_IDENTIFIER *)buffer;
+    memset(buffer, 0, sizeof(buffer));
+
+    counter_id->CounterSetGuid = TestCounterGUID;
+    counter_id->CounterId = PERF_WILDCARD_COUNTER;
+    counter_id->InstanceId = PERF_WILDCARD_COUNTER;
+
+    ret = pPerfAddCounters(query, counter_id, sizeof(*counter_id));
+    ok(ret == ERROR_INVALID_PARAMETER, "got ret %lu.\n", ret);
+
+    counter_id->Size = sizeof(*counter_id);
+    ret = pPerfAddCounters(query, counter_id, 8);
+    ok(ret == ERROR_INVALID_PARAMETER, "got ret %lu.\n", ret);
+    ret = pPerfAddCounters(query, counter_id, sizeof(*counter_id));
+    ok(!ret, "got ret %lu.\n", ret);
+    ok(counter_id->Status == ERROR_WMI_GUID_NOT_FOUND, "got Status %#lx.\n", counter_id->Status);
+
+    ret = pPerfQueryCounterData(query, NULL, 0, NULL);
+    ok(ret == ERROR_INVALID_PARAMETER, "got ret %lu.\n", ret);
+
+    size = 0xdeadbeef;
+    ret = pPerfQueryCounterData(query, NULL, 0, &size);
+    ok(ret == ERROR_NOT_ENOUGH_MEMORY, "got ret %lu.\n", ret);
+    ok(size == sizeof(dh), "got size %lu.\n", size);
+
+    ret = pPerfQueryCounterData(query, &dh, sizeof(dh), NULL);
+    ok(ret == ERROR_INVALID_PARAMETER, "got ret %lu.\n", ret);
+
+    QueryPerformanceFrequency(&freq);
+    QueryPerformanceCounter(&qpc1);
+    NtQuerySystemTime(&nttime1);
+
+    size = 0xdeadbeef;
+    ret = pPerfQueryCounterData(query, &dh, sizeof(dh), &size);
+    QueryPerformanceCounter(&qpc2);
+    NtQuerySystemTime(&nttime2);
+    SystemTimeToFileTime(&dh.SystemTime, (FILETIME *)&systime);
+    ok(!ret, "got ret %lu.\n", ret);
+    ok(size == sizeof(dh), "got size %lu.\n", size);
+    ok(dh.dwTotalSize == sizeof(dh), "got dwTotalSize %lu.\n", dh.dwTotalSize);
+    ok(!dh.dwNumCounters, "got dwNumCounters %lu.\n", dh.dwNumCounters);
+    ok(dh.PerfFreq == freq.QuadPart, "got PerfFreq %I64u.\n", dh.PerfFreq);
+    ok(dh.PerfTimeStamp >= qpc1.QuadPart && dh.PerfTimeStamp <= qpc2.QuadPart,
+            "got PerfTimeStamp %I64u, qpc1 %I64u, qpc2 %I64u.\n",
+            dh.PerfTimeStamp, qpc1.QuadPart, qpc2.QuadPart);
+    ok(dh.PerfTime100NSec >= nttime1.QuadPart && dh.PerfTime100NSec <= nttime2.QuadPart,
+            "got PerfTime100NSec %I64u, nttime1 %I64u, nttime2 %I64u.\n",
+            dh.PerfTime100NSec, nttime1.QuadPart, nttime2.QuadPart);
+    ok(systime.QuadPart >= trunc_nttime_ms(nttime1.QuadPart) && systime.QuadPart <= trunc_nttime_ms(nttime2.QuadPart),
+            "got systime %I64u, nttime1 %I64u, nttime2 %I64u, %d.\n",
+            systime.QuadPart, nttime1.QuadPart, nttime2.QuadPart, dh.SystemTime.wMilliseconds);
+
+    ret = pPerfCloseQueryHandle(query);
+    ok(!ret, "got ret %lu.\n", ret);
+}
+
 START_TEST(perf)
 {
+    init_functions();
+
     test_provider_init();
+    test_perf_counters();
 }
diff --git a/include/perflib.h b/include/perflib.h
index eb65f0802a4..40704aeb6f7 100644
--- wine/include/perflib.h
+++ wine/include/perflib.h
@@ -83,6 +83,28 @@ typedef struct _PROVIDER_CONTEXT {
     LPVOID pMemContext;
 } PERF_PROVIDER_CONTEXT, * PPERF_PROVIDER_CONTEXT;
 
+typedef struct _PERF_COUNTER_IDENTIFIER {
+    GUID CounterSetGuid;
+    ULONG Status;
+    ULONG Size;
+    ULONG CounterId;
+    ULONG InstanceId;
+    ULONG Index;
+    ULONG Reserved;
+} PERF_COUNTER_IDENTIFIER, *PPERF_COUNTER_IDENTIFIER;
+
+#define PERF_WILDCARD_COUNTER  0xFFFFFFFF
+#define PERF_WILDCARD_INSTANCE L"*"
+
+typedef struct _PERF_DATA_HEADER {
+    ULONG dwTotalSize;
+    ULONG dwNumCounters;
+    LONGLONG PerfTimeStamp;
+    LONGLONG PerfTime100NSec;
+    LONGLONG PerfFreq;
+    SYSTEMTIME SystemTime;
+} PERF_DATA_HEADER, *PPERF_DATA_HEADER;
+
 PERF_COUNTERSET_INSTANCE WINAPI *PerfCreateInstance(HANDLE, const GUID *, const WCHAR *, ULONG);
 ULONG WINAPI PerfDeleteInstance(HANDLE, PERF_COUNTERSET_INSTANCE *);
 ULONG WINAPI PerfSetCounterRefValue(HANDLE, PERF_COUNTERSET_INSTANCE *, ULONG, void *);
@@ -91,6 +113,11 @@ ULONG WINAPI PerfStartProvider(GUID *, PERFLIBREQUEST, HANDLE *);
 ULONG WINAPI PerfStartProviderEx(GUID *, PERF_PROVIDER_CONTEXT *, HANDLE *);
 ULONG WINAPI PerfStopProvider(HANDLE);
 
+ULONG WINAPI PerfAddCounters(HANDLE, PERF_COUNTER_IDENTIFIER *, DWORD);
+ULONG WINAPI PerfCloseQueryHandle(HANDLE);
+ULONG WINAPI PerfOpenQueryHandle(const WCHAR *, HANDLE *);
+ULONG WINAPI PerfQueryCounterData(HANDLE, PERF_DATA_HEADER *, DWORD, DWORD *);
+
 #ifdef __cplusplus
 }       /* extern "C" */
 #endif
-- 
2.39.2 (Apple Git-144)

diff --git a/dlls/kernel32/kernel32.spec b/dlls/kernel32/kernel32.spec
index 2ae9ccdc93f..51a14338d93 100644
--- wine/dlls/kernel32/kernel32.spec
+++ wine/dlls/kernel32/kernel32.spec
@@ -1470,6 +1470,7 @@
 @ stdcall -import SetThreadGroupAffinity(long ptr ptr)
 @ stdcall -import SetThreadIdealProcessor(long long)
 @ stdcall -import SetThreadIdealProcessorEx(long ptr ptr)
+@ stdcall -import SetThreadInformation(long long ptr long)
 @ stdcall -import SetThreadLocale(long)
 @ stdcall -import SetThreadPreferredUILanguages(long ptr ptr)
 @ stdcall -import SetThreadPriority(long long)
diff --git a/dlls/kernelbase/kernelbase.spec b/dlls/kernelbase/kernelbase.spec
index 00012198eb6..3fb2192b1ff 100644
--- wine/dlls/kernelbase/kernelbase.spec
+++ wine/dlls/kernelbase/kernelbase.spec
@@ -1519,7 +1519,7 @@
 @ stdcall SetThreadGroupAffinity(long ptr ptr)
 @ stdcall SetThreadIdealProcessor(long long)
 @ stdcall SetThreadIdealProcessorEx(long ptr ptr)
-# @ stub SetThreadInformation
+@ stdcall SetThreadInformation(long long ptr long)
 @ stdcall SetThreadLocale(long)
 @ stdcall SetThreadPreferredUILanguages(long ptr ptr)
 @ stdcall SetThreadPriority(long long)
diff --git a/dlls/kernelbase/thread.c b/dlls/kernelbase/thread.c
index 1c878474acb..3f61ae46776 100644
--- wine/dlls/kernelbase/thread.c
+++ wine/dlls/kernelbase/thread.c
@@ -606,6 +606,25 @@ LANGID WINAPI DECLSPEC_HOTPATCH SetThreadUILanguage( LANGID langid )
 }
 
 
+/**********************************************************************
+ *            SetThreadInformation   (kernelbase.@)
+ */
+BOOL WINAPI DECLSPEC_HOTPATCH SetThreadInformation( HANDLE thread, THREAD_INFORMATION_CLASS info_class,
+        VOID *info, DWORD size )
+{
+    switch (info_class)
+    {
+        case ThreadMemoryPriority:
+            return set_ntstatus( NtSetInformationThread( thread, ThreadPagePriority, info, size ));
+        case ThreadPowerThrottling:
+            return set_ntstatus( NtSetInformationThread( thread, ThreadPowerThrottlingState, info, size ));
+        default:
+            FIXME("Unsupported class %u.\n", info_class);
+            return FALSE;
+    }
+}
+
+
 /**********************************************************************
  *           SuspendThread   (kernelbase.@)
  */
diff --git a/include/processthreadsapi.h b/include/processthreadsapi.h
index 8cdaff4796a..d266b7a727b 100644
--- wine/include/processthreadsapi.h
+++ wine/include/processthreadsapi.h
@@ -23,8 +23,23 @@
 extern "C" {
 #endif
 
+typedef enum _THREAD_INFORMATION_CLASS
+{
+    ThreadMemoryPriority,
+    ThreadAbsoluteCpuPriority,
+    ThreadDynamicCodePolicy,
+    ThreadPowerThrottling,
+    ThreadInformationClassMax
+} THREAD_INFORMATION_CLASS;
+
+typedef struct _MEMORY_PRIORITY_INFORMATION
+{
+    ULONG MemoryPriority;
+} MEMORY_PRIORITY_INFORMATION, *PMEMORY_PRIORITY_INFORMATION;
+
 WINBASEAPI HRESULT WINAPI GetThreadDescription(HANDLE,PWSTR *);
 WINBASEAPI HRESULT WINAPI SetThreadDescription(HANDLE,PCWSTR);
+WINBASEAPI BOOL WINAPI SetThreadInformation(HANDLE,THREAD_INFORMATION_CLASS,LPVOID,DWORD);
 
 #ifdef __cplusplus
 }
-- 
2.39.2 (Apple Git-144)

diff --git a/configure b/configure
index cdf99fc287d..bfa6e1885a1 100755
--- wine/configure
+++ wine/configure
@@ -1424,6 +1424,7 @@ enable_wimgapi
 enable_win32u
 enable_windows_devices_enumeration
 enable_windows_gaming_input
+enable_windows_gaming_ui_gamebar
 enable_windows_globalization
 enable_windows_media_devices
 enable_windows_media_speech
@@ -22531,6 +22532,8 @@ wine_fn_config_makefile dlls/windebug.dll16 enable_win16
 wine_fn_config_makefile dlls/windows.devices.enumeration enable_windows_devices_enumeration
 wine_fn_config_makefile dlls/windows.gaming.input enable_windows_gaming_input
 wine_fn_config_makefile dlls/windows.gaming.input/tests enable_tests
+wine_fn_config_makefile dlls/windows.gaming.ui.gamebar enable_windows_gaming_ui_gamebar 
+wine_fn_config_makefile dlls/windows.gaming.ui.gamebar/tests enable_tests
 wine_fn_config_makefile dlls/windows.globalization enable_windows_globalization
 wine_fn_config_makefile dlls/windows.globalization/tests enable_tests
 wine_fn_config_makefile dlls/windows.media.devices enable_windows_media_devices
diff --git a/configure.ac b/configure.ac
index c05d5b6f539..8fad7462dd9 100644
--- wine/configure.ac
+++ wine/configure.ac
@@ -3175,6 +3175,8 @@ WINE_CONFIG_MAKEFILE(dlls/windebug.dll16,enable_win16)
 WINE_CONFIG_MAKEFILE(dlls/windows.devices.enumeration)
 WINE_CONFIG_MAKEFILE(dlls/windows.gaming.input)
 WINE_CONFIG_MAKEFILE(dlls/windows.gaming.input/tests)
+WINE_CONFIG_MAKEFILE(dlls/windows.gaming.ui.gamebar)
+WINE_CONFIG_MAKEFILE(dlls/windows.gaming.ui.gamebar/tests)
 WINE_CONFIG_MAKEFILE(dlls/windows.globalization)
 WINE_CONFIG_MAKEFILE(dlls/windows.globalization/tests)
 WINE_CONFIG_MAKEFILE(dlls/windows.media.devices)
diff --git a/dlls/windows.gaming.ui.gamebar/Makefile.in b/dlls/windows.gaming.ui.gamebar/Makefile.in
new file mode 100644
index 00000000000..a0eefc4b951
--- /dev/null
+++ wine/dlls/windows.gaming.ui.gamebar/Makefile.in
@@ -0,0 +1,8 @@
+MODULE = windows.gaming.ui.gamebar.dll
+IMPORTS = combase uuid
+
+C_SRCS = \
+	main.c
+
+IDL_SRCS = \
+	classes.idl
diff --git a/dlls/windows.gaming.ui.gamebar/classes.idl b/dlls/windows.gaming.ui.gamebar/classes.idl
new file mode 100644
index 00000000000..ef10fcb6283
--- /dev/null
+++ wine/dlls/windows.gaming.ui.gamebar/classes.idl
@@ -0,0 +1,33 @@
+/*
+ * Runtime Classes for windows.gaming.ui.gamebar.dll
+ *
+ * Copyright 2022 Paul Gofman for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#pragma makedep register
+
+#ifdef __WIDL__
+#pragma winrt ns_prefix
+#endif
+
+import "inspectable.idl";
+import "eventtoken.idl";
+import "windowscontracts.idl";
+import "windows.foundation.idl";
+
+#define DO_NO_IMPORTS
+#include "windows.gaming.ui.idl"
diff --git a/dlls/windows.gaming.ui.gamebar/main.c b/dlls/windows.gaming.ui.gamebar/main.c
new file mode 100644
index 00000000000..ec6b442cfc0
--- /dev/null
+++ wine/dlls/windows.gaming.ui.gamebar/main.c
@@ -0,0 +1,282 @@
+/* WinRT Windows.Gaming.UI.GameBar implementation
+ *
+ * Copyright 2022 Paul Gofman for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include <stdarg.h>
+#include <stddef.h>
+
+#define COBJMACROS
+#include "windef.h"
+#include "winbase.h"
+#include "winreg.h"
+#include "winuser.h"
+#include "winstring.h"
+
+#include "initguid.h"
+
+#define WIDL_using_Windows_Foundation
+#define WIDL_using_Windows_Gaming_UI
+#include "activation.h"
+#include "windows.gaming.ui.h"
+
+#include "wine/debug.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(gamebar);
+
+static EventRegistrationToken dummy_token = {.value = 0xdeadbeef};
+
+struct gamebar_statics
+{
+    IActivationFactory IActivationFactory_iface;
+    IGameBarStatics IGameBarStatics_iface;
+    LONG ref;
+};
+
+static inline struct gamebar_statics *impl_from_IActivationFactory( IActivationFactory *iface )
+{
+    return CONTAINING_RECORD( iface, struct gamebar_statics, IActivationFactory_iface );
+}
+
+static HRESULT WINAPI factory_QueryInterface( IActivationFactory *iface, REFIID iid, void **out )
+{
+    struct gamebar_statics *impl = impl_from_IActivationFactory( iface );
+
+    TRACE( "iface %p, iid %s, out %p.\n", iface, debugstr_guid( iid ), out );
+
+    if (IsEqualGUID( iid, &IID_IUnknown ) ||
+        IsEqualGUID( iid, &IID_IInspectable ) ||
+        IsEqualGUID( iid, &IID_IAgileObject ) ||
+        IsEqualGUID( iid, &IID_IActivationFactory ))
+    {
+        IInspectable_AddRef( (*out = &impl->IActivationFactory_iface) );
+        return S_OK;
+    }
+
+    if (IsEqualGUID( iid, &IID_IGameBarStatics ))
+    {
+        IInspectable_AddRef( (*out = &impl->IGameBarStatics_iface) );
+        return S_OK;
+    }
+
+    FIXME( "%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid( iid ) );
+    *out = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI factory_AddRef( IActivationFactory *iface )
+{
+    struct gamebar_statics *impl = impl_from_IActivationFactory( iface );
+    ULONG ref = InterlockedIncrement( &impl->ref );
+    TRACE( "iface %p increasing refcount to %lu.\n", iface, ref );
+    return ref;
+}
+
+static ULONG WINAPI factory_Release( IActivationFactory *iface )
+{
+    struct gamebar_statics *impl = impl_from_IActivationFactory( iface );
+    ULONG ref = InterlockedDecrement( &impl->ref );
+    TRACE( "iface %p decreasing refcount to %lu.\n", iface, ref );
+    return ref;
+}
+
+static HRESULT WINAPI factory_GetIids( IActivationFactory *iface, ULONG *iid_count, IID **iids )
+{
+    FIXME( "iface %p, iid_count %p, iids %p stub!\n", iface, iid_count, iids );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI factory_GetRuntimeClassName( IActivationFactory *iface, HSTRING *class_name )
+{
+    FIXME( "iface %p, class_name %p stub!\n", iface, class_name );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI factory_GetTrustLevel( IActivationFactory *iface, TrustLevel *trust_level )
+{
+    FIXME( "iface %p, trust_level %p stub!\n", iface, trust_level );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI factory_ActivateInstance( IActivationFactory *iface, IInspectable **instance )
+{
+    FIXME( "iface %p, instance %p stub!\n", iface, instance );
+    return E_NOTIMPL;
+}
+
+static const struct IActivationFactoryVtbl factory_vtbl =
+{
+    factory_QueryInterface,
+    factory_AddRef,
+    factory_Release,
+    /* IInspectable methods */
+    factory_GetIids,
+    factory_GetRuntimeClassName,
+    factory_GetTrustLevel,
+    /* IActivationFactory methods */
+    factory_ActivateInstance,
+};
+
+#define DEFINE_IINSPECTABLE_( pfx, iface_type, impl_type, impl_from, iface_mem, expr )             \
+    static inline impl_type *impl_from( iface_type *iface )                                        \
+    {                                                                                              \
+        return CONTAINING_RECORD( iface, impl_type, iface_mem );                                   \
+    }                                                                                              \
+    static HRESULT WINAPI pfx##_QueryInterface( iface_type *iface, REFIID iid, void **out )        \
+    {                                                                                              \
+        impl_type *impl = impl_from( iface );                                                      \
+        return IInspectable_QueryInterface( (IInspectable *)(expr), iid, out );                    \
+    }                                                                                              \
+    static ULONG WINAPI pfx##_AddRef( iface_type *iface )                                          \
+    {                                                                                              \
+        impl_type *impl = impl_from( iface );                                                      \
+        return IInspectable_AddRef( (IInspectable *)(expr) );                                      \
+    }                                                                                              \
+    static ULONG WINAPI pfx##_Release( iface_type *iface )                                         \
+    {                                                                                              \
+        impl_type *impl = impl_from( iface );                                                      \
+        return IInspectable_Release( (IInspectable *)(expr) );                                     \
+    }                                                                                              \
+    static HRESULT WINAPI pfx##_GetIids( iface_type *iface, ULONG *iid_count, IID **iids )         \
+    {                                                                                              \
+        impl_type *impl = impl_from( iface );                                                      \
+        return IInspectable_GetIids( (IInspectable *)(expr), iid_count, iids );                    \
+    }                                                                                              \
+    static HRESULT WINAPI pfx##_GetRuntimeClassName( iface_type *iface, HSTRING *class_name )      \
+    {                                                                                              \
+        impl_type *impl = impl_from( iface );                                                      \
+        return IInspectable_GetRuntimeClassName( (IInspectable *)(expr), class_name );             \
+    }                                                                                              \
+    static HRESULT WINAPI pfx##_GetTrustLevel( iface_type *iface, TrustLevel *trust_level )        \
+    {                                                                                              \
+        impl_type *impl = impl_from( iface );                                                      \
+        return IInspectable_GetTrustLevel( (IInspectable *)(expr), trust_level );                  \
+    }
+#define DEFINE_IINSPECTABLE( pfx, iface_type, impl_type, base_iface )                              \
+    DEFINE_IINSPECTABLE_( pfx, iface_type, impl_type, impl_from_##iface_type, iface_type##_iface, &impl->base_iface )
+
+DEFINE_IINSPECTABLE( statics, IGameBarStatics, struct gamebar_statics, IActivationFactory_iface )
+
+static HRESULT WINAPI statics_add_VisibilityChanged( IGameBarStatics *iface,
+                                                          IEventHandler_IInspectable *handler,
+                                                          EventRegistrationToken *token )
+{
+    FIXME( "iface %p, handler %p, token %p stub.\n", iface, handler, token );
+    *token = dummy_token;
+    return S_OK;
+}
+
+static HRESULT WINAPI statics_remove_VisibilityChanged( IGameBarStatics *iface, EventRegistrationToken token )
+{
+    FIXME( "iface %p, token %#I64x stub.\n", iface, token.value );
+    return S_OK;
+}
+
+static HRESULT WINAPI statics_add_IsInputRedirectedChanged( IGameBarStatics *iface,
+                                                          IEventHandler_IInspectable *handler,
+                                                          EventRegistrationToken *token )
+{
+    FIXME( "iface %p, handler %p, token %p stub.\n", iface, handler, token );
+    *token = dummy_token;
+    return S_OK;
+}
+
+static HRESULT WINAPI statics_remove_IsInputRedirectedChanged( IGameBarStatics *iface, EventRegistrationToken token )
+{
+    FIXME( "iface %p, token %#I64x stub.\n", iface, token.value );
+    return S_OK;
+}
+
+static HRESULT WINAPI statics_get_Visible( IGameBarStatics *iface, BOOLEAN *value)
+{
+    TRACE( "iface %p, value %p.\n", iface, value );
+
+    if (!value) return E_INVALIDARG;
+    *value = FALSE;
+    return S_OK;
+}
+
+static HRESULT WINAPI statics_get_IsInputRedirected( IGameBarStatics *iface, BOOLEAN *value)
+{
+    TRACE( "iface %p, value %p.\n", iface, value );
+
+    if (!value) return E_INVALIDARG;
+    *value = FALSE;
+    return S_OK;
+}
+
+static const struct IGameBarStaticsVtbl statics_vtbl =
+{
+    statics_QueryInterface,
+    statics_AddRef,
+    statics_Release,
+    /* IInspectable methods */
+    statics_GetIids,
+    statics_GetRuntimeClassName,
+    statics_GetTrustLevel,
+    /* IGameBarStatics methods */
+    statics_add_VisibilityChanged,
+    statics_remove_VisibilityChanged,
+    statics_add_IsInputRedirectedChanged,
+    statics_remove_IsInputRedirectedChanged,
+    statics_get_Visible,
+    statics_get_IsInputRedirected,
+};
+
+static struct gamebar_statics gamebar_statics =
+{
+    {&factory_vtbl},
+    {&statics_vtbl},
+    1,
+};
+
+static IActivationFactory *gamebar_factory = &gamebar_statics.IActivationFactory_iface;
+
+HRESULT WINAPI DllGetClassObject(REFCLSID clsid, REFIID riid, void **out)
+{
+    FIXME("clsid %s, riid %s, out %p stub!\n", debugstr_guid(clsid), debugstr_guid(riid), out);
+
+    return CLASS_E_CLASSNOTAVAILABLE;
+}
+
+HRESULT WINAPI DllGetActivationFactory( HSTRING class_str, IActivationFactory **factory )
+{
+    const WCHAR *buffer = WindowsGetStringRawBuffer( class_str, NULL );
+
+    TRACE( "class %s, factory %p.\n", debugstr_w(buffer), factory );
+
+    *factory = NULL;
+
+    if (!wcscmp( buffer, RuntimeClass_Windows_Gaming_UI_GameBar ))
+        IActivationFactory_QueryInterface( gamebar_factory, &IID_IActivationFactory, (void **)factory );
+
+    if (*factory) return S_OK;
+    return CLASS_E_CLASSNOTAVAILABLE;
+}
+
+BOOL WINAPI DllMain( HINSTANCE instance, DWORD reason, void *reserved )
+{
+    TRACE( "instance %p, reason %lu, reserved %p.\n", instance, reason, reserved );
+
+    switch (reason)
+    {
+    case DLL_PROCESS_ATTACH:
+        DisableThreadLibraryCalls( instance );
+        break;
+    }
+    return TRUE;
+}
diff --git a/dlls/windows.gaming.ui.gamebar/tests/Makefile.in b/dlls/windows.gaming.ui.gamebar/tests/Makefile.in
new file mode 100644
index 00000000000..67d70eee241
--- /dev/null
+++ wine/dlls/windows.gaming.ui.gamebar/tests/Makefile.in
@@ -0,0 +1,5 @@
+TESTDLL = windows.gaming.ui.gamebar.dll
+IMPORTS = combase
+
+C_SRCS = \
+	gamebar.c
diff --git a/dlls/windows.gaming.ui.gamebar/tests/gamebar.c b/dlls/windows.gaming.ui.gamebar/tests/gamebar.c
new file mode 100644
index 00000000000..14fcb05284f
--- /dev/null
+++ wine/dlls/windows.gaming.ui.gamebar/tests/gamebar.c
@@ -0,0 +1,91 @@
+/*
+ * Copyright 2022 Paul Gofman for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+#define COBJMACROS
+#include "initguid.h"
+#include <stdarg.h>
+
+#include "windef.h"
+#include "winbase.h"
+#include "winerror.h"
+#include "winstring.h"
+
+#include "roapi.h"
+
+#define WIDL_using_Windows_Foundation
+#define WIDL_using_Windows_Gaming_UI
+#include "windows.foundation.h"
+#include "windows.gaming.ui.h"
+
+#include "wine/test.h"
+
+static void test_GameBarStatics(void)
+{
+    static const WCHAR *gamebar_statics_name = L"Windows.Gaming.UI.GameBar";
+
+    IActivationFactory *factory = NULL;
+    IInspectable *inspectable = NULL, *tmp_inspectable = NULL;
+    IAgileObject *agile_object = NULL, *tmp_agile_object = NULL;
+    IGameBarStatics *gamebar_statics = NULL;
+    HSTRING str;
+    HRESULT hr;
+
+    hr = WindowsCreateString(gamebar_statics_name, wcslen(gamebar_statics_name), &str);
+    ok(hr == S_OK, "WindowsCreateString failed, hr %#lx\n", hr);
+
+    hr = RoGetActivationFactory(str, &IID_IActivationFactory, (void **)&factory);
+    ok(hr == S_OK, "RoGetActivationFactory failed, hr %#lx\n", hr);
+    WindowsDeleteString(str);
+
+    /* interface tests */
+    hr = IActivationFactory_QueryInterface(factory, &IID_IInspectable, (void **)&inspectable);
+    ok(hr == S_OK, "IActivationFactory_QueryInterface IID_IInspectable failed, hr %#lx\n", hr);
+
+    hr = IActivationFactory_QueryInterface(factory, &IID_IAgileObject, (void **)&agile_object);
+    ok(hr == S_OK, "IActivationFactory_QueryInterface IID_IAgileObject failed, hr %#lx\n", hr);
+
+    hr = IActivationFactory_QueryInterface(factory, &IID_IGameBarStatics, (void **)&gamebar_statics);
+    ok(hr == S_OK, "IActivationFactory_QueryInterface IID_IMediaDeviceStatics failed, hr %#lx\n", hr);
+
+    hr = IGameBarStatics_QueryInterface(gamebar_statics, &IID_IInspectable, (void **)&tmp_inspectable);
+    ok(hr == S_OK, "IMediaDeviceStatics_QueryInterface IID_IInspectable failed, hr %#lx\n", hr);
+    ok(tmp_inspectable == inspectable, "IMediaDeviceStatics_QueryInterface IID_IInspectable returned %p, expected %p\n", tmp_inspectable, inspectable);
+    IInspectable_Release(tmp_inspectable);
+
+    hr = IGameBarStatics_QueryInterface(gamebar_statics, &IID_IAgileObject, (void **)&tmp_agile_object);
+    ok(hr == S_OK, "IMediaDeviceStatics_QueryInterface IID_IAgileObject failed, hr %#lx\n", hr);
+    ok(tmp_agile_object == agile_object, "IMediaDeviceStatics_QueryInterface IID_IAgileObject returned %p, expected %p\n", tmp_agile_object, agile_object);
+    IAgileObject_Release(tmp_agile_object);
+
+
+    IAgileObject_Release(agile_object);
+    IInspectable_Release(inspectable);
+    IActivationFactory_Release(factory);
+    IGameBarStatics_Release(gamebar_statics);
+}
+
+START_TEST(gamebar)
+{
+    HRESULT hr;
+
+    hr = RoInitialize(RO_INIT_MULTITHREADED);
+    ok(hr == S_OK, "RoInitialize failed, hr %#lx\n", hr);
+
+    test_GameBarStatics();
+
+    RoUninitialize();
+}
diff --git a/dlls/windows.gaming.ui.gamebar/windows.gaming.ui.gamebar.spec b/dlls/windows.gaming.ui.gamebar/windows.gaming.ui.gamebar.spec
new file mode 100644
index 00000000000..20a8bfa98ea
--- /dev/null
+++ wine/dlls/windows.gaming.ui.gamebar/windows.gaming.ui.gamebar.spec
@@ -0,0 +1,3 @@
+@ stdcall -private DllCanUnloadNow()
+@ stdcall -private DllGetActivationFactory(ptr ptr)
+@ stdcall -private DllGetClassObject(ptr ptr ptr)
-- 
2.39.2 (Apple Git-144)

diff --git a/dlls/mfmediaengine/Makefile.in b/dlls/mfmediaengine/Makefile.in
index a0e944c0633..bd273aafdab 100644
--- wine/dlls/mfmediaengine/Makefile.in
+++ wine/dlls/mfmediaengine/Makefile.in
@@ -1,4 +1,6 @@
+EXTRADEFS = -DWINE_NO_LONG_TYPES
 MODULE    = mfmediaengine.dll
+IMPORTLIB = mfmediaengine
 IMPORTS = oleaut32 ole32 mfplat mf mfuuid dxguid uuid
 
 EXTRADLLFLAGS = -Wb,--prefer-native
diff --git a/dlls/mfmediaengine/main.c b/dlls/mfmediaengine/main.c
index a191448b69f..98504c5e269 100644
--- wine/dlls/mfmediaengine/main.c
+++ wine/dlls/mfmediaengine/main.c
@@ -29,8 +29,6 @@
 #include "mferror.h"
 #include "dxgi.h"
 #include "d3d11.h"
-#include "mmdeviceapi.h"
-#include "audiosessiontypes.h"
 
 #include "wine/debug.h"
 
@@ -115,8 +113,7 @@ struct rect
 
 struct media_engine
 {
-    IMFMediaEngineEx IMFMediaEngineEx_iface;
-    IMFGetService IMFGetService_iface;
+    IMFMediaEngine IMFMediaEngine_iface;
     IMFAsyncCallback session_events;
     IMFAsyncCallback load_handler;
     IMFSampleGrabberSinkCallback grabber_callback;
@@ -141,11 +138,6 @@ struct media_engine
     IMFSourceResolver *resolver;
     BSTR current_source;
     struct
-    {
-        IMFMediaSource *source;
-        IMFPresentationDescriptor *pd;
-    } presentation;
-    struct
     {
         LONGLONG pts;
         SIZE size;
@@ -214,7 +206,7 @@ static HRESULT media_engine_lock_d3d_device(struct media_engine *engine, ID3D11D
     {
         if (FAILED(hr = IMFDXGIDeviceManager_OpenDeviceHandle(engine->device_manager, &engine->device_handle)))
         {
-            WARN("Failed to open device handle, hr %#lx.\n", hr);
+            WARN("Failed to open device handle, hr %#x.\n", hr);
             return hr;
         }
     }
@@ -230,7 +222,7 @@ static HRESULT media_engine_lock_d3d_device(struct media_engine *engine, ID3D11D
 
         if (FAILED(hr = IMFDXGIDeviceManager_OpenDeviceHandle(engine->device_manager, &engine->device_handle)))
         {
-            WARN("Failed to open a device handle, hr %#lx.\n", hr);
+            WARN("Failed to open a device handle, hr %#x.\n", hr);
             return hr;
         }
         hr = IMFDXGIDeviceManager_LockDevice(engine->device_manager, engine->device_handle, &IID_ID3D11Device,
@@ -340,7 +332,7 @@ static HRESULT media_engine_create_d3d11_video_frame_resources(struct media_engi
 
     if (FAILED(hr = ID3D11Device_CreateBuffer(device, &buffer_desc, &resource_data, &engine->video_frame.d3d11.vb)))
     {
-        WARN("Failed to create a vertex buffer, hr %#lx.\n", hr);
+        WARN("Failed to create a vertex buffer, hr %#x.\n", hr);
         goto failed;
     }
 
@@ -349,7 +341,7 @@ static HRESULT media_engine_create_d3d11_video_frame_resources(struct media_engi
 
     if (FAILED(hr = ID3D11Device_CreateBuffer(device, &buffer_desc, NULL, &engine->video_frame.d3d11.ps_cb)))
     {
-        WARN("Failed to create a buffer, hr %#lx.\n", hr);
+        WARN("Failed to create a buffer, hr %#x.\n", hr);
         goto failed;
     }
 
@@ -368,14 +360,14 @@ static HRESULT media_engine_create_d3d11_video_frame_resources(struct media_engi
 
     if (FAILED(hr = ID3D11Device_CreateTexture2D(device, &texture_desc, NULL, &engine->video_frame.d3d11.source)))
     {
-        WARN("Failed to create source texture, hr %#lx.\n", hr);
+        WARN("Failed to create source texture, hr %#x.\n", hr);
         goto failed;
     }
 
     if (FAILED(hr = ID3D11Device_CreateShaderResourceView(device, (ID3D11Resource *)engine->video_frame.d3d11.source,
             NULL, &engine->video_frame.d3d11.srv)))
     {
-        WARN("Failed to create SRV, hr %#lx.\n", hr);
+        WARN("Failed to create SRV, hr %#x.\n", hr);
         goto failed;
     }
 
@@ -388,7 +380,7 @@ static HRESULT media_engine_create_d3d11_video_frame_resources(struct media_engi
 
     if (FAILED(hr = ID3D11Device_CreateSamplerState(device, &sampler_desc, &engine->video_frame.d3d11.sampler)))
     {
-        WARN("Failed to create a sampler state, hr %#lx.\n", hr);
+        WARN("Failed to create a sampler state, hr %#x.\n", hr);
         goto failed;
     }
 
@@ -396,20 +388,20 @@ static HRESULT media_engine_create_d3d11_video_frame_resources(struct media_engi
     if (FAILED(hr = ID3D11Device_CreateInputLayout(device, layout_desc, ARRAY_SIZE(layout_desc), vs_code, sizeof(vs_code),
             &engine->video_frame.d3d11.input_layout)))
     {
-        WARN("Failed to create input layout, hr %#lx.\n", hr);
+        WARN("Failed to create input layout, hr %#x.\n", hr);
         goto failed;
     }
 
     /* Shaders */
     if (FAILED(hr = ID3D11Device_CreateVertexShader(device, vs_code, sizeof(vs_code), NULL, &engine->video_frame.d3d11.vs)))
     {
-        WARN("Failed to create the vertex shader, hr %#lx.\n", hr);
+        WARN("Failed to create the vertex shader, hr %#x.\n", hr);
         goto failed;
     }
 
     if (FAILED(hr = ID3D11Device_CreatePixelShader(device, ps_code, sizeof(ps_code), NULL, &engine->video_frame.d3d11.ps)))
     {
-        WARN("Failed to create the pixel shader, hr %#lx.\n", hr);
+        WARN("Failed to create the pixel shader, hr %#x.\n", hr);
         goto failed;
     }
 
@@ -474,7 +466,7 @@ static ULONG WINAPI media_error_AddRef(IMFMediaError *iface)
     struct media_error *me = impl_from_IMFMediaError(iface);
     ULONG refcount = InterlockedIncrement(&me->refcount);
 
-    TRACE("%p, refcount %lu.\n", iface, refcount);
+    TRACE("%p, refcount %u.\n", iface, refcount);
 
     return refcount;
 }
@@ -484,7 +476,7 @@ static ULONG WINAPI media_error_Release(IMFMediaError *iface)
     struct media_error *me = impl_from_IMFMediaError(iface);
     ULONG refcount = InterlockedDecrement(&me->refcount);
 
-    TRACE("%p, refcount %lu.\n", iface, refcount);
+    TRACE("%p, refcount %u.\n", iface, refcount);
 
     if (!refcount)
         free(me);
@@ -524,7 +516,7 @@ static HRESULT WINAPI media_error_SetExtendedErrorCode(IMFMediaError *iface, HRE
 {
     struct media_error *me = impl_from_IMFMediaError(iface);
 
-    TRACE("%p, %#lx.\n", iface, code);
+    TRACE("%p, %#x.\n", iface, code);
 
     me->extended_code = code;
 
@@ -581,7 +573,7 @@ static ULONG WINAPI time_range_AddRef(IMFMediaTimeRange *iface)
     struct time_range *range = impl_from_IMFMediaTimeRange(iface);
     ULONG refcount = InterlockedIncrement(&range->refcount);
 
-    TRACE("%p, refcount %lu.\n", iface, refcount);
+    TRACE("%p, refcount %u.\n", iface, refcount);
 
     return refcount;
 }
@@ -591,7 +583,7 @@ static ULONG WINAPI time_range_Release(IMFMediaTimeRange *iface)
     struct time_range *range = impl_from_IMFMediaTimeRange(iface);
     ULONG refcount = InterlockedDecrement(&range->refcount);
 
-    TRACE("%p, refcount %lu.\n", iface, refcount);
+    TRACE("%p, refcount %u.\n", iface, refcount);
 
     if (!refcount)
     {
@@ -615,7 +607,7 @@ static HRESULT WINAPI time_range_GetStart(IMFMediaTimeRange *iface, DWORD idx, d
 {
     struct time_range *range = impl_from_IMFMediaTimeRange(iface);
 
-    TRACE("%p, %lu, %p.\n", iface, idx, start);
+    TRACE("%p, %u, %p.\n", iface, idx, start);
 
     if (idx >= range->count)
         return E_INVALIDARG;
@@ -629,7 +621,7 @@ static HRESULT WINAPI time_range_GetEnd(IMFMediaTimeRange *iface, DWORD idx, dou
 {
     struct time_range *range = impl_from_IMFMediaTimeRange(iface);
 
-    TRACE("%p, %lu, %p.\n", iface, idx, end);
+    TRACE("%p, %u, %p.\n", iface, idx, end);
 
     if (idx >= range->count)
         return E_INVALIDARG;
@@ -658,35 +650,13 @@ static BOOL WINAPI time_range_ContainsTime(IMFMediaTimeRange *iface, double time
 static HRESULT WINAPI time_range_AddRange(IMFMediaTimeRange *iface, double start, double end)
 {
     struct time_range *range = impl_from_IMFMediaTimeRange(iface);
-    struct range *c;
-    size_t i;
 
     TRACE("%p, %.8e, %.8e.\n", iface, start, end);
 
-    for (i = 0; i < range->count; ++i)
+    if (range->count)
     {
-        c = &range->ranges[i];
-
-        /* New range is fully contained within existing one. */
-        if (c->start <= start && c->end >= end)
-            return S_OK;
-
-        /* New range fully contains existing one. */
-        if (c->start >= start && c->end <= end)
-        {
-            c->start = start;
-            c->end = end;
-            return S_OK;
-        }
-
-        /* Merge if ranges intersect. */
-        if ((start >= c->start && start <= c->end) ||
-                (end >= c->start && end <= c->end))
-        {
-            c->start = min(c->start, start);
-            c->end = max(c->end, end);
-            return S_OK;
-        }
+        FIXME("Range merging is not implemented.\n");
+        return E_NOTIMPL;
     }
 
     if (!mf_array_reserve((void **)&range->ranges, &range->capacity, range->count + 1, sizeof(*range->ranges)))
@@ -747,14 +717,9 @@ static void media_engine_set_flag(struct media_engine *engine, unsigned int mask
         engine->flags &= ~mask;
 }
 
-static inline struct media_engine *impl_from_IMFMediaEngineEx(IMFMediaEngineEx *iface)
+static inline struct media_engine *impl_from_IMFMediaEngine(IMFMediaEngine *iface)
 {
-    return CONTAINING_RECORD(iface, struct media_engine, IMFMediaEngineEx_iface);
-}
-
-static inline struct media_engine *impl_from_IMFGetService(IMFGetService *iface)
-{
-    return CONTAINING_RECORD(iface, struct media_engine, IMFGetService_iface);
+    return CONTAINING_RECORD(iface, struct media_engine, IMFMediaEngine_iface);
 }
 
 static struct media_engine *impl_from_session_events_IMFAsyncCallback(IMFAsyncCallback *iface)
@@ -819,7 +784,7 @@ static void media_engine_get_frame_size(struct media_engine *engine, IMFTopology
     IMFMediaTypeHandler_Release(handler);
     if (FAILED(hr))
     {
-        WARN("Failed to get current media type %#lx.\n", hr);
+        WARN("Failed to get current media type %#x.\n", hr);
         return;
     }
 
@@ -855,13 +820,13 @@ static HRESULT WINAPI media_engine_callback_QueryInterface(IMFAsyncCallback *ifa
 static ULONG WINAPI media_engine_session_events_AddRef(IMFAsyncCallback *iface)
 {
     struct media_engine *engine = impl_from_session_events_IMFAsyncCallback(iface);
-    return IMFMediaEngineEx_AddRef(&engine->IMFMediaEngineEx_iface);
+    return IMFMediaEngine_AddRef(&engine->IMFMediaEngine_iface);
 }
 
 static ULONG WINAPI media_engine_session_events_Release(IMFAsyncCallback *iface)
 {
     struct media_engine *engine = impl_from_session_events_IMFAsyncCallback(iface);
-    return IMFMediaEngineEx_Release(&engine->IMFMediaEngineEx_iface);
+    return IMFMediaEngine_Release(&engine->IMFMediaEngine_iface);
 }
 
 static HRESULT WINAPI media_engine_callback_GetParameters(IMFAsyncCallback *iface, DWORD *flags, DWORD *queue)
@@ -878,13 +843,13 @@ static HRESULT WINAPI media_engine_session_events_Invoke(IMFAsyncCallback *iface
 
     if (FAILED(hr = IMFMediaSession_EndGetEvent(engine->session, result, &event)))
     {
-        WARN("Failed to get session event, hr %#lx.\n", hr);
+        WARN("Failed to get session event, hr %#x.\n", hr);
         goto failed;
     }
 
     if (FAILED(hr = IMFMediaEvent_GetType(event, &event_type)))
     {
-        WARN("Failed to get event type, hr %#lx.\n", hr);
+        WARN("Failed to get event type, hr %#x.\n", hr);
         goto failed;
     }
 
@@ -960,7 +925,7 @@ failed:
         IMFMediaEvent_Release(event);
 
     if (FAILED(hr = IMFMediaSession_BeginGetEvent(engine->session, iface, NULL)))
-        WARN("Failed to subscribe to session events, hr %#lx.\n", hr);
+        WARN("Failed to subscribe to session events, hr %#x.\n", hr);
 
     return S_OK;
 }
@@ -977,13 +942,13 @@ static const IMFAsyncCallbackVtbl media_engine_session_events_vtbl =
 static ULONG WINAPI media_engine_load_handler_AddRef(IMFAsyncCallback *iface)
 {
     struct media_engine *engine = impl_from_load_handler_IMFAsyncCallback(iface);
-    return IMFMediaEngineEx_AddRef(&engine->IMFMediaEngineEx_iface);
+    return IMFMediaEngine_AddRef(&engine->IMFMediaEngine_iface);
 }
 
 static ULONG WINAPI media_engine_load_handler_Release(IMFAsyncCallback *iface)
 {
     struct media_engine *engine = impl_from_load_handler_IMFAsyncCallback(iface);
-    return IMFMediaEngineEx_Release(&engine->IMFMediaEngineEx_iface);
+    return IMFMediaEngine_Release(&engine->IMFMediaEngine_iface);
 }
 
 static HRESULT media_engine_create_source_node(IMFMediaSource *source, IMFPresentationDescriptor *pd, IMFStreamDescriptor *sd,
@@ -1076,35 +1041,22 @@ static HRESULT media_engine_create_video_renderer(struct media_engine *engine, I
     return hr;
 }
 
-static void media_engine_clear_presentation(struct media_engine *engine)
-{
-    if (engine->presentation.source)
-    {
-        IMFMediaSource_Shutdown(engine->presentation.source);
-        IMFMediaSource_Release(engine->presentation.source);
-    }
-    if (engine->presentation.pd)
-        IMFPresentationDescriptor_Release(engine->presentation.pd);
-    memset(&engine->presentation, 0, sizeof(engine->presentation));
-}
-
 static HRESULT media_engine_create_topology(struct media_engine *engine, IMFMediaSource *source)
 {
     IMFStreamDescriptor *sd_audio = NULL, *sd_video = NULL;
+    unsigned int stream_count = 0, i;
     IMFPresentationDescriptor *pd;
-    DWORD stream_count = 0, i;
     IMFTopology *topology;
     UINT64 duration;
     HRESULT hr;
 
     media_engine_release_video_frame_resources(engine);
-    media_engine_clear_presentation(engine);
 
     if (FAILED(hr = IMFMediaSource_CreatePresentationDescriptor(source, &pd)))
         return hr;
 
     if (FAILED(hr = IMFPresentationDescriptor_GetStreamDescriptorCount(pd, &stream_count)))
-        WARN("Failed to get stream count, hr %#lx.\n", hr);
+        WARN("Failed to get stream count, hr %#x.\n", hr);
 
     /* Enable first video stream and first audio stream. */
 
@@ -1142,8 +1094,6 @@ static HRESULT media_engine_create_topology(struct media_engine *engine, IMFMedi
 
             IMFMediaTypeHandler_Release(type_handler);
         }
-
-        IMFStreamDescriptor_Release(sd);
     }
 
     if (!sd_video && !sd_audio)
@@ -1152,11 +1102,6 @@ static HRESULT media_engine_create_topology(struct media_engine *engine, IMFMedi
         return E_UNEXPECTED;
     }
 
-    engine->presentation.source = source;
-    IMFMediaSource_AddRef(engine->presentation.source);
-    engine->presentation.pd = pd;
-    IMFPresentationDescriptor_AddRef(engine->presentation.pd);
-
     media_engine_set_flag(engine, FLAGS_ENGINE_HAS_VIDEO, !!sd_video);
     media_engine_set_flag(engine, FLAGS_ENGINE_HAS_AUDIO, !!sd_audio);
 
@@ -1174,16 +1119,13 @@ static HRESULT media_engine_create_topology(struct media_engine *engine, IMFMedi
         IMFTopologyNode *sar_node = NULL, *audio_src = NULL;
         IMFTopologyNode *grabber_node = NULL, *video_src = NULL;
 
-        if (engine->flags & MF_MEDIA_ENGINE_REAL_TIME_MODE)
-            IMFTopology_SetUINT32(topology, &MF_LOW_LATENCY, TRUE);
-
         if (sd_audio)
         {
             if (FAILED(hr = media_engine_create_source_node(source, pd, sd_audio, &audio_src)))
-                WARN("Failed to create audio source node, hr %#lx.\n", hr);
+                WARN("Failed to create audio source node, hr %#x.\n", hr);
 
             if (FAILED(hr = media_engine_create_audio_renderer(engine, &sar_node)))
-                WARN("Failed to create audio renderer node, hr %#lx.\n", hr);
+                WARN("Failed to create audio renderer node, hr %#x.\n", hr);
 
             if (sar_node && audio_src)
             {
@@ -1201,10 +1143,10 @@ static HRESULT media_engine_create_topology(struct media_engine *engine, IMFMedi
         if (SUCCEEDED(hr) && sd_video)
         {
             if (FAILED(hr = media_engine_create_source_node(source, pd, sd_video, &video_src)))
-                WARN("Failed to create video source node, hr %#lx.\n", hr);
+                WARN("Failed to create video source node, hr %#x.\n", hr);
 
             if (FAILED(hr = media_engine_create_video_renderer(engine, &grabber_node)))
-                WARN("Failed to create video grabber node, hr %#lx.\n", hr);
+                WARN("Failed to create video grabber node, hr %#x.\n", hr);
 
             if (grabber_node && video_src)
             {
@@ -1252,10 +1194,10 @@ static void media_engine_start_playback(struct media_engine *engine)
 static HRESULT WINAPI media_engine_load_handler_Invoke(IMFAsyncCallback *iface, IMFAsyncResult *result)
 {
     struct media_engine *engine = impl_from_load_handler_IMFAsyncCallback(iface);
-    IUnknown *object = NULL, *state;
     unsigned int start_playback;
     MF_OBJECT_TYPE obj_type;
     IMFMediaSource *source;
+    IUnknown *object = NULL;
     HRESULT hr;
 
     EnterCriticalSection(&engine->cs);
@@ -1266,16 +1208,8 @@ static HRESULT WINAPI media_engine_load_handler_Invoke(IMFAsyncCallback *iface,
     start_playback = engine->flags & FLAGS_ENGINE_PLAY_PENDING;
     media_engine_set_flag(engine, FLAGS_ENGINE_SOURCE_PENDING | FLAGS_ENGINE_PLAY_PENDING, FALSE);
 
-    if (SUCCEEDED(IMFAsyncResult_GetState(result, &state)))
-    {
-        hr = IMFSourceResolver_EndCreateObjectFromByteStream(engine->resolver, result, &obj_type, &object);
-        IUnknown_Release(state);
-    }
-    else
-        hr = IMFSourceResolver_EndCreateObjectFromURL(engine->resolver, result, &obj_type, &object);
-
-    if (FAILED(hr))
-        WARN("Failed to create source object, hr %#lx.\n", hr);
+    if (FAILED(hr = IMFSourceResolver_EndCreateObjectFromURL(engine->resolver, result, &obj_type, &object)))
+        WARN("Failed to create source object, hr %#x.\n", hr);
 
     if (object)
     {
@@ -1316,39 +1250,29 @@ static const IMFAsyncCallbackVtbl media_engine_load_handler_vtbl =
     media_engine_load_handler_Invoke,
 };
 
-static HRESULT WINAPI media_engine_QueryInterface(IMFMediaEngineEx *iface, REFIID riid, void **obj)
+static HRESULT WINAPI media_engine_QueryInterface(IMFMediaEngine *iface, REFIID riid, void **obj)
 {
-    struct media_engine *engine = impl_from_IMFMediaEngineEx(iface);
-
     TRACE("%p, %s, %p.\n", iface, debugstr_guid(riid), obj);
 
-    if (IsEqualIID(riid, &IID_IMFMediaEngineEx) ||
-        IsEqualIID(riid, &IID_IMFMediaEngine) ||
+    if (IsEqualIID(riid, &IID_IMFMediaEngine) ||
         IsEqualIID(riid, &IID_IUnknown))
     {
         *obj = iface;
-    }
-    else if (IsEqualIID(riid, &IID_IMFGetService))
-    {
-        *obj = &engine->IMFGetService_iface;
-    }
-    else
-    {
-        WARN("Unsupported interface %s.\n", debugstr_guid(riid));
-        *obj = NULL;
-        return E_NOINTERFACE;
+        IMFMediaEngine_AddRef(iface);
+        return S_OK;
     }
 
-    IUnknown_AddRef((IUnknown *)*obj);
-    return S_OK;
+    WARN("Unsupported interface %s.\n", debugstr_guid(riid));
+    *obj = NULL;
+    return E_NOINTERFACE;
 }
 
-static ULONG WINAPI media_engine_AddRef(IMFMediaEngineEx *iface)
+static ULONG WINAPI media_engine_AddRef(IMFMediaEngine *iface)
 {
-    struct media_engine *engine = impl_from_IMFMediaEngineEx(iface);
+    struct media_engine *engine = impl_from_IMFMediaEngine(iface);
     ULONG refcount = InterlockedIncrement(&engine->refcount);
 
-    TRACE("%p, refcount %lu.\n", iface, refcount);
+    TRACE("%p, refcount %u.\n", iface, refcount);
 
     return refcount;
 }
@@ -1366,7 +1290,6 @@ static void free_media_engine(struct media_engine *engine)
     if (engine->resolver)
         IMFSourceResolver_Release(engine->resolver);
     media_engine_release_video_frame_resources(engine);
-    media_engine_clear_presentation(engine);
     if (engine->device_manager)
     {
         IMFDXGIDeviceManager_CloseDeviceHandle(engine->device_manager, engine->device_handle);
@@ -1378,12 +1301,12 @@ static void free_media_engine(struct media_engine *engine)
     free(engine);
 }
 
-static ULONG WINAPI media_engine_Release(IMFMediaEngineEx *iface)
+static ULONG WINAPI media_engine_Release(IMFMediaEngine *iface)
 {
-    struct media_engine *engine = impl_from_IMFMediaEngineEx(iface);
+    struct media_engine *engine = impl_from_IMFMediaEngine(iface);
     ULONG refcount = InterlockedDecrement(&engine->refcount);
 
-    TRACE("%p, refcount %lu.\n", iface, refcount);
+    TRACE("%p, refcount %u.\n", iface, refcount);
 
     if (!refcount)
         free_media_engine(engine);
@@ -1391,9 +1314,9 @@ static ULONG WINAPI media_engine_Release(IMFMediaEngineEx *iface)
     return refcount;
 }
 
-static HRESULT WINAPI media_engine_GetError(IMFMediaEngineEx *iface, IMFMediaError **error)
+static HRESULT WINAPI media_engine_GetError(IMFMediaEngine *iface, IMFMediaError **error)
 {
-    struct media_engine *engine = impl_from_IMFMediaEngineEx(iface);
+    struct media_engine *engine = impl_from_IMFMediaEngine(iface);
     HRESULT hr = S_OK;
 
     TRACE("%p, %p.\n", iface, error);
@@ -1416,9 +1339,9 @@ static HRESULT WINAPI media_engine_GetError(IMFMediaEngineEx *iface, IMFMediaErr
     return hr;
 }
 
-static HRESULT WINAPI media_engine_SetErrorCode(IMFMediaEngineEx *iface, MF_MEDIA_ENGINE_ERR code)
+static HRESULT WINAPI media_engine_SetErrorCode(IMFMediaEngine *iface, MF_MEDIA_ENGINE_ERR code)
 {
-    struct media_engine *engine = impl_from_IMFMediaEngineEx(iface);
+    struct media_engine *engine = impl_from_IMFMediaEngine(iface);
     HRESULT hr = S_OK;
 
     TRACE("%p, %u.\n", iface, code);
@@ -1436,76 +1359,66 @@ static HRESULT WINAPI media_engine_SetErrorCode(IMFMediaEngineEx *iface, MF_MEDI
     return hr;
 }
 
-static HRESULT WINAPI media_engine_SetSourceElements(IMFMediaEngineEx *iface, IMFMediaEngineSrcElements *elements)
+static HRESULT WINAPI media_engine_SetSourceElements(IMFMediaEngine *iface, IMFMediaEngineSrcElements *elements)
 {
     FIXME("(%p, %p): stub.\n", iface, elements);
 
     return E_NOTIMPL;
 }
 
-static HRESULT media_engine_set_source(struct media_engine *engine, IMFByteStream *bytestream, BSTR url)
+static HRESULT WINAPI media_engine_SetSource(IMFMediaEngine *iface, BSTR url)
 {
-    IPropertyStore *props = NULL;
-    unsigned int flags;
+    struct media_engine *engine = impl_from_IMFMediaEngine(iface);
     HRESULT hr = S_OK;
 
-    SysFreeString(engine->current_source);
-    engine->current_source = NULL;
-    if (url)
-        engine->current_source = SysAllocString(url);
-
-    engine->ready_state = MF_MEDIA_ENGINE_READY_HAVE_NOTHING;
-
-    IMFMediaEngineNotify_EventNotify(engine->callback, MF_MEDIA_ENGINE_EVENT_PURGEQUEUEDEVENTS, 0, 0);
+    TRACE("%p, %s.\n", iface, debugstr_w(url));
 
-    engine->network_state = MF_MEDIA_ENGINE_NETWORK_NO_SOURCE;
+    EnterCriticalSection(&engine->cs);
 
-    if (url || bytestream)
+    if (engine->flags & FLAGS_ENGINE_SHUT_DOWN)
+        hr = MF_E_SHUTDOWN;
+    else
     {
-        flags = MF_RESOLUTION_MEDIASOURCE | MF_RESOLUTION_CONTENT_DOES_NOT_HAVE_TO_MATCH_EXTENSION_OR_MIME_TYPE;
-        if (engine->flags & MF_MEDIA_ENGINE_DISABLE_LOCAL_PLUGINS)
-            flags |= MF_RESOLUTION_DISABLE_LOCAL_PLUGINS;
+        SysFreeString(engine->current_source);
+        engine->current_source = NULL;
+        if (url)
+            engine->current_source = SysAllocString(url);
 
-        IMFAttributes_GetUnknown(engine->attributes, &MF_MEDIA_ENGINE_SOURCE_RESOLVER_CONFIG_STORE,
-                &IID_IPropertyStore, (void **)&props);
-        if (bytestream)
-            hr = IMFSourceResolver_BeginCreateObjectFromByteStream(engine->resolver, bytestream, url, flags,
-                    props, NULL, &engine->load_handler, (IUnknown *)bytestream);
-        else
-            hr = IMFSourceResolver_BeginCreateObjectFromURL(engine->resolver, url, flags, props, NULL,
-                    &engine->load_handler, NULL);
-        if (SUCCEEDED(hr))
-            media_engine_set_flag(engine, FLAGS_ENGINE_SOURCE_PENDING, TRUE);
+        engine->ready_state = MF_MEDIA_ENGINE_READY_HAVE_NOTHING;
 
-        if (props)
-            IPropertyStore_Release(props);
-    }
+        IMFMediaEngineNotify_EventNotify(engine->callback, MF_MEDIA_ENGINE_EVENT_PURGEQUEUEDEVENTS, 0, 0);
 
-    return hr;
-}
+        engine->network_state = MF_MEDIA_ENGINE_NETWORK_NO_SOURCE;
 
-static HRESULT WINAPI media_engine_SetSource(IMFMediaEngineEx *iface, BSTR url)
-{
-    struct media_engine *engine = impl_from_IMFMediaEngineEx(iface);
-    HRESULT hr;
+        if (url)
+        {
+            IPropertyStore *props = NULL;
+            unsigned int flags;
 
-    TRACE("%p, %s.\n", iface, debugstr_w(url));
+            flags = MF_RESOLUTION_MEDIASOURCE;
+            if (engine->flags & MF_MEDIA_ENGINE_DISABLE_LOCAL_PLUGINS)
+                flags |= MF_RESOLUTION_DISABLE_LOCAL_PLUGINS;
 
-    EnterCriticalSection(&engine->cs);
+            IMFAttributes_GetUnknown(engine->attributes, &MF_MEDIA_ENGINE_SOURCE_RESOLVER_CONFIG_STORE,
+                    &IID_IPropertyStore, (void **)&props);
+            hr = IMFSourceResolver_BeginCreateObjectFromURL(engine->resolver, url, flags, props, NULL,
+                    &engine->load_handler, NULL);
+            if (SUCCEEDED(hr))
+                media_engine_set_flag(engine, FLAGS_ENGINE_SOURCE_PENDING, TRUE);
 
-    if (engine->flags & FLAGS_ENGINE_SHUT_DOWN)
-        hr = MF_E_SHUTDOWN;
-    else
-        hr = media_engine_set_source(engine, NULL, url);
+            if (props)
+                IPropertyStore_Release(props);
+        }
+    }
 
     LeaveCriticalSection(&engine->cs);
 
     return hr;
 }
 
-static HRESULT WINAPI media_engine_GetCurrentSource(IMFMediaEngineEx *iface, BSTR *url)
+static HRESULT WINAPI media_engine_GetCurrentSource(IMFMediaEngine *iface, BSTR *url)
 {
-    struct media_engine *engine = impl_from_IMFMediaEngineEx(iface);
+    struct media_engine *engine = impl_from_IMFMediaEngine(iface);
     HRESULT hr = S_OK;
 
     TRACE("%p, %p.\n", iface, url);
@@ -1513,32 +1426,28 @@ static HRESULT WINAPI media_engine_GetCurrentSource(IMFMediaEngineEx *iface, BST
     *url = NULL;
 
     EnterCriticalSection(&engine->cs);
-
-    if (engine->flags & FLAGS_ENGINE_SHUT_DOWN)
-        hr = MF_E_SHUTDOWN;
     if (engine->current_source)
     {
         if (!(*url = SysAllocString(engine->current_source)))
             hr = E_OUTOFMEMORY;
     }
-
     LeaveCriticalSection(&engine->cs);
 
     return hr;
 }
 
-static USHORT WINAPI media_engine_GetNetworkState(IMFMediaEngineEx *iface)
+static USHORT WINAPI media_engine_GetNetworkState(IMFMediaEngine *iface)
 {
-    struct media_engine *engine = impl_from_IMFMediaEngineEx(iface);
+    struct media_engine *engine = impl_from_IMFMediaEngine(iface);
 
     TRACE("%p.\n", iface);
 
     return engine->network_state;
 }
 
-static MF_MEDIA_ENGINE_PRELOAD WINAPI media_engine_GetPreload(IMFMediaEngineEx *iface)
+static MF_MEDIA_ENGINE_PRELOAD WINAPI media_engine_GetPreload(IMFMediaEngine *iface)
 {
-    struct media_engine *engine = impl_from_IMFMediaEngineEx(iface);
+    struct media_engine *engine = impl_from_IMFMediaEngine(iface);
     MF_MEDIA_ENGINE_PRELOAD preload;
 
     TRACE("%p.\n", iface);
@@ -1550,9 +1459,9 @@ static MF_MEDIA_ENGINE_PRELOAD WINAPI media_engine_GetPreload(IMFMediaEngineEx *
     return preload;
 }
 
-static HRESULT WINAPI media_engine_SetPreload(IMFMediaEngineEx *iface, MF_MEDIA_ENGINE_PRELOAD preload)
+static HRESULT WINAPI media_engine_SetPreload(IMFMediaEngine *iface, MF_MEDIA_ENGINE_PRELOAD preload)
 {
-    struct media_engine *engine = impl_from_IMFMediaEngineEx(iface);
+    struct media_engine *engine = impl_from_IMFMediaEngine(iface);
 
     TRACE("%p, %d.\n", iface, preload);
 
@@ -1563,9 +1472,9 @@ static HRESULT WINAPI media_engine_SetPreload(IMFMediaEngineEx *iface, MF_MEDIA_
     return S_OK;
 }
 
-static HRESULT WINAPI media_engine_GetBuffered(IMFMediaEngineEx *iface, IMFMediaTimeRange **range)
+static HRESULT WINAPI media_engine_GetBuffered(IMFMediaEngine *iface, IMFMediaTimeRange **range)
 {
-    struct media_engine *engine = impl_from_IMFMediaEngineEx(iface);
+    struct media_engine *engine = impl_from_IMFMediaEngine(iface);
     HRESULT hr;
 
     TRACE("%p, %p.\n", iface, range);
@@ -1574,54 +1483,30 @@ static HRESULT WINAPI media_engine_GetBuffered(IMFMediaEngineEx *iface, IMFMedia
         return hr;
 
     EnterCriticalSection(&engine->cs);
-
-    if (engine->flags & FLAGS_ENGINE_SHUT_DOWN)
-        hr = MF_E_SHUTDOWN;
-    else if (!isnan(engine->duration))
+    if (!isnan(engine->duration))
         hr = IMFMediaTimeRange_AddRange(*range, 0.0, engine->duration);
-
     LeaveCriticalSection(&engine->cs);
 
     return hr;
 }
 
-static HRESULT WINAPI media_engine_Load(IMFMediaEngineEx *iface)
+static HRESULT WINAPI media_engine_Load(IMFMediaEngine *iface)
 {
-    struct media_engine *engine = impl_from_IMFMediaEngineEx(iface);
-    HRESULT hr = E_NOTIMPL;
-
     FIXME("(%p): stub.\n", iface);
 
-    EnterCriticalSection(&engine->cs);
-
-    if (engine->flags & FLAGS_ENGINE_SHUT_DOWN)
-        hr = MF_E_SHUTDOWN;
-
-    LeaveCriticalSection(&engine->cs);
-
-    return hr;
+    return E_NOTIMPL;
 }
 
-static HRESULT WINAPI media_engine_CanPlayType(IMFMediaEngineEx *iface, BSTR type, MF_MEDIA_ENGINE_CANPLAY *answer)
+static HRESULT WINAPI media_engine_CanPlayType(IMFMediaEngine *iface, BSTR type, MF_MEDIA_ENGINE_CANPLAY *answer)
 {
-    struct media_engine *engine = impl_from_IMFMediaEngineEx(iface);
-    HRESULT hr = E_NOTIMPL;
-
     FIXME("(%p, %s, %p): stub.\n", iface, debugstr_w(type), answer);
 
-    EnterCriticalSection(&engine->cs);
-
-    if (engine->flags & FLAGS_ENGINE_SHUT_DOWN)
-        hr = MF_E_SHUTDOWN;
-
-    LeaveCriticalSection(&engine->cs);
-
-    return hr;
+    return E_NOTIMPL;
 }
 
-static USHORT WINAPI media_engine_GetReadyState(IMFMediaEngineEx *iface)
+static USHORT WINAPI media_engine_GetReadyState(IMFMediaEngine *iface)
 {
-    struct media_engine *engine = impl_from_IMFMediaEngineEx(iface);
+    struct media_engine *engine = impl_from_IMFMediaEngine(iface);
     unsigned short state;
 
     TRACE("%p.\n", iface);
@@ -1633,16 +1518,16 @@ static USHORT WINAPI media_engine_GetReadyState(IMFMediaEngineEx *iface)
     return state;
 }
 
-static BOOL WINAPI media_engine_IsSeeking(IMFMediaEngineEx *iface)
+static BOOL WINAPI media_engine_IsSeeking(IMFMediaEngine *iface)
 {
     FIXME("(%p): stub.\n", iface);
 
     return FALSE;
 }
 
-static double WINAPI media_engine_GetCurrentTime(IMFMediaEngineEx *iface)
+static double WINAPI media_engine_GetCurrentTime(IMFMediaEngine *iface)
 {
-    struct media_engine *engine = impl_from_IMFMediaEngineEx(iface);
+    struct media_engine *engine = impl_from_IMFMediaEngine(iface);
     double ret = 0.0;
     MFTIME clocktime;
 
@@ -1662,33 +1547,23 @@ static double WINAPI media_engine_GetCurrentTime(IMFMediaEngineEx *iface)
     return ret;
 }
 
-static HRESULT WINAPI media_engine_SetCurrentTime(IMFMediaEngineEx *iface, double time)
+static HRESULT WINAPI media_engine_SetCurrentTime(IMFMediaEngine *iface, double time)
 {
-    struct media_engine *engine = impl_from_IMFMediaEngineEx(iface);
-    HRESULT hr = E_NOTIMPL;
-
     FIXME("(%p, %f): stub.\n", iface, time);
 
-    EnterCriticalSection(&engine->cs);
-
-    if (engine->flags & FLAGS_ENGINE_SHUT_DOWN)
-        hr = MF_E_SHUTDOWN;
-
-    LeaveCriticalSection(&engine->cs);
-
-    return hr;
+    return E_NOTIMPL;
 }
 
-static double WINAPI media_engine_GetStartTime(IMFMediaEngineEx *iface)
+static double WINAPI media_engine_GetStartTime(IMFMediaEngine *iface)
 {
     FIXME("(%p): stub.\n", iface);
 
     return 0.0;
 }
 
-static double WINAPI media_engine_GetDuration(IMFMediaEngineEx *iface)
+static double WINAPI media_engine_GetDuration(IMFMediaEngine *iface)
 {
-    struct media_engine *engine = impl_from_IMFMediaEngineEx(iface);
+    struct media_engine *engine = impl_from_IMFMediaEngine(iface);
     double value;
 
     TRACE("%p.\n", iface);
@@ -1700,9 +1575,9 @@ static double WINAPI media_engine_GetDuration(IMFMediaEngineEx *iface)
     return value;
 }
 
-static BOOL WINAPI media_engine_IsPaused(IMFMediaEngineEx *iface)
+static BOOL WINAPI media_engine_IsPaused(IMFMediaEngine *iface)
 {
-    struct media_engine *engine = impl_from_IMFMediaEngineEx(iface);
+    struct media_engine *engine = impl_from_IMFMediaEngine(iface);
     BOOL value;
 
     TRACE("%p.\n", iface);
@@ -1714,9 +1589,9 @@ static BOOL WINAPI media_engine_IsPaused(IMFMediaEngineEx *iface)
     return value;
 }
 
-static double WINAPI media_engine_GetDefaultPlaybackRate(IMFMediaEngineEx *iface)
+static double WINAPI media_engine_GetDefaultPlaybackRate(IMFMediaEngine *iface)
 {
-    struct media_engine *engine = impl_from_IMFMediaEngineEx(iface);
+    struct media_engine *engine = impl_from_IMFMediaEngine(iface);
     double rate;
 
     TRACE("%p.\n", iface);
@@ -1728,9 +1603,9 @@ static double WINAPI media_engine_GetDefaultPlaybackRate(IMFMediaEngineEx *iface
     return rate;
 }
 
-static HRESULT WINAPI media_engine_SetDefaultPlaybackRate(IMFMediaEngineEx *iface, double rate)
+static HRESULT WINAPI media_engine_SetDefaultPlaybackRate(IMFMediaEngine *iface, double rate)
 {
-    struct media_engine *engine = impl_from_IMFMediaEngineEx(iface);
+    struct media_engine *engine = impl_from_IMFMediaEngine(iface);
     HRESULT hr = S_OK;
 
     TRACE("%p, %f.\n", iface, rate);
@@ -1748,9 +1623,9 @@ static HRESULT WINAPI media_engine_SetDefaultPlaybackRate(IMFMediaEngineEx *ifac
     return hr;
 }
 
-static double WINAPI media_engine_GetPlaybackRate(IMFMediaEngineEx *iface)
+static double WINAPI media_engine_GetPlaybackRate(IMFMediaEngine *iface)
 {
-    struct media_engine *engine = impl_from_IMFMediaEngineEx(iface);
+    struct media_engine *engine = impl_from_IMFMediaEngine(iface);
     double rate;
 
     TRACE("%p.\n", iface);
@@ -1762,9 +1637,9 @@ static double WINAPI media_engine_GetPlaybackRate(IMFMediaEngineEx *iface)
     return rate;
 }
 
-static HRESULT WINAPI media_engine_SetPlaybackRate(IMFMediaEngineEx *iface, double rate)
+static HRESULT WINAPI media_engine_SetPlaybackRate(IMFMediaEngine *iface, double rate)
 {
-    struct media_engine *engine = impl_from_IMFMediaEngineEx(iface);
+    struct media_engine *engine = impl_from_IMFMediaEngine(iface);
     HRESULT hr = S_OK;
 
     TRACE("%p, %f.\n", iface, rate);
@@ -1782,43 +1657,23 @@ static HRESULT WINAPI media_engine_SetPlaybackRate(IMFMediaEngineEx *iface, doub
     return hr;
 }
 
-static HRESULT WINAPI media_engine_GetPlayed(IMFMediaEngineEx *iface, IMFMediaTimeRange **played)
+static HRESULT WINAPI media_engine_GetPlayed(IMFMediaEngine *iface, IMFMediaTimeRange **played)
 {
-    struct media_engine *engine = impl_from_IMFMediaEngineEx(iface);
-    HRESULT hr = E_NOTIMPL;
-
     FIXME("(%p, %p): stub.\n", iface, played);
 
-    EnterCriticalSection(&engine->cs);
-
-    if (engine->flags & FLAGS_ENGINE_SHUT_DOWN)
-        hr = MF_E_SHUTDOWN;
-
-    LeaveCriticalSection(&engine->cs);
-
-    return hr;
+    return E_NOTIMPL;
 }
 
-static HRESULT WINAPI media_engine_GetSeekable(IMFMediaEngineEx *iface, IMFMediaTimeRange **seekable)
+static HRESULT WINAPI media_engine_GetSeekable(IMFMediaEngine *iface, IMFMediaTimeRange **seekable)
 {
-    struct media_engine *engine = impl_from_IMFMediaEngineEx(iface);
-    HRESULT hr = E_NOTIMPL;
-
     FIXME("(%p, %p): stub.\n", iface, seekable);
 
-    EnterCriticalSection(&engine->cs);
-
-    if (engine->flags & FLAGS_ENGINE_SHUT_DOWN)
-        hr = MF_E_SHUTDOWN;
-
-    LeaveCriticalSection(&engine->cs);
-
-    return hr;
+    return E_NOTIMPL;
 }
 
-static BOOL WINAPI media_engine_IsEnded(IMFMediaEngineEx *iface)
+static BOOL WINAPI media_engine_IsEnded(IMFMediaEngine *iface)
 {
-    struct media_engine *engine = impl_from_IMFMediaEngineEx(iface);
+    struct media_engine *engine = impl_from_IMFMediaEngine(iface);
     BOOL value;
 
     TRACE("%p.\n", iface);
@@ -1830,9 +1685,9 @@ static BOOL WINAPI media_engine_IsEnded(IMFMediaEngineEx *iface)
     return value;
 }
 
-static BOOL WINAPI media_engine_GetAutoPlay(IMFMediaEngineEx *iface)
+static BOOL WINAPI media_engine_GetAutoPlay(IMFMediaEngine *iface)
 {
-    struct media_engine *engine = impl_from_IMFMediaEngineEx(iface);
+    struct media_engine *engine = impl_from_IMFMediaEngine(iface);
     BOOL value;
 
     TRACE("%p.\n", iface);
@@ -1844,9 +1699,9 @@ static BOOL WINAPI media_engine_GetAutoPlay(IMFMediaEngineEx *iface)
     return value;
 }
 
-static HRESULT WINAPI media_engine_SetAutoPlay(IMFMediaEngineEx *iface, BOOL autoplay)
+static HRESULT WINAPI media_engine_SetAutoPlay(IMFMediaEngine *iface, BOOL autoplay)
 {
-    struct media_engine *engine = impl_from_IMFMediaEngineEx(iface);
+    struct media_engine *engine = impl_from_IMFMediaEngine(iface);
 
     FIXME("(%p, %d): stub.\n", iface, autoplay);
 
@@ -1857,9 +1712,9 @@ static HRESULT WINAPI media_engine_SetAutoPlay(IMFMediaEngineEx *iface, BOOL aut
     return S_OK;
 }
 
-static BOOL WINAPI media_engine_GetLoop(IMFMediaEngineEx *iface)
+static BOOL WINAPI media_engine_GetLoop(IMFMediaEngine *iface)
 {
-    struct media_engine *engine = impl_from_IMFMediaEngineEx(iface);
+    struct media_engine *engine = impl_from_IMFMediaEngine(iface);
     BOOL value;
 
     TRACE("%p.\n", iface);
@@ -1871,9 +1726,9 @@ static BOOL WINAPI media_engine_GetLoop(IMFMediaEngineEx *iface)
     return value;
 }
 
-static HRESULT WINAPI media_engine_SetLoop(IMFMediaEngineEx *iface, BOOL loop)
+static HRESULT WINAPI media_engine_SetLoop(IMFMediaEngine *iface, BOOL loop)
 {
-    struct media_engine *engine = impl_from_IMFMediaEngineEx(iface);
+    struct media_engine *engine = impl_from_IMFMediaEngine(iface);
 
     FIXME("(%p, %d): stub.\n", iface, loop);
 
@@ -1884,75 +1739,63 @@ static HRESULT WINAPI media_engine_SetLoop(IMFMediaEngineEx *iface, BOOL loop)
     return S_OK;
 }
 
-static HRESULT WINAPI media_engine_Play(IMFMediaEngineEx *iface)
+static HRESULT WINAPI media_engine_Play(IMFMediaEngine *iface)
 {
-    struct media_engine *engine = impl_from_IMFMediaEngineEx(iface);
-    HRESULT hr = S_OK;
+    struct media_engine *engine = impl_from_IMFMediaEngine(iface);
 
     TRACE("%p.\n", iface);
 
     EnterCriticalSection(&engine->cs);
 
-    if (engine->flags & FLAGS_ENGINE_SHUT_DOWN)
-        hr = MF_E_SHUTDOWN;
-    else
-    {
-        IMFMediaEngineNotify_EventNotify(engine->callback, MF_MEDIA_ENGINE_EVENT_PURGEQUEUEDEVENTS, 0, 0);
-
-        if (!(engine->flags & FLAGS_ENGINE_WAITING))
-        {
-            media_engine_set_flag(engine, FLAGS_ENGINE_PAUSED | FLAGS_ENGINE_IS_ENDED, FALSE);
-            IMFMediaEngineNotify_EventNotify(engine->callback, MF_MEDIA_ENGINE_EVENT_PLAY, 0, 0);
+    IMFMediaEngineNotify_EventNotify(engine->callback, MF_MEDIA_ENGINE_EVENT_PURGEQUEUEDEVENTS, 0, 0);
 
-            if (!(engine->flags & FLAGS_ENGINE_SOURCE_PENDING))
-                media_engine_start_playback(engine);
-            else
-                media_engine_set_flag(engine, FLAGS_ENGINE_PLAY_PENDING, TRUE);
+    if (!(engine->flags & FLAGS_ENGINE_WAITING))
+    {
+        media_engine_set_flag(engine, FLAGS_ENGINE_PAUSED | FLAGS_ENGINE_IS_ENDED, FALSE);
+        IMFMediaEngineNotify_EventNotify(engine->callback, MF_MEDIA_ENGINE_EVENT_PLAY, 0, 0);
 
-            media_engine_set_flag(engine, FLAGS_ENGINE_WAITING, TRUE);
-        }
+        if (!(engine->flags & FLAGS_ENGINE_SOURCE_PENDING))
+            media_engine_start_playback(engine);
+        else
+            media_engine_set_flag(engine, FLAGS_ENGINE_PLAY_PENDING, TRUE);
 
-        IMFMediaEngineNotify_EventNotify(engine->callback, MF_MEDIA_ENGINE_EVENT_WAITING, 0, 0);
+        media_engine_set_flag(engine, FLAGS_ENGINE_WAITING, TRUE);
     }
 
+    IMFMediaEngineNotify_EventNotify(engine->callback, MF_MEDIA_ENGINE_EVENT_WAITING, 0, 0);
+
     LeaveCriticalSection(&engine->cs);
 
-    return hr;
+    return S_OK;
 }
 
-static HRESULT WINAPI media_engine_Pause(IMFMediaEngineEx *iface)
+static HRESULT WINAPI media_engine_Pause(IMFMediaEngine *iface)
 {
-    struct media_engine *engine = impl_from_IMFMediaEngineEx(iface);
-    HRESULT hr = S_OK;
+    struct media_engine *engine = impl_from_IMFMediaEngine(iface);
 
     TRACE("%p.\n", iface);
 
     EnterCriticalSection(&engine->cs);
 
-    if (engine->flags & FLAGS_ENGINE_SHUT_DOWN)
-        hr = MF_E_SHUTDOWN;
-    else
+    if (!(engine->flags & FLAGS_ENGINE_PAUSED))
     {
-        if (!(engine->flags & FLAGS_ENGINE_PAUSED))
-        {
-            media_engine_set_flag(engine, FLAGS_ENGINE_WAITING | FLAGS_ENGINE_IS_ENDED, FALSE);
-            media_engine_set_flag(engine, FLAGS_ENGINE_PAUSED, TRUE);
-
-            IMFMediaEngineNotify_EventNotify(engine->callback, MF_MEDIA_ENGINE_EVENT_TIMEUPDATE, 0, 0);
-            IMFMediaEngineNotify_EventNotify(engine->callback, MF_MEDIA_ENGINE_EVENT_PAUSE, 0, 0);
-        }
+        media_engine_set_flag(engine, FLAGS_ENGINE_WAITING | FLAGS_ENGINE_IS_ENDED, FALSE);
+        media_engine_set_flag(engine, FLAGS_ENGINE_PAUSED, TRUE);
 
-        IMFMediaEngineNotify_EventNotify(engine->callback, MF_MEDIA_ENGINE_EVENT_PURGEQUEUEDEVENTS, 0, 0);
+        IMFMediaEngineNotify_EventNotify(engine->callback, MF_MEDIA_ENGINE_EVENT_TIMEUPDATE, 0, 0);
+        IMFMediaEngineNotify_EventNotify(engine->callback, MF_MEDIA_ENGINE_EVENT_PAUSE, 0, 0);
     }
 
+    IMFMediaEngineNotify_EventNotify(engine->callback, MF_MEDIA_ENGINE_EVENT_PURGEQUEUEDEVENTS, 0, 0);
+
     LeaveCriticalSection(&engine->cs);
 
-    return hr;
+    return S_OK;
 }
 
-static BOOL WINAPI media_engine_GetMuted(IMFMediaEngineEx *iface)
+static BOOL WINAPI media_engine_GetMuted(IMFMediaEngine *iface)
 {
-    struct media_engine *engine = impl_from_IMFMediaEngineEx(iface);
+    struct media_engine *engine = impl_from_IMFMediaEngine(iface);
     BOOL ret;
 
     TRACE("%p.\n", iface);
@@ -1964,9 +1807,9 @@ static BOOL WINAPI media_engine_GetMuted(IMFMediaEngineEx *iface)
     return ret;
 }
 
-static HRESULT WINAPI media_engine_SetMuted(IMFMediaEngineEx *iface, BOOL muted)
+static HRESULT WINAPI media_engine_SetMuted(IMFMediaEngine *iface, BOOL muted)
 {
-    struct media_engine *engine = impl_from_IMFMediaEngineEx(iface);
+    struct media_engine *engine = impl_from_IMFMediaEngine(iface);
     HRESULT hr = S_OK;
 
     TRACE("%p, %d.\n", iface, muted);
@@ -1984,9 +1827,9 @@ static HRESULT WINAPI media_engine_SetMuted(IMFMediaEngineEx *iface, BOOL muted)
     return hr;
 }
 
-static double WINAPI media_engine_GetVolume(IMFMediaEngineEx *iface)
+static double WINAPI media_engine_GetVolume(IMFMediaEngine *iface)
 {
-    struct media_engine *engine = impl_from_IMFMediaEngineEx(iface);
+    struct media_engine *engine = impl_from_IMFMediaEngine(iface);
     double volume;
 
     TRACE("%p.\n", iface);
@@ -1998,9 +1841,9 @@ static double WINAPI media_engine_GetVolume(IMFMediaEngineEx *iface)
     return volume;
 }
 
-static HRESULT WINAPI media_engine_SetVolume(IMFMediaEngineEx *iface, double volume)
+static HRESULT WINAPI media_engine_SetVolume(IMFMediaEngine *iface, double volume)
 {
-    struct media_engine *engine = impl_from_IMFMediaEngineEx(iface);
+    struct media_engine *engine = impl_from_IMFMediaEngine(iface);
     HRESULT hr = S_OK;
 
     TRACE("%p, %f.\n", iface, volume);
@@ -2018,9 +1861,9 @@ static HRESULT WINAPI media_engine_SetVolume(IMFMediaEngineEx *iface, double vol
     return hr;
 }
 
-static BOOL WINAPI media_engine_HasVideo(IMFMediaEngineEx *iface)
+static BOOL WINAPI media_engine_HasVideo(IMFMediaEngine *iface)
 {
-    struct media_engine *engine = impl_from_IMFMediaEngineEx(iface);
+    struct media_engine *engine = impl_from_IMFMediaEngine(iface);
     BOOL value;
 
     TRACE("%p.\n", iface);
@@ -2032,9 +1875,9 @@ static BOOL WINAPI media_engine_HasVideo(IMFMediaEngineEx *iface)
     return value;
 }
 
-static BOOL WINAPI media_engine_HasAudio(IMFMediaEngineEx *iface)
+static BOOL WINAPI media_engine_HasAudio(IMFMediaEngine *iface)
 {
-    struct media_engine *engine = impl_from_IMFMediaEngineEx(iface);
+    struct media_engine *engine = impl_from_IMFMediaEngine(iface);
     BOOL value;
 
     TRACE("%p.\n", iface);
@@ -2046,9 +1889,9 @@ static BOOL WINAPI media_engine_HasAudio(IMFMediaEngineEx *iface)
     return value;
 }
 
-static HRESULT WINAPI media_engine_GetNativeVideoSize(IMFMediaEngineEx *iface, DWORD *cx, DWORD *cy)
+static HRESULT WINAPI media_engine_GetNativeVideoSize(IMFMediaEngine *iface, DWORD *cx, DWORD *cy)
 {
-    struct media_engine *engine = impl_from_IMFMediaEngineEx(iface);
+    struct media_engine *engine = impl_from_IMFMediaEngine(iface);
     HRESULT hr = S_OK;
 
     TRACE("%p, %p, %p.\n", iface, cx, cy);
@@ -2073,9 +1916,9 @@ static HRESULT WINAPI media_engine_GetNativeVideoSize(IMFMediaEngineEx *iface, D
     return hr;
 }
 
-static HRESULT WINAPI media_engine_GetVideoAspectRatio(IMFMediaEngineEx *iface, DWORD *cx, DWORD *cy)
+static HRESULT WINAPI media_engine_GetVideoAspectRatio(IMFMediaEngine *iface, DWORD *cx, DWORD *cy)
 {
-    struct media_engine *engine = impl_from_IMFMediaEngineEx(iface);
+    struct media_engine *engine = impl_from_IMFMediaEngine(iface);
     HRESULT hr = S_OK;
 
     TRACE("%p, %p, %p.\n", iface, cx, cy);
@@ -2100,9 +1943,9 @@ static HRESULT WINAPI media_engine_GetVideoAspectRatio(IMFMediaEngineEx *iface,
     return hr;
 }
 
-static HRESULT WINAPI media_engine_Shutdown(IMFMediaEngineEx *iface)
+static HRESULT WINAPI media_engine_Shutdown(IMFMediaEngine *iface)
 {
-    struct media_engine *engine = impl_from_IMFMediaEngineEx(iface);
+    struct media_engine *engine = impl_from_IMFMediaEngine(iface);
     HRESULT hr = S_OK;
 
     FIXME("(%p): stub.\n", iface);
@@ -2113,7 +1956,6 @@ static HRESULT WINAPI media_engine_Shutdown(IMFMediaEngineEx *iface)
     else
     {
         media_engine_set_flag(engine, FLAGS_ENGINE_SHUT_DOWN, TRUE);
-        media_engine_clear_presentation(engine);
         IMFMediaSession_Shutdown(engine->session);
     }
     LeaveCriticalSection(&engine->cs);
@@ -2215,7 +2057,7 @@ static HRESULT media_engine_transfer_to_d3d11_texture(struct media_engine *engin
 
     if (FAILED(hr = media_engine_create_d3d11_video_frame_resources(engine, device)))
     {
-        WARN("Failed to create d3d resources, hr %#lx.\n", hr);
+        WARN("Failed to create d3d resources, hr %#x.\n", hr);
         goto done;
     }
 
@@ -2234,7 +2076,7 @@ static HRESULT media_engine_transfer_to_d3d11_texture(struct media_engine *engin
 
     if (FAILED(hr = ID3D11Device_CreateRenderTargetView(device, (ID3D11Resource *)texture, NULL, &rtv)))
     {
-        WARN("Failed to create an rtv, hr %#lx.\n", hr);
+        WARN("Failed to create an rtv, hr %#x.\n", hr);
         goto done;
     }
 
@@ -2343,10 +2185,10 @@ done:
     return hr;
 }
 
-static HRESULT WINAPI media_engine_TransferVideoFrame(IMFMediaEngineEx *iface, IUnknown *surface,
+static HRESULT WINAPI media_engine_TransferVideoFrame(IMFMediaEngine *iface, IUnknown *surface,
         const MFVideoNormalizedRect *src_rect, const RECT *dst_rect, const MFARGB *color)
 {
-    struct media_engine *engine = impl_from_IMFMediaEngineEx(iface);
+    struct media_engine *engine = impl_from_IMFMediaEngine(iface);
     ID3D11Texture2D *texture;
     HRESULT hr = E_NOINTERFACE;
 
@@ -2371,9 +2213,9 @@ static HRESULT WINAPI media_engine_TransferVideoFrame(IMFMediaEngineEx *iface, I
     return hr;
 }
 
-static HRESULT WINAPI media_engine_OnVideoStreamTick(IMFMediaEngineEx *iface, LONGLONG *pts)
+static HRESULT WINAPI media_engine_OnVideoStreamTick(IMFMediaEngine *iface, LONGLONG *pts)
 {
-    struct media_engine *engine = impl_from_IMFMediaEngineEx(iface);
+    struct media_engine *engine = impl_from_IMFMediaEngine(iface);
     HRESULT hr;
 
     TRACE("%p, %p.\n", iface, pts);
@@ -2395,390 +2237,7 @@ static HRESULT WINAPI media_engine_OnVideoStreamTick(IMFMediaEngineEx *iface, LO
     return hr;
 }
 
-static HRESULT WINAPI media_engine_SetSourceFromByteStream(IMFMediaEngineEx *iface, IMFByteStream *bytestream, BSTR url)
-{
-    struct media_engine *engine = impl_from_IMFMediaEngineEx(iface);
-    HRESULT hr;
-
-    TRACE("%p, %p, %s.\n", iface, bytestream, debugstr_w(url));
-
-    EnterCriticalSection(&engine->cs);
-
-    if (engine->flags & FLAGS_ENGINE_SHUT_DOWN)
-        hr = MF_E_SHUTDOWN;
-    else if (!bytestream || !url)
-        hr = E_POINTER;
-    else
-        hr = media_engine_set_source(engine, bytestream, url);
-
-    LeaveCriticalSection(&engine->cs);
-
-    return hr;
-}
-
-static HRESULT WINAPI media_engine_GetStatistics(IMFMediaEngineEx *iface, MF_MEDIA_ENGINE_STATISTIC stat_id, PROPVARIANT *stat)
-{
-    FIXME("%p, %x, %p stub.\n", iface, stat_id, stat);
-
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI media_engine_UpdateVideoStream(IMFMediaEngineEx *iface, const MFVideoNormalizedRect *src,
-        const RECT *dst, const MFARGB *border_color)
-{
-    FIXME("%p, %p, %p, %p stub.\n", iface, src, dst, border_color);
-
-    return E_NOTIMPL;
-}
-
-static double WINAPI media_engine_GetBalance(IMFMediaEngineEx *iface)
-{
-    FIXME("%p stub.\n", iface);
-
-    return 0.0;
-}
-
-static HRESULT WINAPI media_engine_SetBalance(IMFMediaEngineEx *iface, double balance)
-{
-    FIXME("%p, %f stub.\n", iface, balance);
-
-    return E_NOTIMPL;
-}
-
-static BOOL WINAPI media_engine_IsPlaybackRateSupported(IMFMediaEngineEx *iface, double rate)
-{
-    FIXME("%p, %f stub.\n", iface, rate);
-
-    return FALSE;
-}
-
-static HRESULT WINAPI media_engine_FrameStep(IMFMediaEngineEx *iface, BOOL forward)
-{
-    FIXME("%p, %d stub.\n", iface, forward);
-
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI media_engine_GetResourceCharacteristics(IMFMediaEngineEx *iface, DWORD *flags)
-{
-    struct media_engine *engine = impl_from_IMFMediaEngineEx(iface);
-    HRESULT hr = E_FAIL;
-
-    TRACE("%p, %p.\n", iface, flags);
-
-    EnterCriticalSection(&engine->cs);
-    if (engine->flags & FLAGS_ENGINE_SHUT_DOWN)
-        hr = MF_E_SHUTDOWN;
-    else if (engine->presentation.source)
-        hr = IMFMediaSource_GetCharacteristics(engine->presentation.source, flags);
-    LeaveCriticalSection(&engine->cs);
-
-    return hr;
-}
-
-static HRESULT WINAPI media_engine_GetPresentationAttribute(IMFMediaEngineEx *iface, REFGUID attribute,
-        PROPVARIANT *value)
-{
-    struct media_engine *engine = impl_from_IMFMediaEngineEx(iface);
-    HRESULT hr = E_FAIL;
-
-    TRACE("%p, %s, %p.\n", iface, debugstr_guid(attribute), value);
-
-    EnterCriticalSection(&engine->cs);
-    if (engine->flags & FLAGS_ENGINE_SHUT_DOWN)
-        hr = MF_E_SHUTDOWN;
-    else if (engine->presentation.pd)
-        hr = IMFPresentationDescriptor_GetItem(engine->presentation.pd, attribute, value);
-    LeaveCriticalSection(&engine->cs);
-
-    return hr;
-}
-
-static HRESULT WINAPI media_engine_GetNumberOfStreams(IMFMediaEngineEx *iface, DWORD *stream_count)
-{
-    FIXME("%p, %p stub.\n", iface, stream_count);
-
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI media_engine_GetStreamAttribute(IMFMediaEngineEx *iface, DWORD stream_index, REFGUID attribute,
-        PROPVARIANT *value)
-{
-    struct media_engine *engine = impl_from_IMFMediaEngineEx(iface);
-    IMFStreamDescriptor *sd;
-    HRESULT hr = E_FAIL;
-    BOOL selected;
-
-    TRACE("%p, %ld, %s, %p.\n", iface, stream_index, debugstr_guid(attribute), value);
-
-    EnterCriticalSection(&engine->cs);
-    if (engine->flags & FLAGS_ENGINE_SHUT_DOWN)
-        hr = MF_E_SHUTDOWN;
-    else if (engine->presentation.pd)
-    {
-        if (SUCCEEDED(hr = IMFPresentationDescriptor_GetStreamDescriptorByIndex(engine->presentation.pd,
-                stream_index, &selected, &sd)))
-        {
-            hr = IMFStreamDescriptor_GetItem(sd, attribute, value);
-            IMFStreamDescriptor_Release(sd);
-        }
-    }
-    LeaveCriticalSection(&engine->cs);
-
-    return hr;
-}
-
-static HRESULT WINAPI media_engine_GetStreamSelection(IMFMediaEngineEx *iface, DWORD stream_index, BOOL *enabled)
-{
-    FIXME("%p, %ld, %p stub.\n", iface, stream_index, enabled);
-
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI media_engine_SetStreamSelection(IMFMediaEngineEx *iface, DWORD stream_index, BOOL enabled)
-{
-    FIXME("%p, %ld, %d stub.\n", iface, stream_index, enabled);
-
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI media_engine_ApplyStreamSelections(IMFMediaEngineEx *iface)
-{
-    FIXME("%p stub.\n", iface);
-
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI media_engine_IsProtected(IMFMediaEngineEx *iface, BOOL *protected)
-{
-    FIXME("%p, %p stub.\n", iface, protected);
-
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI media_engine_InsertVideoEffect(IMFMediaEngineEx *iface, IUnknown *effect, BOOL is_optional)
-{
-    FIXME("%p, %p, %d stub.\n", iface, effect, is_optional);
-
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI media_engine_InsertAudioEffect(IMFMediaEngineEx *iface, IUnknown *effect, BOOL is_optional)
-{
-    FIXME("%p, %p, %d stub.\n", iface, effect, is_optional);
-
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI media_engine_RemoveAllEffects(IMFMediaEngineEx *iface)
-{
-    FIXME("%p stub.\n", iface);
-
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI media_engine_SetTimelineMarkerTimer(IMFMediaEngineEx *iface, double timeout)
-{
-    FIXME("%p, %f stub.\n", iface, timeout);
-
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI media_engine_GetTimelineMarkerTimer(IMFMediaEngineEx *iface, double *timeout)
-{
-    FIXME("%p, %p stub.\n", iface, timeout);
-
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI media_engine_CancelTimelineMarkerTimer(IMFMediaEngineEx *iface)
-{
-    FIXME("%p stub.\n", iface);
-
-    return E_NOTIMPL;
-}
-
-static BOOL WINAPI media_engine_IsStereo3D(IMFMediaEngineEx *iface)
-{
-    FIXME("%p stub.\n", iface);
-
-    return FALSE;
-}
-
-static HRESULT WINAPI media_engine_GetStereo3DFramePackingMode(IMFMediaEngineEx *iface, MF_MEDIA_ENGINE_S3D_PACKING_MODE *mode)
-{
-    FIXME("%p, %p stub.\n", iface, mode);
-
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI media_engine_SetStereo3DFramePackingMode(IMFMediaEngineEx *iface, MF_MEDIA_ENGINE_S3D_PACKING_MODE mode)
-{
-    FIXME("%p, %#x stub.\n", iface, mode);
-
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI media_engine_GetStereo3DRenderMode(IMFMediaEngineEx *iface, MF3DVideoOutputType *output_type)
-{
-    FIXME("%p, %p stub.\n", iface, output_type);
-
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI media_engine_SetStereo3DRenderMode(IMFMediaEngineEx *iface, MF3DVideoOutputType output_type)
-{
-    FIXME("%p, %#x stub.\n", iface, output_type);
-
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI media_engine_EnableWindowlessSwapchainMode(IMFMediaEngineEx *iface, BOOL enable)
-{
-    FIXME("%p, %d stub.\n", iface, enable);
-
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI media_engine_GetVideoSwapchainHandle(IMFMediaEngineEx *iface, HANDLE *swapchain)
-{
-    FIXME("%p, %p stub.\n", iface, swapchain);
-
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI media_engine_EnableHorizontalMirrorMode(IMFMediaEngineEx *iface, BOOL enable)
-{
-    FIXME("%p, %d stub.\n", iface, enable);
-
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI media_engine_GetAudioStreamCategory(IMFMediaEngineEx *iface, UINT32 *category)
-{
-    struct media_engine *engine = impl_from_IMFMediaEngineEx(iface);
-    HRESULT hr;
-
-    TRACE("%p, %p.\n", iface, category);
-
-    EnterCriticalSection(&engine->cs);
-
-    if (engine->flags & FLAGS_ENGINE_SHUT_DOWN)
-        hr = MF_E_SHUTDOWN;
-    else
-        hr = IMFAttributes_GetUINT32(engine->attributes, &MF_MEDIA_ENGINE_AUDIO_CATEGORY, category);
-
-    LeaveCriticalSection(&engine->cs);
-
-    return hr;
-}
-
-static HRESULT WINAPI media_engine_SetAudioStreamCategory(IMFMediaEngineEx *iface, UINT32 category)
-{
-    struct media_engine *engine = impl_from_IMFMediaEngineEx(iface);
-    HRESULT hr;
-
-    TRACE("%p, %u.\n", iface, category);
-
-    EnterCriticalSection(&engine->cs);
-
-    if (engine->flags & FLAGS_ENGINE_SHUT_DOWN)
-        hr = MF_E_SHUTDOWN;
-    else
-        hr = IMFAttributes_SetUINT32(engine->attributes, &MF_MEDIA_ENGINE_AUDIO_CATEGORY, category);
-
-    LeaveCriticalSection(&engine->cs);
-
-    return hr;
-}
-
-static HRESULT WINAPI media_engine_GetAudioEndpointRole(IMFMediaEngineEx *iface, UINT32 *role)
-{
-    struct media_engine *engine = impl_from_IMFMediaEngineEx(iface);
-    HRESULT hr;
-
-    TRACE("%p, %p.\n", iface, role);
-
-    EnterCriticalSection(&engine->cs);
-
-    if (engine->flags & FLAGS_ENGINE_SHUT_DOWN)
-        hr = MF_E_SHUTDOWN;
-    else
-        hr = IMFAttributes_GetUINT32(engine->attributes, &MF_MEDIA_ENGINE_AUDIO_ENDPOINT_ROLE, role);
-
-    LeaveCriticalSection(&engine->cs);
-
-    return hr;
-}
-
-static HRESULT WINAPI media_engine_SetAudioEndpointRole(IMFMediaEngineEx *iface, UINT32 role)
-{
-    struct media_engine *engine = impl_from_IMFMediaEngineEx(iface);
-    HRESULT hr;
-
-    TRACE("%p, %u.\n", iface, role);
-
-    EnterCriticalSection(&engine->cs);
-
-    if (engine->flags & FLAGS_ENGINE_SHUT_DOWN)
-        hr = MF_E_SHUTDOWN;
-    else
-        hr = IMFAttributes_SetUINT32(engine->attributes, &MF_MEDIA_ENGINE_AUDIO_ENDPOINT_ROLE, role);
-
-    LeaveCriticalSection(&engine->cs);
-
-    return hr;
-}
-
-static HRESULT WINAPI media_engine_GetRealTimeMode(IMFMediaEngineEx *iface, BOOL *enabled)
-{
-    struct media_engine *engine = impl_from_IMFMediaEngineEx(iface);
-    HRESULT hr = S_OK;
-
-    TRACE("%p, %p.\n", iface, enabled);
-
-    EnterCriticalSection(&engine->cs);
-    if (engine->flags & FLAGS_ENGINE_SHUT_DOWN)
-        hr = MF_E_SHUTDOWN;
-    else
-        *enabled = !!(engine->flags & MF_MEDIA_ENGINE_REAL_TIME_MODE);
-    LeaveCriticalSection(&engine->cs);
-
-    return hr;
-}
-
-static HRESULT WINAPI media_engine_SetRealTimeMode(IMFMediaEngineEx *iface, BOOL enable)
-{
-    struct media_engine *engine = impl_from_IMFMediaEngineEx(iface);
-    HRESULT hr = S_OK;
-
-    TRACE("%p, %d.\n", iface, enable);
-
-    EnterCriticalSection(&engine->cs);
-    if (engine->flags & FLAGS_ENGINE_SHUT_DOWN)
-        hr = MF_E_SHUTDOWN;
-    else
-        media_engine_set_flag(engine, MF_MEDIA_ENGINE_REAL_TIME_MODE, enable);
-    LeaveCriticalSection(&engine->cs);
-
-    return hr;
-}
-
-static HRESULT WINAPI media_engine_SetCurrentTimeEx(IMFMediaEngineEx *iface, double seektime, MF_MEDIA_ENGINE_SEEK_MODE mode)
-{
-    FIXME("%p, %f, %#x stub.\n", iface, seektime, mode);
-
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI media_engine_EnableTimeUpdateTimer(IMFMediaEngineEx *iface, BOOL enable)
-{
-    FIXME("%p, %d stub.\n", iface, enable);
-
-    return E_NOTIMPL;
-}
-
-static const IMFMediaEngineExVtbl media_engine_vtbl =
+static const IMFMediaEngineVtbl media_engine_vtbl =
 {
     media_engine_QueryInterface,
     media_engine_AddRef,
@@ -2825,77 +2284,6 @@ static const IMFMediaEngineExVtbl media_engine_vtbl =
     media_engine_Shutdown,
     media_engine_TransferVideoFrame,
     media_engine_OnVideoStreamTick,
-    media_engine_SetSourceFromByteStream,
-    media_engine_GetStatistics,
-    media_engine_UpdateVideoStream,
-    media_engine_GetBalance,
-    media_engine_SetBalance,
-    media_engine_IsPlaybackRateSupported,
-    media_engine_FrameStep,
-    media_engine_GetResourceCharacteristics,
-    media_engine_GetPresentationAttribute,
-    media_engine_GetNumberOfStreams,
-    media_engine_GetStreamAttribute,
-    media_engine_GetStreamSelection,
-    media_engine_SetStreamSelection,
-    media_engine_ApplyStreamSelections,
-    media_engine_IsProtected,
-    media_engine_InsertVideoEffect,
-    media_engine_InsertAudioEffect,
-    media_engine_RemoveAllEffects,
-    media_engine_SetTimelineMarkerTimer,
-    media_engine_GetTimelineMarkerTimer,
-    media_engine_CancelTimelineMarkerTimer,
-    media_engine_IsStereo3D,
-    media_engine_GetStereo3DFramePackingMode,
-    media_engine_SetStereo3DFramePackingMode,
-    media_engine_GetStereo3DRenderMode,
-    media_engine_SetStereo3DRenderMode,
-    media_engine_EnableWindowlessSwapchainMode,
-    media_engine_GetVideoSwapchainHandle,
-    media_engine_EnableHorizontalMirrorMode,
-    media_engine_GetAudioStreamCategory,
-    media_engine_SetAudioStreamCategory,
-    media_engine_GetAudioEndpointRole,
-    media_engine_SetAudioEndpointRole,
-    media_engine_GetRealTimeMode,
-    media_engine_SetRealTimeMode,
-    media_engine_SetCurrentTimeEx,
-    media_engine_EnableTimeUpdateTimer,
-};
-
-static HRESULT WINAPI media_engine_gs_QueryInterface(IMFGetService *iface, REFIID riid, void **obj)
-{
-    struct media_engine *engine = impl_from_IMFGetService(iface);
-    return IMFMediaEngineEx_QueryInterface(&engine->IMFMediaEngineEx_iface, riid, obj);
-}
-
-static ULONG WINAPI media_engine_gs_AddRef(IMFGetService *iface)
-{
-    struct media_engine *engine = impl_from_IMFGetService(iface);
-    return IMFMediaEngineEx_AddRef(&engine->IMFMediaEngineEx_iface);
-}
-
-static ULONG WINAPI media_engine_gs_Release(IMFGetService *iface)
-{
-    struct media_engine *engine = impl_from_IMFGetService(iface);
-    return IMFMediaEngineEx_Release(&engine->IMFMediaEngineEx_iface);
-}
-
-static HRESULT WINAPI media_engine_gs_GetService(IMFGetService *iface, REFGUID service,
-        REFIID riid, void **object)
-{
-    FIXME("%p, %s, %s, %p stub.\n", iface, debugstr_guid(service), debugstr_guid(riid), object);
-
-    return E_NOTIMPL;
-}
-
-static const IMFGetServiceVtbl media_engine_get_service_vtbl =
-{
-    media_engine_gs_QueryInterface,
-    media_engine_gs_AddRef,
-    media_engine_gs_Release,
-    media_engine_gs_GetService,
 };
 
 static HRESULT WINAPI media_engine_grabber_callback_QueryInterface(IMFSampleGrabberSinkCallback *iface,
@@ -2916,13 +2304,13 @@ static HRESULT WINAPI media_engine_grabber_callback_QueryInterface(IMFSampleGrab
 static ULONG WINAPI media_engine_grabber_callback_AddRef(IMFSampleGrabberSinkCallback *iface)
 {
     struct media_engine *engine = impl_from_IMFSampleGrabberSinkCallback(iface);
-    return IMFMediaEngineEx_AddRef(&engine->IMFMediaEngineEx_iface);
+    return IMFMediaEngine_AddRef(&engine->IMFMediaEngine_iface);
 }
 
 static ULONG WINAPI media_engine_grabber_callback_Release(IMFSampleGrabberSinkCallback *iface)
 {
     struct media_engine *engine = impl_from_IMFSampleGrabberSinkCallback(iface);
-    return IMFMediaEngineEx_Release(&engine->IMFMediaEngineEx_iface);
+    return IMFMediaEngine_Release(&engine->IMFMediaEngine_iface);
 }
 
 static HRESULT WINAPI media_engine_grabber_callback_OnClockStart(IMFSampleGrabberSinkCallback *iface,
@@ -3051,8 +2439,7 @@ static HRESULT init_media_engine(DWORD flags, IMFAttributes *attributes, struct
     IMFClock *clock;
     HRESULT hr;
 
-    engine->IMFMediaEngineEx_iface.lpVtbl = &media_engine_vtbl;
-    engine->IMFGetService_iface.lpVtbl = &media_engine_get_service_vtbl;
+    engine->IMFMediaEngine_iface.lpVtbl = &media_engine_vtbl;
     engine->session_events.lpVtbl = &media_engine_session_events_vtbl;
     engine->load_handler.lpVtbl = &media_engine_load_handler_vtbl;
     engine->grabber_callback.lpVtbl = &media_engine_grabber_callback_vtbl;
@@ -3096,12 +2483,6 @@ static HRESULT init_media_engine(DWORD flags, IMFAttributes *attributes, struct
     if (FAILED(hr = IMFAttributes_CopyAllItems(attributes, engine->attributes)))
         return hr;
 
-    /* Set default audio configuration */
-    if (FAILED(IMFAttributes_GetItem(engine->attributes, &MF_MEDIA_ENGINE_AUDIO_CATEGORY, NULL)))
-        IMFAttributes_SetUINT32(engine->attributes, &MF_MEDIA_ENGINE_AUDIO_CATEGORY, AudioCategory_Other);
-    if (FAILED(IMFAttributes_GetItem(engine->attributes, &MF_MEDIA_ENGINE_AUDIO_ENDPOINT_ROLE, NULL)))
-        IMFAttributes_SetUINT32(engine->attributes, &MF_MEDIA_ENGINE_AUDIO_ENDPOINT_ROLE, eMultimedia);
-
     IMFAttributes_GetUINT64(attributes, &MF_MEDIA_ENGINE_PLAYBACK_HWND, &playback_hwnd);
     hr = IMFAttributes_GetUINT32(attributes, &MF_MEDIA_ENGINE_VIDEO_OUTPUT_FORMAT, &output_format);
     if (playback_hwnd) /* FIXME: handle MF_MEDIA_ENGINE_PLAYBACK_VISUAL */
@@ -3123,7 +2504,7 @@ static HRESULT WINAPI media_engine_factory_CreateInstance(IMFMediaEngineClassFac
     struct media_engine *object;
     HRESULT hr;
 
-    TRACE("%p, %#lx, %p, %p.\n", iface, flags, attributes, engine);
+    TRACE("%p, %#x, %p, %p.\n", iface, flags, attributes, engine);
 
     if (!attributes || !engine)
         return E_POINTER;
@@ -3139,7 +2520,7 @@ static HRESULT WINAPI media_engine_factory_CreateInstance(IMFMediaEngineClassFac
         return hr;
     }
 
-    *engine = (IMFMediaEngine *)&object->IMFMediaEngineEx_iface;
+    *engine = &object->IMFMediaEngine_iface;
 
     return S_OK;
 }
diff --git a/dlls/mfmediaengine/tests/Makefile.in b/dlls/mfmediaengine/tests/Makefile.in
index 421b75587a0..13bbef64df2 100644
--- wine/dlls/mfmediaengine/tests/Makefile.in
+++ wine/dlls/mfmediaengine/tests/Makefile.in
@@ -1,5 +1,6 @@
+EXTRADEFS = -DWINE_NO_LONG_TYPES
 TESTDLL   = mfmediaengine.dll
-IMPORTS   = ole32 mfplat oleaut32 mfuuid uuid
+IMPORTS   = ole32 mfplat mfmediaengine oleaut32 mfuuid uuid
 
 C_SRCS = \
 	mfmediaengine.c
diff --git a/dlls/mfmediaengine/tests/mfmediaengine.c b/dlls/mfmediaengine/tests/mfmediaengine.c
index 008ee58849c..096f6e3f2a5 100644
--- wine/dlls/mfmediaengine/tests/mfmediaengine.c
+++ wine/dlls/mfmediaengine/tests/mfmediaengine.c
@@ -29,9 +29,8 @@
 #include "mferror.h"
 #include "dxgi.h"
 #include "initguid.h"
-#include "mmdeviceapi.h"
-#include "audiosessiontypes.h"
 
+#include "wine/heap.h"
 #include "wine/test.h"
 
 static HRESULT (WINAPI *pMFCreateDXGIDeviceManager)(UINT *token, IMFDXGIDeviceManager **manager);
@@ -44,22 +43,7 @@ static void _expect_ref(IUnknown *obj, ULONG ref, int line)
     ULONG rc;
     IUnknown_AddRef(obj);
     rc = IUnknown_Release(obj);
-    ok_(__FILE__,line)(rc == ref, "Unexpected refcount %ld, expected %ld.\n", rc, ref);
-}
-
-#define check_interface(a, b, c) check_interface_(__LINE__, a, b, c)
-static void check_interface_(unsigned int line, void *iface_ptr, REFIID iid, BOOL supported)
-{
-    IUnknown *iface = iface_ptr;
-    HRESULT hr, expected_hr;
-    IUnknown *unk;
-
-    expected_hr = supported ? S_OK : E_NOINTERFACE;
-
-    hr = IUnknown_QueryInterface(iface, iid, (void **)&unk);
-    ok_(__FILE__, line)(hr == expected_hr, "Got hr %#lx, expected %#lx.\n", hr, expected_hr);
-    if (SUCCEEDED(hr))
-        IUnknown_Release(unk);
+    ok_(__FILE__,line)(rc == ref, "Unexpected refcount %d, expected %d.\n", rc, ref);
 }
 
 static void init_functions(void)
@@ -105,12 +89,7 @@ static ULONG WINAPI media_engine_notify_AddRef(IMFMediaEngineNotify *iface)
 static ULONG WINAPI media_engine_notify_Release(IMFMediaEngineNotify *iface)
 {
     struct media_engine_notify *notify = impl_from_IMFMediaEngineNotify(iface);
-    ULONG refcount = InterlockedDecrement(&notify->refcount);
-
-    if (!refcount)
-        free(notify);
-
-    return refcount;
+    return InterlockedDecrement(&notify->refcount);
 }
 
 static HRESULT WINAPI media_engine_notify_EventNotify(IMFMediaEngineNotify *iface, DWORD event, DWORD_PTR param1, DWORD param2)
@@ -126,18 +105,6 @@ static IMFMediaEngineNotifyVtbl media_engine_notify_vtbl =
     media_engine_notify_EventNotify,
 };
 
-static struct media_engine_notify *create_callback(void)
-{
-    struct media_engine_notify *object;
-
-    object = calloc(1, sizeof(*object));
-
-    object->IMFMediaEngineNotify_iface.lpVtbl = &media_engine_notify_vtbl;
-    object->refcount = 1;
-
-    return object;
-}
-
 static IMFMediaEngine *create_media_engine(IMFMediaEngineNotify *callback)
 {
     IMFDXGIDeviceManager *manager;
@@ -147,18 +114,18 @@ static IMFMediaEngine *create_media_engine(IMFMediaEngineNotify *callback)
     HRESULT hr;
 
     hr = pMFCreateDXGIDeviceManager(&token, &manager);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to create dxgi device manager, hr %#x.\n", hr);
 
     hr = MFCreateAttributes(&attributes, 3);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to create attributes, hr %#x.\n", hr);
 
     hr = IMFAttributes_SetUnknown(attributes, &MF_MEDIA_ENGINE_CALLBACK, (IUnknown *)callback);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to set attribute, hr %#x.\n", hr);
     hr = IMFAttributes_SetUINT32(attributes, &MF_MEDIA_ENGINE_VIDEO_OUTPUT_FORMAT, DXGI_FORMAT_UNKNOWN);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to set attribute, hr %#x.\n", hr);
 
     hr = IMFMediaEngineClassFactory_CreateInstance(factory, 0, attributes, &media_engine);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to create media engine, hr %#x.\n", hr);
 
     IMFAttributes_Release(attributes);
     IMFDXGIDeviceManager_Release(manager);
@@ -166,24 +133,11 @@ static IMFMediaEngine *create_media_engine(IMFMediaEngineNotify *callback)
     return media_engine;
 }
 
-static IMFMediaEngineEx *create_media_engine_ex(IMFMediaEngineNotify *callback)
-{
-    IMFMediaEngine *engine = create_media_engine(callback);
-    IMFMediaEngineEx *engine_ex = NULL;
-
-    if (engine)
-    {
-        IMFMediaEngine_QueryInterface(engine, &IID_IMFMediaEngineEx, (void **)&engine_ex);
-        IMFMediaEngine_Release(engine);
-    }
-
-    return engine_ex;
-}
-
 static void test_factory(void)
 {
+    struct media_engine_notify notify_impl = {{&media_engine_notify_vtbl}, 1};
+    IMFMediaEngineNotify *notify = &notify_impl.IMFMediaEngineNotify_iface;
     IMFMediaEngineClassFactory *factory, *factory2;
-    struct media_engine_notify *notify;
     IMFDXGIDeviceManager *manager;
     IMFMediaEngine *media_engine;
     IMFAttributes *attributes;
@@ -192,158 +146,118 @@ static void test_factory(void)
 
     hr = CoCreateInstance(&CLSID_MFMediaEngineClassFactory, NULL, CLSCTX_INPROC_SERVER, &IID_IMFMediaEngineClassFactory,
             (void **)&factory);
-    ok(hr == S_OK || broken(hr == REGDB_E_CLASSNOTREG) /* pre-win8 */, "Failed to create class factory, hr %#lx.\n", hr);
+    ok(hr == S_OK || broken(hr == REGDB_E_CLASSNOTREG) /* pre-win8 */, "Failed to create class factory, hr %#x.\n", hr);
     if (FAILED(hr))
     {
         win_skip("Media Engine is not supported.\n");
         return;
     }
 
-    notify = create_callback();
-
     /* Aggregation is not supported. */
     hr = CoCreateInstance(&CLSID_MFMediaEngineClassFactory, (IUnknown *)factory, CLSCTX_INPROC_SERVER,
             &IID_IMFMediaEngineClassFactory, (void **)&factory2);
-    ok(hr == CLASS_E_NOAGGREGATION, "Unexpected hr %#lx.\n", hr);
+    ok(hr == CLASS_E_NOAGGREGATION, "Unexpected hr %#x.\n", hr);
 
     hr = pMFCreateDXGIDeviceManager(&token, &manager);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "MFCreateDXGIDeviceManager failed: %#x.\n", hr);
     hr = MFCreateAttributes(&attributes, 3);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "MFCreateAttributes failed: %#x.\n", hr);
 
-    hr = IMFMediaEngineClassFactory_CreateInstance(factory, MF_MEDIA_ENGINE_WAITFORSTABLE_STATE, attributes, &media_engine);
-    ok(hr == MF_E_ATTRIBUTENOTFOUND, "Unexpected hr %#lx.\n", hr);
+    hr = IMFMediaEngineClassFactory_CreateInstance(factory, MF_MEDIA_ENGINE_WAITFORSTABLE_STATE,
+                                                   attributes, &media_engine);
+    ok(hr == MF_E_ATTRIBUTENOTFOUND, "IMFMediaEngineClassFactory_CreateInstance got %#x.\n", hr);
 
     hr = IMFAttributes_SetUnknown(attributes, &MF_MEDIA_ENGINE_OPM_HWND, NULL);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
-    hr = IMFMediaEngineClassFactory_CreateInstance(factory, MF_MEDIA_ENGINE_WAITFORSTABLE_STATE, attributes, &media_engine);
-    ok(hr == MF_E_ATTRIBUTENOTFOUND, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "IMFAttributes_SetUnknown failed: %#x.\n", hr);
+    hr = IMFMediaEngineClassFactory_CreateInstance(factory, MF_MEDIA_ENGINE_WAITFORSTABLE_STATE,
+                                                   attributes, &media_engine);
+    ok(hr == MF_E_ATTRIBUTENOTFOUND, "IMFMediaEngineClassFactory_CreateInstance got %#x.\n", hr);
 
     IMFAttributes_DeleteAllItems(attributes);
-    hr = IMFAttributes_SetUnknown(attributes, &MF_MEDIA_ENGINE_CALLBACK, (IUnknown *)&notify->IMFMediaEngineNotify_iface);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    hr = IMFAttributes_SetUnknown(attributes, &MF_MEDIA_ENGINE_CALLBACK, (IUnknown *)notify);
+    ok(hr == S_OK, "IMFAttributes_SetUnknown failed: %#x.\n", hr);
     hr = IMFAttributes_SetUINT32(attributes, &MF_MEDIA_ENGINE_VIDEO_OUTPUT_FORMAT, DXGI_FORMAT_UNKNOWN);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "IMFAttributes_SetUINT32 failed: %#x.\n", hr);
     EXPECT_REF(factory, 1);
-    hr = IMFMediaEngineClassFactory_CreateInstance(factory, MF_MEDIA_ENGINE_WAITFORSTABLE_STATE, attributes, &media_engine);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    hr = IMFMediaEngineClassFactory_CreateInstance(factory, MF_MEDIA_ENGINE_WAITFORSTABLE_STATE,
+                                                   attributes, &media_engine);
+    ok(hr == S_OK, "IMFMediaEngineClassFactory_CreateInstance failed: %#x.\n", hr);
     EXPECT_REF(factory, 1);
 
     IMFMediaEngine_Release(media_engine);
     IMFAttributes_Release(attributes);
     IMFDXGIDeviceManager_Release(manager);
     IMFMediaEngineClassFactory_Release(factory);
-    IMFMediaEngineNotify_Release(&notify->IMFMediaEngineNotify_iface);
 }
 
 static void test_CreateInstance(void)
 {
-    struct media_engine_notify *notify;
-    IMFMediaEngineEx *media_engine_ex;
+    struct media_engine_notify notify_impl = {{&media_engine_notify_vtbl}, 1};
+    IMFMediaEngineNotify *notify = &notify_impl.IMFMediaEngineNotify_iface;
     IMFDXGIDeviceManager *manager;
     IMFMediaEngine *media_engine;
     IMFAttributes *attributes;
-    IUnknown *unk;
     UINT token;
     HRESULT hr;
-    BOOL ret;
-
-    notify = create_callback();
 
     hr = pMFCreateDXGIDeviceManager(&token, &manager);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to create dxgi device manager, hr %#x.\n", hr);
 
     hr = MFCreateAttributes(&attributes, 3);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to create attributes, hr %#x.\n", hr);
 
     hr = IMFMediaEngineClassFactory_CreateInstance(factory, MF_MEDIA_ENGINE_WAITFORSTABLE_STATE,
             attributes, &media_engine);
-    ok(hr == MF_E_ATTRIBUTENOTFOUND, "Unexpected hr %#lx.\n", hr);
+    ok(hr == MF_E_ATTRIBUTENOTFOUND, "Unexpected hr %#x.\n", hr);
 
     hr = IMFAttributes_SetUnknown(attributes, &MF_MEDIA_ENGINE_OPM_HWND, NULL);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to set attribute, hr %#x.\n", hr);
 
     hr = IMFMediaEngineClassFactory_CreateInstance(factory, MF_MEDIA_ENGINE_WAITFORSTABLE_STATE,
             attributes, &media_engine);
-    ok(hr == MF_E_ATTRIBUTENOTFOUND, "Unexpected hr %#lx.\n", hr);
+    ok(hr == MF_E_ATTRIBUTENOTFOUND, "Unexpected hr %#x.\n", hr);
 
     IMFAttributes_DeleteAllItems(attributes);
 
-    hr = IMFAttributes_SetUnknown(attributes, &MF_MEDIA_ENGINE_CALLBACK, (IUnknown *)&notify->IMFMediaEngineNotify_iface);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    hr = IMFAttributes_SetUnknown(attributes, &MF_MEDIA_ENGINE_CALLBACK, (IUnknown *)notify);
+    ok(hr == S_OK, "Failed to set attribute, hr %#x.\n", hr);
     hr = IMFAttributes_SetUINT32(attributes, &MF_MEDIA_ENGINE_VIDEO_OUTPUT_FORMAT, DXGI_FORMAT_UNKNOWN);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
-
-    hr = IMFMediaEngineClassFactory_CreateInstance(factory, MF_MEDIA_ENGINE_REAL_TIME_MODE
-            | MF_MEDIA_ENGINE_WAITFORSTABLE_STATE, attributes, &media_engine);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
-
-    check_interface(media_engine, &IID_IMFMediaEngine, TRUE);
-
-    hr = IMFMediaEngine_QueryInterface(media_engine, &IID_IMFGetService, (void **)&unk);
-    ok(hr == S_OK || broken(hr == E_NOINTERFACE) /* supported since win10 */, "Unexpected hr %#lx.\n", hr);
-    if (SUCCEEDED(hr))
-        IUnknown_Release(unk);
-
-    if (SUCCEEDED(IMFMediaEngine_QueryInterface(media_engine, &IID_IMFMediaEngineEx, (void **)&media_engine_ex)))
-    {
-        hr = IMFMediaEngineEx_GetRealTimeMode(media_engine_ex, &ret);
-        ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
-        ok(ret, "Unexpected value.\n");
-
-        hr = IMFMediaEngineEx_SetRealTimeMode(media_engine_ex, FALSE);
-        ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
-
-        hr = IMFMediaEngineEx_GetRealTimeMode(media_engine_ex, &ret);
-        ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
-        ok(!ret, "Unexpected value.\n");
+    ok(hr == S_OK, "Failed to set attribute, hr %#x.\n", hr);
 
-        hr = IMFMediaEngineEx_SetRealTimeMode(media_engine_ex, TRUE);
-        ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
-
-        hr = IMFMediaEngineEx_GetRealTimeMode(media_engine_ex, &ret);
-        ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
-        ok(ret, "Unexpected value.\n");
-
-        IMFMediaEngineEx_Release(media_engine_ex);
-    }
+    hr = IMFMediaEngineClassFactory_CreateInstance(factory, MF_MEDIA_ENGINE_WAITFORSTABLE_STATE, attributes, &media_engine);
+    ok(hr == S_OK, "Failed to create media engine, hr %#x.\n", hr);
 
     IMFMediaEngine_Release(media_engine);
     IMFAttributes_Release(attributes);
     IMFDXGIDeviceManager_Release(manager);
-    IMFMediaEngineNotify_Release(&notify->IMFMediaEngineNotify_iface);
 }
 
 static void test_Shutdown(void)
 {
-    struct media_engine_notify *notify;
-    IMFMediaEngineEx *media_engine_ex;
+    struct media_engine_notify notify_impl = {{&media_engine_notify_vtbl}, 1};
+    IMFMediaEngineNotify *callback = &notify_impl.IMFMediaEngineNotify_iface;
     IMFMediaTimeRange *time_range;
     IMFMediaEngine *media_engine;
-    PROPVARIANT propvar;
-    DWORD flags, cx, cy;
     unsigned int state;
-    UINT32 value;
+    DWORD cx, cy;
     double val;
     HRESULT hr;
     BSTR str;
-    BOOL ret;
 
-    notify = create_callback();
-
-    media_engine = create_media_engine(&notify->IMFMediaEngineNotify_iface);
+    media_engine = create_media_engine(callback);
 
     hr = IMFMediaEngine_Shutdown(media_engine);
-    ok(hr == S_OK, "Failed to shut down, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to shut down, hr %#x.\n", hr);
 
     hr = IMFMediaEngine_Shutdown(media_engine);
-    ok(hr == MF_E_SHUTDOWN || broken(hr == S_OK) /* before win10 */, "Unexpected hr %#lx.\n", hr);
+    ok(hr == MF_E_SHUTDOWN || broken(hr == S_OK) /* before win10 */, "Unexpected hr %#x.\n", hr);
 
     hr = IMFMediaEngine_SetSource(media_engine, NULL);
-    ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#lx.\n", hr);
+    ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#x.\n", hr);
 
     hr = IMFMediaEngine_GetCurrentSource(media_engine, &str);
-    ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#lx.\n", hr);
+todo_wine
+    ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#x.\n", hr);
 
     state = IMFMediaEngine_GetNetworkState(media_engine);
     ok(!state, "Unexpected state %d.\n", state);
@@ -353,26 +267,29 @@ static void test_Shutdown(void)
     ok(!state, "Unexpected state %d.\n", state);
 
     hr = IMFMediaEngine_SetPreload(media_engine, MF_MEDIA_ENGINE_PRELOAD_AUTOMATIC);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     state = IMFMediaEngine_GetPreload(media_engine);
     ok(state == MF_MEDIA_ENGINE_PRELOAD_AUTOMATIC, "Unexpected state %d.\n", state);
 
     hr = IMFMediaEngine_SetPreload(media_engine, 100);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     state = IMFMediaEngine_GetPreload(media_engine);
     ok(state == 100, "Unexpected state %d.\n", state);
 
     hr = IMFMediaEngine_GetBuffered(media_engine, &time_range);
-    ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#lx.\n", hr);
+todo_wine
+    ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#x.\n", hr);
 
     hr = IMFMediaEngine_Load(media_engine);
-    ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#lx.\n", hr);
+todo_wine
+    ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#x.\n", hr);
 
     str = SysAllocString(L"video/mp4");
     hr = IMFMediaEngine_CanPlayType(media_engine, str, &state);
-    ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#lx.\n", hr);
+todo_wine
+    ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#x.\n", hr);
     SysFreeString(str);
 
     state = IMFMediaEngine_GetReadyState(media_engine);
@@ -385,7 +302,8 @@ static void test_Shutdown(void)
     ok(val == 0.0, "Unexpected time %f.\n", val);
 
     hr = IMFMediaEngine_SetCurrentTime(media_engine, 1.0);
-    ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#lx.\n", hr);
+todo_wine
+    ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#x.\n", hr);
 
     val = IMFMediaEngine_GetStartTime(media_engine);
     ok(val == 0.0, "Unexpected time %f.\n", val);
@@ -397,16 +315,18 @@ static void test_Shutdown(void)
     ok(val == 1.0, "Unexpected rate %f.\n", val);
 
     hr = IMFMediaEngine_SetDefaultPlaybackRate(media_engine, 2.0);
-    ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#lx.\n", hr);
+    ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#x.\n", hr);
 
     val = IMFMediaEngine_GetPlaybackRate(media_engine);
     ok(val == 1.0, "Unexpected rate %f.\n", val);
 
     hr = IMFMediaEngine_GetPlayed(media_engine, &time_range);
-    ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#lx.\n", hr);
+todo_wine
+    ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#x.\n", hr);
 
     hr = IMFMediaEngine_GetSeekable(media_engine, &time_range);
-    ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#lx.\n", hr);
+todo_wine
+    ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#x.\n", hr);
 
     state = IMFMediaEngine_IsEnded(media_engine);
     ok(!state, "Unexpected state %d.\n", state);
@@ -416,7 +336,7 @@ static void test_Shutdown(void)
     ok(!state, "Unexpected state.\n");
 
     hr = IMFMediaEngine_SetAutoPlay(media_engine, TRUE);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     state = IMFMediaEngine_GetAutoPlay(media_engine);
     ok(!!state, "Unexpected state.\n");
@@ -426,28 +346,30 @@ static void test_Shutdown(void)
     ok(!state, "Unexpected state.\n");
 
     hr = IMFMediaEngine_SetLoop(media_engine, TRUE);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     state = IMFMediaEngine_GetLoop(media_engine);
     ok(!!state, "Unexpected state.\n");
 
     hr = IMFMediaEngine_Play(media_engine);
-    ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#lx.\n", hr);
+todo_wine
+    ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#x.\n", hr);
 
     hr = IMFMediaEngine_Pause(media_engine);
-    ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#lx.\n", hr);
+todo_wine
+    ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#x.\n", hr);
 
     state = IMFMediaEngine_GetMuted(media_engine);
     ok(!state, "Unexpected state.\n");
 
     hr = IMFMediaEngine_SetMuted(media_engine, TRUE);
-    ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#lx.\n", hr);
+    ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#x.\n", hr);
 
     val = IMFMediaEngine_GetVolume(media_engine);
     ok(val == 1.0, "Unexpected value %f.\n", val);
 
     hr = IMFMediaEngine_SetVolume(media_engine, 2.0);
-    ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#lx.\n", hr);
+    ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#x.\n", hr);
 
     state = IMFMediaEngine_HasVideo(media_engine);
     ok(!state, "Unexpected state.\n");
@@ -456,59 +378,18 @@ static void test_Shutdown(void)
     ok(!state, "Unexpected state.\n");
 
     hr = IMFMediaEngine_GetNativeVideoSize(media_engine, &cx, &cy);
-    ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#lx.\n", hr);
+    ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#x.\n", hr);
 
     hr = IMFMediaEngine_GetVideoAspectRatio(media_engine, &cx, &cy);
-    ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#lx.\n", hr);
-
-    if (SUCCEEDED(IMFMediaEngine_QueryInterface(media_engine, &IID_IMFMediaEngineEx, (void **)&media_engine_ex)))
-    {
-        hr = IMFMediaEngineEx_SetSourceFromByteStream(media_engine_ex, NULL, NULL);
-        ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#lx.\n", hr);
-
-        hr = IMFMediaEngineEx_GetAudioStreamCategory(media_engine_ex, &value);
-        ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#lx.\n", hr);
-
-        hr = IMFMediaEngineEx_GetAudioEndpointRole(media_engine_ex, &value);
-        ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#lx.\n", hr);
-
-        hr = IMFMediaEngineEx_SetAudioStreamCategory(media_engine_ex, AudioCategory_ForegroundOnlyMedia);
-        ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#lx.\n", hr);
-
-        hr = IMFMediaEngineEx_SetAudioEndpointRole(media_engine_ex, eConsole);
-        ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#lx.\n", hr);
-
-        hr = IMFMediaEngineEx_GetResourceCharacteristics(media_engine_ex, NULL);
-        ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#lx.\n", hr);
-
-        hr = IMFMediaEngineEx_GetResourceCharacteristics(media_engine_ex, &flags);
-        ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#lx.\n", hr);
-
-        hr = IMFMediaEngineEx_GetRealTimeMode(media_engine_ex, NULL);
-        ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#lx.\n", hr);
-
-        hr = IMFMediaEngineEx_GetRealTimeMode(media_engine_ex, &ret);
-        ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#lx.\n", hr);
-
-        hr = IMFMediaEngineEx_SetRealTimeMode(media_engine_ex, TRUE);
-        ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#lx.\n", hr);
-
-        hr = IMFMediaEngineEx_GetPresentationAttribute(media_engine_ex, &MF_PD_DURATION, &propvar);
-        ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#lx.\n", hr);
-
-        hr = IMFMediaEngineEx_GetStreamAttribute(media_engine_ex, 0, &MF_SD_PROTECTED, &propvar);
-        ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#lx.\n", hr);
-
-        IMFMediaEngineEx_Release(media_engine_ex);
-    }
+    ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#x.\n", hr);
 
     IMFMediaEngine_Release(media_engine);
-    IMFMediaEngineNotify_Release(&notify->IMFMediaEngineNotify_iface);
 }
 
 static void test_Play(void)
 {
-    struct media_engine_notify *notify;
+    struct media_engine_notify notify_impl = {{&media_engine_notify_vtbl}, 1};
+    IMFMediaEngineNotify *callback = &notify_impl.IMFMediaEngineNotify_iface;
     IMFMediaTimeRange *range, *range1;
     IMFMediaEngine *media_engine;
     LONGLONG pts;
@@ -516,18 +397,16 @@ static void test_Play(void)
     HRESULT hr;
     BOOL ret;
 
-    notify = create_callback();
-
-    media_engine = create_media_engine(&notify->IMFMediaEngineNotify_iface);
+    media_engine = create_media_engine(callback);
 
     hr = IMFMediaEngine_GetBuffered(media_engine, &range);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     hr = IMFMediaEngine_GetBuffered(media_engine, &range1);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(range != range1, "Unexpected pointer.\n");
 
     count = IMFMediaTimeRange_GetLength(range);
-    ok(!count, "Unexpected count %lu.\n", count);
+    ok(!count, "Unexpected count %u.\n", count);
 
     IMFMediaTimeRange_Release(range);
     IMFMediaTimeRange_Release(range1);
@@ -536,30 +415,30 @@ static void test_Play(void)
     ok(ret, "Unexpected state %d.\n", ret);
 
     hr = IMFMediaEngine_OnVideoStreamTick(media_engine, NULL);
-    ok(hr == E_POINTER, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Unexpected hr %#x.\n", hr);
 
     pts = 0;
     hr = IMFMediaEngine_OnVideoStreamTick(media_engine, &pts);
-    ok(hr == S_FALSE, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Unexpected hr %#x.\n", hr);
     ok(pts == MINLONGLONG, "Unexpected timestamp.\n");
 
     hr = IMFMediaEngine_Play(media_engine);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     ret = IMFMediaEngine_IsPaused(media_engine);
     ok(!ret, "Unexpected state %d.\n", ret);
 
     hr = IMFMediaEngine_Play(media_engine);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IMFMediaEngine_Shutdown(media_engine);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IMFMediaEngine_OnVideoStreamTick(media_engine, NULL);
-    ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#lx.\n", hr);
+    ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#x.\n", hr);
 
     hr = IMFMediaEngine_OnVideoStreamTick(media_engine, &pts);
-    ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#lx.\n", hr);
+    ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#x.\n", hr);
 
     ret = IMFMediaEngine_IsPaused(media_engine);
     ok(!ret, "Unexpected state %d.\n", ret);
@@ -567,34 +446,32 @@ static void test_Play(void)
     IMFMediaEngine_Release(media_engine);
 
     /* Play -> Pause */
-    media_engine = create_media_engine(&notify->IMFMediaEngineNotify_iface);
+    media_engine = create_media_engine(callback);
 
     hr = IMFMediaEngine_Play(media_engine);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     ret = IMFMediaEngine_IsPaused(media_engine);
     ok(!ret, "Unexpected state %d.\n", ret);
 
     hr = IMFMediaEngine_Pause(media_engine);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     ret = IMFMediaEngine_IsPaused(media_engine);
     ok(!!ret, "Unexpected state %d.\n", ret);
 
     IMFMediaEngine_Release(media_engine);
-    IMFMediaEngineNotify_Release(&notify->IMFMediaEngineNotify_iface);
 }
 
 static void test_playback_rate(void)
 {
-    struct media_engine_notify *notify;
+    struct media_engine_notify notify_impl = {{&media_engine_notify_vtbl}, 1};
+    IMFMediaEngineNotify *callback = &notify_impl.IMFMediaEngineNotify_iface;
     IMFMediaEngine *media_engine;
     double rate;
     HRESULT hr;
 
-    notify = create_callback();
-
-    media_engine = create_media_engine(&notify->IMFMediaEngineNotify_iface);
+    media_engine = create_media_engine(callback);
 
     rate = IMFMediaEngine_GetDefaultPlaybackRate(media_engine);
     ok(rate == 1.0, "Unexpected default rate.\n");
@@ -603,132 +480,127 @@ static void test_playback_rate(void)
     ok(rate == 1.0, "Unexpected default rate.\n");
 
     hr = IMFMediaEngine_SetPlaybackRate(media_engine, 0.0);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     rate = IMFMediaEngine_GetPlaybackRate(media_engine);
     ok(rate == 0.0, "Unexpected default rate.\n");
 
     hr = IMFMediaEngine_SetDefaultPlaybackRate(media_engine, 0.0);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     IMFMediaEngine_Release(media_engine);
-    IMFMediaEngineNotify_Release(&notify->IMFMediaEngineNotify_iface);
 }
 
 static void test_mute(void)
 {
-    struct media_engine_notify *notify;
+    struct media_engine_notify notify_impl = {{&media_engine_notify_vtbl}, 1};
+    IMFMediaEngineNotify *callback = &notify_impl.IMFMediaEngineNotify_iface;
     IMFMediaEngine *media_engine;
     HRESULT hr;
     BOOL ret;
 
-    notify = create_callback();
-
-    media_engine = create_media_engine(&notify->IMFMediaEngineNotify_iface);
+    media_engine = create_media_engine(callback);
 
     ret = IMFMediaEngine_GetMuted(media_engine);
     ok(!ret, "Unexpected state.\n");
 
     hr = IMFMediaEngine_SetMuted(media_engine, TRUE);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     ret = IMFMediaEngine_GetMuted(media_engine);
     ok(ret, "Unexpected state.\n");
 
     hr = IMFMediaEngine_Shutdown(media_engine);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     ret = IMFMediaEngine_GetMuted(media_engine);
     ok(ret, "Unexpected state.\n");
 
     IMFMediaEngine_Release(media_engine);
-    IMFMediaEngineNotify_Release(&notify->IMFMediaEngineNotify_iface);
 }
 
 static void test_error(void)
 {
-    struct media_engine_notify *notify;
+    struct media_engine_notify notify_impl = {{&media_engine_notify_vtbl}, 1};
+    IMFMediaEngineNotify *callback = &notify_impl.IMFMediaEngineNotify_iface;
     IMFMediaEngine *media_engine;
     IMFMediaError *eo, *eo2;
     unsigned int code;
     HRESULT hr;
 
-    notify = create_callback();
-
-    media_engine = create_media_engine(&notify->IMFMediaEngineNotify_iface);
+    media_engine = create_media_engine(callback);
 
     eo = (void *)0xdeadbeef;
     hr = IMFMediaEngine_GetError(media_engine, &eo);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(!eo, "Unexpected instance.\n");
 
     hr = IMFMediaEngine_SetErrorCode(media_engine, MF_MEDIA_ENGINE_ERR_ENCRYPTED + 1);
-    ok(hr == E_INVALIDARG, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
 
     hr = IMFMediaEngine_SetErrorCode(media_engine, MF_MEDIA_ENGINE_ERR_ABORTED);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     eo = NULL;
     hr = IMFMediaEngine_GetError(media_engine, &eo);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(!!eo, "Unexpected instance.\n");
 
     eo2 = NULL;
     hr = IMFMediaEngine_GetError(media_engine, &eo2);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(eo2 != eo, "Unexpected instance.\n");
 
     IMFMediaError_Release(eo2);
     IMFMediaError_Release(eo);
 
     hr = IMFMediaEngine_SetErrorCode(media_engine, MF_MEDIA_ENGINE_ERR_NOERROR);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     eo = (void *)0xdeadbeef;
     hr = IMFMediaEngine_GetError(media_engine, &eo);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(!eo, "Unexpected instance.\n");
 
     hr = IMFMediaEngine_Shutdown(media_engine);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to shut down, hr %#x.\n", hr);
 
     eo = (void *)0xdeadbeef;
     hr = IMFMediaEngine_GetError(media_engine, &eo);
-    ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#lx.\n", hr);
+    ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#x.\n", hr);
     ok(!eo, "Unexpected instance.\n");
 
     hr = IMFMediaEngine_SetErrorCode(media_engine, MF_MEDIA_ENGINE_ERR_NOERROR);
-    ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#lx.\n", hr);
+    ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#x.\n", hr);
 
     IMFMediaEngine_Release(media_engine);
 
     /* Error object. */
     hr = IMFMediaEngineClassFactory_CreateError(factory, &eo);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to create error object, hr %#x.\n", hr);
 
     code = IMFMediaError_GetErrorCode(eo);
     ok(code == MF_MEDIA_ENGINE_ERR_NOERROR, "Unexpected code %u.\n", code);
 
     hr = IMFMediaError_GetExtendedErrorCode(eo);
-    ok(hr == S_OK, "Unexpected code %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected code %#x.\n", hr);
 
     hr = IMFMediaError_SetErrorCode(eo, MF_MEDIA_ENGINE_ERR_ENCRYPTED + 1);
-    ok(hr == E_INVALIDARG, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
 
     hr = IMFMediaError_SetErrorCode(eo, MF_MEDIA_ENGINE_ERR_ABORTED);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     code = IMFMediaError_GetErrorCode(eo);
     ok(code == MF_MEDIA_ENGINE_ERR_ABORTED, "Unexpected code %u.\n", code);
 
     hr = IMFMediaError_SetExtendedErrorCode(eo, E_FAIL);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IMFMediaError_GetExtendedErrorCode(eo);
-    ok(hr == E_FAIL, "Unexpected code %#lx.\n", hr);
+    ok(hr == E_FAIL, "Unexpected code %#x.\n", hr);
 
     IMFMediaError_Release(eo);
-    IMFMediaEngineNotify_Release(&notify->IMFMediaEngineNotify_iface);
 }
 
 static void test_time_range(void)
@@ -740,11 +612,11 @@ static void test_time_range(void)
     BOOL ret;
 
     hr = IMFMediaEngineClassFactory_CreateTimeRange(factory, &range);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     /* Empty ranges. */
     hr = IMFMediaTimeRange_Clear(range);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     ret = IMFMediaTimeRange_ContainsTime(range, 10.0);
     ok(!ret, "Unexpected return value %d.\n", ret);
@@ -753,225 +625,81 @@ static void test_time_range(void)
     ok(!count, "Unexpected range count.\n");
 
     hr = IMFMediaTimeRange_GetStart(range, 0, &start);
-    ok(hr == E_INVALIDARG, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
 
     hr = IMFMediaTimeRange_GetEnd(range, 0, &end);
-    ok(hr == E_INVALIDARG, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
 
     /* Add a range. */
     hr = IMFMediaTimeRange_AddRange(range, 10.0, 1.0);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     count = IMFMediaTimeRange_GetLength(range);
     ok(count == 1, "Unexpected range count.\n");
 
     hr = IMFMediaTimeRange_GetStart(range, 0, &start);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(start == 10.0, "Unexpected start %.e.\n", start);
 
     hr = IMFMediaTimeRange_GetEnd(range, 0, &end);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(end == 1.0, "Unexpected end %.e.\n", end);
 
     hr = IMFMediaTimeRange_AddRange(range, 2.0, 3.0);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+todo_wine
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     count = IMFMediaTimeRange_GetLength(range);
     ok(count == 1, "Unexpected range count.\n");
 
     hr = IMFMediaTimeRange_GetStart(range, 0, &start);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+todo_wine
     ok(start == 2.0, "Unexpected start %.8e.\n", start);
 
     hr = IMFMediaTimeRange_GetEnd(range, 0, &end);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+todo_wine
     ok(end == 3.0, "Unexpected end %.8e.\n", end);
 
     hr = IMFMediaTimeRange_AddRange(range, 10.0, 9.0);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+todo_wine
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     count = IMFMediaTimeRange_GetLength(range);
+todo_wine
     ok(count == 2, "Unexpected range count.\n");
 
     hr = IMFMediaTimeRange_GetStart(range, 0, &start);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+todo_wine
     ok(start == 2.0, "Unexpected start %.8e.\n", start);
 
     hr = IMFMediaTimeRange_GetEnd(range, 0, &end);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+todo_wine
     ok(end == 3.0, "Unexpected end %.8e.\n", end);
 
     start = 0.0;
     hr = IMFMediaTimeRange_GetStart(range, 1, &start);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
-    ok(start == 10.0, "Unexpected start %.8e.\n", start);
-
-    hr = IMFMediaTimeRange_GetEnd(range, 1, &end);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
-    ok(end == 9.0, "Unexpected end %.8e.\n", end);
-
-    hr = IMFMediaTimeRange_AddRange(range, 2.0, 9.1);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
-
-    count = IMFMediaTimeRange_GetLength(range);
-    ok(count == 2, "Unexpected range count.\n");
-
-    hr = IMFMediaTimeRange_GetStart(range, 0, &start);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
-    ok(start == 2.0, "Unexpected start %.8e.\n", start);
-
-    hr = IMFMediaTimeRange_GetEnd(range, 0, &end);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
-    ok(end == 9.1, "Unexpected end %.8e.\n", end);
-
-    hr = IMFMediaTimeRange_GetStart(range, 1, &start);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+todo_wine {
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(start == 10.0, "Unexpected start %.8e.\n", start);
-
+}
     hr = IMFMediaTimeRange_GetEnd(range, 1, &end);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+todo_wine {
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(end == 9.0, "Unexpected end %.8e.\n", end);
-
-    hr = IMFMediaTimeRange_AddRange(range, 8.5, 2.5);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
-
-    count = IMFMediaTimeRange_GetLength(range);
-    ok(count == 2, "Unexpected range count.\n");
-
-    hr = IMFMediaTimeRange_GetStart(range, 0, &start);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
-    ok(start == 2.0, "Unexpected start %.8e.\n", start);
-
-    hr = IMFMediaTimeRange_GetEnd(range, 0, &end);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
-    ok(end == 9.1, "Unexpected end %.8e.\n", end);
-
-    hr = IMFMediaTimeRange_AddRange(range, 20.0, 20.0);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
-
-    count = IMFMediaTimeRange_GetLength(range);
-    ok(count == 3, "Unexpected range count.\n");
-
+}
     hr = IMFMediaTimeRange_Clear(range);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     count = IMFMediaTimeRange_GetLength(range);
     ok(!count, "Unexpected range count.\n");
 
-    /* Intersect */
-    hr = IMFMediaTimeRange_AddRange(range, 5.0, 10.0);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
-
-    hr = IMFMediaTimeRange_AddRange(range, 6.0, 12.0);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
-
-    hr = IMFMediaTimeRange_GetStart(range, 0, &start);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
-    ok(start == 5.0, "Unexpected start %.8e.\n", start);
-
-    hr = IMFMediaTimeRange_GetEnd(range, 0, &end);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
-    ok(end == 12.0, "Unexpected end %.8e.\n", end);
-
-    count = IMFMediaTimeRange_GetLength(range);
-    ok(count == 1, "Unexpected range count.\n");
-
-    hr = IMFMediaTimeRange_AddRange(range, 4.0, 6.0);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
-
-    count = IMFMediaTimeRange_GetLength(range);
-    ok(count == 1, "Unexpected range count.\n");
-
-    hr = IMFMediaTimeRange_GetStart(range, 0, &start);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
-    ok(start == 4.0, "Unexpected start %.8e.\n", start);
-
-    hr = IMFMediaTimeRange_GetEnd(range, 0, &end);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
-    ok(end == 12.0, "Unexpected end %.8e.\n", end);
-
-    hr = IMFMediaTimeRange_AddRange(range, 5.0, 3.0);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
-
-    count = IMFMediaTimeRange_GetLength(range);
-    ok(count == 1, "Unexpected range count.\n");
-
-    hr = IMFMediaTimeRange_GetStart(range, 0, &start);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
-    ok(start == 4.0, "Unexpected start %.8e.\n", start);
-
-    hr = IMFMediaTimeRange_GetEnd(range, 0, &end);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
-    ok(end == 12.0, "Unexpected end %.8e.\n", end);
-
     IMFMediaTimeRange_Release(range);
 }
 
-static void test_SetSourceFromByteStream(void)
-{
-    struct media_engine_notify *notify;
-    IMFMediaEngineEx *media_engine;
-    PROPVARIANT propvar;
-    DWORD flags;
-    HRESULT hr;
-
-    notify = create_callback();
-
-    media_engine = create_media_engine_ex(&notify->IMFMediaEngineNotify_iface);
-    if (!media_engine)
-    {
-        win_skip("IMFMediaEngineEx is not supported.\n");
-        IMFMediaEngineNotify_Release(&notify->IMFMediaEngineNotify_iface);
-        return;
-    }
-
-    hr = IMFMediaEngineEx_SetSourceFromByteStream(media_engine, NULL, NULL);
-    ok(hr == E_POINTER, "Unexpected hr %#lx.\n", hr);
-
-    hr = IMFMediaEngineEx_GetResourceCharacteristics(media_engine, NULL);
-    ok(hr == E_FAIL, "Unexpected hr %#lx.\n", hr);
-
-    hr = IMFMediaEngineEx_GetResourceCharacteristics(media_engine, &flags);
-    ok(hr == E_FAIL, "Unexpected hr %#lx.\n", hr);
-
-    hr = IMFMediaEngineEx_GetPresentationAttribute(media_engine, &MF_PD_DURATION, &propvar);
-    ok(hr == E_FAIL, "Unexpected hr %#lx.\n", hr);
-
-    hr = IMFMediaEngineEx_GetStreamAttribute(media_engine, 0, &MF_SD_PROTECTED, &propvar);
-    ok(hr == E_FAIL, "Unexpected hr %#lx.\n", hr);
-
-    IMFMediaEngineEx_Release(media_engine);
-    IMFMediaEngineNotify_Release(&notify->IMFMediaEngineNotify_iface);
-}
-
-static void test_audio_configuration(void)
-{
-    struct media_engine_notify *notify;
-    IMFMediaEngineEx *media_engine;
-    UINT32 value;
-    HRESULT hr;
-
-    notify = create_callback();
-
-    media_engine = create_media_engine_ex(&notify->IMFMediaEngineNotify_iface);
-    if (!media_engine)
-    {
-        IMFMediaEngineNotify_Release(&notify->IMFMediaEngineNotify_iface);
-        return;
-    }
-
-    hr = IMFMediaEngineEx_GetAudioStreamCategory(media_engine, &value);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
-    ok(value == AudioCategory_Other, "Unexpected value %u.\n", value);
-
-    hr = IMFMediaEngineEx_GetAudioEndpointRole(media_engine, &value);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
-    ok(value == eMultimedia, "Unexpected value %u.\n", value);
-
-    IMFMediaEngineEx_Release(media_engine);
-    IMFMediaEngineNotify_Release(&notify->IMFMediaEngineNotify_iface);
-}
-
 START_TEST(mfmediaengine)
 {
     HRESULT hr;
@@ -990,7 +718,7 @@ START_TEST(mfmediaengine)
     init_functions();
 
     hr = MFStartup(MF_VERSION, MFSTARTUP_FULL);
-    ok(hr == S_OK, "MFStartup failed: %#lx.\n", hr);
+    ok(hr == S_OK, "MFStartup failed: %#x.\n", hr);
 
     test_factory();
     test_CreateInstance();
@@ -1000,8 +728,6 @@ START_TEST(mfmediaengine)
     test_mute();
     test_error();
     test_time_range();
-    test_SetSourceFromByteStream();
-    test_audio_configuration();
 
     IMFMediaEngineClassFactory_Release(factory);
 
diff --git a/dlls/mfplat/Makefile.in b/dlls/mfplat/Makefile.in
index 4515d652c58..79af7650de6 100644
--- wine/dlls/mfplat/Makefile.in
+++ wine/dlls/mfplat/Makefile.in
@@ -1,7 +1,7 @@
+EXTRADEFS = -DWINE_NO_LONG_TYPES
 MODULE    = mfplat.dll
 IMPORTLIB = mfplat
-IMPORTS   = advapi32 ole32 mfuuid propsys rtworkq kernelbase
-DELAYIMPORTS = bcrypt
+IMPORTS   = advapi32 ole32 mfuuid propsys rtworkq
 
 EXTRADLLFLAGS = -Wb,--prefer-native
 
diff --git a/dlls/mfplat/aac_decoder.c b/dlls/mfplat/aac_decoder.c
new file mode 100644
index 00000000000..97f2824039d
--- /dev/null
+++ wine/dlls/mfplat/aac_decoder.c
@@ -0,0 +1,620 @@
+/* AAC Decoder Transform
+ *
+ * Copyright 2022 Rémi Bernon for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "gst_private.h"
+
+#include "mfapi.h"
+#include "mferror.h"
+#include "mfobjects.h"
+#include "mftransform.h"
+#include "wmcodecdsp.h"
+
+#include "wine/debug.h"
+#include "wine/heap.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(mfplat);
+
+static const GUID *aac_decoder_input_types[] =
+{
+    &MFAudioFormat_AAC,
+};
+static const GUID *aac_decoder_output_types[] =
+{
+    &MFAudioFormat_PCM,
+    &MFAudioFormat_Float,
+};
+
+struct aac_decoder
+{
+    IMFTransform IMFTransform_iface;
+    LONG refcount;
+    IMFMediaType *input_type;
+    IMFMediaType *output_type;
+
+    IMFSample *input_sample;
+    struct wg_transform *wg_transform;
+};
+
+static struct aac_decoder *impl_from_IMFTransform(IMFTransform *iface)
+{
+    return CONTAINING_RECORD(iface, struct aac_decoder, IMFTransform_iface);
+}
+
+static void try_create_wg_transform(struct aac_decoder *decoder)
+{
+    struct wg_encoded_format input_format;
+    struct wg_format output_format;
+
+    if (!decoder->input_type || !decoder->output_type)
+        return;
+
+    if (decoder->wg_transform)
+        wg_transform_destroy(decoder->wg_transform);
+
+    mf_media_type_to_wg_encoded_format(decoder->input_type, &input_format);
+    if (input_format.encoded_type == WG_ENCODED_TYPE_UNKNOWN)
+        return;
+
+    mf_media_type_to_wg_format(decoder->output_type, &output_format);
+    if (output_format.major_type == WG_MAJOR_TYPE_UNKNOWN)
+        return;
+
+    decoder->wg_transform = wg_transform_create(&input_format, &output_format);
+    if (!decoder->wg_transform)
+        WARN("Failed to create wg_transform.\n");
+}
+
+static HRESULT WINAPI aac_decoder_QueryInterface(IMFTransform *iface, REFIID iid, void **out)
+{
+    struct aac_decoder *decoder = impl_from_IMFTransform(iface);
+
+    TRACE("iface %p, iid %s, out %p.\n", iface, debugstr_guid(iid), out);
+
+    if (IsEqualGUID(iid, &IID_IUnknown) || IsEqualGUID(iid, &IID_IMFTransform))
+        *out = &decoder->IMFTransform_iface;
+    else
+    {
+        *out = NULL;
+        WARN("%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid(iid));
+        return E_NOINTERFACE;
+    }
+
+    IUnknown_AddRef((IUnknown *)*out);
+    return S_OK;
+}
+
+static ULONG WINAPI aac_decoder_AddRef(IMFTransform *iface)
+{
+    struct aac_decoder *decoder = impl_from_IMFTransform(iface);
+    ULONG refcount = InterlockedIncrement(&decoder->refcount);
+
+    TRACE("iface %p increasing refcount to %u.\n", decoder, refcount);
+
+    return refcount;
+}
+
+static ULONG WINAPI aac_decoder_Release(IMFTransform *iface)
+{
+    struct aac_decoder *decoder = impl_from_IMFTransform(iface);
+    ULONG refcount = InterlockedDecrement(&decoder->refcount);
+
+    TRACE("iface %p decreasing refcount to %u.\n", decoder, refcount);
+
+    if (!refcount)
+    {
+        if (decoder->input_sample)
+            IMFSample_Release(decoder->input_sample);
+        if (decoder->wg_transform)
+            wg_transform_destroy(decoder->wg_transform);
+        if (decoder->input_type)
+            IMFMediaType_Release(decoder->input_type);
+        if (decoder->output_type)
+            IMFMediaType_Release(decoder->output_type);
+        free(decoder);
+    }
+
+    return refcount;
+}
+
+static HRESULT WINAPI aac_decoder_GetStreamLimits(IMFTransform *iface, DWORD *input_minimum, DWORD *input_maximum,
+        DWORD *output_minimum, DWORD *output_maximum)
+{
+    FIXME("iface %p, input_minimum %p, input_maximum %p, output_minimum %p, output_maximum %p stub!\n",
+            iface, input_minimum, input_maximum, output_minimum, output_maximum);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI aac_decoder_GetStreamCount(IMFTransform *iface, DWORD *inputs, DWORD *outputs)
+{
+    FIXME("iface %p, inputs %p, outputs %p stub!\n", iface, inputs, outputs);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI aac_decoder_GetStreamIDs(IMFTransform *iface, DWORD input_size, DWORD *inputs,
+        DWORD output_size, DWORD *outputs)
+{
+    FIXME("iface %p, input_size %u, inputs %p, output_size %u, outputs %p stub!\n",
+            iface, input_size, inputs, output_size, outputs);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI aac_decoder_GetInputStreamInfo(IMFTransform *iface, DWORD id, MFT_INPUT_STREAM_INFO *info)
+{
+    struct aac_decoder *decoder = impl_from_IMFTransform(iface);
+    UINT32 block_alignment;
+    HRESULT hr;
+
+    TRACE("iface %p, id %u, info %p.\n", iface, id, info);
+
+    if (!decoder->input_type || !decoder->output_type)
+        return MF_E_TRANSFORM_TYPE_NOT_SET;
+
+    if (FAILED(hr = IMFMediaType_GetUINT32(decoder->input_type, &MF_MT_AUDIO_BLOCK_ALIGNMENT, &block_alignment)))
+        return hr;
+
+    info->hnsMaxLatency = 0;
+    info->dwFlags = MFT_INPUT_STREAM_WHOLE_SAMPLES|MFT_INPUT_STREAM_SINGLE_SAMPLE_PER_BUFFER
+            |MFT_INPUT_STREAM_FIXED_SAMPLE_SIZE|MFT_INPUT_STREAM_HOLDS_BUFFERS;
+    info->cbSize = 0;
+    info->cbMaxLookahead = 0;
+    info->cbAlignment = 0;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI aac_decoder_GetOutputStreamInfo(IMFTransform *iface, DWORD id, MFT_OUTPUT_STREAM_INFO *info)
+{
+    struct aac_decoder *decoder = impl_from_IMFTransform(iface);
+    UINT32 channel_count, block_alignment;
+    HRESULT hr;
+
+    TRACE("iface %p, id %u, info %p.\n", iface, id, info);
+
+    if (!decoder->input_type || !decoder->output_type)
+        return MF_E_TRANSFORM_TYPE_NOT_SET;
+
+    if (FAILED(hr = IMFMediaType_GetUINT32(decoder->output_type, &MF_MT_AUDIO_NUM_CHANNELS, &channel_count)))
+        return hr;
+    if (FAILED(hr = IMFMediaType_GetUINT32(decoder->output_type, &MF_MT_AUDIO_BLOCK_ALIGNMENT, &block_alignment)))
+        return hr;
+
+    info->dwFlags = 0;
+    info->cbSize = 0x1800 * block_alignment * channel_count;
+    info->cbAlignment = 0;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI aac_decoder_GetAttributes(IMFTransform *iface, IMFAttributes **attributes)
+{
+    FIXME("iface %p, attributes %p stub!\n", iface, attributes);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI aac_decoder_GetInputStreamAttributes(IMFTransform *iface, DWORD id,
+        IMFAttributes **attributes)
+{
+    FIXME("iface %p, id %u, attributes %p stub!\n", iface, id, attributes);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI aac_decoder_GetOutputStreamAttributes(IMFTransform *iface, DWORD id,
+        IMFAttributes **attributes)
+{
+    FIXME("iface %p, id %u, attributes %p stub!\n", iface, id, attributes);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI aac_decoder_DeleteInputStream(IMFTransform *iface, DWORD id)
+{
+    FIXME("iface %p, id %u stub!\n", iface, id);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI aac_decoder_AddInputStreams(IMFTransform *iface, DWORD streams, DWORD *ids)
+{
+    FIXME("iface %p, streams %u, ids %p stub!\n", iface, streams, ids);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI aac_decoder_GetInputAvailableType(IMFTransform *iface, DWORD id, DWORD index,
+        IMFMediaType **type)
+{
+    FIXME("iface %p, id %u, index %u, type %p stub!\n", iface, id, index, type);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI aac_decoder_GetOutputAvailableType(IMFTransform *iface, DWORD id, DWORD index,
+        IMFMediaType **type)
+{
+    UINT32 channel_count, sample_size, sample_rate, block_alignment;
+    struct aac_decoder *decoder = impl_from_IMFTransform(iface);
+    IMFMediaType *media_type;
+    const GUID *output_type;
+    HRESULT hr;
+
+    TRACE("iface %p, id %u, index %u, type %p.\n", iface, id, index, type);
+
+    if (!decoder->input_type)
+        return MF_E_TRANSFORM_TYPE_NOT_SET;
+
+    *type = NULL;
+
+    if (index >= ARRAY_SIZE(aac_decoder_output_types))
+        return MF_E_NO_MORE_TYPES;
+    index = ARRAY_SIZE(aac_decoder_output_types) - index - 1;
+    output_type = aac_decoder_output_types[index];
+
+    if (FAILED(hr = MFCreateMediaType(&media_type)))
+        return hr;
+
+    if (FAILED(hr = IMFMediaType_SetGUID(media_type, &MF_MT_MAJOR_TYPE, &MFMediaType_Audio)))
+        goto done;
+    if (FAILED(hr = IMFMediaType_SetGUID(media_type, &MF_MT_SUBTYPE, output_type)))
+        goto done;
+
+    if (IsEqualGUID(output_type, &MFAudioFormat_Float))
+        sample_size = 32;
+    else if (IsEqualGUID(output_type, &MFAudioFormat_PCM))
+        sample_size = 16;
+    else
+    {
+        FIXME("Subtype %s not implemented!\n", debugstr_guid(output_type));
+        hr = E_NOTIMPL;
+        goto done;
+    }
+
+    if (FAILED(hr = IMFMediaType_SetUINT32(media_type, &MF_MT_AUDIO_BITS_PER_SAMPLE, sample_size)))
+        goto done;
+
+    if (FAILED(hr = IMFMediaType_GetUINT32(decoder->input_type, &MF_MT_AUDIO_NUM_CHANNELS, &channel_count)))
+        goto done;
+    if (FAILED(hr = IMFMediaType_SetUINT32(media_type, &MF_MT_AUDIO_NUM_CHANNELS, channel_count)))
+        goto done;
+
+    if (FAILED(hr = IMFMediaType_GetUINT32(decoder->input_type, &MF_MT_AUDIO_SAMPLES_PER_SECOND, &sample_rate)))
+        goto done;
+    if (FAILED(hr = IMFMediaType_SetUINT32(media_type, &MF_MT_AUDIO_SAMPLES_PER_SECOND, sample_rate)))
+        goto done;
+
+    block_alignment = sample_size * channel_count / 8;
+    if (FAILED(hr = IMFMediaType_SetUINT32(media_type, &MF_MT_AUDIO_BLOCK_ALIGNMENT, block_alignment)))
+        goto done;
+    if (FAILED(hr = IMFMediaType_SetUINT32(media_type, &MF_MT_AUDIO_AVG_BYTES_PER_SECOND, sample_rate * block_alignment)))
+        goto done;
+
+    if (FAILED(hr = IMFMediaType_SetUINT32(media_type, &MF_MT_ALL_SAMPLES_INDEPENDENT, 1)))
+        goto done;
+    if (FAILED(hr = IMFMediaType_SetUINT32(media_type, &MF_MT_FIXED_SIZE_SAMPLES, 1)))
+        goto done;
+    if (FAILED(hr = IMFMediaType_SetUINT32(media_type, &MF_MT_AUDIO_PREFER_WAVEFORMATEX, 1)))
+        goto done;
+
+done:
+    if (SUCCEEDED(hr))
+        IMFMediaType_AddRef((*type = media_type));
+
+    IMFMediaType_Release(media_type);
+    return hr;
+}
+
+static HRESULT WINAPI aac_decoder_SetInputType(IMFTransform *iface, DWORD id, IMFMediaType *type, DWORD flags)
+{
+    struct aac_decoder *decoder = impl_from_IMFTransform(iface);
+    MF_ATTRIBUTE_TYPE item_type;
+    GUID major, subtype;
+    HRESULT hr;
+    ULONG i;
+
+    TRACE("iface %p, id %u, type %p, flags %#x.\n", iface, id, type, flags);
+
+    if (FAILED(hr = IMFMediaType_GetGUID(type, &MF_MT_MAJOR_TYPE, &major)) ||
+        FAILED(hr = IMFMediaType_GetGUID(type, &MF_MT_SUBTYPE, &subtype)))
+        return hr;
+
+    if (!IsEqualGUID(&major, &MFMediaType_Audio))
+        return MF_E_INVALIDMEDIATYPE;
+
+    for (i = 0; i < ARRAY_SIZE(aac_decoder_input_types); ++i)
+        if (IsEqualGUID(&subtype, aac_decoder_input_types[i]))
+            break;
+    if (i == ARRAY_SIZE(aac_decoder_input_types))
+        return MF_E_INVALIDMEDIATYPE;
+
+    if (FAILED(IMFMediaType_GetItemType(type, &MF_MT_USER_DATA, &item_type)) ||
+        item_type != MF_ATTRIBUTE_BLOB)
+        return MF_E_INVALIDMEDIATYPE;
+    if (FAILED(IMFMediaType_GetItemType(type, &MF_MT_AUDIO_BLOCK_ALIGNMENT, &item_type)) ||
+        item_type != MF_ATTRIBUTE_UINT32)
+        return MF_E_INVALIDMEDIATYPE;
+    if (FAILED(IMFMediaType_GetItemType(type, &MF_MT_AUDIO_SAMPLES_PER_SECOND, &item_type)) ||
+        item_type != MF_ATTRIBUTE_UINT32)
+        return MF_E_INVALIDMEDIATYPE;
+    if (FAILED(IMFMediaType_GetItemType(type, &MF_MT_AUDIO_NUM_CHANNELS, &item_type)) ||
+        item_type != MF_ATTRIBUTE_UINT32)
+        return MF_E_INVALIDMEDIATYPE;
+    if (FAILED(IMFMediaType_GetItemType(type, &MF_MT_AUDIO_BITS_PER_SAMPLE, &item_type)) ||
+        item_type != MF_ATTRIBUTE_UINT32)
+        return MF_E_INVALIDMEDIATYPE;
+    if (FAILED(IMFMediaType_GetItemType(type, &MF_MT_AUDIO_AVG_BYTES_PER_SECOND, &item_type)) ||
+        item_type != MF_ATTRIBUTE_UINT32)
+        return MF_E_INVALIDMEDIATYPE;
+    if (FAILED(IMFMediaType_GetItemType(type, &MF_MT_AUDIO_PREFER_WAVEFORMATEX, &item_type)) ||
+        item_type != MF_ATTRIBUTE_UINT32)
+        return MF_E_INVALIDMEDIATYPE;
+
+    if (!decoder->input_type && FAILED(hr = MFCreateMediaType(&decoder->input_type)))
+        return hr;
+
+    if (decoder->output_type)
+    {
+        IMFMediaType_Release(decoder->output_type);
+        decoder->output_type = NULL;
+    }
+
+    return IMFMediaType_CopyAllItems(type, (IMFAttributes *)decoder->input_type);
+}
+
+static HRESULT WINAPI aac_decoder_SetOutputType(IMFTransform *iface, DWORD id, IMFMediaType *type, DWORD flags)
+{
+    struct aac_decoder *decoder = impl_from_IMFTransform(iface);
+    MF_ATTRIBUTE_TYPE item_type;
+    ULONG i, sample_size;
+    GUID major, subtype;
+    HRESULT hr;
+
+    TRACE("iface %p, id %u, type %p, flags %#x.\n", iface, id, type, flags);
+
+    if (FAILED(hr = IMFMediaType_GetGUID(type, &MF_MT_MAJOR_TYPE, &major)) ||
+        FAILED(hr = IMFMediaType_GetGUID(type, &MF_MT_SUBTYPE, &subtype)))
+        return hr;
+
+    if (!IsEqualGUID(&major, &MFMediaType_Audio))
+        return MF_E_INVALIDMEDIATYPE;
+
+    for (i = 0; i < ARRAY_SIZE(aac_decoder_output_types); ++i)
+        if (IsEqualGUID(&subtype, aac_decoder_output_types[i]))
+            break;
+    if (i == ARRAY_SIZE(aac_decoder_output_types))
+        return MF_E_INVALIDMEDIATYPE;
+
+    if (IsEqualGUID(&subtype, &MFAudioFormat_Float))
+        sample_size = 32;
+    else if (IsEqualGUID(&subtype, &MFAudioFormat_PCM))
+        sample_size = 16;
+    else
+    {
+        FIXME("Subtype %s not implemented!\n", debugstr_guid(&subtype));
+        hr = E_NOTIMPL;
+        return hr;
+    }
+
+    if (FAILED(IMFMediaType_SetUINT32(decoder->input_type, &MF_MT_AUDIO_BITS_PER_SAMPLE, sample_size)))
+        return MF_E_INVALIDMEDIATYPE;
+
+    if (FAILED(IMFMediaType_GetItemType(type, &MF_MT_AUDIO_AVG_BYTES_PER_SECOND, &item_type)) ||
+        item_type != MF_ATTRIBUTE_UINT32)
+        return MF_E_INVALIDMEDIATYPE;
+    if (FAILED(IMFMediaType_GetItemType(type, &MF_MT_AUDIO_BITS_PER_SAMPLE, &item_type)) ||
+        item_type != MF_ATTRIBUTE_UINT32)
+        return MF_E_INVALIDMEDIATYPE;
+    if (FAILED(IMFMediaType_GetItemType(type, &MF_MT_AUDIO_NUM_CHANNELS, &item_type)) ||
+        item_type != MF_ATTRIBUTE_UINT32)
+        return MF_E_INVALIDMEDIATYPE;
+    if (FAILED(IMFMediaType_GetItemType(type, &MF_MT_AUDIO_SAMPLES_PER_SECOND, &item_type)) ||
+        item_type != MF_ATTRIBUTE_UINT32)
+        return MF_E_INVALIDMEDIATYPE;
+    if (FAILED(IMFMediaType_GetItemType(type, &MF_MT_AUDIO_BLOCK_ALIGNMENT, &item_type)) ||
+        item_type != MF_ATTRIBUTE_UINT32)
+        return MF_E_INVALIDMEDIATYPE;
+
+    if (!decoder->output_type && FAILED(hr = MFCreateMediaType(&decoder->output_type)))
+        return hr;
+
+    if (FAILED(hr = IMFMediaType_CopyAllItems(type, (IMFAttributes *)decoder->output_type)))
+        return hr;
+
+    try_create_wg_transform(decoder);
+    return S_OK;
+}
+
+static HRESULT WINAPI aac_decoder_GetInputCurrentType(IMFTransform *iface, DWORD id, IMFMediaType **type)
+{
+    FIXME("iface %p, id %u, type %p stub!\n", iface, id, type);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI aac_decoder_GetOutputCurrentType(IMFTransform *iface, DWORD id, IMFMediaType **type)
+{
+    FIXME("iface %p, id %u, type %p stub!\n", iface, id, type);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI aac_decoder_GetInputStatus(IMFTransform *iface, DWORD id, DWORD *flags)
+{
+    FIXME("iface %p, id %u, flags %p stub!\n", iface, id, flags);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI aac_decoder_GetOutputStatus(IMFTransform *iface, DWORD *flags)
+{
+    FIXME("iface %p, flags %p stub!\n", iface, flags);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI aac_decoder_SetOutputBounds(IMFTransform *iface, LONGLONG lower, LONGLONG upper)
+{
+    FIXME("iface %p, lower %s, upper %s stub!\n", iface,
+            wine_dbgstr_longlong(lower), wine_dbgstr_longlong(upper));
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI aac_decoder_ProcessEvent(IMFTransform *iface, DWORD id, IMFMediaEvent *event)
+{
+    FIXME("iface %p, id %u, event %p stub!\n", iface, id, event);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI aac_decoder_ProcessMessage(IMFTransform *iface, MFT_MESSAGE_TYPE message, ULONG_PTR param)
+{
+    FIXME("iface %p, message %#x, param %p stub!\n", iface, message, (void *)param);
+    return S_OK;
+}
+
+static HRESULT WINAPI aac_decoder_ProcessInput(IMFTransform *iface, DWORD id, IMFSample *sample, DWORD flags)
+{
+    struct aac_decoder *decoder = impl_from_IMFTransform(iface);
+    IMFMediaBuffer *media_buffer;
+    MFT_INPUT_STREAM_INFO info;
+    UINT32 buffer_size;
+    BYTE *buffer;
+    HRESULT hr;
+
+    TRACE("iface %p, id %u, sample %p, flags %#x.\n", iface, id, sample, flags);
+
+    if (FAILED(hr = IMFTransform_GetInputStreamInfo(iface, 0, &info)))
+        return hr;
+
+    if (!decoder->wg_transform)
+        return MF_E_TRANSFORM_TYPE_NOT_SET;
+
+    if (decoder->input_sample)
+        return MF_E_NOTACCEPTING;
+
+    if (FAILED(hr = IMFSample_ConvertToContiguousBuffer(sample, &media_buffer)))
+        return hr;
+
+    if (FAILED(hr = IMFMediaBuffer_Lock(media_buffer, &buffer, NULL, &buffer_size)))
+        goto done;
+
+    if (SUCCEEDED(hr = wg_transform_push_data(decoder->wg_transform, buffer, buffer_size)))
+        IMFSample_AddRef((decoder->input_sample = sample));
+
+    IMFMediaBuffer_Unlock(media_buffer);
+
+done:
+    IMFMediaBuffer_Release(media_buffer);
+    return hr;
+}
+
+static HRESULT WINAPI aac_decoder_ProcessOutput(IMFTransform *iface, DWORD flags, DWORD count,
+        MFT_OUTPUT_DATA_BUFFER *samples, DWORD *status)
+{
+    struct aac_decoder *decoder = impl_from_IMFTransform(iface);
+    struct wg_sample wg_sample = {0};
+    IMFMediaBuffer *media_buffer;
+    MFT_OUTPUT_STREAM_INFO info;
+    HRESULT hr;
+
+    TRACE("iface %p, flags %#x, count %u, samples %p, status %p.\n", iface, flags, count, samples, status);
+
+    if (count > 1)
+    {
+        FIXME("Not implemented count %u\n", count);
+        return E_NOTIMPL;
+    }
+
+    if (FAILED(hr = IMFTransform_GetOutputStreamInfo(iface, 0, &info)))
+        return hr;
+
+    if (!decoder->wg_transform)
+        return MF_E_TRANSFORM_TYPE_NOT_SET;
+
+    *status = 0;
+    samples[0].dwStatus = 0;
+    if (!samples[0].pSample)
+    {
+        samples[0].dwStatus = MFT_OUTPUT_DATA_BUFFER_NO_SAMPLE;
+        return MF_E_TRANSFORM_NEED_MORE_INPUT;
+    }
+
+    if (FAILED(hr = IMFSample_ConvertToContiguousBuffer(samples[0].pSample, &media_buffer)))
+        return hr;
+
+    if (FAILED(hr = IMFMediaBuffer_Lock(media_buffer, &wg_sample.data, &wg_sample.size, NULL)))
+        goto done;
+
+    if (wg_sample.size < info.cbSize)
+        hr = MF_E_BUFFERTOOSMALL;
+    else if (SUCCEEDED(hr = wg_transform_read_data(decoder->wg_transform, &wg_sample)))
+    {
+        if (wg_sample.flags & WG_SAMPLE_FLAG_INCOMPLETE)
+            samples[0].dwStatus |= MFT_OUTPUT_DATA_BUFFER_INCOMPLETE;
+    }
+    else
+    {
+        if (decoder->input_sample)
+            IMFSample_Release(decoder->input_sample);
+        decoder->input_sample = NULL;
+    }
+
+    IMFMediaBuffer_Unlock(media_buffer);
+
+done:
+    IMFMediaBuffer_SetCurrentLength(media_buffer, wg_sample.size);
+    IMFMediaBuffer_Release(media_buffer);
+    return hr;
+}
+
+static const IMFTransformVtbl aac_decoder_vtbl =
+{
+    aac_decoder_QueryInterface,
+    aac_decoder_AddRef,
+    aac_decoder_Release,
+    aac_decoder_GetStreamLimits,
+    aac_decoder_GetStreamCount,
+    aac_decoder_GetStreamIDs,
+    aac_decoder_GetInputStreamInfo,
+    aac_decoder_GetOutputStreamInfo,
+    aac_decoder_GetAttributes,
+    aac_decoder_GetInputStreamAttributes,
+    aac_decoder_GetOutputStreamAttributes,
+    aac_decoder_DeleteInputStream,
+    aac_decoder_AddInputStreams,
+    aac_decoder_GetInputAvailableType,
+    aac_decoder_GetOutputAvailableType,
+    aac_decoder_SetInputType,
+    aac_decoder_SetOutputType,
+    aac_decoder_GetInputCurrentType,
+    aac_decoder_GetOutputCurrentType,
+    aac_decoder_GetInputStatus,
+    aac_decoder_GetOutputStatus,
+    aac_decoder_SetOutputBounds,
+    aac_decoder_ProcessEvent,
+    aac_decoder_ProcessMessage,
+    aac_decoder_ProcessInput,
+    aac_decoder_ProcessOutput,
+};
+
+HRESULT aac_decoder_create(REFIID riid, void **ret)
+{
+    struct aac_decoder *decoder;
+
+    TRACE("riid %s, ret %p.\n", debugstr_guid(riid), ret);
+
+    if (!(decoder = calloc(1, sizeof(*decoder))))
+        return E_OUTOFMEMORY;
+
+    decoder->IMFTransform_iface.lpVtbl = &aac_decoder_vtbl;
+    decoder->refcount = 1;
+
+    *ret = &decoder->IMFTransform_iface;
+    TRACE("Created decoder %p\n", *ret);
+    return S_OK;
+}
diff --git a/dlls/mfplat/audioconvert.c b/dlls/mfplat/audioconvert.c
new file mode 100644
index 00000000000..2e16c9c78f5
--- /dev/null
+++ wine/dlls/mfplat/audioconvert.c
@@ -0,0 +1,910 @@
+/* GStreamer Audio Converter
+ *
+ * Copyright 2020 Derek Lesho
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "gst_private.h"
+
+#include "mfapi.h"
+#include "mferror.h"
+#include "ks.h"
+#include "ksmedia.h"
+
+#include "wine/debug.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(mfplat);
+
+struct audio_converter
+{
+    IMFTransform IMFTransform_iface;
+    LONG refcount;
+    IMFMediaType *input_type;
+    IMFMediaType *output_type;
+    CRITICAL_SECTION cs;
+    BOOL buffer_inflight;
+    LONGLONG buffer_pts, buffer_dur;
+    struct wg_parser *parser;
+    struct wg_parser_stream *stream;
+    IMFAttributes *attributes, *output_attributes;
+};
+
+static struct audio_converter *impl_audio_converter_from_IMFTransform(IMFTransform *iface)
+{
+    return CONTAINING_RECORD(iface, struct audio_converter, IMFTransform_iface);
+}
+
+static HRESULT WINAPI audio_converter_QueryInterface(IMFTransform *iface, REFIID riid, void **obj)
+{
+    TRACE("%p, %s, %p.\n", iface, debugstr_guid(riid), obj);
+
+    if (IsEqualIID(riid, &IID_IMFTransform) ||
+            IsEqualIID(riid, &IID_IUnknown))
+    {
+        *obj = iface;
+        IMFTransform_AddRef(iface);
+        return S_OK;
+    }
+
+    WARN("Unsupported %s.\n", debugstr_guid(riid));
+    *obj = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI audio_converter_AddRef(IMFTransform *iface)
+{
+    struct audio_converter *transform = impl_audio_converter_from_IMFTransform(iface);
+    ULONG refcount = InterlockedIncrement(&transform->refcount);
+
+    TRACE("%p, refcount %u.\n", iface, refcount);
+
+    return refcount;
+}
+
+static ULONG WINAPI audio_converter_Release(IMFTransform *iface)
+{
+    struct audio_converter *transform = impl_audio_converter_from_IMFTransform(iface);
+    ULONG refcount = InterlockedDecrement(&transform->refcount);
+
+    TRACE("%p, refcount %u.\n", iface, refcount);
+
+    if (!refcount)
+    {
+        transform->cs.DebugInfo->Spare[0] = 0;
+        DeleteCriticalSection(&transform->cs);
+        if (transform->attributes)
+            IMFAttributes_Release(transform->attributes);
+        if (transform->output_attributes)
+            IMFAttributes_Release(transform->output_attributes);
+        if (transform->stream)
+            wg_parser_disconnect(transform->parser);
+        if (transform->parser)
+            wg_parser_destroy(transform->parser);
+        free(transform);
+    }
+
+    return refcount;
+}
+
+static HRESULT WINAPI audio_converter_GetStreamLimits(IMFTransform *iface, DWORD *input_minimum, DWORD *input_maximum,
+        DWORD *output_minimum, DWORD *output_maximum)
+{
+    TRACE("%p, %p, %p, %p, %p.\n", iface, input_minimum, input_maximum, output_minimum, output_maximum);
+
+    *input_minimum = *input_maximum = *output_minimum = *output_maximum = 1;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI audio_converter_GetStreamCount(IMFTransform *iface, DWORD *inputs, DWORD *outputs)
+{
+    TRACE("%p, %p, %p.\n", iface, inputs, outputs);
+
+    *inputs = *outputs = 1;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI audio_converter_GetStreamIDs(IMFTransform *iface, DWORD input_size, DWORD *inputs,
+        DWORD output_size, DWORD *outputs)
+{
+    TRACE("%p %u %p %u %p.\n", iface, input_size, inputs, output_size, outputs);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI audio_converter_GetInputStreamInfo(IMFTransform *iface, DWORD id, MFT_INPUT_STREAM_INFO *info)
+{
+    struct audio_converter *converter = impl_audio_converter_from_IMFTransform(iface);
+
+    TRACE("%p %u %p.\n", iface, id, info);
+
+    if (id != 0)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    info->dwFlags = MFT_INPUT_STREAM_WHOLE_SAMPLES | MFT_INPUT_STREAM_DOES_NOT_ADDREF;
+    info->cbMaxLookahead = 0;
+    info->cbAlignment = 0;
+    info->hnsMaxLatency = 0;
+    info->cbSize = 0;
+
+    EnterCriticalSection(&converter->cs);
+
+    if (converter->input_type)
+        IMFMediaType_GetUINT32(converter->input_type, &MF_MT_AUDIO_BLOCK_ALIGNMENT, &info->cbSize);
+
+    LeaveCriticalSection(&converter->cs);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI audio_converter_GetOutputStreamInfo(IMFTransform *iface, DWORD id, MFT_OUTPUT_STREAM_INFO *info)
+{
+    struct audio_converter *converter = impl_audio_converter_from_IMFTransform(iface);
+
+    TRACE("%p %u %p.\n", iface, id, info);
+
+    if (id != 0)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    info->dwFlags = MFT_OUTPUT_STREAM_CAN_PROVIDE_SAMPLES | MFT_OUTPUT_STREAM_WHOLE_SAMPLES;
+    info->cbAlignment = 0;
+    info->cbSize = 0;
+
+    EnterCriticalSection(&converter->cs);
+
+    if (converter->output_type)
+        IMFMediaType_GetUINT32(converter->output_type, &MF_MT_AUDIO_BLOCK_ALIGNMENT, &info->cbSize);
+
+    LeaveCriticalSection(&converter->cs);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI audio_converter_GetAttributes(IMFTransform *iface, IMFAttributes **attributes)
+{
+    struct audio_converter *converter = impl_audio_converter_from_IMFTransform(iface);
+
+    TRACE("%p, %p.\n", iface, attributes);
+
+    *attributes = converter->attributes;
+    IMFAttributes_AddRef(*attributes);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI audio_converter_GetInputStreamAttributes(IMFTransform *iface, DWORD id,
+        IMFAttributes **attributes)
+{
+    FIXME("%p, %u, %p.\n", iface, id, attributes);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI audio_converter_GetOutputStreamAttributes(IMFTransform *iface, DWORD id,
+        IMFAttributes **attributes)
+{
+    struct audio_converter *converter = impl_audio_converter_from_IMFTransform(iface);
+
+    TRACE("%p, %u, %p.\n", iface, id, attributes);
+
+    if (id != 0)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    *attributes = converter->output_attributes;
+    IMFAttributes_AddRef(*attributes);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI audio_converter_DeleteInputStream(IMFTransform *iface, DWORD id)
+{
+    TRACE("%p, %u.\n", iface, id);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI audio_converter_AddInputStreams(IMFTransform *iface, DWORD streams, DWORD *ids)
+{
+    TRACE("%p, %u, %p.\n", iface, streams, ids);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI audio_converter_GetInputAvailableType(IMFTransform *iface, DWORD id, DWORD index,
+        IMFMediaType **type)
+{
+    IMFMediaType *ret;
+    HRESULT hr;
+
+    TRACE("%p, %u, %u, %p.\n", iface, id, index, type);
+
+    if (id != 0)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    if (index >= 2)
+        return MF_E_NO_MORE_TYPES;
+
+    if (FAILED(hr = MFCreateMediaType(&ret)))
+        return hr;
+
+    if (FAILED(hr = IMFMediaType_SetGUID(ret, &MF_MT_MAJOR_TYPE, &MFMediaType_Audio)))
+    {
+        IMFMediaType_Release(ret);
+        return hr;
+    }
+
+    if (FAILED(hr = IMFMediaType_SetGUID(ret, &MF_MT_SUBTYPE, index ? &MFAudioFormat_Float : &MFAudioFormat_PCM)))
+    {
+        IMFMediaType_Release(ret);
+        return hr;
+    }
+
+    *type = ret;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI audio_converter_GetOutputAvailableType(IMFTransform *iface, DWORD id, DWORD index,
+        IMFMediaType **type)
+{
+    IMFMediaType *output_type;
+    HRESULT hr;
+
+    static const struct
+    {
+        const GUID *subtype;
+        DWORD depth;
+    }
+    formats[] =
+    {
+        {&MFAudioFormat_PCM, 16},
+        {&MFAudioFormat_PCM, 24},
+        {&MFAudioFormat_PCM, 32},
+        {&MFAudioFormat_Float, 32},
+    };
+
+    static const DWORD rates[] = {44100, 48000};
+    static const DWORD channel_cnts[] = {1, 2, 6};
+    const GUID *subtype;
+    DWORD rate, channels, bps;
+
+    TRACE("%p, %u, %u, %p.\n", iface, id, index, type);
+
+    if (id != 0)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    if (index >= ARRAY_SIZE(formats) * 2/*rates*/ * 3/*layouts*/)
+        return MF_E_NO_MORE_TYPES;
+
+    if (FAILED(hr = MFCreateMediaType(&output_type)))
+        return hr;
+
+    subtype = formats[index / 6].subtype;
+    bps = formats[index / 6].depth;
+    rate = rates[index % 2];
+    channels = channel_cnts[(index / 2) % 3];
+
+    if (FAILED(hr = IMFMediaType_SetGUID(output_type, &MF_MT_MAJOR_TYPE, &MFMediaType_Audio)))
+        goto fail;
+    if (FAILED(hr = IMFMediaType_SetGUID(output_type, &MF_MT_SUBTYPE, subtype)))
+        goto fail;
+    if (FAILED(hr = IMFMediaType_SetUINT32(output_type, &MF_MT_AUDIO_SAMPLES_PER_SECOND, rate)))
+        goto fail;
+    if (FAILED(hr = IMFMediaType_SetUINT32(output_type, &MF_MT_AUDIO_NUM_CHANNELS, channels)))
+        goto fail;
+    if (FAILED(hr = IMFMediaType_SetUINT32(output_type, &MF_MT_AUDIO_BITS_PER_SAMPLE, bps)))
+        goto fail;
+
+    if (FAILED(hr = IMFMediaType_SetUINT32(output_type, &MF_MT_AUDIO_BLOCK_ALIGNMENT, channels * bps / 8)))
+        goto fail;
+    if (FAILED(hr = IMFMediaType_SetUINT32(output_type, &MF_MT_AUDIO_AVG_BYTES_PER_SECOND, rate * channels * bps / 8)))
+        goto fail;
+    if (FAILED(hr = IMFMediaType_SetUINT32(output_type, &MF_MT_AUDIO_CHANNEL_MASK,
+            channels == 1 ? KSAUDIO_SPEAKER_MONO :
+            channels == 2 ? KSAUDIO_SPEAKER_STEREO :
+          /*channels == 6*/ KSAUDIO_SPEAKER_5POINT1)))
+        goto fail;
+    if (FAILED(hr = IMFMediaType_SetUINT32(output_type, &MF_MT_ALL_SAMPLES_INDEPENDENT, TRUE)))
+        goto fail;
+
+    *type = output_type;
+
+    return S_OK;
+fail:
+    IMFMediaType_Release(output_type);
+    return hr;
+}
+
+static HRESULT WINAPI audio_converter_SetInputType(IMFTransform *iface, DWORD id, IMFMediaType *type, DWORD flags)
+{
+    GUID major_type, subtype;
+    struct wg_format format;
+    DWORD unused;
+    HRESULT hr;
+
+    struct audio_converter *converter = impl_audio_converter_from_IMFTransform(iface);
+
+    TRACE("%p, %u, %p, %#x.\n", iface, id, type, flags);
+
+    if (id != 0)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    if (!type)
+    {
+        if (flags & MFT_SET_TYPE_TEST_ONLY)
+            return S_OK;
+
+        EnterCriticalSection(&converter->cs);
+
+        if (converter->input_type)
+        {
+            if (converter->stream)
+            {
+                wg_parser_disconnect(converter->parser);
+                converter->stream = NULL;
+            }
+            IMFMediaType_Release(converter->input_type);
+            converter->input_type = NULL;
+        }
+
+        LeaveCriticalSection(&converter->cs);
+
+        return S_OK;
+    }
+
+    if (FAILED(IMFMediaType_GetGUID(type, &MF_MT_MAJOR_TYPE, &major_type)))
+        return MF_E_INVALIDTYPE;
+    if (FAILED(IMFMediaType_GetGUID(type, &MF_MT_SUBTYPE, &subtype)))
+        return MF_E_INVALIDTYPE;
+    if (FAILED(IMFMediaType_GetUINT32(type, &MF_MT_AUDIO_SAMPLES_PER_SECOND, &unused)))
+        return MF_E_INVALIDTYPE;
+    if (FAILED(IMFMediaType_GetUINT32(type, &MF_MT_AUDIO_NUM_CHANNELS, &unused)))
+        return MF_E_INVALIDTYPE;
+    if (IsEqualGUID(&subtype, &MFAudioFormat_PCM) && FAILED(IMFMediaType_GetUINT32(type, &MF_MT_AUDIO_BITS_PER_SAMPLE, &unused)))
+        return MF_E_INVALIDTYPE;
+
+    if (!(IsEqualGUID(&major_type, &MFMediaType_Audio)))
+        return MF_E_INVALIDTYPE;
+
+    if (!IsEqualGUID(&subtype, &MFAudioFormat_PCM) && !IsEqualGUID(&subtype, &MFAudioFormat_Float))
+        return MF_E_INVALIDTYPE;
+
+    mf_media_type_to_wg_format(type, &format);
+    if (!format.major_type)
+        return MF_E_INVALIDTYPE;
+
+    if (flags & MFT_SET_TYPE_TEST_ONLY)
+        return S_OK;
+
+    EnterCriticalSection(&converter->cs);
+
+    hr = S_OK;
+
+    if (!converter->input_type)
+        hr = MFCreateMediaType(&converter->input_type);
+
+    if (SUCCEEDED(hr))
+        hr = IMFMediaType_CopyAllItems(type, (IMFAttributes *) converter->input_type);
+
+    if (FAILED(hr))
+    {
+        IMFMediaType_Release(converter->input_type);
+        converter->input_type = NULL;
+    }
+
+    if (converter->stream)
+    {
+        wg_parser_disconnect(converter->parser);
+        converter->stream = NULL;
+    }
+
+    if (converter->input_type && converter->output_type)
+    {
+        struct wg_format output_format;
+        mf_media_type_to_wg_format(converter->output_type, &output_format);
+
+        if (SUCCEEDED(hr = wg_parser_connect_unseekable(converter->parser, &format, 1, &output_format, NULL)))
+            converter->stream = wg_parser_get_stream(converter->parser, 0);
+    }
+
+    LeaveCriticalSection(&converter->cs);
+
+    return hr;
+}
+
+static HRESULT WINAPI audio_converter_SetOutputType(IMFTransform *iface, DWORD id, IMFMediaType *type, DWORD flags)
+{
+    struct audio_converter *converter = impl_audio_converter_from_IMFTransform(iface);
+    GUID major_type, subtype;
+    struct wg_format format;
+    DWORD unused;
+    HRESULT hr;
+
+    TRACE("%p, %u, %p, %#x.\n", iface, id, type, flags);
+
+    if (id != 0)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    if (!type)
+    {
+        if (flags & MFT_SET_TYPE_TEST_ONLY)
+            return S_OK;
+
+        EnterCriticalSection(&converter->cs);
+
+        if (converter->output_type)
+        {
+            if (converter->stream)
+            {
+                wg_parser_disconnect(converter->parser);
+                converter->stream = NULL;
+            }
+            IMFMediaType_Release(converter->output_type);
+            converter->output_type = NULL;
+        }
+
+        LeaveCriticalSection(&converter->cs);
+
+        return S_OK;
+    }
+
+    if (FAILED(IMFMediaType_GetGUID(type, &MF_MT_MAJOR_TYPE, &major_type)))
+        return MF_E_INVALIDTYPE;
+    if (FAILED(IMFMediaType_GetGUID(type, &MF_MT_SUBTYPE, &subtype)))
+        return MF_E_INVALIDTYPE;
+    if (FAILED(IMFMediaType_GetUINT32(type, &MF_MT_AUDIO_NUM_CHANNELS, &unused)))
+        return MF_E_INVALIDTYPE;
+    if (IsEqualGUID(&subtype, &MFAudioFormat_PCM) && FAILED(IMFMediaType_GetUINT32(type, &MF_MT_AUDIO_BITS_PER_SAMPLE, &unused)))
+        return MF_E_INVALIDTYPE;
+    if (FAILED(IMFMediaType_GetUINT32(type, &MF_MT_AUDIO_SAMPLES_PER_SECOND, &unused)))
+        return MF_E_INVALIDTYPE;
+
+    if (!(IsEqualGUID(&major_type, &MFMediaType_Audio)))
+        return MF_E_INVALIDTYPE;
+
+    if (!IsEqualGUID(&subtype, &MFAudioFormat_PCM) && !IsEqualGUID(&subtype, &MFAudioFormat_Float))
+        return MF_E_INVALIDTYPE;
+
+    mf_media_type_to_wg_format(type, &format);
+    if (!format.major_type)
+        return MF_E_INVALIDTYPE;
+
+    if (flags & MFT_SET_TYPE_TEST_ONLY)
+        return S_OK;
+
+    EnterCriticalSection(&converter->cs);
+
+    hr = S_OK;
+
+    if (!converter->output_type)
+        hr = MFCreateMediaType(&converter->output_type);
+
+    if (SUCCEEDED(hr))
+        hr = IMFMediaType_CopyAllItems(type, (IMFAttributes *) converter->output_type);
+
+    if (FAILED(hr))
+    {
+        IMFMediaType_Release(converter->output_type);
+        converter->output_type = NULL;
+    }
+
+    if (converter->stream)
+    {
+        wg_parser_disconnect(converter->parser);
+        converter->stream = NULL;
+    }
+
+    if (converter->input_type && converter->output_type)
+    {
+        struct wg_format input_format;
+        mf_media_type_to_wg_format(converter->input_type, &input_format);
+
+        if (SUCCEEDED(hr = wg_parser_connect_unseekable(converter->parser, &input_format, 1, &format, NULL)))
+            converter->stream = wg_parser_get_stream(converter->parser, 0);
+    }
+
+    LeaveCriticalSection(&converter->cs);
+
+    return hr;
+}
+
+static HRESULT WINAPI audio_converter_GetInputCurrentType(IMFTransform *iface, DWORD id, IMFMediaType **type)
+{
+    struct audio_converter *converter = impl_audio_converter_from_IMFTransform(iface);
+    IMFMediaType *ret;
+    HRESULT hr;
+
+    TRACE("%p, %u, %p.\n", converter, id, type);
+
+    if (id != 0)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    if (FAILED(hr = MFCreateMediaType(&ret)))
+        return hr;
+
+    EnterCriticalSection(&converter->cs);
+
+    if (converter->input_type)
+        hr = IMFMediaType_CopyAllItems(converter->input_type, (IMFAttributes *)ret);
+    else
+        hr = MF_E_TRANSFORM_TYPE_NOT_SET;
+
+    LeaveCriticalSection(&converter->cs);
+
+    if (SUCCEEDED(hr))
+        *type = ret;
+    else
+        IMFMediaType_Release(ret);
+
+    return hr;
+}
+
+static HRESULT WINAPI audio_converter_GetOutputCurrentType(IMFTransform *iface, DWORD id, IMFMediaType **type)
+{
+    struct audio_converter *converter = impl_audio_converter_from_IMFTransform(iface);
+    IMFMediaType *ret;
+    HRESULT hr;
+
+    TRACE("%p, %u, %p.\n", converter, id, type);
+
+    if (id != 0)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    if (FAILED(hr = MFCreateMediaType(&ret)))
+        return hr;
+
+    EnterCriticalSection(&converter->cs);
+
+    if (converter->output_type)
+        hr = IMFMediaType_CopyAllItems(converter->output_type, (IMFAttributes *)ret);
+    else
+        hr = MF_E_TRANSFORM_TYPE_NOT_SET;
+
+    LeaveCriticalSection(&converter->cs);
+
+    if (SUCCEEDED(hr))
+        *type = ret;
+    else
+        IMFMediaType_Release(ret);
+
+    return hr;
+}
+
+static HRESULT WINAPI audio_converter_GetInputStatus(IMFTransform *iface, DWORD id, DWORD *flags)
+{
+    FIXME("%p, %u, %p.\n", iface, id, flags);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI audio_converter_GetOutputStatus(IMFTransform *iface, DWORD *flags)
+{
+    FIXME("%p, %p.\n", iface, flags);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI audio_converter_SetOutputBounds(IMFTransform *iface, LONGLONG lower, LONGLONG upper)
+{
+    FIXME("%p, %s, %s.\n", iface, wine_dbgstr_longlong(lower), wine_dbgstr_longlong(upper));
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI audio_converter_ProcessEvent(IMFTransform *iface, DWORD id, IMFMediaEvent *event)
+{
+    TRACE("%p, %u, %p.\n", iface, id, event);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI audio_converter_ProcessMessage(IMFTransform *iface, MFT_MESSAGE_TYPE message, ULONG_PTR param)
+{
+    struct audio_converter *converter = impl_audio_converter_from_IMFTransform(iface);
+    struct wg_parser_buffer wg_buffer;
+
+    TRACE("%p, %u %lu.\n", iface, message, param);
+
+    switch(message)
+    {
+        case MFT_MESSAGE_COMMAND_FLUSH:
+        {
+            EnterCriticalSection(&converter->cs);
+            if (!converter->buffer_inflight)
+            {
+                LeaveCriticalSection(&converter->cs);
+                return S_OK;
+            }
+
+            wg_parser_stream_get_buffer(converter->stream, &wg_buffer);
+            wg_parser_stream_release_buffer(converter->stream);
+            converter->buffer_inflight = FALSE;
+
+            LeaveCriticalSection(&converter->cs);
+            return S_OK;
+        }
+        case MFT_MESSAGE_NOTIFY_BEGIN_STREAMING:
+            return S_OK;
+        default:
+            FIXME("Unhandled message type %x.\n", message);
+            return E_NOTIMPL;
+    }
+}
+
+static HRESULT WINAPI audio_converter_ProcessInput(IMFTransform *iface, DWORD id, IMFSample *sample, DWORD flags)
+{
+    struct audio_converter *converter = impl_audio_converter_from_IMFTransform(iface);
+    IMFMediaBuffer *buffer = NULL;
+    unsigned char *buffer_data;
+    DWORD buffer_size;
+    uint64_t offset;
+    uint32_t size;
+    HRESULT hr;
+
+    TRACE("%p, %u, %p, %#x.\n", iface, id, sample, flags);
+
+    if (flags)
+        WARN("Unsupported flags %#x.\n", flags);
+
+    if (id != 0)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    EnterCriticalSection(&converter->cs);
+
+    if (!converter->stream)
+    {
+        hr = MF_E_TRANSFORM_TYPE_NOT_SET;
+        goto done;
+    }
+
+    if (converter->buffer_inflight)
+    {
+        hr = MF_E_NOTACCEPTING;
+        goto done;
+    }
+
+    if (FAILED(hr = IMFSample_ConvertToContiguousBuffer(sample, &buffer)))
+        goto done;
+
+    if (FAILED(hr = IMFMediaBuffer_Lock(buffer, &buffer_data, NULL, &buffer_size)))
+        goto done;
+
+    if (!wg_parser_get_next_read_offset(converter->parser, &offset, &size))
+    {
+        hr = MF_E_UNEXPECTED;
+        IMFMediaBuffer_Unlock(buffer);
+        goto done;
+    }
+
+    wg_parser_push_data(converter->parser, WG_READ_SUCCESS, buffer_data, buffer_size);
+
+    IMFMediaBuffer_Unlock(buffer);
+    converter->buffer_inflight = TRUE;
+    if (FAILED(IMFSample_GetSampleTime(sample, &converter->buffer_pts)))
+        converter->buffer_pts = -1;
+    if (FAILED(IMFSample_GetSampleDuration(sample, &converter->buffer_dur)))
+        converter->buffer_dur = -1;
+
+done:
+    if (buffer)
+        IMFMediaBuffer_Release(buffer);
+    LeaveCriticalSection(&converter->cs);
+    return hr;
+}
+
+static HRESULT WINAPI audio_converter_ProcessOutput(IMFTransform *iface, DWORD flags, DWORD count,
+        MFT_OUTPUT_DATA_BUFFER *samples, DWORD *status)
+{
+    struct audio_converter *converter = impl_audio_converter_from_IMFTransform(iface);
+    IMFSample *allocated_sample = NULL;
+    struct wg_parser_buffer wg_buffer;
+    IMFMediaBuffer *buffer = NULL;
+    unsigned char *buffer_data;
+    DWORD buffer_len;
+    HRESULT hr = S_OK;
+
+    TRACE("%p, %#x, %u, %p, %p.\n", iface, flags, count, samples, status);
+
+    if (flags)
+        WARN("Unsupported flags %#x.\n", flags);
+
+    if (!count)
+        return S_OK;
+
+    if (count != 1)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    if (samples[0].dwStreamID != 0)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    EnterCriticalSection(&converter->cs);
+
+    if (!converter->stream)
+    {
+        hr = MF_E_TRANSFORM_TYPE_NOT_SET;
+        goto done;
+    }
+
+    if (!converter->buffer_inflight)
+    {
+        hr = MF_E_TRANSFORM_NEED_MORE_INPUT;
+        goto done;
+    }
+
+    if (!wg_parser_stream_get_buffer(converter->stream, &wg_buffer))
+        assert(0);
+
+    if (!samples[0].pSample)
+    {
+        if (FAILED(hr = MFCreateMemoryBuffer(wg_buffer.size, &buffer)))
+        {
+            ERR("Failed to create buffer, hr %#x.\n", hr);
+            goto done;
+        }
+
+        if (FAILED(hr = MFCreateSample(&allocated_sample)))
+        {
+            ERR("Failed to create sample, hr %#x.\n", hr);
+            goto done;
+        }
+
+        samples[0].pSample = allocated_sample;
+
+        if (FAILED(hr = IMFSample_AddBuffer(samples[0].pSample, buffer)))
+        {
+            ERR("Failed to add buffer, hr %#x.\n", hr);
+            goto done;
+        }
+
+        IMFMediaBuffer_Release(buffer);
+        buffer = NULL;
+    }
+
+    if (FAILED(hr = IMFSample_ConvertToContiguousBuffer(samples[0].pSample, &buffer)))
+    {
+        ERR("Failed to get buffer from sample, hr %#x.\n", hr);
+        goto done;
+    }
+
+    if (FAILED(hr = IMFMediaBuffer_GetMaxLength(buffer, &buffer_len)))
+    {
+        ERR("Failed to get buffer size, hr %#x.\n", hr);
+        goto done;
+    }
+
+    if (buffer_len < wg_buffer.size)
+    {
+        WARN("Client's buffer is smaller (%u bytes) than the output sample (%u bytes)\n",
+            buffer_len, wg_buffer.size);
+
+        hr = MF_E_BUFFERTOOSMALL;
+        goto done;
+    }
+
+    if (FAILED(hr = IMFMediaBuffer_SetCurrentLength(buffer, wg_buffer.size)))
+    {
+        ERR("Failed to set size, hr %#x.\n", hr);
+        goto done;
+    }
+
+    if (FAILED(hr = IMFMediaBuffer_Lock(buffer, &buffer_data, NULL, NULL)))
+    {
+        ERR("Failed to lock buffer hr %#x.\n", hr);
+        goto done;
+    }
+
+    if (!wg_parser_stream_copy_buffer(converter->stream, buffer_data, 0, wg_buffer.size))
+    {
+        ERR("Failed to copy buffer.\n");
+        IMFMediaBuffer_Unlock(buffer);
+        hr = E_FAIL;
+        goto done;
+    }
+
+    IMFMediaBuffer_Unlock(buffer);
+
+    wg_parser_stream_release_buffer(converter->stream);
+    converter->buffer_inflight = FALSE;
+
+    if (converter->buffer_pts != -1)
+        IMFSample_SetSampleTime(samples[0].pSample, converter->buffer_pts);
+    if (converter->buffer_dur != -1)
+        IMFSample_SetSampleDuration(samples[0].pSample, converter->buffer_dur);
+
+    samples[0].dwStatus = 0;
+    samples[0].pEvents = NULL;
+
+    done:
+    if (buffer)
+        IMFMediaBuffer_Release(buffer);
+    if (allocated_sample && FAILED(hr))
+    {
+        IMFSample_Release(allocated_sample);
+        samples[0].pSample = NULL;
+    }
+    LeaveCriticalSection(&converter->cs);
+    return hr;
+}
+
+static const IMFTransformVtbl audio_converter_vtbl =
+{
+    audio_converter_QueryInterface,
+    audio_converter_AddRef,
+    audio_converter_Release,
+    audio_converter_GetStreamLimits,
+    audio_converter_GetStreamCount,
+    audio_converter_GetStreamIDs,
+    audio_converter_GetInputStreamInfo,
+    audio_converter_GetOutputStreamInfo,
+    audio_converter_GetAttributes,
+    audio_converter_GetInputStreamAttributes,
+    audio_converter_GetOutputStreamAttributes,
+    audio_converter_DeleteInputStream,
+    audio_converter_AddInputStreams,
+    audio_converter_GetInputAvailableType,
+    audio_converter_GetOutputAvailableType,
+    audio_converter_SetInputType,
+    audio_converter_SetOutputType,
+    audio_converter_GetInputCurrentType,
+    audio_converter_GetOutputCurrentType,
+    audio_converter_GetInputStatus,
+    audio_converter_GetOutputStatus,
+    audio_converter_SetOutputBounds,
+    audio_converter_ProcessEvent,
+    audio_converter_ProcessMessage,
+    audio_converter_ProcessInput,
+    audio_converter_ProcessOutput,
+};
+
+HRESULT audio_converter_create(REFIID riid, void **ret)
+{
+    struct audio_converter *object;
+    HRESULT hr;
+
+    TRACE("%s %p\n", debugstr_guid(riid), ret);
+
+    if (!(object = calloc(1, sizeof(*object))))
+        return E_OUTOFMEMORY;
+
+    object->IMFTransform_iface.lpVtbl = &audio_converter_vtbl;
+    object->refcount = 1;
+
+    InitializeCriticalSection(&object->cs);
+    object->cs.DebugInfo->Spare[0] = (DWORD_PTR)(__FILE__ ": audio_converter_lock");
+
+    if (FAILED(hr = MFCreateAttributes(&object->attributes, 0)))
+    {
+        IMFTransform_Release(&object->IMFTransform_iface);
+        return hr;
+    }
+
+    if (FAILED(hr = MFCreateAttributes(&object->output_attributes, 0)))
+    {
+        IMFTransform_Release(&object->IMFTransform_iface);
+        return hr;
+    }
+
+    if (!(object->parser = wg_parser_create(WG_PARSER_AUDIOCONV, true)))
+    {
+        ERR("Failed to create audio converter due to GStreamer error.\n");
+        IMFTransform_Release(&object->IMFTransform_iface);
+        return E_OUTOFMEMORY;
+    }
+
+    *ret = &object->IMFTransform_iface;
+    return S_OK;
+}
diff --git a/dlls/mfplat/buffer.c b/dlls/mfplat/buffer.c
index eada3df18ad..9081dc39eab 100644
--- wine/dlls/mfplat/buffer.c
+++ wine/dlls/mfplat/buffer.c
@@ -18,8 +18,6 @@
 
 #define COBJMACROS
 
-#include <malloc.h>
-
 #include "mfplat_private.h"
 #include "rtworkq.h"
 
@@ -28,6 +26,8 @@
 #include "d3d9.h"
 #include "evr.h"
 
+#include "wine/debug.h"
+
 WINE_DEFAULT_DEBUG_CHANNEL(mfplat);
 
 #define ALIGN_SIZE(size, alignment) (((size) + (alignment)) & ~((alignment)))
@@ -49,7 +49,7 @@ struct buffer
     struct
     {
         BYTE *linear_buffer;
-        DWORD plane_size;
+        unsigned int plane_size;
 
         BYTE *scanline0;
         unsigned int width;
@@ -148,7 +148,7 @@ static ULONG WINAPI memory_buffer_AddRef(IMFMediaBuffer *iface)
     struct buffer *buffer = impl_from_IMFMediaBuffer(iface);
     ULONG refcount = InterlockedIncrement(&buffer->refcount);
 
-    TRACE("%p, refcount %lu.\n", buffer, refcount);
+    TRACE("%p, refcount %u.\n", buffer, refcount);
 
     return refcount;
 }
@@ -158,7 +158,7 @@ static ULONG WINAPI memory_buffer_Release(IMFMediaBuffer *iface)
     struct buffer *buffer = impl_from_IMFMediaBuffer(iface);
     ULONG refcount = InterlockedDecrement(&buffer->refcount);
 
-    TRACE("%p, refcount %lu.\n", iface, refcount);
+    TRACE("%p, refcount %u.\n", iface, refcount);
 
     if (!refcount)
     {
@@ -173,7 +173,7 @@ static ULONG WINAPI memory_buffer_Release(IMFMediaBuffer *iface)
         }
         DeleteCriticalSection(&buffer->cs);
         free(buffer->_2d.linear_buffer);
-        _aligned_free(buffer->data);
+        free(buffer->data);
         free(buffer);
     }
 
@@ -223,7 +223,7 @@ static HRESULT WINAPI memory_buffer_SetCurrentLength(IMFMediaBuffer *iface, DWOR
 {
     struct buffer *buffer = impl_from_IMFMediaBuffer(iface);
 
-    TRACE("%p, %lu.\n", iface, current_length);
+    TRACE("%p, %u.\n", iface, current_length);
 
     if (current_length > buffer->max_length)
         return E_INVALIDARG;
@@ -309,12 +309,8 @@ static HRESULT WINAPI memory_1d_2d_buffer_Lock(IMFMediaBuffer *iface, BYTE **dat
         hr = MF_E_INVALIDREQUEST;
     else if (!buffer->_2d.linear_buffer)
     {
-        if (!(buffer->_2d.linear_buffer = malloc(buffer->_2d.plane_size)))
+        if (!(buffer->_2d.linear_buffer = malloc(ALIGN_SIZE(buffer->_2d.plane_size, MF_64_BYTE_ALIGNMENT))))
             hr = E_OUTOFMEMORY;
-
-        if (SUCCEEDED(hr))
-            copy_image(buffer, buffer->_2d.linear_buffer, buffer->_2d.width, buffer->data, buffer->_2d.pitch,
-                    buffer->_2d.width, buffer->_2d.height);
     }
 
     if (SUCCEEDED(hr))
@@ -384,7 +380,7 @@ static HRESULT WINAPI d3d9_surface_buffer_Lock(IMFMediaBuffer *iface, BYTE **dat
     {
         D3DLOCKED_RECT rect;
 
-        if (!(buffer->_2d.linear_buffer = malloc(buffer->_2d.plane_size)))
+        if (!(buffer->_2d.linear_buffer = malloc(ALIGN_SIZE(buffer->_2d.plane_size, MF_64_BYTE_ALIGNMENT))))
             hr = E_OUTOFMEMORY;
 
         if (SUCCEEDED(hr))
@@ -449,7 +445,7 @@ static HRESULT WINAPI d3d9_surface_buffer_SetCurrentLength(IMFMediaBuffer *iface
 {
     struct buffer *buffer = impl_from_IMFMediaBuffer(iface);
 
-    TRACE("%p, %lu.\n", iface, current_length);
+    TRACE("%p, %u.\n", iface, current_length);
 
     buffer->current_length = current_length;
 
@@ -601,14 +597,14 @@ static HRESULT WINAPI memory_2d_buffer_GetContiguousLength(IMF2DBuffer2 *iface,
 
 static HRESULT WINAPI memory_2d_buffer_ContiguousCopyTo(IMF2DBuffer2 *iface, BYTE *dest_buffer, DWORD dest_length)
 {
-    FIXME("%p, %p, %lu.\n", iface, dest_buffer, dest_length);
+    FIXME("%p, %p, %u.\n", iface, dest_buffer, dest_length);
 
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI memory_2d_buffer_ContiguousCopyFrom(IMF2DBuffer2 *iface, const BYTE *src_buffer, DWORD src_length)
 {
-    FIXME("%p, %p, %lu.\n", iface, src_buffer, src_length);
+    FIXME("%p, %p, %u.\n", iface, src_buffer, src_length);
 
     return E_NOTIMPL;
 }
@@ -670,14 +666,13 @@ static HRESULT WINAPI d3d9_surface_buffer_Lock2D(IMF2DBuffer2 *iface, BYTE **sca
 
     if (buffer->_2d.linear_buffer)
         hr = MF_E_UNEXPECTED;
-    else if (!buffer->_2d.locks)
+    else if (!buffer->_2d.locks++)
     {
         hr = IDirect3DSurface9_LockRect(buffer->d3d9_surface.surface, &buffer->d3d9_surface.rect, NULL, 0);
     }
 
     if (SUCCEEDED(hr))
     {
-        buffer->_2d.locks++;
         *scanline0 = buffer->d3d9_surface.rect.pBits;
         *pitch = buffer->d3d9_surface.rect.Pitch;
     }
@@ -756,14 +751,13 @@ static HRESULT WINAPI d3d9_surface_buffer_Lock2DSize(IMF2DBuffer2 *iface, MF2DBu
 
     if (buffer->_2d.linear_buffer)
         hr = MF_E_UNEXPECTED;
-    else if (!buffer->_2d.locks)
+    else if (!buffer->_2d.locks++)
     {
         hr = IDirect3DSurface9_LockRect(buffer->d3d9_surface.surface, &buffer->d3d9_surface.rect, NULL, 0);
     }
 
     if (SUCCEEDED(hr))
     {
-        buffer->_2d.locks++;
         *scanline0 = buffer->d3d9_surface.rect.pBits;
         *pitch = buffer->d3d9_surface.rect.Pitch;
         if (buffer_start)
@@ -897,7 +891,7 @@ static HRESULT dxgi_surface_buffer_create_readback_texture(struct buffer *buffer
     texture_desc.MiscFlags = 0;
     texture_desc.MipLevels = 1;
     if (FAILED(hr = ID3D11Device_CreateTexture2D(device, &texture_desc, NULL, &buffer->dxgi_surface.rb_texture)))
-        WARN("Failed to create readback texture, hr %#lx.\n", hr);
+        WARN("Failed to create readback texture, hr %#x.\n", hr);
 
     ID3D11Device_Release(device);
 
@@ -922,7 +916,7 @@ static HRESULT dxgi_surface_buffer_map(struct buffer *buffer)
     if (FAILED(hr = ID3D11DeviceContext_Map(immediate_context, (ID3D11Resource *)buffer->dxgi_surface.rb_texture,
             0, D3D11_MAP_READ_WRITE, 0, &buffer->dxgi_surface.map_desc)))
     {
-        WARN("Failed to map readback texture, hr %#lx.\n", hr);
+        WARN("Failed to map readback texture, hr %#x.\n", hr);
     }
 
     ID3D11DeviceContext_Release(immediate_context);
@@ -965,7 +959,7 @@ static HRESULT WINAPI dxgi_surface_buffer_Lock(IMFMediaBuffer *iface, BYTE **dat
         hr = MF_E_INVALIDREQUEST;
     else if (!buffer->_2d.linear_buffer)
     {
-        if (!(buffer->_2d.linear_buffer = malloc(buffer->_2d.plane_size)))
+        if (!(buffer->_2d.linear_buffer = malloc(ALIGN_SIZE(buffer->_2d.plane_size, MF_64_BYTE_ALIGNMENT))))
             hr = E_OUTOFMEMORY;
 
         if (SUCCEEDED(hr))
@@ -1024,7 +1018,7 @@ static HRESULT WINAPI dxgi_surface_buffer_SetCurrentLength(IMFMediaBuffer *iface
 {
     struct buffer *buffer = impl_from_IMFMediaBuffer(iface);
 
-    TRACE("%p, %lu.\n", iface, current_length);
+    TRACE("%p, %u.\n", iface, current_length);
 
     buffer->current_length = current_length;
 
@@ -1262,24 +1256,8 @@ static const IMFDXGIBufferVtbl dxgi_buffer_vtbl =
 static HRESULT memory_buffer_init(struct buffer *buffer, DWORD max_length, DWORD alignment,
         const IMFMediaBufferVtbl *vtbl)
 {
-    if (alignment < MF_16_BYTE_ALIGNMENT)
-        alignment = MF_16_BYTE_ALIGNMENT;
-    alignment++;
-
-    if (alignment & (alignment - 1))
-    {
-        alignment--;
-        alignment |= alignment >> 1;
-        alignment |= alignment >> 2;
-        alignment |= alignment >> 4;
-        alignment |= alignment >> 8;
-        alignment |= alignment >> 16;
-        alignment++;
-    }
-
-    if (!(buffer->data = _aligned_malloc(max_length, alignment)))
+    if (!(buffer->data = calloc(1, ALIGN_SIZE(max_length, alignment))))
         return E_OUTOFMEMORY;
-    memset(buffer->data, 0, max_length);
 
     buffer->IMFMediaBuffer_iface.lpVtbl = vtbl;
     buffer->refcount = 1;
@@ -1328,10 +1306,9 @@ static p_copy_image_func get_2d_buffer_copy_func(DWORD fourcc)
 
 static HRESULT create_2d_buffer(DWORD width, DWORD height, DWORD fourcc, BOOL bottom_up, IMFMediaBuffer **buffer)
 {
-    unsigned int stride, max_length;
-    unsigned int row_alignment;
+    unsigned int stride, max_length, plane_size;
     struct buffer *object;
-    DWORD plane_size;
+    unsigned int row_alignment;
     GUID subtype;
     BOOL is_yuv;
     HRESULT hr;
@@ -1389,7 +1366,7 @@ static HRESULT create_2d_buffer(DWORD width, DWORD height, DWORD fourcc, BOOL bo
             max_length = pitch * height;
     }
 
-    if (FAILED(hr = memory_buffer_init(object, max_length, row_alignment, &memory_1d_2d_buffer_vtbl)))
+    if (FAILED(hr = memory_buffer_init(object, max_length, MF_1_BYTE_ALIGNMENT, &memory_1d_2d_buffer_vtbl)))
     {
         free(object);
         return hr;
@@ -1462,7 +1439,7 @@ static HRESULT create_dxgi_surface_buffer(IUnknown *surface, unsigned int sub_re
 
     if (FAILED(hr = IUnknown_QueryInterface(surface, &IID_ID3D11Texture2D, (void **)&texture)))
     {
-        WARN("Failed to get texture interface, hr %#lx.\n", hr);
+        WARN("Failed to get texture interface, hr %#x.\n", hr);
         return hr;
     }
 
@@ -1514,7 +1491,7 @@ static HRESULT create_dxgi_surface_buffer(IUnknown *surface, unsigned int sub_re
  */
 HRESULT WINAPI MFCreateMemoryBuffer(DWORD max_length, IMFMediaBuffer **buffer)
 {
-    TRACE("%lu, %p.\n", max_length, buffer);
+    TRACE("%u, %p.\n", max_length, buffer);
 
     return create_1d_buffer(max_length, MF_1_BYTE_ALIGNMENT, buffer);
 }
@@ -1524,7 +1501,7 @@ HRESULT WINAPI MFCreateMemoryBuffer(DWORD max_length, IMFMediaBuffer **buffer)
  */
 HRESULT WINAPI MFCreateAlignedMemoryBuffer(DWORD max_length, DWORD alignment, IMFMediaBuffer **buffer)
 {
-    TRACE("%lu, %lu, %p.\n", max_length, alignment, buffer);
+    TRACE("%u, %u, %p.\n", max_length, alignment, buffer);
 
     return create_1d_buffer(max_length, alignment, buffer);
 }
@@ -1534,7 +1511,7 @@ HRESULT WINAPI MFCreateAlignedMemoryBuffer(DWORD max_length, DWORD alignment, IM
  */
 HRESULT WINAPI MFCreate2DMediaBuffer(DWORD width, DWORD height, DWORD fourcc, BOOL bottom_up, IMFMediaBuffer **buffer)
 {
-    TRACE("%lu, %lu, %s, %d, %p.\n", width, height, debugstr_fourcc(fourcc), bottom_up, buffer);
+    TRACE("%u, %u, %s, %d, %p.\n", width, height, debugstr_fourcc(fourcc), bottom_up, buffer);
 
     return create_2d_buffer(width, height, fourcc, bottom_up, buffer);
 }
@@ -1582,7 +1559,7 @@ HRESULT WINAPI MFCreateMediaBufferFromMediaType(IMFMediaType *media_type, LONGLO
     HRESULT hr;
     GUID major;
 
-    TRACE("%p, %s, %lu, %lu, %p.\n", media_type, debugstr_time(duration), min_length, alignment, buffer);
+    TRACE("%p, %s, %u, %u, %p.\n", media_type, debugstr_time(duration), min_length, alignment, buffer);
 
     if (!media_type)
         return E_INVALIDARG;
@@ -1596,8 +1573,6 @@ HRESULT WINAPI MFCreateMediaBufferFromMediaType(IMFMediaType *media_type, LONGLO
         if (FAILED(IMFMediaType_GetUINT32(media_type, &MF_MT_AUDIO_BLOCK_ALIGNMENT, &block_alignment)))
             WARN("Block alignment was not specified.\n");
 
-        alignment = max(16, alignment);
-
         if (block_alignment)
         {
             avg_length = 0;
@@ -1612,6 +1587,8 @@ HRESULT WINAPI MFCreateMediaBufferFromMediaType(IMFMediaType *media_type, LONGLO
                 }
             }
 
+            alignment = max(16, alignment);
+
             length = buffer_get_aligned_length(avg_length + 1, alignment);
             length = buffer_get_aligned_length(length, block_alignment);
         }
@@ -1620,7 +1597,7 @@ HRESULT WINAPI MFCreateMediaBufferFromMediaType(IMFMediaType *media_type, LONGLO
 
         length = max(length, min_length);
 
-        return create_1d_buffer(length, alignment - 1, buffer);
+        return create_1d_buffer(length, MF_1_BYTE_ALIGNMENT, buffer);
     }
     else
         FIXME("Major type %s is not supported.\n", debugstr_guid(&major));
diff --git a/dlls/mfplat/colorconvert.c b/dlls/mfplat/colorconvert.c
new file mode 100644
index 00000000000..92322e877ec
--- /dev/null
+++ wine/dlls/mfplat/colorconvert.c
@@ -0,0 +1,901 @@
+/* GStreamer Color Converter
+ *
+ * Copyright 2020 Derek Lesho
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "gst_private.h"
+
+#include "mfapi.h"
+#include "mferror.h"
+
+#include "wine/debug.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(mfplat);
+
+static const GUID *raw_types[] = {
+    &MFVideoFormat_RGB24,
+    &MFVideoFormat_RGB32,
+    &MFVideoFormat_RGB555,
+    &MFVideoFormat_RGB8,
+    &MFVideoFormat_AYUV,
+    &MFVideoFormat_I420,
+    &MFVideoFormat_IYUV,
+    &MFVideoFormat_NV11,
+    &MFVideoFormat_NV12,
+    &MFVideoFormat_UYVY,
+    &MFVideoFormat_v216,
+    &MFVideoFormat_v410,
+    &MFVideoFormat_YUY2,
+    &MFVideoFormat_YVYU,
+    &MFVideoFormat_YVYU,
+};
+
+struct color_converter
+{
+    IMFTransform IMFTransform_iface;
+    LONG refcount;
+    IMFMediaType *input_type;
+    IMFMediaType *output_type;
+    CRITICAL_SECTION cs;
+    BOOL buffer_inflight;
+    LONGLONG buffer_pts, buffer_dur;
+    struct wg_parser *parser;
+    struct wg_parser_stream *stream;
+};
+
+static struct color_converter *impl_color_converter_from_IMFTransform(IMFTransform *iface)
+{
+    return CONTAINING_RECORD(iface, struct color_converter, IMFTransform_iface);
+}
+
+static HRESULT WINAPI color_converter_QueryInterface(IMFTransform *iface, REFIID riid, void **obj)
+{
+    TRACE("%p, %s, %p.\n", iface, debugstr_guid(riid), obj);
+
+    if (IsEqualGUID(riid, &IID_IMFTransform) ||
+        IsEqualGUID(riid, &IID_IUnknown))
+    {
+        *obj = iface;
+        IMFTransform_AddRef(iface);
+        return S_OK;
+    }
+
+    WARN("Unsupported %s.\n", debugstr_guid(riid));
+    *obj = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI color_converter_AddRef(IMFTransform *iface)
+{
+    struct color_converter *transform = impl_color_converter_from_IMFTransform(iface);
+    ULONG refcount = InterlockedIncrement(&transform->refcount);
+
+    TRACE("%p, refcount %u.\n", iface, refcount);
+
+    return refcount;
+}
+
+static ULONG WINAPI color_converter_Release(IMFTransform *iface)
+{
+    struct color_converter *transform = impl_color_converter_from_IMFTransform(iface);
+    ULONG refcount = InterlockedDecrement(&transform->refcount);
+
+    TRACE("%p, refcount %u.\n", iface, refcount);
+
+    if (!refcount)
+    {
+        transform->cs.DebugInfo->Spare[0] = 0;
+        DeleteCriticalSection(&transform->cs);
+        if (transform->output_type)
+            IMFMediaType_Release(transform->output_type);
+        if (transform->stream)
+            wg_parser_disconnect(transform->parser);
+        if (transform->parser)
+            wg_parser_destroy(transform->parser);
+        free(transform);
+    }
+
+    return refcount;
+}
+
+static HRESULT WINAPI color_converter_GetStreamLimits(IMFTransform *iface, DWORD *input_minimum, DWORD *input_maximum,
+        DWORD *output_minimum, DWORD *output_maximum)
+{
+    TRACE("%p, %p, %p, %p, %p.\n", iface, input_minimum, input_maximum, output_minimum, output_maximum);
+
+    *input_minimum = *input_maximum = *output_minimum = *output_maximum = 1;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI color_converter_GetStreamCount(IMFTransform *iface, DWORD *inputs, DWORD *outputs)
+{
+    TRACE("%p, %p, %p.\n", iface, inputs, outputs);
+
+    *inputs = *outputs = 1;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI color_converter_GetStreamIDs(IMFTransform *iface, DWORD input_size, DWORD *inputs,
+        DWORD output_size, DWORD *outputs)
+{
+    TRACE("%p %u %p %u %p.\n", iface, input_size, inputs, output_size, outputs);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI color_converter_GetInputStreamInfo(IMFTransform *iface, DWORD id, MFT_INPUT_STREAM_INFO *info)
+{
+    struct color_converter *converter = impl_color_converter_from_IMFTransform(iface);
+    UINT64 framesize;
+    GUID subtype;
+
+    TRACE("%p %u %p.\n", iface, id, info);
+
+    if (id != 0)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    info->dwFlags = MFT_INPUT_STREAM_WHOLE_SAMPLES | MFT_INPUT_STREAM_DOES_NOT_ADDREF | MFT_INPUT_STREAM_FIXED_SAMPLE_SIZE;
+    info->cbMaxLookahead = 0;
+    info->cbAlignment = 0;
+    info->hnsMaxLatency = 0;
+    info->cbSize = 0;
+
+    EnterCriticalSection(&converter->cs);
+
+    if (converter->input_type)
+    {
+        if (SUCCEEDED(IMFMediaType_GetGUID(converter->input_type, &MF_MT_SUBTYPE, &subtype)) &&
+            SUCCEEDED(IMFMediaType_GetUINT64(converter->input_type, &MF_MT_FRAME_SIZE, &framesize)))
+        {
+            MFCalculateImageSize(&subtype, framesize >> 32, (UINT32) framesize, &info->cbSize);
+        }
+
+        if (!info->cbSize)
+            WARN("Failed to get desired input buffer size, the non-provided sample path will likely break\n");
+    }
+
+    LeaveCriticalSection(&converter->cs);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI color_converter_GetOutputStreamInfo(IMFTransform *iface, DWORD id, MFT_OUTPUT_STREAM_INFO *info)
+{
+    struct color_converter *converter = impl_color_converter_from_IMFTransform(iface);
+    UINT64 framesize;
+    GUID subtype;
+
+    TRACE("%p %u %p.\n", iface, id, info);
+
+    if (id != 0)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    info->dwFlags = MFT_OUTPUT_STREAM_FIXED_SAMPLE_SIZE | MFT_OUTPUT_STREAM_CAN_PROVIDE_SAMPLES | MFT_OUTPUT_STREAM_WHOLE_SAMPLES | MFT_OUTPUT_STREAM_SINGLE_SAMPLE_PER_BUFFER;
+    info->cbAlignment = 0;
+    info->cbSize = 0;
+
+    EnterCriticalSection(&converter->cs);
+
+    if (converter->output_type)
+    {
+        if (SUCCEEDED(IMFMediaType_GetGUID(converter->output_type, &MF_MT_SUBTYPE, &subtype)) &&
+            SUCCEEDED(IMFMediaType_GetUINT64(converter->output_type, &MF_MT_FRAME_SIZE, &framesize)))
+        {
+            MFCalculateImageSize(&subtype, framesize >> 32, (UINT32) framesize, &info->cbSize);
+        }
+
+        if (!info->cbSize)
+            WARN("Failed to get desired output buffer size, the non-provided sample path will likely break\n");
+    }
+
+    LeaveCriticalSection(&converter->cs);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI color_converter_GetAttributes(IMFTransform *iface, IMFAttributes **attributes)
+{
+    FIXME("%p, %p.\n", iface, attributes);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI color_converter_GetInputStreamAttributes(IMFTransform *iface, DWORD id,
+        IMFAttributes **attributes)
+{
+    FIXME("%p, %u, %p.\n", iface, id, attributes);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI color_converter_GetOutputStreamAttributes(IMFTransform *iface, DWORD id,
+        IMFAttributes **attributes)
+{
+    FIXME("%p, %u, %p.\n", iface, id, attributes);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI color_converter_DeleteInputStream(IMFTransform *iface, DWORD id)
+{
+    TRACE("%p, %u.\n", iface, id);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI color_converter_AddInputStreams(IMFTransform *iface, DWORD streams, DWORD *ids)
+{
+    TRACE("%p, %u, %p.\n", iface, streams, ids);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI color_converter_GetInputAvailableType(IMFTransform *iface, DWORD id, DWORD index,
+        IMFMediaType **type)
+{
+    IMFMediaType *ret;
+    HRESULT hr;
+
+    TRACE("%p, %u, %u, %p.\n", iface, id, index, type);
+
+    if (id != 0)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    if (index >= ARRAY_SIZE(raw_types))
+        return MF_E_NO_MORE_TYPES;
+
+    if (FAILED(hr = MFCreateMediaType(&ret)))
+        return hr;
+
+    if (FAILED(hr = IMFMediaType_SetGUID(ret, &MF_MT_MAJOR_TYPE, &MFMediaType_Video)))
+    {
+        IMFMediaType_Release(ret);
+        return hr;
+    }
+
+    if (FAILED(hr = IMFMediaType_SetGUID(ret, &MF_MT_SUBTYPE, raw_types[index])))
+    {
+        IMFMediaType_Release(ret);
+        return hr;
+    }
+
+    *type = ret;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI color_converter_GetOutputAvailableType(IMFTransform *iface, DWORD id, DWORD index,
+        IMFMediaType **type)
+{
+    struct color_converter *converter = impl_color_converter_from_IMFTransform(iface);
+    IMFMediaType *ret;
+    HRESULT hr;
+
+    TRACE("%p, %u, %u, %p.\n", iface, id, index, type);
+
+    if (id != 0)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    if (index >= ARRAY_SIZE(raw_types))
+        return MF_E_NO_MORE_TYPES;
+
+    if (FAILED(hr = MFCreateMediaType(&ret)))
+        return hr;
+
+    EnterCriticalSection(&converter->cs);
+
+    if (converter->input_type)
+        IMFMediaType_CopyAllItems(converter->input_type, (IMFAttributes *) ret);
+
+    LeaveCriticalSection(&converter->cs);
+
+    if (FAILED(hr = IMFMediaType_SetGUID(ret, &MF_MT_MAJOR_TYPE, &MFMediaType_Video)))
+    {
+        IMFMediaType_Release(ret);
+        return hr;
+    }
+
+    if (FAILED(hr = IMFMediaType_SetGUID(ret, &MF_MT_SUBTYPE, raw_types[index])))
+    {
+        IMFMediaType_Release(ret);
+        return hr;
+    }
+
+    *type = ret;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI color_converter_SetInputType(IMFTransform *iface, DWORD id, IMFMediaType *type, DWORD flags)
+{
+    struct color_converter *converter = impl_color_converter_from_IMFTransform(iface);
+    UINT64 input_framesize, output_framesize;
+    GUID major_type, subtype;
+    struct wg_format format;
+    unsigned int i;
+    HRESULT hr;
+
+    TRACE("%p, %u, %p, %#x.\n", iface, id, type, flags);
+
+    if (id != 0)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    if (!type)
+    {
+        if (flags & MFT_SET_TYPE_TEST_ONLY)
+            return S_OK;
+
+        EnterCriticalSection(&converter->cs);
+
+        if (converter->input_type)
+        {
+            if (converter->stream)
+            {
+                wg_parser_disconnect(converter->parser);
+                converter->stream = NULL;
+            }
+            IMFMediaType_Release(converter->input_type);
+            converter->input_type = NULL;
+        }
+
+        LeaveCriticalSection(&converter->cs);
+
+        return S_OK;
+    }
+
+    if (FAILED(IMFMediaType_GetGUID(type, &MF_MT_MAJOR_TYPE, &major_type)))
+        return MF_E_INVALIDTYPE;
+    if (FAILED(IMFMediaType_GetGUID(type, &MF_MT_SUBTYPE, &subtype)))
+        return MF_E_INVALIDTYPE;
+
+    if (!IsEqualGUID(&major_type, &MFMediaType_Video))
+        return MF_E_INVALIDTYPE;
+
+    for (i = 0; i < ARRAY_SIZE(raw_types); i++)
+    {
+        if (IsEqualGUID(&subtype, raw_types[i]))
+            break;
+    }
+
+    if (i == ARRAY_SIZE(raw_types))
+        return MF_E_INVALIDTYPE;
+
+    EnterCriticalSection(&converter->cs);
+
+    if(converter->output_type
+         && SUCCEEDED(IMFMediaType_GetUINT64(converter->output_type, &MF_MT_FRAME_SIZE, &output_framesize))
+         && SUCCEEDED(IMFMediaType_GetUINT64(type, &MF_MT_FRAME_SIZE, &input_framesize))
+         && input_framesize != output_framesize)
+    {
+        LeaveCriticalSection(&converter->cs);
+        return MF_E_INVALIDTYPE;
+    }
+
+    LeaveCriticalSection(&converter->cs);
+
+    mf_media_type_to_wg_format(type, &format);
+    if (!format.major_type)
+        return MF_E_INVALIDTYPE;
+
+    if (flags & MFT_SET_TYPE_TEST_ONLY)
+        return S_OK;
+
+    EnterCriticalSection(&converter->cs);
+
+    hr = S_OK;
+
+    if (!converter->input_type)
+        hr = MFCreateMediaType(&converter->input_type);
+
+    if (SUCCEEDED(hr))
+        hr = IMFMediaType_CopyAllItems(type, (IMFAttributes *) converter->input_type);
+
+    if (FAILED(hr))
+    {
+        IMFMediaType_Release(converter->input_type);
+        converter->input_type = NULL;
+    }
+
+    if (converter->stream)
+    {
+        wg_parser_disconnect(converter->parser);
+        converter->stream = NULL;
+    }
+
+    if (converter->input_type && converter->output_type)
+    {
+        struct wg_format output_format;
+        mf_media_type_to_wg_format(converter->output_type, &output_format);
+
+        if (SUCCEEDED(hr = wg_parser_connect_unseekable(converter->parser, &format, 1, &output_format, NULL)))
+            converter->stream = wg_parser_get_stream(converter->parser, 0);
+    }
+
+    LeaveCriticalSection(&converter->cs);
+
+    return hr;
+}
+
+static HRESULT WINAPI color_converter_SetOutputType(IMFTransform *iface, DWORD id, IMFMediaType *type, DWORD flags)
+{
+    struct color_converter *converter = impl_color_converter_from_IMFTransform(iface);
+    UINT64 input_framesize, output_framesize;
+    GUID major_type, subtype;
+    struct wg_format format;
+    unsigned int i;
+    HRESULT hr;
+
+    TRACE("%p, %u, %p, %#x.\n", iface, id, type, flags);
+
+    if (id != 0)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    if (!type)
+    {
+        if (flags & MFT_SET_TYPE_TEST_ONLY)
+            return S_OK;
+
+        EnterCriticalSection(&converter->cs);
+
+        if (converter->output_type)
+        {
+            if (converter->stream)
+            {
+                wg_parser_disconnect(converter->parser);
+                converter->stream = NULL;
+            }
+            IMFMediaType_Release(converter->output_type);
+            converter->output_type = NULL;
+        }
+
+        LeaveCriticalSection(&converter->cs);
+
+        return S_OK;
+    }
+
+    if (FAILED(IMFMediaType_GetGUID(type, &MF_MT_MAJOR_TYPE, &major_type)))
+        return MF_E_INVALIDTYPE;
+    if (FAILED(IMFMediaType_GetGUID(type, &MF_MT_SUBTYPE, &subtype)))
+        return MF_E_INVALIDTYPE;
+
+    if (!IsEqualGUID(&major_type, &MFMediaType_Video))
+        return MF_E_INVALIDTYPE;
+
+    for (i = 0; i < ARRAY_SIZE(raw_types); i++)
+    {
+        if (IsEqualGUID(&subtype, raw_types[i]))
+            break;
+    }
+
+    if (i == ARRAY_SIZE(raw_types))
+        return MF_E_INVALIDTYPE;
+
+    EnterCriticalSection(&converter->cs);
+
+    if(converter->input_type
+         && SUCCEEDED(IMFMediaType_GetUINT64(converter->input_type, &MF_MT_FRAME_SIZE, &input_framesize))
+         && SUCCEEDED(IMFMediaType_GetUINT64(type, &MF_MT_FRAME_SIZE, &output_framesize))
+         && input_framesize != output_framesize)
+    {
+        LeaveCriticalSection(&converter->cs);
+        return MF_E_INVALIDTYPE;
+    }
+
+    LeaveCriticalSection(&converter->cs);
+
+    mf_media_type_to_wg_format(type, &format);
+    if (!format.major_type)
+        return MF_E_INVALIDTYPE;
+
+    if (flags & MFT_SET_TYPE_TEST_ONLY)
+        return S_OK;
+
+    EnterCriticalSection(&converter->cs);
+
+    hr = S_OK;
+
+    if (!converter->output_type)
+        hr = MFCreateMediaType(&converter->output_type);
+
+    if (SUCCEEDED(hr))
+        hr = IMFMediaType_CopyAllItems(type, (IMFAttributes *) converter->output_type);
+
+    if (FAILED(hr))
+    {
+        IMFMediaType_Release(converter->output_type);
+        converter->output_type = NULL;
+    }
+
+    if (converter->stream)
+    {
+        wg_parser_disconnect(converter->parser);
+        converter->stream = NULL;
+    }
+
+    if (converter->input_type && converter->output_type)
+    {
+        struct wg_format input_format;
+        mf_media_type_to_wg_format(converter->input_type, &input_format);
+
+        if (SUCCEEDED(hr = wg_parser_connect_unseekable(converter->parser, &input_format, 1, &format, NULL)))
+            converter->stream = wg_parser_get_stream(converter->parser, 0);
+    }
+
+    LeaveCriticalSection(&converter->cs);
+
+    return hr;
+}
+
+static HRESULT WINAPI color_converter_GetInputCurrentType(IMFTransform *iface, DWORD id, IMFMediaType **type)
+{
+    FIXME("%p, %u, %p.\n", iface, id, type);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI color_converter_GetOutputCurrentType(IMFTransform *iface, DWORD id, IMFMediaType **type)
+{
+    struct color_converter *converter = impl_color_converter_from_IMFTransform(iface);
+    IMFMediaType *ret;
+    HRESULT hr;
+
+    TRACE("%p, %u, %p.\n", converter, id, type);
+
+    if (id != 0)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    if (FAILED(hr = MFCreateMediaType(&ret)))
+        return hr;
+
+    EnterCriticalSection(&converter->cs);
+
+    if (converter->output_type)
+        hr = IMFMediaType_CopyAllItems(converter->output_type, (IMFAttributes *)ret);
+    else
+        hr = MF_E_TRANSFORM_TYPE_NOT_SET;
+
+    LeaveCriticalSection(&converter->cs);
+
+    if (SUCCEEDED(hr))
+        *type = ret;
+    else
+        IMFMediaType_Release(ret);
+
+    return hr;
+}
+
+static HRESULT WINAPI color_converter_GetInputStatus(IMFTransform *iface, DWORD id, DWORD *flags)
+{
+    FIXME("%p, %u, %p.\n", iface, id, flags);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI color_converter_GetOutputStatus(IMFTransform *iface, DWORD *flags)
+{
+    FIXME("%p, %p.\n", iface, flags);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI color_converter_SetOutputBounds(IMFTransform *iface, LONGLONG lower, LONGLONG upper)
+{
+    FIXME("%p, %s, %s.\n", iface, wine_dbgstr_longlong(lower), wine_dbgstr_longlong(upper));
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI color_converter_ProcessEvent(IMFTransform *iface, DWORD id, IMFMediaEvent *event)
+{
+    TRACE("%p, %u, %p.\n", iface, id, event);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI color_converter_ProcessMessage(IMFTransform *iface, MFT_MESSAGE_TYPE message, ULONG_PTR param)
+{
+    struct color_converter *converter = impl_color_converter_from_IMFTransform(iface);
+    struct wg_parser_buffer wg_buffer;
+
+    TRACE("%p, %u %lu.\n", iface, message, param);
+
+    switch(message)
+    {
+        case MFT_MESSAGE_COMMAND_FLUSH:
+        {
+            EnterCriticalSection(&converter->cs);
+            if (!converter->buffer_inflight)
+            {
+                LeaveCriticalSection(&converter->cs);
+                return S_OK;
+            }
+
+            wg_parser_stream_get_buffer(converter->stream, &wg_buffer);
+            wg_parser_stream_release_buffer(converter->stream);
+            converter->buffer_inflight = FALSE;
+
+            LeaveCriticalSection(&converter->cs);
+            return S_OK;
+        }
+        case MFT_MESSAGE_NOTIFY_BEGIN_STREAMING:
+            return S_OK;
+        default:
+            FIXME("Unhandled message type %x.\n", message);
+            return E_NOTIMPL;
+    }
+}
+
+static HRESULT WINAPI color_converter_ProcessInput(IMFTransform *iface, DWORD id, IMFSample *sample, DWORD flags)
+{
+    struct color_converter *converter = impl_color_converter_from_IMFTransform(iface);
+    IMFMediaBuffer *buffer = NULL;
+    unsigned char *buffer_data;
+    DWORD buffer_size;
+    uint64_t offset;
+    uint32_t size;
+    HRESULT hr;
+
+    TRACE("%p, %u, %p, %#x.\n", iface, id, sample, flags);
+
+    if (flags)
+        WARN("Unsupported flags %#x.\n", flags);
+
+    if (id != 0)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    EnterCriticalSection(&converter->cs);
+
+    if (!converter->stream)
+    {
+        hr = MF_E_TRANSFORM_TYPE_NOT_SET;
+        goto done;
+    }
+
+    if (converter->buffer_inflight)
+    {
+        hr = MF_E_NOTACCEPTING;
+        goto done;
+    }
+
+    if (FAILED(hr = IMFSample_ConvertToContiguousBuffer(sample, &buffer)))
+        goto done;
+
+    if (FAILED(hr = IMFMediaBuffer_Lock(buffer, &buffer_data, NULL, &buffer_size)))
+        goto done;
+
+    for (;;)
+    {
+        if (!wg_parser_get_next_read_offset(converter->parser, &offset, &size))
+        {
+            TRACE("sink unconnected\n");
+            continue;
+        }
+
+        wg_parser_push_data(converter->parser, WG_READ_SUCCESS, buffer_data, min(buffer_size, size));
+
+        if (buffer_size <= size)
+            break;
+
+        buffer_data += size;
+        buffer_size -= size;
+    }
+
+    IMFMediaBuffer_Unlock(buffer);
+    converter->buffer_inflight = TRUE;
+    if (FAILED(IMFSample_GetSampleTime(sample, &converter->buffer_pts)))
+        converter->buffer_pts = -1;
+    if (FAILED(IMFSample_GetSampleDuration(sample, &converter->buffer_dur)))
+        converter->buffer_dur = -1;
+
+done:
+    if (buffer)
+        IMFMediaBuffer_Release(buffer);
+    LeaveCriticalSection(&converter->cs);
+    return hr;
+}
+
+static HRESULT WINAPI color_converter_ProcessOutput(IMFTransform *iface, DWORD flags, DWORD count,
+        MFT_OUTPUT_DATA_BUFFER *samples, DWORD *status)
+{
+    struct color_converter *converter = impl_color_converter_from_IMFTransform(iface);
+    IMFSample *allocated_sample = NULL;
+    struct wg_parser_buffer wg_buffer;
+    IMFMediaBuffer *buffer = NULL;
+    unsigned char *buffer_data;
+    DWORD buffer_len;
+    HRESULT hr = S_OK;
+
+    TRACE("%p, %#x, %u, %p, %p.\n", iface, flags, count, samples, status);
+
+    if (flags)
+        WARN("Unsupported flags %#x.\n", flags);
+
+    if (!count)
+        return S_OK;
+
+    if (count != 1)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    if (samples[0].dwStreamID != 0)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    EnterCriticalSection(&converter->cs);
+
+    if (!converter->stream)
+    {
+        hr = MF_E_TRANSFORM_TYPE_NOT_SET;
+        goto done;
+    }
+
+    if (!converter->buffer_inflight)
+    {
+        hr = MF_E_TRANSFORM_NEED_MORE_INPUT;
+        goto done;
+    }
+
+    if (!wg_parser_stream_get_buffer(converter->stream, &wg_buffer))
+        assert(0);
+
+    if (!samples[0].pSample)
+    {
+        if (FAILED(hr = MFCreateMemoryBuffer(wg_buffer.size, &buffer)))
+        {
+            ERR("Failed to create buffer, hr %#x.\n", hr);
+            goto done;
+        }
+
+        if (FAILED(hr = MFCreateSample(&allocated_sample)))
+        {
+            ERR("Failed to create sample, hr %#x.\n", hr);
+            goto done;
+        }
+
+        samples[0].pSample = allocated_sample;
+
+        if (FAILED(hr = IMFSample_AddBuffer(samples[0].pSample, buffer)))
+        {
+            ERR("Failed to add buffer, hr %#x.\n", hr);
+            goto done;
+        }
+
+        IMFMediaBuffer_Release(buffer);
+        buffer = NULL;
+    }
+
+    if (FAILED(hr = IMFSample_ConvertToContiguousBuffer(samples[0].pSample, &buffer)))
+    {
+        ERR("Failed to get buffer from sample, hr %#x.\n", hr);
+        goto done;
+    }
+
+    if (FAILED(hr = IMFMediaBuffer_GetMaxLength(buffer, &buffer_len)))
+    {
+        ERR("Failed to get buffer size, hr %#x.\n", hr);
+        goto done;
+    }
+
+    if (buffer_len < wg_buffer.size)
+    {
+        WARN("Client's buffer is smaller (%u bytes) than the output sample (%u bytes)\n",
+            buffer_len, wg_buffer.size);
+
+        hr = MF_E_BUFFERTOOSMALL;
+        goto done;
+    }
+
+    if (FAILED(hr = IMFMediaBuffer_SetCurrentLength(buffer, wg_buffer.size)))
+    {
+        ERR("Failed to set size, hr %#x.\n", hr);
+        goto done;
+    }
+
+    if (FAILED(hr = IMFMediaBuffer_Lock(buffer, &buffer_data, NULL, NULL)))
+    {
+        ERR("Failed to lock buffer hr %#x.\n", hr);
+        goto done;
+    }
+
+    if (!wg_parser_stream_copy_buffer(converter->stream, buffer_data, 0, wg_buffer.size))
+    {
+        ERR("Failed to copy buffer.\n");
+        IMFMediaBuffer_Unlock(buffer);
+        hr = E_FAIL;
+        goto done;
+    }
+
+    IMFMediaBuffer_Unlock(buffer);
+
+    wg_parser_stream_release_buffer(converter->stream);
+    converter->buffer_inflight = FALSE;
+
+    if (converter->buffer_pts != -1)
+        IMFSample_SetSampleTime(samples[0].pSample, converter->buffer_pts);
+    if (converter->buffer_dur != -1)
+        IMFSample_SetSampleDuration(samples[0].pSample, converter->buffer_dur);
+
+    samples[0].dwStatus = 0;
+    samples[0].pEvents = NULL;
+
+    done:
+    if (buffer)
+        IMFMediaBuffer_Release(buffer);
+    if (FAILED(hr) && allocated_sample)
+    {
+        IMFSample_Release(allocated_sample);
+        samples[0].pSample = NULL;
+    }
+    LeaveCriticalSection(&converter->cs);
+    return hr;
+}
+
+static const IMFTransformVtbl color_converter_vtbl =
+{
+    color_converter_QueryInterface,
+    color_converter_AddRef,
+    color_converter_Release,
+    color_converter_GetStreamLimits,
+    color_converter_GetStreamCount,
+    color_converter_GetStreamIDs,
+    color_converter_GetInputStreamInfo,
+    color_converter_GetOutputStreamInfo,
+    color_converter_GetAttributes,
+    color_converter_GetInputStreamAttributes,
+    color_converter_GetOutputStreamAttributes,
+    color_converter_DeleteInputStream,
+    color_converter_AddInputStreams,
+    color_converter_GetInputAvailableType,
+    color_converter_GetOutputAvailableType,
+    color_converter_SetInputType,
+    color_converter_SetOutputType,
+    color_converter_GetInputCurrentType,
+    color_converter_GetOutputCurrentType,
+    color_converter_GetInputStatus,
+    color_converter_GetOutputStatus,
+    color_converter_SetOutputBounds,
+    color_converter_ProcessEvent,
+    color_converter_ProcessMessage,
+    color_converter_ProcessInput,
+    color_converter_ProcessOutput,
+};
+
+HRESULT color_converter_create(REFIID riid, void **ret)
+{
+    struct color_converter *object;
+
+    TRACE("%s %p\n", debugstr_guid(riid), ret);
+
+    if (!(object = calloc(1, sizeof(*object))))
+        return E_OUTOFMEMORY;
+
+    object->IMFTransform_iface.lpVtbl = &color_converter_vtbl;
+    object->refcount = 1;
+
+    InitializeCriticalSection(&object->cs);
+    object->cs.DebugInfo->Spare[0] = (DWORD_PTR)(__FILE__ ": color_converter_lock");
+
+    if (!(object->parser = wg_parser_create(WG_PARSER_VIDEOCONV, true)))
+    {
+        ERR("Failed to create video converter due to GStreamer error.\n");
+        IMFTransform_Release(&object->IMFTransform_iface);
+        return E_OUTOFMEMORY;
+    }
+
+    *ret = &object->IMFTransform_iface;
+    return S_OK;
+}
diff --git a/dlls/mfplat/decode_transform.c b/dlls/mfplat/decode_transform.c
new file mode 100644
index 00000000000..fb7f432923f
--- /dev/null
+++ wine/dlls/mfplat/decode_transform.c
@@ -0,0 +1,1218 @@
+/* GStreamer Decoder Transform
+ *
+ * Copyright 2021 Derek Lesho
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "gst_private.h"
+
+#include "mfapi.h"
+#include "mferror.h"
+#include "mfobjects.h"
+#include "mftransform.h"
+
+#include "wine/debug.h"
+#include "wine/heap.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(mfplat);
+
+const GUID *h264_input_types[] = {&MFVideoFormat_H264};
+/* NV12 comes first https://docs.microsoft.com/en-us/windows/win32/medfound/mft-decoder-expose-output-types-in-native-order . thanks to @vitorhnn */
+const GUID *h264_output_types[] = {&MFVideoFormat_NV12, &MFVideoFormat_I420, &MFVideoFormat_IYUV, &MFVideoFormat_YUY2, &MFVideoFormat_YV12};
+
+const GUID *aac_input_types[] = {&MFAudioFormat_AAC};
+const GUID *aac_output_types[] = {&MFAudioFormat_Float};
+
+static struct decoder_desc
+{
+    const GUID *major_type;
+    const GUID **input_types;
+    unsigned int input_types_count;
+    const GUID **output_types;
+    unsigned int output_types_count;
+} decoder_descs[] =
+{
+    { /* DECODER_TYPE_H264 */
+        &MFMediaType_Video,
+        h264_input_types,
+        ARRAY_SIZE(h264_input_types),
+        h264_output_types,
+        ARRAY_SIZE(h264_output_types),
+    },
+    { /* DECODER_TYPE_AAC */
+        &MFMediaType_Audio,
+        aac_input_types,
+        ARRAY_SIZE(aac_input_types),
+        aac_output_types,
+        ARRAY_SIZE(aac_output_types),
+    }
+};
+
+struct pipeline_event
+{
+    enum
+    {
+        PIPELINE_EVENT_NONE,
+        PIPELINE_EVENT_PARSER_STARTED,
+        PIPELINE_EVENT_READ_REQUEST,
+    } type;
+    union
+    {
+        struct
+        {
+            struct wg_parser_stream *stream;
+        } parser_started;
+    } u;
+};
+
+struct mf_decoder
+{
+    IMFTransform IMFTransform_iface;
+    LONG refcount;
+    enum decoder_type type;
+    IMFMediaType *input_type, *output_type;
+    CRITICAL_SECTION cs, help_cs, event_cs;
+    CONDITION_VARIABLE help_cv, event_cv;
+    BOOL flushing, draining, eos, helper_thread_shutdown, video;
+    HANDLE helper_thread, read_thread;
+    uint64_t offset_tracker;
+    struct wg_parser *wg_parser;
+    struct wg_parser_stream *wg_stream;
+
+    struct
+    {
+        enum
+        {
+            HELP_REQ_NONE,
+            HELP_REQ_START_PARSER,
+        } type;
+    } help_request;
+
+    struct pipeline_event event;
+};
+
+static struct mf_decoder *impl_mf_decoder_from_IMFTransform(IMFTransform *iface)
+{
+    return CONTAINING_RECORD(iface, struct mf_decoder, IMFTransform_iface);
+}
+
+static HRESULT WINAPI mf_decoder_QueryInterface (IMFTransform *iface, REFIID riid, void **out)
+{
+    TRACE("%p, %s, %p.\n", iface, debugstr_guid(riid), out);
+
+    if (IsEqualIID(riid, &IID_IMFTransform) ||
+            IsEqualIID(riid, &IID_IUnknown))
+    {
+        *out = iface;
+        IMFTransform_AddRef(iface);
+        return S_OK;
+    }
+
+    WARN("Unsupported %s.\n", debugstr_guid(riid));
+    *out = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI mf_decoder_AddRef(IMFTransform *iface)
+{
+    struct mf_decoder *decoder = impl_mf_decoder_from_IMFTransform(iface);
+    ULONG refcount = InterlockedIncrement(&decoder->refcount);
+
+    TRACE("%p, refcount %u.\n", iface, refcount);
+
+    return refcount;
+}
+
+static ULONG WINAPI mf_decoder_Release(IMFTransform *iface)
+{
+    struct mf_decoder *decoder = impl_mf_decoder_from_IMFTransform(iface);
+    ULONG refcount = InterlockedDecrement(&decoder->refcount);
+
+    TRACE("%p, refcount %u.\n", iface, refcount);
+
+    if (!refcount)
+    {
+        if (decoder->input_type)
+        {
+            IMFMediaType_Release(decoder->input_type);
+            decoder->input_type = NULL;
+        }
+
+        if (decoder->output_type)
+        {
+            IMFMediaType_Release(decoder->output_type);
+            decoder->output_type = NULL;
+        }
+
+        if (decoder->wg_parser)
+        {
+            /* NULL wg_parser is possible if the wg_parser creation failed. */
+
+            if (decoder->wg_stream)
+                wg_parser_disconnect(decoder->wg_parser);
+
+            EnterCriticalSection(&decoder->event_cs);
+            decoder->helper_thread_shutdown = TRUE;
+            WakeAllConditionVariable(&decoder->event_cv);
+            LeaveCriticalSection(&decoder->event_cs);
+
+            EnterCriticalSection(&decoder->help_cs);
+            WakeAllConditionVariable(&decoder->help_cv);
+            LeaveCriticalSection(&decoder->help_cs);
+
+            if (WaitForSingleObject(decoder->helper_thread, 10000) != WAIT_OBJECT_0)
+                FIXME("Failed waiting for helper thread to terminate.\n");
+            CloseHandle(decoder->helper_thread);
+            if (WaitForSingleObject(decoder->read_thread, 10000) != WAIT_OBJECT_0)
+                FIXME("Failed waiting for read thread to terminate.\n");
+            CloseHandle(decoder->read_thread);
+
+            wg_parser_destroy(decoder->wg_parser);
+        }
+
+        DeleteCriticalSection(&decoder->cs);
+        DeleteCriticalSection(&decoder->help_cs);
+        DeleteCriticalSection(&decoder->event_cs);
+
+        heap_free(decoder);
+    }
+
+    return refcount;
+}
+
+static HRESULT WINAPI mf_decoder_GetStreamLimits(IMFTransform *iface, DWORD *input_minimum, DWORD *input_maximum,
+        DWORD *output_minimum, DWORD *output_maximum)
+{
+    TRACE("%p, %p, %p, %p, %p.\n", iface, input_minimum, input_maximum, output_minimum, output_maximum);
+
+    *input_minimum = *input_maximum = *output_minimum = *output_maximum = 1;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI mf_decoder_GetStreamCount(IMFTransform *iface, DWORD *inputs, DWORD *outputs)
+{
+    TRACE("%p %p %p.\n", iface, inputs, outputs);
+
+    *inputs = *outputs = 1;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI mf_decoder_GetStreamIDs(IMFTransform *iface, DWORD input_size, DWORD *inputs,
+        DWORD output_size, DWORD *outputs)
+{
+    TRACE("%p %u %p %u %p.\n", iface, input_size, inputs, output_size, outputs);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI mf_decoder_GetInputStreamInfo(IMFTransform *iface, DWORD id, MFT_INPUT_STREAM_INFO *info)
+{
+    struct mf_decoder *decoder = impl_mf_decoder_from_IMFTransform(iface);
+
+    TRACE("%p %u %p\n", decoder, id, info);
+
+    if (id != 0)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    info->dwFlags = MFT_INPUT_STREAM_WHOLE_SAMPLES | MFT_INPUT_STREAM_DOES_NOT_ADDREF;
+    info->cbAlignment = 0;
+    info->cbSize = 0;
+    /* TODO: retrieve following fields from gstreamer */
+    info->hnsMaxLatency = 0;
+    info->cbMaxLookahead = 0;
+    return S_OK;
+}
+
+static HRESULT WINAPI mf_decoder_GetOutputStreamInfo(IMFTransform *iface, DWORD id, MFT_OUTPUT_STREAM_INFO *info)
+{
+    struct mf_decoder *decoder = impl_mf_decoder_from_IMFTransform(iface);
+    MFT_OUTPUT_STREAM_INFO stream_info = {};
+    GUID output_subtype;
+    UINT64 framesize;
+
+    TRACE("%p %u %p\n", decoder, id, info);
+
+    if (id != 0)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    EnterCriticalSection(&decoder->cs);
+
+    if (!decoder->output_type)
+    {
+        LeaveCriticalSection(&decoder->cs);
+        return MF_E_TRANSFORM_TYPE_NOT_SET;
+    }
+
+    if (decoder->video)
+    {
+        stream_info.dwFlags = MFT_OUTPUT_STREAM_WHOLE_SAMPLES | MFT_OUTPUT_STREAM_SINGLE_SAMPLE_PER_BUFFER |
+                              MFT_OUTPUT_STREAM_FIXED_SAMPLE_SIZE | MFT_OUTPUT_STREAM_CAN_PROVIDE_SAMPLES;
+        stream_info.cbSize = 0;
+        if (SUCCEEDED(IMFMediaType_GetGUID(decoder->output_type, &MF_MT_SUBTYPE, &output_subtype)) &&
+            SUCCEEDED(IMFMediaType_GetUINT64(decoder->output_type, &MF_MT_FRAME_SIZE, &framesize)))
+        {
+            MFCalculateImageSize(&output_subtype, framesize >> 32, (UINT32) framesize, &stream_info.cbSize);
+        }
+        if (!stream_info.cbSize)
+            ERR("Failed to get desired output buffer size\n");
+    }
+    else
+    {
+        stream_info.dwFlags = MFT_OUTPUT_STREAM_FIXED_SAMPLE_SIZE | MFT_OUTPUT_STREAM_CAN_PROVIDE_SAMPLES;
+        stream_info.cbSize = 4;
+    }
+    stream_info.cbAlignment = 0;
+
+    LeaveCriticalSection(&decoder->cs);
+
+    *info = stream_info;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI mf_decoder_GetAttributes(IMFTransform *iface, IMFAttributes **attributes)
+{
+    FIXME("%p, %p. semi-stub!\n", iface, attributes);
+
+    return MFCreateAttributes(attributes, 0);
+}
+
+static HRESULT WINAPI mf_decoder_GetInputStreamAttributes(IMFTransform *iface, DWORD id,
+        IMFAttributes **attributes)
+{
+    FIXME("%p, %u, %p.\n", iface, id, attributes);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI mf_decoder_GetOutputStreamAttributes(IMFTransform *iface, DWORD id,
+        IMFAttributes **attributes)
+{
+    FIXME("%p, %u, %p.\n", iface, id, attributes);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI mf_decoder_DeleteInputStream(IMFTransform *iface, DWORD id)
+{
+    TRACE("%p, %u.\n", iface, id);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI mf_decoder_AddInputStreams(IMFTransform *iface, DWORD streams, DWORD *ids)
+{
+    TRACE("%p, %u, %p.\n", iface, streams, ids);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI mf_decoder_GetInputAvailableType(IMFTransform *iface, DWORD id, DWORD index,
+        IMFMediaType **type)
+{
+    struct mf_decoder *decoder = impl_mf_decoder_from_IMFTransform(iface);
+    IMFMediaType *input_type;
+    HRESULT hr;
+
+    TRACE("%p, %u, %u, %p\n", decoder, id, index, type);
+
+    if (id != 0)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    if (index >= decoder_descs[decoder->type].input_types_count)
+        return MF_E_NO_MORE_TYPES;
+
+    if (FAILED(hr = MFCreateMediaType(&input_type)))
+        return hr;
+
+    if (FAILED(hr = IMFMediaType_SetGUID(input_type, &MF_MT_MAJOR_TYPE, decoder_descs[decoder->type].major_type)))
+    {
+        IMFMediaType_Release(input_type);
+        return hr;
+    }
+
+    if (FAILED(hr = IMFMediaType_SetGUID(input_type, &MF_MT_SUBTYPE, decoder_descs[decoder->type].input_types[index])))
+    {
+        IMFMediaType_Release(input_type);
+        return hr;
+    }
+
+    *type = input_type;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI mf_decoder_GetOutputAvailableType(IMFTransform *iface, DWORD id, DWORD index,
+        IMFMediaType **type)
+{
+    struct mf_decoder *decoder = impl_mf_decoder_from_IMFTransform(iface);
+    IMFMediaType *output_type;
+    HRESULT hr;
+
+    TRACE("%p, %u, %u, %p\n", decoder, id, index, type);
+
+    if (id != 0)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    if (index >= decoder_descs[decoder->type].output_types_count)
+        return MF_E_NO_MORE_TYPES;
+
+    if (FAILED(hr = MFCreateMediaType(&output_type)))
+        return hr;
+
+    if (FAILED(hr = IMFMediaType_SetGUID(output_type, &MF_MT_MAJOR_TYPE, decoder_descs[decoder->type].major_type)))
+    {
+        IMFMediaType_Release(output_type);
+        return hr;
+    }
+
+    if (FAILED(hr = IMFMediaType_SetGUID(output_type, &MF_MT_SUBTYPE, decoder_descs[decoder->type].output_types[index])))
+    {
+        IMFMediaType_Release(output_type);
+        return hr;
+    }
+
+    *type = output_type;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI mf_decoder_SetInputType(IMFTransform *iface, DWORD id, IMFMediaType *type, DWORD flags)
+{
+    struct mf_decoder *decoder = impl_mf_decoder_from_IMFTransform(iface);
+    struct wg_format input_format;
+    GUID major_type, subtype;
+    unsigned int i;
+    HRESULT hr;
+
+    TRACE("%p, %u, %p, %#x.\n", decoder, id, type, flags);
+
+    if (id != 0)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    if (!type)
+    {
+        if (flags & MFT_SET_TYPE_TEST_ONLY)
+            return S_OK;
+
+        EnterCriticalSection(&decoder->cs);
+
+        if (decoder->wg_stream)
+        {
+            decoder->wg_stream = NULL;
+            wg_parser_disconnect(decoder->wg_parser);
+        }
+
+        if (decoder->input_type)
+        {
+            IMFMediaType_Release(decoder->input_type);
+            decoder->input_type = NULL;
+        }
+
+        LeaveCriticalSection(&decoder->cs);
+
+        return S_OK;
+    }
+
+    if (FAILED(IMFMediaType_GetGUID(type, &MF_MT_MAJOR_TYPE, &major_type)))
+        return MF_E_INVALIDTYPE;
+    if (FAILED(IMFMediaType_GetGUID(type, &MF_MT_SUBTYPE, &subtype)))
+        return MF_E_INVALIDTYPE;
+
+    if (!(IsEqualGUID(&major_type, decoder_descs[decoder->type].major_type)))
+        return MF_E_INVALIDTYPE;
+
+    for (i = 0; i < decoder_descs[decoder->type].input_types_count; i++)
+    {
+        if (IsEqualGUID(&subtype, decoder_descs[decoder->type].input_types[i]))
+            break;
+        if (i == decoder_descs[decoder->type].input_types_count)
+            return MF_E_INVALIDTYPE;
+    }
+
+    mf_media_type_to_wg_format(type, &input_format);
+    if (!input_format.major_type)
+        return MF_E_INVALIDTYPE;
+
+    if (flags & MFT_SET_TYPE_TEST_ONLY)
+        return S_OK;
+
+    EnterCriticalSection(&decoder->cs);
+
+    hr = S_OK;
+
+    if (decoder->wg_stream)
+    {
+        decoder->wg_stream = NULL;
+        wg_parser_disconnect(decoder->wg_parser);
+    }
+
+    if (!decoder->input_type)
+        hr = MFCreateMediaType(&decoder->input_type);
+
+    if (SUCCEEDED(hr) && FAILED(hr = IMFMediaType_CopyAllItems(type, (IMFAttributes*) decoder->input_type)))
+    {
+        IMFMediaType_Release(decoder->input_type);
+        decoder->input_type = NULL;
+    }
+
+    if (decoder->input_type && decoder->output_type)
+    {
+        EnterCriticalSection(&decoder->help_cs);
+        while(decoder->help_request.type != HELP_REQ_NONE)
+            SleepConditionVariableCS(&decoder->help_cv, &decoder->help_cs, INFINITE);
+        decoder->help_request.type = HELP_REQ_START_PARSER;
+        LeaveCriticalSection(&decoder->help_cs);
+        WakeAllConditionVariable(&decoder->help_cv);
+    }
+
+    LeaveCriticalSection(&decoder->cs);
+    return hr;
+}
+
+static HRESULT WINAPI mf_decoder_SetOutputType(IMFTransform *iface, DWORD id, IMFMediaType *type, DWORD flags)
+{
+    struct mf_decoder *decoder = impl_mf_decoder_from_IMFTransform(iface);
+    struct wg_format output_format;
+    GUID major_type, subtype;
+    HRESULT hr;
+    unsigned int i;
+
+    TRACE("%p, %u, %p, %#x.\n", decoder, id, type, flags);
+
+    if (id != 0)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    if (!type)
+    {
+        if (flags & MFT_SET_TYPE_TEST_ONLY)
+            return S_OK;
+
+        EnterCriticalSection(&decoder->cs);
+
+        if (decoder->wg_stream)
+        {
+            decoder->wg_stream = NULL;
+            wg_parser_disconnect(decoder->wg_parser);
+        }
+
+        if (decoder->output_type)
+        {
+            IMFMediaType_Release(decoder->output_type);
+            decoder->output_type = NULL;
+        }
+
+        LeaveCriticalSection(&decoder->cs);
+
+        return S_OK;
+    }
+
+    if (FAILED(IMFMediaType_GetGUID(type, &MF_MT_MAJOR_TYPE, &major_type)))
+        return MF_E_INVALIDTYPE;
+    if (FAILED(IMFMediaType_GetGUID(type, &MF_MT_SUBTYPE, &subtype)))
+        return MF_E_INVALIDTYPE;
+
+    if (!(IsEqualGUID(&major_type, decoder_descs[decoder->type].major_type)))
+        return MF_E_INVALIDTYPE;
+
+    for (i = 0; i < decoder_descs[decoder->type].output_types_count; i++)
+    {
+        if (IsEqualGUID(&subtype, decoder_descs[decoder->type].output_types[i]))
+            break;
+        if (i == decoder_descs[decoder->type].output_types_count)
+            return MF_E_INVALIDTYPE;
+    }
+
+    mf_media_type_to_wg_format(type, &output_format);
+    if (!output_format.major_type)
+        return MF_E_INVALIDTYPE;
+
+    if (flags & MFT_SET_TYPE_TEST_ONLY)
+        return S_OK;
+
+    EnterCriticalSection(&decoder->cs);
+
+    hr = S_OK;
+
+    if (decoder->wg_stream)
+    {
+        decoder->wg_stream = NULL;
+        wg_parser_disconnect(decoder->wg_parser);
+    }
+
+    if (!decoder->output_type)
+        hr = MFCreateMediaType(&decoder->output_type);
+
+    if (SUCCEEDED(hr) && FAILED(hr = IMFMediaType_CopyAllItems(type, (IMFAttributes*) decoder->output_type)))
+    {
+        IMFMediaType_Release(decoder->output_type);
+        decoder->output_type = NULL;
+    }
+
+    if (decoder->input_type && decoder->output_type)
+    {
+        EnterCriticalSection(&decoder->help_cs);
+        while(decoder->help_request.type != HELP_REQ_NONE)
+            SleepConditionVariableCS(&decoder->help_cv, &decoder->help_cs, INFINITE);
+        decoder->help_request.type = HELP_REQ_START_PARSER;
+        LeaveCriticalSection(&decoder->help_cs);
+        WakeAllConditionVariable(&decoder->help_cv);
+    }
+
+    LeaveCriticalSection(&decoder->cs);
+    return hr;
+}
+
+static HRESULT WINAPI mf_decoder_GetInputCurrentType(IMFTransform *iface, DWORD id, IMFMediaType **type)
+{
+    FIXME("%p, %u, %p.\n", iface, id, type);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI mf_decoder_GetOutputCurrentType(IMFTransform *iface, DWORD id, IMFMediaType **type)
+{
+    FIXME("%p, %u, %p.\n", iface, id, type);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI mf_decoder_GetInputStatus(IMFTransform *iface, DWORD id, DWORD *flags)
+{
+    FIXME("%p, %u, %p\n", iface, id, flags);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI mf_decoder_GetOutputStatus(IMFTransform *iface, DWORD *flags)
+{
+    FIXME("%p, %p.\n", iface, flags);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI mf_decoder_SetOutputBounds(IMFTransform *iface, LONGLONG lower, LONGLONG upper)
+{
+    FIXME("%p, %s, %s.\n", iface, wine_dbgstr_longlong(lower), wine_dbgstr_longlong(upper));
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI mf_decoder_ProcessEvent(IMFTransform *iface, DWORD id, IMFMediaEvent *event)
+{
+    FIXME("%p, %u, %p.\n", iface, id, event);
+
+    return E_NOTIMPL;
+}
+
+static DWORD CALLBACK helper_thread_func(PVOID ctx)
+{
+    struct mf_decoder *decoder = (struct mf_decoder *)ctx;
+
+    for(;;)
+    {
+        EnterCriticalSection(&decoder->help_cs);
+
+        while(!decoder->helper_thread_shutdown && decoder->help_request.type == HELP_REQ_NONE)
+            SleepConditionVariableCS(&decoder->help_cv, &decoder->help_cs, INFINITE);
+        if (decoder->helper_thread_shutdown)
+        {
+            LeaveCriticalSection(&decoder->help_cs);
+            return 0;
+        }
+
+        switch(decoder->help_request.type)
+        {
+            case HELP_REQ_START_PARSER:
+            {
+                struct wg_format input_format, output_format;
+                struct wg_rect wg_aperture = {0};
+                MFVideoArea *aperture = NULL;
+                UINT32 aperture_size;
+
+                decoder->help_request.type = HELP_REQ_NONE;
+                LeaveCriticalSection(&decoder->help_cs);
+
+                mf_media_type_to_wg_format(decoder->input_type, &input_format);
+                mf_media_type_to_wg_format(decoder->output_type, &output_format);
+
+                if (SUCCEEDED(IMFMediaType_GetAllocatedBlob(decoder->output_type,
+                    &MF_MT_MINIMUM_DISPLAY_APERTURE, (UINT8 **) &aperture, &aperture_size)))
+                {
+                    TRACE("Decoded media's aperture: x: %u %u/65536, y: %u %u/65536, area: %u x %u\n",
+                        aperture->OffsetX.value, aperture->OffsetX.fract,
+                        aperture->OffsetY.value, aperture->OffsetY.fract, aperture->Area.cx, aperture->Area.cy);
+
+                    /* TODO: verify aperture params? */
+
+                    wg_aperture.left = aperture->OffsetX.value;
+                    wg_aperture.top = aperture->OffsetY.value;
+                    wg_aperture.right = aperture->Area.cx;
+                    wg_aperture.bottom = aperture->Area.cy;
+
+                    CoTaskMemFree(aperture);
+                }
+
+                wg_parser_connect_unseekable(decoder->wg_parser,
+                    &input_format, 1, &output_format, aperture ? &wg_aperture : NULL);
+
+                EnterCriticalSection(&decoder->event_cs);
+                while (!decoder->helper_thread_shutdown && decoder->event.type != PIPELINE_EVENT_NONE)
+                    SleepConditionVariableCS(&decoder->event_cv, &decoder->event_cs, INFINITE);
+
+                if (decoder->helper_thread_shutdown)
+                {
+                    LeaveCriticalSection(&decoder->event_cs);
+                    return 0;
+                }
+
+                decoder->event.type = PIPELINE_EVENT_PARSER_STARTED;
+                decoder->event.u.parser_started.stream = wg_parser_get_stream(decoder->wg_parser, 0);
+
+                LeaveCriticalSection(&decoder->event_cs);
+                WakeAllConditionVariable(&decoder->event_cv);
+
+                break;
+            }
+            default:
+                assert(0);
+        }
+    }
+}
+
+/* We use a separate thread to wait for reads, as we may want to wait to WAIT_ANY
+   on a read and another event. */
+static DWORD CALLBACK read_thread_func(PVOID ctx)
+{
+    struct mf_decoder *decoder = (struct mf_decoder *)ctx;
+    uint64_t offset;
+    uint32_t size;
+
+    for (;;)
+    {
+        if (decoder->helper_thread_shutdown)
+            break;
+
+        if (!wg_parser_get_next_read_offset(decoder->wg_parser, &offset, &size))
+            continue;
+
+        EnterCriticalSection(&decoder->event_cs);
+        while (!decoder->helper_thread_shutdown && decoder->event.type != PIPELINE_EVENT_NONE)
+            SleepConditionVariableCS(&decoder->event_cv, &decoder->event_cs, INFINITE);
+
+        if (decoder->helper_thread_shutdown)
+        {
+            LeaveCriticalSection(&decoder->event_cs);
+            break;
+        }
+
+        decoder->event.type = PIPELINE_EVENT_READ_REQUEST;
+        WakeAllConditionVariable(&decoder->event_cv);
+        while (!decoder->helper_thread_shutdown && decoder->event.type == PIPELINE_EVENT_READ_REQUEST)
+            SleepConditionVariableCS(&decoder->event_cv, &decoder->event_cs, INFINITE);
+        LeaveCriticalSection(&decoder->event_cs);
+    }
+
+    return 0;
+}
+
+static struct pipeline_event get_pipeline_event(struct mf_decoder *decoder)
+{
+    struct pipeline_event ret;
+
+    EnterCriticalSection(&decoder->event_cs);
+    while(decoder->event.type == PIPELINE_EVENT_NONE)
+        SleepConditionVariableCS(&decoder->event_cv, &decoder->event_cs, INFINITE);
+
+    ret = decoder->event;
+
+    if (ret.type != PIPELINE_EVENT_READ_REQUEST)
+    {
+        decoder->event.type = PIPELINE_EVENT_NONE;
+        WakeAllConditionVariable(&decoder->event_cv);
+    }
+
+    LeaveCriticalSection(&decoder->event_cs);
+
+    return ret;
+}
+
+static HRESULT WINAPI mf_decoder_ProcessMessage(IMFTransform *iface, MFT_MESSAGE_TYPE message, ULONG_PTR param)
+{
+    struct mf_decoder *decoder = impl_mf_decoder_from_IMFTransform(iface);
+    HRESULT hr;
+
+    TRACE("%p, %x %lu.\n", decoder, message, param);
+
+    EnterCriticalSection(&decoder->cs);
+    if (!decoder->input_type || !decoder->output_type)
+    {
+        LeaveCriticalSection(&decoder->cs);
+        return MF_E_TRANSFORM_TYPE_NOT_SET;
+    }
+
+    hr = S_OK;
+
+    switch (message)
+    {
+        case MFT_MESSAGE_NOTIFY_BEGIN_STREAMING:
+        case MFT_MESSAGE_NOTIFY_START_OF_STREAM:
+            break;
+        case MFT_MESSAGE_NOTIFY_END_OF_STREAM:
+        {
+            if (param)
+            {
+                hr = MF_E_INVALIDSTREAMNUMBER;
+                break;
+            }
+            if (!decoder->wg_stream)
+            {
+                ERR("End-Of-Stream marked on a decoder MFT which hasn't finished initialization\n");
+                hr = E_FAIL;
+                break;
+            }
+
+            decoder->eos = TRUE;
+            break;
+        }
+        case MFT_MESSAGE_COMMAND_DRAIN:
+        {
+            struct pipeline_event pip_event;
+
+            if (!decoder->wg_stream)
+            {
+                ERR("Drain requested on a decoder MFT which hasn't finished initialization\n");
+                hr = E_FAIL;
+                break;
+            }
+
+            pip_event = get_pipeline_event(decoder);
+            assert(pip_event.type == PIPELINE_EVENT_READ_REQUEST);
+
+            wg_parser_push_data(decoder->wg_parser, WG_READ_EOS, NULL, 0);
+
+            EnterCriticalSection(&decoder->event_cs);
+            decoder->event.type = PIPELINE_EVENT_NONE;
+            LeaveCriticalSection(&decoder->event_cs);
+            WakeAllConditionVariable(&decoder->event_cv);
+
+            decoder->draining = TRUE;
+            decoder->offset_tracker = 0;
+            break;
+        }
+        case MFT_MESSAGE_COMMAND_FLUSH:
+        {
+            struct pipeline_event pip_event;
+
+            if (!decoder->wg_stream)
+            {
+                ERR("Flush requested on a decoder MFT which hasn't finished initialization\n");
+                hr = E_FAIL;
+                break;
+            }
+
+            pip_event = get_pipeline_event(decoder);
+            assert(pip_event.type == PIPELINE_EVENT_READ_REQUEST);
+
+            wg_parser_push_data(decoder->wg_parser, WG_READ_FLUSHING, NULL, 0);
+
+            EnterCriticalSection(&decoder->event_cs);
+            decoder->event.type = PIPELINE_EVENT_NONE;
+            LeaveCriticalSection(&decoder->event_cs);
+            WakeAllConditionVariable(&decoder->event_cv);
+
+            decoder->offset_tracker = 0;
+            break;
+        }
+        default:
+        {
+            ERR("Unhandled message type %x.\n", message);
+            hr = E_FAIL;
+            break;
+        }
+    }
+
+    LeaveCriticalSection(&decoder->cs);
+    return hr;
+}
+
+static HRESULT WINAPI mf_decoder_ProcessInput(IMFTransform *iface, DWORD id, IMFSample *sample, DWORD flags)
+{
+    struct mf_decoder *decoder = impl_mf_decoder_from_IMFTransform(iface);
+    struct pipeline_event pip_event;
+    IMFMediaBuffer *buffer = NULL;
+    HRESULT hr = S_OK;
+    BYTE *buffer_data;
+    DWORD buffer_size;
+    uint32_t size = 0;
+    uint64_t offset;
+
+    TRACE("%p, %u, %p, %#x.\n", decoder, id, sample, flags);
+
+    if (flags)
+        WARN("Unsupported flags %#x\n", flags);
+
+    if (id != 0)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    EnterCriticalSection(&decoder->cs);
+
+    if (!decoder->input_type || !decoder->output_type)
+    {
+        LeaveCriticalSection(&decoder->cs);
+        return MF_E_TRANSFORM_TYPE_NOT_SET;
+    }
+
+    if (decoder->draining)
+    {
+        LeaveCriticalSection(&decoder->cs);
+        return MF_E_NOTACCEPTING;
+    }
+
+    if (!decoder->wg_stream)
+    {
+        pip_event = get_pipeline_event(decoder);
+
+        switch (pip_event.type)
+        {
+            case PIPELINE_EVENT_PARSER_STARTED:
+                decoder->wg_stream = pip_event.u.parser_started.stream;
+                break;
+            case PIPELINE_EVENT_READ_REQUEST:
+                break;
+            default:
+                assert(0);
+        }
+    }
+
+    if (decoder->wg_stream && !wg_parser_stream_drain(decoder->wg_stream))
+    {
+        LeaveCriticalSection(&decoder->cs);
+        return MF_E_NOTACCEPTING;
+    }
+
+    /* At this point, we either have a pre-init read request, or drained pipeline */
+
+    if (FAILED(hr = IMFSample_ConvertToContiguousBuffer(sample, &buffer)))
+        goto done;
+
+    if (FAILED(hr = IMFMediaBuffer_Lock(buffer, &buffer_data, NULL, &buffer_size)))
+        goto done;
+
+    pip_event = get_pipeline_event(decoder);
+    assert(pip_event.type == PIPELINE_EVENT_READ_REQUEST);
+
+    for(;;)
+    {
+        uint32_t copy_size;
+
+        if (!wg_parser_get_next_read_offset(decoder->wg_parser, &offset, &size))
+            continue;
+
+        copy_size = min(size, buffer_size);
+
+        if (offset != decoder->offset_tracker)
+        {
+            ERR("A seek is needed, MFTs don't support this!\n");
+            wg_parser_push_data(decoder->wg_parser, WG_READ_FAILURE, NULL, 0);
+            IMFMediaBuffer_Unlock(buffer);
+            hr = E_FAIL;
+            goto done;
+        }
+
+        wg_parser_push_data(decoder->wg_parser, WG_READ_SUCCESS, buffer_data, buffer_size);
+
+        decoder->offset_tracker += copy_size;
+
+        if (buffer_size <= size)
+            break;
+
+        buffer_data += copy_size;
+        buffer_size -= copy_size;
+
+        WARN("Input sample split into multiple read requests\n");
+    }
+
+    EnterCriticalSection(&decoder->event_cs);
+    decoder->event.type = PIPELINE_EVENT_NONE;
+    LeaveCriticalSection(&decoder->event_cs);
+    WakeAllConditionVariable(&decoder->event_cv);
+
+    IMFMediaBuffer_Unlock(buffer);
+
+    done:
+    if (buffer)
+        IMFMediaBuffer_Release(buffer);
+    LeaveCriticalSection(&decoder->cs);
+    return hr;
+}
+
+static HRESULT WINAPI mf_decoder_ProcessOutput(IMFTransform *iface, DWORD flags, DWORD count,
+        MFT_OUTPUT_DATA_BUFFER *samples, DWORD *status)
+{
+    struct mf_decoder *decoder = impl_mf_decoder_from_IMFTransform(iface);
+    MFT_OUTPUT_DATA_BUFFER *relevant_buffer = NULL;
+    struct wg_parser_buffer wg_buffer;
+    struct pipeline_event pip_event;
+    IMFMediaBuffer *buffer;
+    DWORD buffer_len;
+    unsigned int i;
+    BYTE *data;
+    HRESULT hr;
+
+    TRACE("%p, %#x, %u, %p, %p.\n", iface, flags, count, samples, status);
+
+    if (flags)
+        WARN("Unsupported flags %#x\n", flags);
+
+    for (i = 0; i < count; i++)
+    {
+        MFT_OUTPUT_DATA_BUFFER *out_buffer = &samples[i];
+
+        if (out_buffer->dwStreamID != 0)
+            return MF_E_INVALIDSTREAMNUMBER;
+
+        if (relevant_buffer)
+            return MF_E_INVALIDSTREAMNUMBER;
+
+        relevant_buffer = out_buffer;
+    }
+
+    if (!relevant_buffer)
+        return S_OK;
+
+    EnterCriticalSection(&decoder->cs);
+
+    if (!decoder->input_type || !decoder->output_type)
+    {
+        LeaveCriticalSection(&decoder->cs);
+        return MF_E_TRANSFORM_TYPE_NOT_SET;
+    }
+
+    if (!decoder->wg_stream)
+    {
+        pip_event = get_pipeline_event(decoder);
+
+        switch (pip_event.type)
+        {
+            case PIPELINE_EVENT_PARSER_STARTED:
+                decoder->wg_stream = pip_event.u.parser_started.stream;
+                break;
+            case PIPELINE_EVENT_READ_REQUEST:
+                LeaveCriticalSection(&decoder->cs);
+                return MF_E_TRANSFORM_NEED_MORE_INPUT;
+            default:
+                assert(0);
+        }
+    }
+
+    if (wg_parser_stream_drain(decoder->wg_stream))
+    {
+        /* this would be unexpected, as we should get the EOS-event when a drain command completes. */
+        assert (!decoder->draining);
+
+        LeaveCriticalSection(&decoder->cs);
+        return MF_E_TRANSFORM_NEED_MORE_INPUT;
+    }
+
+    if (!wg_parser_stream_get_buffer(decoder->wg_stream, &wg_buffer))
+    {
+        if (!decoder->draining)
+        {
+            LeaveCriticalSection(&decoder->cs);
+            WARN("Received EOS event while not draining\n");
+            return E_FAIL;
+        }
+        decoder->draining = FALSE;
+        LeaveCriticalSection(&decoder->cs);
+        return MF_E_TRANSFORM_NEED_MORE_INPUT;
+    }
+
+    if (relevant_buffer->pSample)
+    {
+        if (FAILED(hr = IMFSample_ConvertToContiguousBuffer(relevant_buffer->pSample, &buffer)))
+        {
+            ERR("Failed to get buffer from sample, hr %#x.\n", hr);
+            LeaveCriticalSection(&decoder->cs);
+            return hr;
+        }
+    }
+    else
+    {
+        if (FAILED(hr = MFCreateMemoryBuffer(wg_buffer.size, &buffer)))
+        {
+            ERR("Failed to create buffer, hr %#x.\n", hr);
+            LeaveCriticalSection(&decoder->cs);
+            return hr;
+        }
+
+        if (FAILED(hr = MFCreateSample(&relevant_buffer->pSample)))
+        {
+            ERR("Failed to create sample, hr %#x.\n", hr);
+            LeaveCriticalSection(&decoder->cs);
+            IMFMediaBuffer_Release(buffer);
+            return hr;
+        }
+
+        if (FAILED(hr = IMFSample_AddBuffer(relevant_buffer->pSample, buffer)))
+        {
+            ERR("Failed to add buffer, hr %#x.\n", hr);
+            goto out;
+        }
+    }
+
+    if (FAILED(hr = IMFMediaBuffer_GetMaxLength(buffer, &buffer_len)))
+    {
+        ERR("Failed to get buffer size, hr %#x.\n", hr);
+        goto out;
+    }
+
+    if (buffer_len < wg_buffer.size)
+    {
+        WARN("Client's buffer is smaller (%u bytes) than the output sample (%u bytes)\n",
+            buffer_len, wg_buffer.size);
+
+        if (FAILED(hr = IMFMediaBuffer_SetCurrentLength(buffer, buffer_len)))
+        {
+            ERR("Failed to set size, hr %#x.\n", hr);
+            goto out;
+        }
+    }
+    else if (FAILED(hr = IMFMediaBuffer_SetCurrentLength(buffer, wg_buffer.size)))
+    {
+        ERR("Failed to set size, hr %#x.\n", hr);
+        goto out;
+    }
+
+
+    if (FAILED(hr = IMFMediaBuffer_Lock(buffer, &data, NULL, NULL)))
+    {
+        ERR("Failed to lock buffer, hr %#x.\n", hr);
+        goto out;
+    }
+
+    if (!wg_parser_stream_copy_buffer(decoder->wg_stream, data, 0, min(buffer_len, wg_buffer.size)))
+    {
+        hr = E_FAIL;
+        goto out;
+    }
+
+    if (FAILED(hr = IMFMediaBuffer_Unlock(buffer)))
+    {
+        ERR("Failed to unlock buffer, hr %#x.\n", hr);
+        goto out;
+    }
+
+    if (FAILED(hr = IMFSample_SetSampleTime(relevant_buffer->pSample, wg_buffer.pts)))
+    {
+        ERR("Failed to set sample time, hr %#x.\n", hr);
+        goto out;
+    }
+
+    if (FAILED(hr = IMFSample_SetSampleDuration(relevant_buffer->pSample, wg_buffer.duration)))
+    {
+        ERR("Failed to set sample duration, hr %#x.\n", hr);
+        goto out;
+    }
+
+    relevant_buffer->dwStatus = 0;
+    relevant_buffer->pEvents = NULL;
+    *status = 0;
+
+    out:
+    if (SUCCEEDED(hr))
+        wg_parser_stream_release_buffer(decoder->wg_stream);
+    LeaveCriticalSection(&decoder->cs);
+
+    if (FAILED(hr))
+    {
+        IMFSample_Release(relevant_buffer->pSample);
+        relevant_buffer->pSample = NULL;
+    }
+
+    IMFMediaBuffer_Release(buffer);
+
+    return hr;
+}
+
+static const IMFTransformVtbl mf_decoder_vtbl =
+{
+    mf_decoder_QueryInterface,
+    mf_decoder_AddRef,
+    mf_decoder_Release,
+    mf_decoder_GetStreamLimits,
+    mf_decoder_GetStreamCount,
+    mf_decoder_GetStreamIDs,
+    mf_decoder_GetInputStreamInfo,
+    mf_decoder_GetOutputStreamInfo,
+    mf_decoder_GetAttributes,
+    mf_decoder_GetInputStreamAttributes,
+    mf_decoder_GetOutputStreamAttributes,
+    mf_decoder_DeleteInputStream,
+    mf_decoder_AddInputStreams,
+    mf_decoder_GetInputAvailableType,
+    mf_decoder_GetOutputAvailableType,
+    mf_decoder_SetInputType,
+    mf_decoder_SetOutputType,
+    mf_decoder_GetInputCurrentType,
+    mf_decoder_GetOutputCurrentType,
+    mf_decoder_GetInputStatus,
+    mf_decoder_GetOutputStatus,
+    mf_decoder_SetOutputBounds,
+    mf_decoder_ProcessEvent,
+    mf_decoder_ProcessMessage,
+    mf_decoder_ProcessInput,
+    mf_decoder_ProcessOutput,
+};
+
+HRESULT decode_transform_create(REFIID riid, void **obj, enum decoder_type type)
+{
+    struct mf_decoder *object;
+    struct wg_parser *parser;
+
+    TRACE("%s, %p %u.\n", debugstr_guid(riid), obj, type);
+
+    if (!(object = heap_alloc_zero(sizeof(*object))))
+        return E_OUTOFMEMORY;
+
+    object->IMFTransform_iface.lpVtbl = &mf_decoder_vtbl;
+    object->refcount = 1;
+
+    object->type = type;
+    object->video = decoder_descs[type].major_type == &MFMediaType_Video;
+
+    InitializeCriticalSection(&object->cs);
+    InitializeCriticalSection(&object->help_cs);
+    InitializeCriticalSection(&object->event_cs);
+    InitializeConditionVariable(&object->help_cv);
+    InitializeConditionVariable(&object->event_cv);
+
+    if (!(parser = wg_parser_create(WG_PARSER_DECODEBIN, TRUE)))
+    {
+        ERR("Failed to create Decoder MFT type %u: Unspecified GStreamer error\n", type);
+        IMFTransform_Release(&object->IMFTransform_iface);
+        return E_OUTOFMEMORY;
+    }
+    object->wg_parser = parser;
+
+    object->helper_thread = CreateThread(NULL, 0, helper_thread_func, object, 0, NULL);
+    object->read_thread = CreateThread(NULL, 0, read_thread_func, object, 0, NULL);
+
+    *obj = &object->IMFTransform_iface;
+    return S_OK;
+}
diff --git a/dlls/mfplat/gst_guids.h b/dlls/mfplat/gst_guids.h
new file mode 100644
index 00000000000..ea859586d7f
--- /dev/null
+++ wine/dlls/mfplat/gst_guids.h
@@ -0,0 +1,23 @@
+/*
+ * GStreamer Guids
+ *
+ * Copyright 2010 Maarten Lankhorst for CodeWeavers
+ * Copyright 2010 Aric Stewart for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+DEFINE_GUID(CLSID_decodebin_parser, 0xf9d8d64e, 0xa144, 0x47dc, 0x8e, 0xe0, 0xf5, 0x34, 0x98, 0x37, 0x2c, 0x29);
+DEFINE_GUID(WINESUBTYPE_Gstreamer, 0xffffffff, 0x128f, 0x4dd1, 0xad, 0x22, 0xbe, 0xcf, 0xa6, 0x6c, 0xe7, 0xaa);
diff --git a/dlls/mfplat/gst_private.h b/dlls/mfplat/gst_private.h
new file mode 100644
index 00000000000..c6b256b4fdd
--- /dev/null
+++ wine/dlls/mfplat/gst_private.h
@@ -0,0 +1,217 @@
+/*
+ * GStreamer splitter + decoder, adapted from parser.c
+ *
+ * Copyright 2010 Maarten Lankhorst for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifndef __GST_PRIVATE_INCLUDED__
+#define __GST_PRIVATE_INCLUDED__
+
+#include <assert.h>
+#include <limits.h>
+#include <stdarg.h>
+#include <stdbool.h>
+#include <stdint.h>
+#include <stdio.h>
+
+#define COBJMACROS
+#define NONAMELESSSTRUCT
+#define NONAMELESSUNION
+#include "dshow.h"
+#include "mfidl.h"
+#include "wmsdk.h"
+#include "wine/debug.h"
+#include "wine/strmbase.h"
+
+#include "unixlib.h"
+
+bool array_reserve(void **elements, size_t *capacity, size_t count, size_t size) DECLSPEC_HIDDEN;
+
+static inline const char *debugstr_time(REFERENCE_TIME time)
+{
+    ULONGLONG abstime = time >= 0 ? time : -time;
+    unsigned int i = 0, j = 0;
+    char buffer[23], rev[23];
+
+    while (abstime || i <= 8)
+    {
+        buffer[i++] = '0' + (abstime % 10);
+        abstime /= 10;
+        if (i == 7) buffer[i++] = '.';
+    }
+    if (time < 0) buffer[i++] = '-';
+
+    while (i--) rev[j++] = buffer[i];
+    while (rev[j-1] == '0' && rev[j-2] != '.') --j;
+    rev[j] = 0;
+
+    return wine_dbg_sprintf("%s", rev);
+}
+
+#define MEDIATIME_FROM_BYTES(x) ((LONGLONG)(x) * 10000000)
+
+struct wg_parser *wg_parser_create(enum wg_parser_type type, bool unlimited_buffering) DECLSPEC_HIDDEN;
+void wg_parser_destroy(struct wg_parser *parser) DECLSPEC_HIDDEN;
+
+HRESULT wg_parser_connect(struct wg_parser *parser, uint64_t file_size) DECLSPEC_HIDDEN;
+HRESULT wg_parser_connect_unseekable(struct wg_parser *parser, const struct wg_format *in_format,
+            uint32_t stream_count, const struct wg_format *out_formats, const struct wg_rect *apertures) DECLSPEC_HIDDEN;
+void wg_parser_disconnect(struct wg_parser *parser) DECLSPEC_HIDDEN;
+
+bool wg_parser_get_next_read_offset(struct wg_parser *parser, uint64_t *offset, uint32_t *size) DECLSPEC_HIDDEN;
+void wg_parser_push_data(struct wg_parser *parser, enum wg_read_result result, const void *data, uint32_t size) DECLSPEC_HIDDEN;
+
+uint32_t wg_parser_get_stream_count(struct wg_parser *parser) DECLSPEC_HIDDEN;
+struct wg_parser_stream *wg_parser_get_stream(struct wg_parser *parser, uint32_t index) DECLSPEC_HIDDEN;
+
+void wg_parser_stream_get_preferred_format(struct wg_parser_stream *stream, struct wg_format *format) DECLSPEC_HIDDEN;
+void wg_parser_stream_enable(struct wg_parser_stream *stream, const struct wg_format *format, const struct wg_rect *aperture, uint32_t flags) DECLSPEC_HIDDEN;
+void wg_parser_stream_disable(struct wg_parser_stream *stream) DECLSPEC_HIDDEN;
+
+bool wg_parser_stream_get_buffer(struct wg_parser_stream *stream, struct wg_parser_buffer *buffer) DECLSPEC_HIDDEN;
+bool wg_parser_stream_copy_buffer(struct wg_parser_stream *stream,
+        void *data, uint32_t offset, uint32_t size) DECLSPEC_HIDDEN;
+void wg_parser_stream_release_buffer(struct wg_parser_stream *stream) DECLSPEC_HIDDEN;
+void wg_parser_stream_notify_qos(struct wg_parser_stream *stream,
+        bool underflow, double proportion, int64_t diff, uint64_t timestamp) DECLSPEC_HIDDEN;
+
+/* Returns the duration in 100-nanosecond units. */
+uint64_t wg_parser_stream_get_duration(struct wg_parser_stream *stream) DECLSPEC_HIDDEN;
+bool wg_parser_stream_get_language(struct wg_parser_stream *stream, char *buffer, uint32_t size) DECLSPEC_HIDDEN;
+/* start_pos and stop_pos are in 100-nanosecond units. */
+void wg_parser_stream_seek(struct wg_parser_stream *stream, double rate,
+        uint64_t start_pos, uint64_t stop_pos, DWORD start_flags, DWORD stop_flags) DECLSPEC_HIDDEN;
+bool wg_parser_stream_drain(struct wg_parser_stream *stream) DECLSPEC_HIDDEN;
+
+struct wg_transform *wg_transform_create(const struct wg_encoded_format *input_format,
+                const struct wg_format *output_format) DECLSPEC_HIDDEN;
+void wg_transform_destroy(struct wg_transform *transform) DECLSPEC_HIDDEN;
+HRESULT wg_transform_push_data(struct wg_transform *transform, const void *data, uint32_t size) DECLSPEC_HIDDEN;
+HRESULT wg_transform_read_data(struct wg_transform *transform, struct wg_sample *sample) DECLSPEC_HIDDEN;
+
+unsigned int wg_format_get_max_size(const struct wg_format *format);
+
+HRESULT avi_splitter_create(IUnknown *outer, IUnknown **out) DECLSPEC_HIDDEN;
+HRESULT decodebin_parser_create(IUnknown *outer, IUnknown **out) DECLSPEC_HIDDEN;
+HRESULT mpeg_splitter_create(IUnknown *outer, IUnknown **out) DECLSPEC_HIDDEN;
+HRESULT wave_parser_create(IUnknown *outer, IUnknown **out) DECLSPEC_HIDDEN;
+HRESULT wma_decoder_create(IUnknown *outer, IUnknown **out) DECLSPEC_HIDDEN;
+
+bool amt_from_wg_format(AM_MEDIA_TYPE *mt, const struct wg_format *format, bool wm);
+bool amt_to_wg_format(const AM_MEDIA_TYPE *mt, struct wg_format *format);
+
+BOOL init_gstreamer(void) DECLSPEC_HIDDEN;
+
+extern HRESULT mfplat_get_class_object(REFCLSID rclsid, REFIID riid, void **obj) DECLSPEC_HIDDEN;
+extern HRESULT mfplat_DllRegisterServer(void) DECLSPEC_HIDDEN;
+
+IMFMediaType *mf_media_type_from_wg_format(const struct wg_format *format) DECLSPEC_HIDDEN;
+void mf_media_type_to_wg_format(IMFMediaType *type, struct wg_format *format) DECLSPEC_HIDDEN;
+void mf_media_type_to_wg_encoded_format(IMFMediaType *type, struct wg_encoded_format *format) DECLSPEC_HIDDEN;
+
+HRESULT winegstreamer_stream_handler_create(REFIID riid, void **obj) DECLSPEC_HIDDEN;
+
+HRESULT aac_decoder_create(REFIID riid, void **ret) DECLSPEC_HIDDEN;
+HRESULT h264_decoder_create(REFIID riid, void **ret) DECLSPEC_HIDDEN;
+HRESULT audio_converter_create(REFIID riid, void **ret) DECLSPEC_HIDDEN;
+HRESULT color_converter_create(REFIID riid, void **ret) DECLSPEC_HIDDEN;
+
+enum decoder_type
+{
+    DECODER_TYPE_H264,
+    DECODER_TYPE_AAC,
+};
+HRESULT decode_transform_create(REFIID riid, void **obj, enum decoder_type) DECLSPEC_HIDDEN;
+
+struct wm_stream
+{
+    struct wm_reader *reader;
+    struct wg_parser_stream *wg_stream;
+    struct wg_format format;
+    WMT_STREAM_SELECTION selection;
+    WORD index;
+    bool eos;
+    bool allocate_output;
+    bool allocate_stream;
+    /* Note that we only pretend to read compressed samples, and instead output
+     * uncompressed samples regardless of whether we are configured to read
+     * compressed samples. Rather, the behaviour of the reader objects differs
+     * in nontrivial ways depending on this field. */
+    bool read_compressed;
+};
+
+struct wm_reader
+{
+    IWMHeaderInfo3 IWMHeaderInfo3_iface;
+    IWMLanguageList IWMLanguageList_iface;
+    IWMPacketSize2 IWMPacketSize2_iface;
+    IWMProfile3 IWMProfile3_iface;
+    IWMReaderPlaylistBurn IWMReaderPlaylistBurn_iface;
+    IWMReaderTimecode IWMReaderTimecode_iface;
+    LONG refcount;
+    CRITICAL_SECTION cs;
+
+    QWORD start_time;
+
+    IStream *source_stream;
+    HANDLE file;
+    HANDLE read_thread;
+    bool read_thread_shutdown;
+    struct wg_parser *wg_parser;
+
+    struct wm_stream *streams;
+    WORD stream_count;
+
+    IWMReaderCallbackAdvanced *callback_advanced;
+
+    const struct wm_reader_ops *ops;
+};
+
+struct wm_reader_ops
+{
+    void *(*query_interface)(struct wm_reader *reader, REFIID iid);
+    void (*destroy)(struct wm_reader *reader);
+};
+
+void wm_reader_cleanup(struct wm_reader *reader);
+HRESULT wm_reader_close(struct wm_reader *reader);
+HRESULT wm_reader_get_max_stream_size(struct wm_reader *reader, WORD stream_number, DWORD *size);
+HRESULT wm_reader_get_output_format(struct wm_reader *reader, DWORD output,
+        DWORD index, IWMOutputMediaProps **props);
+HRESULT wm_reader_get_output_format_count(struct wm_reader *reader, DWORD output, DWORD *count);
+HRESULT wm_reader_get_output_props(struct wm_reader *reader, DWORD output,
+        IWMOutputMediaProps **props);
+struct wm_stream *wm_reader_get_stream_by_stream_number(struct wm_reader *reader,
+        WORD stream_number);
+HRESULT wm_reader_get_stream_sample(struct wm_reader *reader, WORD stream_number,
+        INSSBuffer **ret_sample, QWORD *pts, QWORD *duration, DWORD *flags, WORD *ret_stream_number);
+HRESULT wm_reader_get_stream_selection(struct wm_reader *reader,
+        WORD stream_number, WMT_STREAM_SELECTION *selection);
+void wm_reader_init(struct wm_reader *reader, const struct wm_reader_ops *ops);
+HRESULT wm_reader_open_file(struct wm_reader *reader, const WCHAR *filename);
+HRESULT wm_reader_open_stream(struct wm_reader *reader, IStream *stream);
+void wm_reader_seek(struct wm_reader *reader, QWORD start, LONGLONG duration);
+HRESULT wm_reader_set_allocate_for_output(struct wm_reader *reader, DWORD output, BOOL allocate);
+HRESULT wm_reader_set_allocate_for_stream(struct wm_reader *reader, WORD stream_number, BOOL allocate);
+HRESULT wm_reader_set_output_props(struct wm_reader *reader, DWORD output,
+        IWMOutputMediaProps *props);
+HRESULT wm_reader_set_read_compressed(struct wm_reader *reader,
+        WORD stream_number, BOOL compressed);
+HRESULT wm_reader_set_streams_selected(struct wm_reader *reader, WORD count,
+        const WORD *stream_numbers, const WMT_STREAM_SELECTION *selections);
+
+#endif /* __GST_PRIVATE_INCLUDED__ */
diff --git a/dlls/mfplat/h264_decoder.c b/dlls/mfplat/h264_decoder.c
new file mode 100644
index 00000000000..f6a4d47188f
--- /dev/null
+++ wine/dlls/mfplat/h264_decoder.c
@@ -0,0 +1,727 @@
+/* H264 Decoder Transform
+ *
+ * Copyright 2022 Rémi Bernon for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "gst_private.h"
+
+#include "mfapi.h"
+#include "mferror.h"
+#include "mfobjects.h"
+#include "mftransform.h"
+#include "wmcodecdsp.h"
+
+#include "wine/debug.h"
+#include "wine/heap.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(mfplat);
+
+static const GUID *h264_decoder_input_types[] =
+{
+    &MFVideoFormat_H264,
+};
+static const GUID *h264_decoder_output_types[] =
+{
+    &MFVideoFormat_NV12,
+    &MFVideoFormat_YV12,
+    &MFVideoFormat_IYUV,
+    &MFVideoFormat_I420,
+    &MFVideoFormat_YUY2,
+};
+
+struct h264_decoder
+{
+    IMFTransform IMFTransform_iface;
+    LONG refcount;
+    IMFMediaType *input_type;
+    IMFMediaType *output_type;
+
+    struct wg_transform *wg_transform;
+    struct wg_format wg_format;
+    ULONGLONG last_pts;
+};
+
+static struct h264_decoder *impl_from_IMFTransform(IMFTransform *iface)
+{
+    return CONTAINING_RECORD(iface, struct h264_decoder, IMFTransform_iface);
+}
+
+static HRESULT try_create_wg_transform(struct h264_decoder *decoder)
+{
+    struct wg_encoded_format input_format;
+    struct wg_format output_format;
+
+    if (decoder->wg_transform)
+        wg_transform_destroy(decoder->wg_transform);
+
+    mf_media_type_to_wg_encoded_format(decoder->input_type, &input_format);
+    if (input_format.encoded_type == WG_ENCODED_TYPE_UNKNOWN)
+        return MF_E_INVALIDMEDIATYPE;
+
+    mf_media_type_to_wg_format(decoder->output_type, &output_format);
+    if (output_format.major_type == WG_MAJOR_TYPE_UNKNOWN)
+        return MF_E_INVALIDMEDIATYPE;
+
+    decoder->last_pts = 0;
+    decoder->wg_transform = wg_transform_create(&input_format, &output_format);
+    if (decoder->wg_transform)
+        return S_OK;
+
+    WARN("Failed to create H264 wg_transform.\n");
+    return E_FAIL;
+}
+
+static HRESULT fill_output_media_type(IMFMediaType *media_type, IMFMediaType *default_type)
+{
+    UINT32 value, width, height;
+    MFVideoArea aperture = {0};
+    UINT64 value64;
+    GUID subtype;
+    HRESULT hr;
+
+    if (FAILED(hr = IMFMediaType_GetGUID(media_type, &MF_MT_SUBTYPE, &subtype)))
+        return hr;
+
+    if (FAILED(hr = IMFMediaType_GetUINT64(media_type, &MF_MT_FRAME_SIZE, &value64)))
+    {
+        if (!default_type || FAILED(hr = IMFMediaType_GetUINT64(default_type, &MF_MT_FRAME_SIZE, &value64)))
+            value64 = (UINT64)1920 << 32 | 1080;
+        if (FAILED(hr = IMFMediaType_SetUINT64(media_type, &MF_MT_FRAME_SIZE, value64)))
+            return hr;
+    }
+    width = value64 >> 32;
+    height = value64;
+
+    if (FAILED(hr = IMFMediaType_GetItem(media_type, &MF_MT_FRAME_RATE, NULL)))
+    {
+        if (!default_type || FAILED(hr = IMFMediaType_GetUINT64(default_type, &MF_MT_FRAME_RATE, &value64)))
+            value64 = (UINT64)30000 << 32 | 1001;
+        if (FAILED(hr = IMFMediaType_SetUINT64(media_type, &MF_MT_FRAME_RATE, value64)))
+            return hr;
+    }
+
+    if (FAILED(hr = IMFMediaType_GetItem(media_type, &MF_MT_PIXEL_ASPECT_RATIO, NULL)))
+    {
+        if (!default_type || FAILED(hr = IMFMediaType_GetUINT64(default_type, &MF_MT_PIXEL_ASPECT_RATIO, &value64)))
+            value64 = (UINT64)1 << 32 | 1;
+        if (FAILED(hr = IMFMediaType_SetUINT64(media_type, &MF_MT_PIXEL_ASPECT_RATIO, value64)))
+            return hr;
+    }
+
+    if (FAILED(hr = IMFMediaType_GetItem(media_type, &MF_MT_SAMPLE_SIZE, NULL)))
+    {
+        if (!default_type || FAILED(hr = IMFMediaType_GetUINT32(default_type, &MF_MT_SAMPLE_SIZE, &value)))
+        {
+            if (IsEqualGUID(&subtype, &MFVideoFormat_YUY2))
+                value = width * height * 2;
+            else
+                value = width * height * 3 / 2;
+        }
+        if (FAILED(hr = IMFMediaType_SetUINT32(media_type, &MF_MT_SAMPLE_SIZE, value)))
+            return hr;
+    }
+
+    if (FAILED(hr = IMFMediaType_GetItem(media_type, &MF_MT_DEFAULT_STRIDE, NULL)))
+    {
+        if (!default_type || FAILED(hr = IMFMediaType_GetUINT32(default_type, &MF_MT_DEFAULT_STRIDE, &value)))
+        {
+            if (IsEqualGUID(&subtype, &MFVideoFormat_YUY2))
+                value = width * 2;
+            else
+                value = width;
+        }
+        if (FAILED(hr = IMFMediaType_SetUINT32(media_type, &MF_MT_DEFAULT_STRIDE, value)))
+            return hr;
+    }
+
+    if (FAILED(hr = IMFMediaType_GetItem(media_type, &MF_MT_INTERLACE_MODE, NULL)))
+    {
+        if (!default_type || FAILED(hr = IMFMediaType_GetUINT32(default_type, &MF_MT_INTERLACE_MODE, &value)))
+            value = MFVideoInterlace_MixedInterlaceOrProgressive;
+        if (FAILED(hr = IMFMediaType_SetUINT32(media_type, &MF_MT_INTERLACE_MODE, value)))
+            return hr;
+    }
+
+    if (FAILED(hr = IMFMediaType_GetItem(media_type, &MF_MT_ALL_SAMPLES_INDEPENDENT, NULL)))
+    {
+        if (!default_type || FAILED(hr = IMFMediaType_GetUINT32(default_type, &MF_MT_ALL_SAMPLES_INDEPENDENT, &value)))
+            value = 1;
+        if (FAILED(hr = IMFMediaType_SetUINT32(media_type, &MF_MT_ALL_SAMPLES_INDEPENDENT, value)))
+            return hr;
+    }
+
+    if (FAILED(hr = IMFMediaType_GetItem(media_type, &MF_MT_VIDEO_ROTATION, NULL)))
+    {
+        if (!default_type || FAILED(hr = IMFMediaType_GetUINT32(default_type, &MF_MT_VIDEO_ROTATION, &value)))
+            value = 0;
+        if (FAILED(hr = IMFMediaType_SetUINT32(media_type, &MF_MT_VIDEO_ROTATION, value)))
+            return hr;
+    }
+
+    if (FAILED(hr = IMFMediaType_GetItem(media_type, &MF_MT_FIXED_SIZE_SAMPLES, NULL)))
+    {
+        if (!default_type || FAILED(hr = IMFMediaType_GetUINT32(default_type, &MF_MT_FIXED_SIZE_SAMPLES, &value)))
+            value = 1;
+        if (FAILED(hr = IMFMediaType_SetUINT32(media_type, &MF_MT_FIXED_SIZE_SAMPLES, value)))
+            return hr;
+    }
+
+    if (FAILED(hr = IMFMediaType_GetItem(media_type, &MF_MT_MINIMUM_DISPLAY_APERTURE, NULL)))
+    {
+        if (default_type && SUCCEEDED(hr = IMFMediaType_GetBlob(default_type, &MF_MT_MINIMUM_DISPLAY_APERTURE,
+                (BYTE *)&aperture, sizeof(aperture), NULL)))
+        {
+            if (FAILED(hr = IMFMediaType_SetBlob(media_type, &MF_MT_MINIMUM_DISPLAY_APERTURE,
+                    (BYTE *)&aperture, sizeof(aperture))))
+                return hr;
+        }
+    }
+
+    return S_OK;
+}
+
+static HRESULT WINAPI h264_decoder_QueryInterface(IMFTransform *iface, REFIID iid, void **out)
+{
+    struct h264_decoder *decoder = impl_from_IMFTransform(iface);
+
+    TRACE("iface %p, iid %s, out %p.\n", iface, debugstr_guid(iid), out);
+
+    if (IsEqualGUID(iid, &IID_IUnknown) || IsEqualGUID(iid, &IID_IMFTransform))
+        *out = &decoder->IMFTransform_iface;
+    else
+    {
+        *out = NULL;
+        WARN("%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid(iid));
+        return E_NOINTERFACE;
+    }
+
+    IUnknown_AddRef((IUnknown *)*out);
+    return S_OK;
+}
+
+static ULONG WINAPI h264_decoder_AddRef(IMFTransform *iface)
+{
+    struct h264_decoder *decoder = impl_from_IMFTransform(iface);
+    ULONG refcount = InterlockedIncrement(&decoder->refcount);
+
+    TRACE("iface %p increasing refcount to %u.\n", decoder, refcount);
+
+    return refcount;
+}
+
+static ULONG WINAPI h264_decoder_Release(IMFTransform *iface)
+{
+    struct h264_decoder *decoder = impl_from_IMFTransform(iface);
+    ULONG refcount = InterlockedDecrement(&decoder->refcount);
+
+    TRACE("iface %p decreasing refcount to %u.\n", decoder, refcount);
+
+    if (!refcount)
+    {
+        if (decoder->wg_transform)
+            wg_transform_destroy(decoder->wg_transform);
+        if (decoder->input_type)
+            IMFMediaType_Release(decoder->input_type);
+        if (decoder->output_type)
+            IMFMediaType_Release(decoder->output_type);
+        free(decoder);
+    }
+
+    return refcount;
+}
+
+static HRESULT WINAPI h264_decoder_GetStreamLimits(IMFTransform *iface, DWORD *input_minimum, DWORD *input_maximum,
+        DWORD *output_minimum, DWORD *output_maximum)
+{
+    FIXME("iface %p, input_minimum %p, input_maximum %p, output_minimum %p, output_maximum %p stub!\n",
+            iface, input_minimum, input_maximum, output_minimum, output_maximum);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI h264_decoder_GetStreamCount(IMFTransform *iface, DWORD *inputs, DWORD *outputs)
+{
+    FIXME("iface %p, inputs %p, outputs %p stub!\n", iface, inputs, outputs);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI h264_decoder_GetStreamIDs(IMFTransform *iface, DWORD input_size, DWORD *inputs,
+        DWORD output_size, DWORD *outputs)
+{
+    FIXME("iface %p, input_size %u, inputs %p, output_size %u, outputs %p stub!\n",
+            iface, input_size, inputs, output_size, outputs);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI h264_decoder_GetInputStreamInfo(IMFTransform *iface, DWORD id, MFT_INPUT_STREAM_INFO *info)
+{
+    struct h264_decoder *decoder = impl_from_IMFTransform(iface);
+
+    TRACE("iface %p, id %u, info %p.\n", iface, id, info);
+
+    if (!decoder->input_type)
+        return MF_E_TRANSFORM_TYPE_NOT_SET;
+
+    info->hnsMaxLatency = 0;
+    info->dwFlags = MFT_INPUT_STREAM_WHOLE_SAMPLES | MFT_INPUT_STREAM_SINGLE_SAMPLE_PER_BUFFER | MFT_INPUT_STREAM_FIXED_SAMPLE_SIZE;
+    info->cbSize = 0x1000;
+    info->cbMaxLookahead = 0;
+    info->cbAlignment = 0;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI h264_decoder_GetOutputStreamInfo(IMFTransform *iface, DWORD id, MFT_OUTPUT_STREAM_INFO *info)
+{
+    struct h264_decoder *decoder = impl_from_IMFTransform(iface);
+    IMFMediaType *media_type;
+    HRESULT hr;
+
+    TRACE("iface %p, id %u, info %p.\n", iface, id, info);
+
+    if (!decoder->input_type || !decoder->output_type)
+        return MF_E_TRANSFORM_TYPE_NOT_SET;
+
+    media_type = decoder->output_type;
+
+    info->dwFlags = MFT_OUTPUT_STREAM_WHOLE_SAMPLES | MFT_OUTPUT_STREAM_SINGLE_SAMPLE_PER_BUFFER | MFT_OUTPUT_STREAM_FIXED_SAMPLE_SIZE;
+    if (FAILED(hr = IMFMediaType_GetUINT32(media_type, &MF_MT_SAMPLE_SIZE, &info->cbSize)))
+        info->cbSize = 1920 * 1080 * 2;
+    info->cbAlignment = 0;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI h264_decoder_GetAttributes(IMFTransform *iface, IMFAttributes **attributes)
+{
+    FIXME("iface %p, attributes %p stub!\n", iface, attributes);
+
+    return MFCreateAttributes(attributes, 0);
+}
+
+static HRESULT WINAPI h264_decoder_GetInputStreamAttributes(IMFTransform *iface, DWORD id,
+        IMFAttributes **attributes)
+{
+    FIXME("iface %p, id %u, attributes %p stub!\n", iface, id, attributes);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI h264_decoder_GetOutputStreamAttributes(IMFTransform *iface, DWORD id,
+        IMFAttributes **attributes)
+{
+    FIXME("iface %p, id %u, attributes %p stub!\n", iface, id, attributes);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI h264_decoder_DeleteInputStream(IMFTransform *iface, DWORD id)
+{
+    FIXME("iface %p, id %u stub!\n", iface, id);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI h264_decoder_AddInputStreams(IMFTransform *iface, DWORD streams, DWORD *ids)
+{
+    FIXME("iface %p, streams %u, ids %p stub!\n", iface, streams, ids);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI h264_decoder_GetInputAvailableType(IMFTransform *iface, DWORD id, DWORD index,
+        IMFMediaType **type)
+{
+    IMFMediaType *media_type;
+    const GUID *subtype;
+    HRESULT hr;
+
+    TRACE("iface %p, id %u, index %u, type %p.\n", iface, id, index, type);
+
+    *type = NULL;
+
+    if (index >= ARRAY_SIZE(h264_decoder_input_types))
+        return MF_E_NO_MORE_TYPES;
+    subtype = h264_decoder_input_types[index];
+
+    if (FAILED(hr = MFCreateMediaType(&media_type)))
+        return hr;
+
+    if (SUCCEEDED(hr = IMFMediaType_SetGUID(media_type, &MF_MT_MAJOR_TYPE, &MFMediaType_Video)) &&
+            SUCCEEDED(hr = IMFMediaType_SetGUID(media_type, &MF_MT_SUBTYPE, subtype)))
+        IMFMediaType_AddRef((*type = media_type));
+
+    IMFMediaType_Release(media_type);
+    return hr;
+}
+
+static HRESULT WINAPI h264_decoder_GetOutputAvailableType(IMFTransform *iface, DWORD id, DWORD index,
+        IMFMediaType **type)
+{
+    struct h264_decoder *decoder = impl_from_IMFTransform(iface);
+    IMFMediaType *media_type;
+    const GUID *output_type;
+    HRESULT hr;
+
+    TRACE("iface %p, id %u, index %u, type %p.\n", iface, id, index, type);
+
+    if (!decoder->input_type)
+        return MF_E_TRANSFORM_TYPE_NOT_SET;
+
+    *type = NULL;
+
+    if (index >= ARRAY_SIZE(h264_decoder_output_types))
+        return MF_E_NO_MORE_TYPES;
+    output_type = h264_decoder_output_types[index];
+
+    if (FAILED(hr = MFCreateMediaType(&media_type)))
+        return hr;
+
+    if (FAILED(hr = IMFMediaType_SetGUID(media_type, &MF_MT_MAJOR_TYPE, &MFMediaType_Video)))
+        goto done;
+    if (FAILED(hr = IMFMediaType_SetGUID(media_type, &MF_MT_SUBTYPE, output_type)))
+        goto done;
+
+    hr = fill_output_media_type(media_type, decoder->output_type);
+
+done:
+    if (SUCCEEDED(hr))
+        IMFMediaType_AddRef((*type = media_type));
+
+    IMFMediaType_Release(media_type);
+    return hr;
+}
+
+static HRESULT WINAPI h264_decoder_SetInputType(IMFTransform *iface, DWORD id, IMFMediaType *type, DWORD flags)
+{
+    struct h264_decoder *decoder = impl_from_IMFTransform(iface);
+    GUID major, subtype;
+    HRESULT hr;
+    ULONG i;
+
+    TRACE("iface %p, id %u, type %p, flags %#x.\n", iface, id, type, flags);
+
+    if (FAILED(hr = IMFMediaType_GetGUID(type, &MF_MT_MAJOR_TYPE, &major)) ||
+            FAILED(hr = IMFMediaType_GetGUID(type, &MF_MT_SUBTYPE, &subtype)))
+        return E_INVALIDARG;
+
+    if (!IsEqualGUID(&major, &MFMediaType_Video))
+        return MF_E_INVALIDMEDIATYPE;
+
+    for (i = 0; i < ARRAY_SIZE(h264_decoder_input_types); ++i)
+        if (IsEqualGUID(&subtype, h264_decoder_input_types[i]))
+            break;
+    if (i == ARRAY_SIZE(h264_decoder_input_types))
+        return MF_E_INVALIDMEDIATYPE;
+
+    if (decoder->output_type)
+    {
+        IMFMediaType_Release(decoder->output_type);
+        decoder->output_type = NULL;
+    }
+
+    if (decoder->input_type)
+        IMFMediaType_Release(decoder->input_type);
+    IMFMediaType_AddRef((decoder->input_type = type));
+
+    return S_OK;
+}
+
+static HRESULT WINAPI h264_decoder_SetOutputType(IMFTransform *iface, DWORD id, IMFMediaType *type, DWORD flags)
+{
+    struct h264_decoder *decoder = impl_from_IMFTransform(iface);
+    GUID major, subtype;
+    BOOL identical;
+    HRESULT hr;
+    ULONG i;
+
+    TRACE("iface %p, id %u, type %p, flags %#x.\n", iface, id, type, flags);
+
+    if (!decoder->input_type)
+        return MF_E_TRANSFORM_TYPE_NOT_SET;
+
+    if (FAILED(hr = IMFMediaType_GetGUID(type, &MF_MT_MAJOR_TYPE, &major)) ||
+            FAILED(hr = IMFMediaType_GetGUID(type, &MF_MT_SUBTYPE, &subtype)))
+        return hr;
+
+    if (!IsEqualGUID(&major, &MFMediaType_Video))
+        return MF_E_INVALIDMEDIATYPE;
+
+    for (i = 0; i < ARRAY_SIZE(h264_decoder_output_types); ++i)
+        if (IsEqualGUID(&subtype, h264_decoder_output_types[i]))
+            break;
+    if (i == ARRAY_SIZE(h264_decoder_output_types))
+        return MF_E_INVALIDMEDIATYPE;
+
+    if (decoder->output_type)
+    {
+        if (SUCCEEDED(hr = IMFMediaType_Compare(decoder->output_type, (IMFAttributes *)type,
+                MF_ATTRIBUTES_MATCH_THEIR_ITEMS, &identical)) && identical)
+            return S_OK;
+        IMFMediaType_Release(decoder->output_type);
+    }
+
+    IMFMediaType_AddRef((decoder->output_type = type));
+
+    if (FAILED(hr = try_create_wg_transform(decoder)))
+    {
+        IMFMediaType_Release(decoder->output_type);
+        decoder->output_type = NULL;
+    }
+
+    return hr;
+}
+
+static HRESULT WINAPI h264_decoder_GetInputCurrentType(IMFTransform *iface, DWORD id, IMFMediaType **type)
+{
+    FIXME("iface %p, id %u, type %p stub!\n", iface, id, type);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI h264_decoder_GetOutputCurrentType(IMFTransform *iface, DWORD id, IMFMediaType **type)
+{
+    FIXME("iface %p, id %u, type %p stub!\n", iface, id, type);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI h264_decoder_GetInputStatus(IMFTransform *iface, DWORD id, DWORD *flags)
+{
+    FIXME("iface %p, id %u, flags %p stub!\n", iface, id, flags);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI h264_decoder_GetOutputStatus(IMFTransform *iface, DWORD *flags)
+{
+    FIXME("iface %p, flags %p stub!\n", iface, flags);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI h264_decoder_SetOutputBounds(IMFTransform *iface, LONGLONG lower, LONGLONG upper)
+{
+    FIXME("iface %p, lower %s, upper %s stub!\n", iface,
+            wine_dbgstr_longlong(lower), wine_dbgstr_longlong(upper));
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI h264_decoder_ProcessEvent(IMFTransform *iface, DWORD id, IMFMediaEvent *event)
+{
+    FIXME("iface %p, id %u, event %p stub!\n", iface, id, event);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI h264_decoder_ProcessMessage(IMFTransform *iface, MFT_MESSAGE_TYPE message, ULONG_PTR param)
+{
+    struct h264_decoder *decoder = impl_from_IMFTransform(iface);
+
+    FIXME("iface %p, message %#x, param %p stub!\n", iface, message, (void *)param);
+
+    switch (message)
+    {
+    case MFT_MESSAGE_NOTIFY_BEGIN_STREAMING:
+        memset(&decoder->wg_format, 0, sizeof(decoder->wg_format));
+        break;
+    default:
+        break;
+    }
+
+    return S_OK;
+}
+
+static HRESULT WINAPI h264_decoder_ProcessInput(IMFTransform *iface, DWORD id, IMFSample *sample, DWORD flags)
+{
+    struct h264_decoder *decoder = impl_from_IMFTransform(iface);
+    IMFMediaBuffer *media_buffer;
+    MFT_INPUT_STREAM_INFO info;
+    UINT32 buffer_size;
+    BYTE *buffer;
+    HRESULT hr;
+
+    TRACE("iface %p, id %u, sample %p, flags %#x.\n", iface, id, sample, flags);
+
+    if (FAILED(hr = IMFTransform_GetInputStreamInfo(iface, 0, &info)))
+        return hr;
+
+    if (!decoder->wg_transform)
+        return MF_E_TRANSFORM_TYPE_NOT_SET;
+
+    if (FAILED(hr = IMFSample_ConvertToContiguousBuffer(sample, &media_buffer)))
+        return hr;
+
+    if (FAILED(hr = IMFMediaBuffer_Lock(media_buffer, &buffer, NULL, &buffer_size)))
+        goto done;
+
+    hr = wg_transform_push_data(decoder->wg_transform, buffer, buffer_size);
+
+    IMFMediaBuffer_Unlock(media_buffer);
+
+done:
+    IMFMediaBuffer_Release(media_buffer);
+    return hr;
+}
+
+static HRESULT WINAPI h264_decoder_ProcessOutput(IMFTransform *iface, DWORD flags, DWORD count,
+        MFT_OUTPUT_DATA_BUFFER *samples, DWORD *status)
+{
+    struct h264_decoder *decoder = impl_from_IMFTransform(iface);
+    struct wg_sample wg_sample = {0};
+    IMFMediaBuffer *media_buffer;
+    MFT_OUTPUT_STREAM_INFO info;
+    MFVideoArea aperture = {0};
+    IMFMediaType *media_type;
+    UINT32 align, offset;
+    UINT64 framerate;
+    HRESULT hr;
+
+    TRACE("iface %p, flags %#x, count %u, samples %p, status %p.\n", iface, flags, count, samples, status);
+
+    if (count > 1)
+    {
+        FIXME("Not implemented count %u\n", count);
+        return E_NOTIMPL;
+    }
+
+    if (FAILED(hr = IMFTransform_GetOutputStreamInfo(iface, 0, &info)))
+        return hr;
+
+    if (!decoder->wg_transform)
+        return MF_E_TRANSFORM_TYPE_NOT_SET;
+
+    *status = 0;
+    samples[0].dwStatus = 0;
+    if (!samples[0].pSample)
+    {
+        samples[0].dwStatus = MFT_OUTPUT_DATA_BUFFER_NO_SAMPLE;
+        return MF_E_TRANSFORM_NEED_MORE_INPUT;
+    }
+
+    if (FAILED(hr = IMFSample_ConvertToContiguousBuffer(samples[0].pSample, &media_buffer)))
+        return hr;
+
+    if (FAILED(hr = IMFMediaBuffer_Lock(media_buffer, &wg_sample.data, &wg_sample.size, NULL)))
+        goto done;
+
+    wg_sample.format = &decoder->wg_format;
+    if (wg_sample.size < info.cbSize)
+        hr = MF_E_BUFFERTOOSMALL;
+    else if (SUCCEEDED(hr = wg_transform_read_data(decoder->wg_transform, &wg_sample)))
+    {
+        if (!(wg_sample.flags & (WG_SAMPLE_FLAG_HAS_PTS|WG_SAMPLE_FLAG_HAS_DURATION)))
+        {
+            IMFMediaType_GetUINT64(decoder->output_type, &MF_MT_FRAME_RATE, &framerate);
+            wg_sample.pts = decoder->last_pts;
+            wg_sample.duration = (UINT64)10000000 * (UINT32)framerate / (framerate >> 32);
+            wg_sample.flags |= (WG_SAMPLE_FLAG_HAS_PTS|WG_SAMPLE_FLAG_HAS_DURATION);
+            decoder->last_pts += wg_sample.duration;
+        }
+
+        if (wg_sample.flags & WG_SAMPLE_FLAG_HAS_PTS)
+            IMFSample_SetSampleTime(samples[0].pSample, wg_sample.pts);
+        if (wg_sample.flags & WG_SAMPLE_FLAG_HAS_DURATION)
+            IMFSample_SetSampleDuration(samples[0].pSample, wg_sample.duration);
+
+        if (decoder->wg_format.u.video.format == WG_VIDEO_FORMAT_NV12 &&
+                (align = decoder->wg_format.u.video.height & 15))
+        {
+            offset = decoder->wg_format.u.video.width * decoder->wg_format.u.video.height;
+            align = (16 - align) * decoder->wg_format.u.video.width;
+            memmove(wg_sample.data + offset + align, wg_sample.data + offset,
+                    wg_sample.size - offset);
+            wg_sample.size += align;
+        }
+
+        hr = IMFMediaBuffer_SetCurrentLength(media_buffer, wg_sample.size);
+    }
+    else if (hr == MF_E_TRANSFORM_STREAM_CHANGE)
+    {
+        media_type = mf_media_type_from_wg_format(&decoder->wg_format);
+        IMFMediaType_SetUINT32(media_type, &MF_MT_SAMPLE_SIZE, wg_sample.size);
+        IMFMediaType_DeleteItem(media_type, &MF_MT_FRAME_RATE);
+        IMFMediaType_DeleteItem(decoder->output_type, &MF_MT_DEFAULT_STRIDE);
+        fill_output_media_type(media_type, decoder->output_type);
+
+        if (decoder->wg_format.u.video.format == WG_VIDEO_FORMAT_NV12 &&
+                (align = decoder->wg_format.u.video.height & 15))
+        {
+            aperture.Area.cx = decoder->wg_format.u.video.width;
+            aperture.Area.cy = decoder->wg_format.u.video.height;
+            IMFMediaType_SetBlob(media_type, &MF_MT_MINIMUM_DISPLAY_APERTURE,
+                    (BYTE *)&aperture, sizeof(aperture));
+
+            aperture.Area.cy += 16 - align;
+            IMFMediaType_SetUINT64(media_type, &MF_MT_FRAME_SIZE,
+                    (UINT64)aperture.Area.cx << 32 | aperture.Area.cy);
+            IMFMediaType_SetUINT32(media_type, &MF_MT_SAMPLE_SIZE,
+                    aperture.Area.cx * aperture.Area.cy * 3 / 2);
+        }
+
+        IMFMediaType_Release(decoder->output_type);
+        decoder->output_type = media_type;
+
+        samples[0].dwStatus |= MFT_OUTPUT_DATA_BUFFER_FORMAT_CHANGE;
+        *status |= MFT_OUTPUT_DATA_BUFFER_FORMAT_CHANGE;
+    }
+
+    IMFMediaBuffer_Unlock(media_buffer);
+
+done:
+    if (FAILED(hr))
+        IMFMediaBuffer_SetCurrentLength(media_buffer, 0);
+    IMFMediaBuffer_Release(media_buffer);
+    return hr;
+}
+
+static const IMFTransformVtbl h264_decoder_vtbl =
+{
+    h264_decoder_QueryInterface,
+    h264_decoder_AddRef,
+    h264_decoder_Release,
+    h264_decoder_GetStreamLimits,
+    h264_decoder_GetStreamCount,
+    h264_decoder_GetStreamIDs,
+    h264_decoder_GetInputStreamInfo,
+    h264_decoder_GetOutputStreamInfo,
+    h264_decoder_GetAttributes,
+    h264_decoder_GetInputStreamAttributes,
+    h264_decoder_GetOutputStreamAttributes,
+    h264_decoder_DeleteInputStream,
+    h264_decoder_AddInputStreams,
+    h264_decoder_GetInputAvailableType,
+    h264_decoder_GetOutputAvailableType,
+    h264_decoder_SetInputType,
+    h264_decoder_SetOutputType,
+    h264_decoder_GetInputCurrentType,
+    h264_decoder_GetOutputCurrentType,
+    h264_decoder_GetInputStatus,
+    h264_decoder_GetOutputStatus,
+    h264_decoder_SetOutputBounds,
+    h264_decoder_ProcessEvent,
+    h264_decoder_ProcessMessage,
+    h264_decoder_ProcessInput,
+    h264_decoder_ProcessOutput,
+};
+
+HRESULT h264_decoder_create(REFIID riid, void **ret)
+{
+    struct h264_decoder *decoder;
+
+    TRACE("riid %s, ret %p.\n", debugstr_guid(riid), ret);
+
+    if (!(decoder = calloc(1, sizeof(*decoder))))
+        return E_OUTOFMEMORY;
+
+    decoder->IMFTransform_iface.lpVtbl = &h264_decoder_vtbl;
+    decoder->refcount = 1;
+
+    *ret = &decoder->IMFTransform_iface;
+    TRACE("Created decoder %p\n", *ret);
+    return S_OK;
+}
diff --git a/dlls/mfplat/main.c b/dlls/mfplat/main.c
index cee052defeb..83fc8549e24 100644
--- wine/dlls/mfplat/main.c
+++ wine/dlls/mfplat/main.c
@@ -36,6 +36,7 @@
 #include "d3d11.h"
 #include "uuids.h"
 
+#include "wine/debug.h"
 #include "wine/list.h"
 
 #include "mfplat_private.h"
@@ -52,9 +53,6 @@
 #include "initguid.h"
 #include "mfd3d12.h"
 
-#include "bcrypt.h"
-#include "pathcch.h"
-
 WINE_DEFAULT_DEBUG_CHANNEL(mfplat);
 
 struct local_handler
@@ -124,20 +122,17 @@ struct system_time_source
     MFCLOCK_STATE state;
     IMFClock *clock;
     LONGLONG start_offset;
-    LONGLONG system_time;
-    LONGLONG clock_time;
     float rate;
     int i_rate;
     CRITICAL_SECTION cs;
 };
 
-static void system_time_source_update_clock_time(struct system_time_source *source, LONGLONG system_time)
+static void system_time_source_apply_rate(const struct system_time_source *source, LONGLONG *value)
 {
-    LONGLONG diff = system_time - source->system_time;
-    if (source->i_rate) diff *= source->i_rate;
-    else if (source->rate != 1.0f) diff *= source->rate;
-    source->clock_time += diff;
-    source->system_time = system_time;
+    if (source->i_rate)
+        *value *= source->i_rate;
+    else
+        *value *= source->rate;
 }
 
 static struct system_time_source *impl_from_IMFPresentationTimeSource(IMFPresentationTimeSource *iface)
@@ -183,7 +178,7 @@ static ULONG WINAPI transform_activate_AddRef(IMFActivate *iface)
     struct transform_activate *activate = impl_from_IMFActivate(iface);
     ULONG refcount = InterlockedIncrement(&activate->attributes.ref);
 
-    TRACE("%p, refcount %lu.\n", iface, refcount);
+    TRACE("%p, refcount %u.\n", iface, refcount);
 
     return refcount;
 }
@@ -193,7 +188,7 @@ static ULONG WINAPI transform_activate_Release(IMFActivate *iface)
     struct transform_activate *activate = impl_from_IMFActivate(iface);
     ULONG refcount = InterlockedDecrement(&activate->attributes.ref);
 
-    TRACE("%p, refcount %lu.\n", iface, refcount);
+    TRACE("%p, refcount %u.\n", iface, refcount);
 
     if (!refcount)
     {
@@ -707,10 +702,9 @@ static HRESULT register_transform(const CLSID *clsid, const WCHAR *name, UINT32
     HRESULT hr = S_OK;
     HKEY hclsid = 0;
     WCHAR buffer[64];
+    DWORD size, ret;
     WCHAR str[250];
     UINT8 *blob;
-    UINT32 size;
-    DWORD ret;
 
     guid_to_string(buffer, clsid);
     swprintf(str, ARRAY_SIZE(str), L"%s\\%s", transform_keyW, buffer);
@@ -1196,7 +1190,7 @@ static HRESULT mft_enum(GUID category, UINT32 flags, const MFT_REGISTER_TYPE_INF
 
     if (FAILED(hr = MFGetPluginControl(&plugin_control)))
     {
-        WARN("Failed to get plugin control instance, hr %#lx.\n", hr);
+        WARN("Failed to get plugin control instance, hr %#x.\n", hr);
         return hr;
     }
 
@@ -1519,7 +1513,7 @@ static HRESULT mft_get_attributes(HKEY hkey, IMFAttributes **ret)
         if (!RegQueryValueExW(hkey, L"Attributes", NULL, NULL, blob, &size))
         {
             if (FAILED(hr = MFInitAttributesFromBlob(attributes, blob, size)))
-                WARN("Failed to initialize attributes, hr %#lx.\n", hr);
+                WARN("Failed to initialize attributes, hr %#x.\n", hr);
         }
 
         free(blob);
@@ -1583,6 +1577,18 @@ HRESULT WINAPI MFTGetInfo(CLSID clsid, WCHAR **name, MFT_REGISTER_TYPE_INFO **in
     return hr;
 }
 
+static BOOL CALLBACK register_winegstreamer_proc(INIT_ONCE *once, void *param, void **ctx)
+{
+    HMODULE mod = LoadLibraryW(L"winegstreamer.dll");
+    if (mod)
+    {
+        HRESULT (WINAPI *proc)(void) = (void *)GetProcAddress(mod, "DllRegisterServer");
+        proc();
+        FreeLibrary(mod);
+    }
+    return TRUE;
+}
+
 /***********************************************************************
  *      MFStartup (mfplat.@)
  */
@@ -1590,8 +1596,11 @@ HRESULT WINAPI MFStartup(ULONG version, DWORD flags)
 {
 #define MF_VERSION_XP   MAKELONG( MF_API_VERSION, 1 )
 #define MF_VERSION_WIN7 MAKELONG( MF_API_VERSION, 2 )
+    static INIT_ONCE once = INIT_ONCE_STATIC_INIT;
+
+    TRACE("%#x, %#x.\n", version, flags);
 
-    TRACE("%#lx, %#lx.\n", version, flags);
+    InitOnceExecuteOnce(&once, register_winegstreamer_proc, NULL, NULL);
 
     if (version != MF_VERSION_XP && version != MF_VERSION_WIN7)
         return MF_E_BAD_STARTUP_VERSION;
@@ -1618,7 +1627,7 @@ HRESULT WINAPI MFShutdown(void)
  */
 HRESULT WINAPI MFCopyImage(BYTE *dest, LONG deststride, const BYTE *src, LONG srcstride, DWORD width, DWORD lines)
 {
-    TRACE("%p, %ld, %p, %ld, %lu, %lu.\n", dest, deststride, src, srcstride, width, lines);
+    TRACE("%p, %d, %p, %d, %u, %u.\n", dest, deststride, src, srcstride, width, lines);
 
     while (lines--)
     {
@@ -2312,7 +2321,7 @@ static const char *debugstr_eventid(DWORD event)
     };
 
     struct event_id *ret = bsearch(&event, event_ids, ARRAY_SIZE(event_ids), sizeof(*event_ids), debug_event_id);
-    return ret ? wine_dbg_sprintf("%s", ret->name) : wine_dbg_sprintf("%lu", event);
+    return ret ? wine_dbg_sprintf("%s", ret->name) : wine_dbg_sprintf("%u", event);
 }
 
 static inline struct attributes *impl_from_IMFAttributes(IMFAttributes *iface)
@@ -2342,7 +2351,7 @@ static ULONG WINAPI mfattributes_AddRef(IMFAttributes *iface)
     struct attributes *attributes = impl_from_IMFAttributes(iface);
     ULONG refcount = InterlockedIncrement(&attributes->ref);
 
-    TRACE("%p, refcount %ld.\n", iface, refcount);
+    TRACE("%p, refcount %d.\n", iface, refcount);
 
     return refcount;
 }
@@ -2352,7 +2361,7 @@ static ULONG WINAPI mfattributes_Release(IMFAttributes *iface)
     struct attributes *attributes = impl_from_IMFAttributes(iface);
     ULONG refcount = InterlockedDecrement(&attributes->ref);
 
-    TRACE("%p, refcount %ld.\n", iface, refcount);
+    TRACE("%p, refcount %d.\n", iface, refcount);
 
     if (!refcount)
     {
@@ -2670,7 +2679,8 @@ HRESULT attributes_GetAllocatedString(struct attributes *attributes, REFGUID key
     if (SUCCEEDED(hr))
     {
         *value = attrval.pwszVal;
-        *length = lstrlenW(*value);
+        if (length)
+            *length = lstrlenW(*value);
     }
 
     return hr;
@@ -3730,7 +3740,7 @@ static ULONG WINAPI async_stream_op_AddRef(IUnknown *iface)
     struct async_stream_op *op = impl_async_stream_op_from_IUnknown(iface);
     ULONG refcount = InterlockedIncrement(&op->refcount);
 
-    TRACE("%p, refcount %ld.\n", iface, refcount);
+    TRACE("%p, refcount %d.\n", iface, refcount);
 
     return refcount;
 }
@@ -3740,7 +3750,7 @@ static ULONG WINAPI async_stream_op_Release(IUnknown *iface)
     struct async_stream_op *op = impl_async_stream_op_from_IUnknown(iface);
     ULONG refcount = InterlockedDecrement(&op->refcount);
 
-    TRACE("%p, refcount %ld.\n", iface, refcount);
+    TRACE("%p, refcount %d.\n", iface, refcount);
 
     if (!refcount)
     {
@@ -3902,7 +3912,7 @@ static ULONG WINAPI bytestream_AddRef(IMFByteStream *iface)
     struct bytestream *stream = impl_from_IMFByteStream(iface);
     ULONG refcount = InterlockedIncrement(&stream->attributes.ref);
 
-    TRACE("%p, refcount %ld.\n", iface, refcount);
+    TRACE("%p, refcount %d.\n", iface, refcount);
 
     return refcount;
 }
@@ -3913,7 +3923,7 @@ static ULONG WINAPI bytestream_Release(IMFByteStream *iface)
     ULONG refcount = InterlockedDecrement(&stream->attributes.ref);
     struct async_stream_op *cur, *cur2;
 
-    TRACE("%p, refcount %ld.\n", iface, refcount);
+    TRACE("%p, refcount %d.\n", iface, refcount);
 
     if (!refcount)
     {
@@ -3952,7 +3962,7 @@ static HRESULT WINAPI bytestream_stream_GetCapabilities(IMFByteStream *iface, DW
     return S_OK;
 }
 
-static HRESULT WINAPI bytestream_GetCapabilities(IMFByteStream *iface, DWORD *capabilities)
+static HRESULT WINAPI bytestream_file_GetCapabilities(IMFByteStream *iface, DWORD *capabilities)
 {
     struct bytestream *stream = impl_from_IMFByteStream(iface);
 
@@ -3963,14 +3973,14 @@ static HRESULT WINAPI bytestream_GetCapabilities(IMFByteStream *iface, DWORD *ca
     return S_OK;
 }
 
-static HRESULT WINAPI bytestream_SetLength(IMFByteStream *iface, QWORD length)
+static HRESULT WINAPI bytestream_file_SetLength(IMFByteStream *iface, QWORD length)
 {
     FIXME("%p, %s\n", iface, wine_dbgstr_longlong(length));
 
     return E_NOTIMPL;
 }
 
-static HRESULT WINAPI bytestream_file_GetCurrentPosition(IMFByteStream *iface, QWORD *position)
+static HRESULT WINAPI bytestream_GetCurrentPosition(IMFByteStream *iface, QWORD *position)
 {
     struct bytestream *stream = impl_from_IMFByteStream(iface);
 
@@ -4030,7 +4040,7 @@ static HRESULT WINAPI bytestream_file_Read(IMFByteStream *iface, BYTE *buffer, U
     HRESULT hr = S_OK;
     BOOL ret;
 
-    TRACE("%p, %p, %lu, %p.\n", iface, buffer, size, read_len);
+    TRACE("%p, %p, %u, %p.\n", iface, buffer, size, read_len);
 
     EnterCriticalSection(&stream->cs);
 
@@ -4054,7 +4064,7 @@ static HRESULT WINAPI bytestream_BeginRead(IMFByteStream *iface, BYTE *data, ULO
 {
     struct bytestream *stream = impl_from_IMFByteStream(iface);
 
-    TRACE("%p, %p, %lu, %p, %p.\n", iface, data, size, callback, state);
+    TRACE("%p, %p, %u, %p, %p.\n", iface, data, size, callback, state);
 
     return bytestream_create_io_request(stream, ASYNC_STREAM_OP_READ, data, size, callback, state);
 }
@@ -4068,9 +4078,9 @@ static HRESULT WINAPI bytestream_EndRead(IMFByteStream *iface, IMFAsyncResult *r
     return bytestream_complete_io_request(stream, ASYNC_STREAM_OP_READ, result, byte_read);
 }
 
-static HRESULT WINAPI bytestream_Write(IMFByteStream *iface, const BYTE *data, ULONG count, ULONG *written)
+static HRESULT WINAPI bytestream_file_Write(IMFByteStream *iface, const BYTE *data, ULONG count, ULONG *written)
 {
-    FIXME("%p, %p, %lu, %p\n", iface, data, count, written);
+    FIXME("%p, %p, %u, %p\n", iface, data, count, written);
 
     return E_NOTIMPL;
 }
@@ -4080,7 +4090,7 @@ static HRESULT WINAPI bytestream_BeginWrite(IMFByteStream *iface, const BYTE *da
 {
     struct bytestream *stream = impl_from_IMFByteStream(iface);
 
-    TRACE("%p, %p, %lu, %p, %p.\n", iface, data, size, callback, state);
+    TRACE("%p, %p, %u, %p, %p.\n", iface, data, size, callback, state);
 
     return bytestream_create_io_request(stream, ASYNC_STREAM_OP_WRITE, data, size, callback, state);
 }
@@ -4094,22 +4104,44 @@ static HRESULT WINAPI bytestream_EndWrite(IMFByteStream *iface, IMFAsyncResult *
     return bytestream_complete_io_request(stream, ASYNC_STREAM_OP_WRITE, result, written);
 }
 
-static HRESULT WINAPI bytestream_Seek(IMFByteStream *iface, MFBYTESTREAM_SEEK_ORIGIN seek, LONGLONG offset,
-                        DWORD flags, QWORD *current)
+static HRESULT WINAPI bytestream_Seek(IMFByteStream *iface, MFBYTESTREAM_SEEK_ORIGIN origin, LONGLONG offset,
+        DWORD flags, QWORD *current)
 {
-    FIXME("%p, %u, %s, 0x%08lx, %p\n", iface, seek, wine_dbgstr_longlong(offset), flags, current);
+    struct bytestream *stream = impl_from_IMFByteStream(iface);
+    HRESULT hr = S_OK;
 
-    return E_NOTIMPL;
+    TRACE("%p, %u, %s, 0x%08x, %p\n", iface, origin, wine_dbgstr_longlong(offset), flags, current);
+
+    EnterCriticalSection(&stream->cs);
+
+    switch (origin)
+    {
+        case msoBegin:
+            stream->position = offset;
+            break;
+        case msoCurrent:
+            stream->position += offset;
+            break;
+        default:
+            WARN("Unknown origin mode %d.\n", origin);
+            hr = E_INVALIDARG;
+    }
+
+    *current = stream->position;
+
+    LeaveCriticalSection(&stream->cs);
+
+    return hr;
 }
 
-static HRESULT WINAPI bytestream_Flush(IMFByteStream *iface)
+static HRESULT WINAPI bytestream_file_Flush(IMFByteStream *iface)
 {
     FIXME("%p\n", iface);
 
     return E_NOTIMPL;
 }
 
-static HRESULT WINAPI bytestream_Close(IMFByteStream *iface)
+static HRESULT WINAPI bytestream_file_Close(IMFByteStream *iface)
 {
     FIXME("%p\n", iface);
 
@@ -4134,21 +4166,21 @@ static const IMFByteStreamVtbl bytestream_file_vtbl =
     bytestream_QueryInterface,
     bytestream_AddRef,
     bytestream_Release,
-    bytestream_GetCapabilities,
+    bytestream_file_GetCapabilities,
     bytestream_file_GetLength,
-    bytestream_SetLength,
-    bytestream_file_GetCurrentPosition,
+    bytestream_file_SetLength,
+    bytestream_GetCurrentPosition,
     bytestream_SetCurrentPosition,
     bytestream_file_IsEndOfStream,
     bytestream_file_Read,
     bytestream_BeginRead,
     bytestream_EndRead,
-    bytestream_Write,
+    bytestream_file_Write,
     bytestream_BeginWrite,
     bytestream_EndWrite,
     bytestream_Seek,
-    bytestream_Flush,
-    bytestream_Close
+    bytestream_file_Flush,
+    bytestream_file_Close
 };
 
 static HRESULT WINAPI bytestream_stream_GetLength(IMFByteStream *iface, QWORD *length)
@@ -4185,17 +4217,6 @@ static HRESULT WINAPI bytestream_stream_SetLength(IMFByteStream *iface, QWORD le
     return hr;
 }
 
-static HRESULT WINAPI bytestream_stream_GetCurrentPosition(IMFByteStream *iface, QWORD *position)
-{
-    struct bytestream *stream = impl_from_IMFByteStream(iface);
-
-    TRACE("%p, %p.\n", iface, position);
-
-    *position = stream->position;
-
-    return S_OK;
-}
-
 static HRESULT WINAPI bytestream_stream_IsEndOfStream(IMFByteStream *iface, BOOL *ret)
 {
     struct bytestream *stream = impl_from_IMFByteStream(iface);
@@ -4220,7 +4241,7 @@ static HRESULT WINAPI bytestream_stream_Read(IMFByteStream *iface, BYTE *buffer,
     LARGE_INTEGER position;
     HRESULT hr;
 
-    TRACE("%p, %p, %lu, %p.\n", iface, buffer, size, read_len);
+    TRACE("%p, %p, %u, %p.\n", iface, buffer, size, read_len);
 
     EnterCriticalSection(&stream->cs);
 
@@ -4242,7 +4263,7 @@ static HRESULT WINAPI bytestream_stream_Write(IMFByteStream *iface, const BYTE *
     LARGE_INTEGER position;
     HRESULT hr;
 
-    TRACE("%p, %p, %lu, %p.\n", iface, buffer, size, written);
+    TRACE("%p, %p, %u, %p.\n", iface, buffer, size, written);
 
     EnterCriticalSection(&stream->cs);
 
@@ -4258,36 +4279,6 @@ static HRESULT WINAPI bytestream_stream_Write(IMFByteStream *iface, const BYTE *
     return hr;
 }
 
-static HRESULT WINAPI bytestream_stream_Seek(IMFByteStream *iface, MFBYTESTREAM_SEEK_ORIGIN origin, LONGLONG offset,
-        DWORD flags, QWORD *current)
-{
-    struct bytestream *stream = impl_from_IMFByteStream(iface);
-    HRESULT hr = S_OK;
-
-    TRACE("%p, %u, %s, %#lx, %p.\n", iface, origin, wine_dbgstr_longlong(offset), flags, current);
-
-    EnterCriticalSection(&stream->cs);
-
-    switch (origin)
-    {
-        case msoBegin:
-            stream->position = offset;
-            break;
-        case msoCurrent:
-            stream->position += offset;
-            break;
-        default:
-            WARN("Unknown origin mode %d.\n", origin);
-            hr = E_INVALIDARG;
-    }
-
-    *current = stream->position;
-
-    LeaveCriticalSection(&stream->cs);
-
-    return hr;
-}
-
 static HRESULT WINAPI bytestream_stream_Flush(IMFByteStream *iface)
 {
     struct bytestream *stream = impl_from_IMFByteStream(iface);
@@ -4312,7 +4303,7 @@ static const IMFByteStreamVtbl bytestream_stream_vtbl =
     bytestream_stream_GetCapabilities,
     bytestream_stream_GetLength,
     bytestream_stream_SetLength,
-    bytestream_stream_GetCurrentPosition,
+    bytestream_GetCurrentPosition,
     bytestream_SetCurrentPosition,
     bytestream_stream_IsEndOfStream,
     bytestream_stream_Read,
@@ -4321,7 +4312,7 @@ static const IMFByteStreamVtbl bytestream_stream_vtbl =
     bytestream_stream_Write,
     bytestream_BeginWrite,
     bytestream_EndWrite,
-    bytestream_stream_Seek,
+    bytestream_Seek,
     bytestream_stream_Flush,
     bytestream_stream_Close,
 };
@@ -4386,11 +4377,10 @@ static const IMFAttributesVtbl bytestream_attributes_vtbl =
     mfattributes_CopyAllItems
 };
 
-static HRESULT WINAPI bytestream_stream_read_callback_Invoke(IRtwqAsyncCallback *iface, IRtwqAsyncResult *result)
+static HRESULT WINAPI bytestream_read_callback_Invoke(IRtwqAsyncCallback *iface, IRtwqAsyncResult *result)
 {
     struct bytestream *stream = impl_from_read_callback_IRtwqAsyncCallback(iface);
     struct async_stream_op *op;
-    LARGE_INTEGER position;
     IUnknown *object;
     HRESULT hr;
 
@@ -4401,13 +4391,8 @@ static HRESULT WINAPI bytestream_stream_read_callback_Invoke(IRtwqAsyncCallback
 
     EnterCriticalSection(&stream->cs);
 
-    position.QuadPart = op->position;
-    if (SUCCEEDED(hr = IStream_Seek(stream->stream, position, STREAM_SEEK_SET, NULL)))
-    {
-        if (SUCCEEDED(hr = IStream_Read(stream->stream, op->u.dest, op->requested_length, &op->actual_length)))
-            stream->position += op->actual_length;
-    }
-
+    hr = IMFByteStream_Read(&stream->IMFByteStream_iface, op->u.dest, op->requested_length, &op->actual_length);
+    if(FAILED(hr)) TRACE("Read failed: %#lx\n", hr);
     IMFAsyncResult_SetStatus(op->caller, hr);
     list_add_tail(&stream->pending, &op->entry);
 
@@ -4418,11 +4403,10 @@ static HRESULT WINAPI bytestream_stream_read_callback_Invoke(IRtwqAsyncCallback
     return S_OK;
 }
 
-static HRESULT WINAPI bytestream_stream_write_callback_Invoke(IRtwqAsyncCallback *iface, IRtwqAsyncResult *result)
+static HRESULT WINAPI bytestream_write_callback_Invoke(IRtwqAsyncCallback *iface, IRtwqAsyncResult *result)
 {
     struct bytestream *stream = impl_from_read_callback_IRtwqAsyncCallback(iface);
     struct async_stream_op *op;
-    LARGE_INTEGER position;
     IUnknown *object;
     HRESULT hr;
 
@@ -4433,13 +4417,8 @@ static HRESULT WINAPI bytestream_stream_write_callback_Invoke(IRtwqAsyncCallback
 
     EnterCriticalSection(&stream->cs);
 
-    position.QuadPart = op->position;
-    if (SUCCEEDED(hr = IStream_Seek(stream->stream, position, STREAM_SEEK_SET, NULL)))
-    {
-        if (SUCCEEDED(hr = IStream_Write(stream->stream, op->u.src, op->requested_length, &op->actual_length)))
-            stream->position += op->actual_length;
-    }
-
+    hr = IMFByteStream_Write(&stream->IMFByteStream_iface, op->u.src, op->requested_length, &op->actual_length);
+    if(FAILED(hr)) TRACE("Write failed: %#lx\n", hr);
     IMFAsyncResult_SetStatus(op->caller, hr);
     list_add_tail(&stream->pending, &op->entry);
 
@@ -4450,22 +4429,22 @@ static HRESULT WINAPI bytestream_stream_write_callback_Invoke(IRtwqAsyncCallback
     return S_OK;
 }
 
-static const IRtwqAsyncCallbackVtbl bytestream_stream_read_callback_vtbl =
+static const IRtwqAsyncCallbackVtbl bytestream_read_callback_vtbl =
 {
     bytestream_callback_QueryInterface,
     bytestream_read_callback_AddRef,
     bytestream_read_callback_Release,
     bytestream_callback_GetParameters,
-    bytestream_stream_read_callback_Invoke,
+    bytestream_read_callback_Invoke,
 };
 
-static const IRtwqAsyncCallbackVtbl bytestream_stream_write_callback_vtbl =
+static const IRtwqAsyncCallbackVtbl bytestream_write_callback_vtbl =
 {
     bytestream_callback_QueryInterface,
     bytestream_write_callback_AddRef,
     bytestream_write_callback_Release,
     bytestream_callback_GetParameters,
-    bytestream_stream_write_callback_Invoke,
+    bytestream_write_callback_Invoke,
 };
 
 /***********************************************************************
@@ -4491,8 +4470,8 @@ HRESULT WINAPI MFCreateMFByteStreamOnStream(IStream *stream, IMFByteStream **byt
 
     object->IMFByteStream_iface.lpVtbl = &bytestream_stream_vtbl;
     object->attributes.IMFAttributes_iface.lpVtbl = &bytestream_attributes_vtbl;
-    object->read_callback.lpVtbl = &bytestream_stream_read_callback_vtbl;
-    object->write_callback.lpVtbl = &bytestream_stream_write_callback_vtbl;
+    object->read_callback.lpVtbl = &bytestream_read_callback_vtbl;
+    object->write_callback.lpVtbl = &bytestream_write_callback_vtbl;
     InitializeCriticalSection(&object->cs);
     list_init(&object->pending);
 
@@ -4516,38 +4495,6 @@ HRESULT WINAPI MFCreateMFByteStreamOnStream(IStream *stream, IMFByteStream **byt
     return S_OK;
 }
 
-static HRESULT WINAPI bytestream_file_read_callback_Invoke(IRtwqAsyncCallback *iface, IRtwqAsyncResult *result)
-{
-    FIXME("%p, %p.\n", iface, result);
-
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI bytestream_file_write_callback_Invoke(IRtwqAsyncCallback *iface, IRtwqAsyncResult *result)
-{
-    FIXME("%p, %p.\n", iface, result);
-
-    return E_NOTIMPL;
-}
-
-static const IRtwqAsyncCallbackVtbl bytestream_file_read_callback_vtbl =
-{
-    bytestream_callback_QueryInterface,
-    bytestream_read_callback_AddRef,
-    bytestream_read_callback_Release,
-    bytestream_callback_GetParameters,
-    bytestream_file_read_callback_Invoke,
-};
-
-static const IRtwqAsyncCallbackVtbl bytestream_file_write_callback_vtbl =
-{
-    bytestream_callback_QueryInterface,
-    bytestream_write_callback_AddRef,
-    bytestream_write_callback_Release,
-    bytestream_callback_GetParameters,
-    bytestream_file_write_callback_Invoke,
-};
-
 static HRESULT WINAPI bytestream_file_getservice_QueryInterface(IMFGetService *iface, REFIID riid, void **obj)
 {
     struct bytestream *stream = impl_bytestream_from_IMFGetService(iface);
@@ -4582,8 +4529,11 @@ static const IMFGetServiceVtbl bytestream_file_getservice_vtbl =
     bytestream_file_getservice_GetService,
 };
 
-static HRESULT create_file_bytestream(MF_FILE_ACCESSMODE accessmode, MF_FILE_OPENMODE openmode, MF_FILE_FLAGS flags,
-        const WCHAR *path, BOOL is_tempfile, IMFByteStream **bytestream)
+/***********************************************************************
+ *      MFCreateFile (mfplat.@)
+ */
+HRESULT WINAPI MFCreateFile(MF_FILE_ACCESSMODE accessmode, MF_FILE_OPENMODE openmode, MF_FILE_FLAGS flags,
+                            LPCWSTR url, IMFByteStream **bytestream)
 {
     DWORD capabilities = MFBYTESTREAM_IS_SEEKABLE | MFBYTESTREAM_DOES_NOT_USE_NETWORK;
     DWORD filecreation_disposition = 0, fileaccessmode = 0, fileattributes = 0;
@@ -4593,6 +4543,8 @@ static HRESULT create_file_bytestream(MF_FILE_ACCESSMODE accessmode, MF_FILE_OPE
     HANDLE file;
     HRESULT hr;
 
+    TRACE("%d, %d, %#x, %s, %p.\n", accessmode, openmode, flags, debugstr_w(url), bytestream);
+
     switch (accessmode)
     {
         case MF_ACCESSMODE_READ:
@@ -4631,12 +4583,12 @@ static HRESULT create_file_bytestream(MF_FILE_ACCESSMODE accessmode, MF_FILE_OPE
 
     if (flags & MF_FILEFLAGS_NOBUFFERING)
         fileattributes |= FILE_FLAG_NO_BUFFERING;
-    if (is_tempfile)
-        fileattributes |= FILE_FLAG_DELETE_ON_CLOSE;
 
     /* Open HANDLE to file */
-    file = CreateFileW(path, fileaccessmode, filesharemode, NULL, filecreation_disposition, fileattributes, 0);
-    if (file == INVALID_HANDLE_VALUE)
+    file = CreateFileW(url, fileaccessmode, filesharemode, NULL,
+                       filecreation_disposition, fileattributes, 0);
+
+    if(file == INVALID_HANDLE_VALUE)
         return HRESULT_FROM_WIN32(GetLastError());
 
     if (!(object = calloc(1, sizeof(*object))))
@@ -4654,68 +4606,26 @@ static HRESULT create_file_bytestream(MF_FILE_ACCESSMODE accessmode, MF_FILE_OPE
     object->IMFByteStream_iface.lpVtbl = &bytestream_file_vtbl;
     object->attributes.IMFAttributes_iface.lpVtbl = &bytestream_attributes_vtbl;
     object->IMFGetService_iface.lpVtbl = &bytestream_file_getservice_vtbl;
-    object->read_callback.lpVtbl = &bytestream_file_read_callback_vtbl;
-    object->write_callback.lpVtbl = &bytestream_file_write_callback_vtbl;
+    object->read_callback.lpVtbl = &bytestream_read_callback_vtbl;
+    object->write_callback.lpVtbl = &bytestream_write_callback_vtbl;
     InitializeCriticalSection(&object->cs);
     list_init(&object->pending);
     object->capabilities = capabilities;
     object->hfile = file;
 
-    if (!is_tempfile && GetFileTime(file, NULL, NULL, &writetime))
+    if (GetFileTime(file, NULL, NULL, &writetime))
     {
         IMFAttributes_SetBlob(&object->attributes.IMFAttributes_iface, &MF_BYTESTREAM_LAST_MODIFIED_TIME,
                 (const UINT8 *)&writetime, sizeof(writetime));
     }
 
-    IMFAttributes_SetString(&object->attributes.IMFAttributes_iface, &MF_BYTESTREAM_ORIGIN_NAME, path);
+    IMFAttributes_SetString(&object->attributes.IMFAttributes_iface, &MF_BYTESTREAM_ORIGIN_NAME, url);
 
     *bytestream = &object->IMFByteStream_iface;
 
     return S_OK;
 }
 
-/***********************************************************************
- *      MFCreateFile (mfplat.@)
- */
-HRESULT WINAPI MFCreateFile(MF_FILE_ACCESSMODE accessmode, MF_FILE_OPENMODE openmode, MF_FILE_FLAGS flags,
-        const WCHAR *path, IMFByteStream **bytestream)
-{
-    TRACE("%d, %d, %#x, %s, %p.\n", accessmode, openmode, flags, debugstr_w(path), bytestream);
-
-    return create_file_bytestream(accessmode, openmode, flags, path, FALSE, bytestream);
-}
-
-/***********************************************************************
- *      MFCreateTempFile (mfplat.@)
- */
-HRESULT WINAPI MFCreateTempFile(MF_FILE_ACCESSMODE accessmode, MF_FILE_OPENMODE openmode, MF_FILE_FLAGS flags,
-        IMFByteStream **bytestream)
-{
-    WCHAR name[24], tmppath[MAX_PATH], *path;
-    ULONG64 rnd;
-    size_t len;
-    HRESULT hr;
-
-    TRACE("%d, %d, %#x, %p.\n", accessmode, openmode, flags, bytestream);
-
-    BCryptGenRandom(NULL, (UCHAR *)&rnd, sizeof(rnd), BCRYPT_USE_SYSTEM_PREFERRED_RNG);
-    swprintf(name, ARRAY_SIZE(name), L"MFP%llX.TMP", rnd);
-    GetTempPathW(ARRAY_SIZE(tmppath), tmppath);
-
-    len = wcslen(tmppath) + wcslen(name) + 2;
-    if (!(path = malloc(len * sizeof(*path))))
-        return E_OUTOFMEMORY;
-
-    wcscpy(path, tmppath);
-    PathCchAppend(path, len, name);
-
-    hr = create_file_bytestream(accessmode, openmode, flags, path, TRUE, bytestream);
-
-    free(path);
-
-    return hr;
-}
-
 struct bytestream_wrapper
 {
     IMFByteStreamCacheControl IMFByteStreamCacheControl_iface;
@@ -4834,7 +4744,7 @@ static ULONG WINAPI bytestream_wrapper_AddRef(IMFByteStream *iface)
     struct bytestream_wrapper *wrapper = impl_wrapper_from_IMFByteStream(iface);
     ULONG refcount = InterlockedIncrement(&wrapper->refcount);
 
-    TRACE("%p, refcount %ld.\n", iface, refcount);
+    TRACE("%p, refcount %d.\n", iface, refcount);
 
     return refcount;
 }
@@ -4844,7 +4754,7 @@ static ULONG WINAPI bytestream_wrapper_Release(IMFByteStream *iface)
     struct bytestream_wrapper *wrapper = impl_wrapper_from_IMFByteStream(iface);
     ULONG refcount = InterlockedDecrement(&wrapper->refcount);
 
-    TRACE("%p, refcount %ld.\n", iface, refcount);
+    TRACE("%p, refcount %d.\n", iface, refcount);
 
     if (!refcount)
     {
@@ -4942,7 +4852,7 @@ static HRESULT WINAPI bytestream_wrapper_Read(IMFByteStream *iface, BYTE *data,
 {
     struct bytestream_wrapper *wrapper = impl_wrapper_from_IMFByteStream(iface);
 
-    TRACE("%p, %p, %lu, %p.\n", iface, data, count, byte_read);
+    TRACE("%p, %p, %u, %p.\n", iface, data, count, byte_read);
 
     return wrapper->is_closed ? MF_E_INVALIDREQUEST :
             IMFByteStream_Read(wrapper->stream, data, count, byte_read);
@@ -4953,7 +4863,7 @@ static HRESULT WINAPI bytestream_wrapper_BeginRead(IMFByteStream *iface, BYTE *d
 {
     struct bytestream_wrapper *wrapper = impl_wrapper_from_IMFByteStream(iface);
 
-    TRACE("%p, %p, %lu, %p, %p.\n", iface, data, size, callback, state);
+    TRACE("%p, %p, %u, %p, %p.\n", iface, data, size, callback, state);
 
     return wrapper->is_closed ? MF_E_INVALIDREQUEST :
             IMFByteStream_BeginRead(wrapper->stream, data, size, callback, state);
@@ -4973,7 +4883,7 @@ static HRESULT WINAPI bytestream_wrapper_Write(IMFByteStream *iface, const BYTE
 {
     struct bytestream_wrapper *wrapper = impl_wrapper_from_IMFByteStream(iface);
 
-    TRACE("%p, %p, %lu, %p.\n", iface, data, count, written);
+    TRACE("%p, %p, %u, %p.\n", iface, data, count, written);
 
     return wrapper->is_closed ? MF_E_INVALIDREQUEST :
             IMFByteStream_Write(wrapper->stream, data, count, written);
@@ -4984,7 +4894,7 @@ static HRESULT WINAPI bytestream_wrapper_BeginWrite(IMFByteStream *iface, const
 {
     struct bytestream_wrapper *wrapper = impl_wrapper_from_IMFByteStream(iface);
 
-    TRACE("%p, %p, %lu, %p, %p.\n", iface, data, size, callback, state);
+    TRACE("%p, %p, %u, %p, %p.\n", iface, data, size, callback, state);
 
     return wrapper->is_closed ? MF_E_INVALIDREQUEST :
             IMFByteStream_BeginWrite(wrapper->stream, data, size, callback, state);
@@ -5005,7 +4915,7 @@ static HRESULT WINAPI bytestream_wrapper_Seek(IMFByteStream *iface, MFBYTESTREAM
 {
     struct bytestream_wrapper *wrapper = impl_wrapper_from_IMFByteStream(iface);
 
-    TRACE("%p, %u, %s, %#lx, %p.\n", iface, seek, wine_dbgstr_longlong(offset), flags, current);
+    TRACE("%p, %u, %s, %#x, %p.\n", iface, seek, wine_dbgstr_longlong(offset), flags, current);
 
     return wrapper->is_closed ? MF_E_INVALIDREQUEST :
             IMFByteStream_Seek(wrapper->stream, seek, offset, flags, current);
@@ -5226,7 +5136,7 @@ static HRESULT WINAPI bytestream_wrapper_events_GetEvent(IMFMediaEventGenerator
 {
     struct bytestream_wrapper *wrapper = impl_wrapper_from_IMFMediaEventGenerator(iface);
 
-    TRACE("%p, %#lx, %p.\n", iface, flags, event);
+    TRACE("%p, %#x, %p.\n", iface, flags, event);
 
     return IMFMediaEventGenerator_GetEvent(wrapper->event_generator, flags, event);
 }
@@ -5254,7 +5164,7 @@ static HRESULT WINAPI bytestream_wrapper_events_QueueEvent(IMFMediaEventGenerato
 {
     struct bytestream_wrapper *wrapper = impl_wrapper_from_IMFMediaEventGenerator(iface);
 
-    TRACE("%p, %ld, %s, %#lx, %s.\n", iface, type, debugstr_guid(ext_type), hr, debugstr_propvar(value));
+    TRACE("%p, %d, %s, %#x, %s.\n", iface, type, debugstr_guid(ext_type), hr, debugstr_propvar(value));
 
     return IMFMediaEventGenerator_QueueEvent(wrapper->event_generator, type, ext_type, hr, value);
 }
@@ -5357,7 +5267,7 @@ static HRESULT WINAPI bytestream_wrapper_propstore_GetAt(IPropertyStore *iface,
 {
     struct bytestream_wrapper *wrapper = impl_wrapper_from_IPropertyStore(iface);
 
-    TRACE("%p, %lu, %p.\n", iface, prop, key);
+    TRACE("%p, %u, %p.\n", iface, prop, key);
 
     return IPropertyStore_GetAt(wrapper->propstore, prop, key);
 }
@@ -5803,39 +5713,39 @@ static ULONG WINAPI MFPluginControl_Release(IMFPluginControl *iface)
 static HRESULT WINAPI MFPluginControl_GetPreferredClsid(IMFPluginControl *iface, DWORD plugin_type,
         const WCHAR *selector, CLSID *clsid)
 {
-    FIXME("(%ld %s %p)\n", plugin_type, debugstr_w(selector), clsid);
+    FIXME("(%d %s %p)\n", plugin_type, debugstr_w(selector), clsid);
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI MFPluginControl_GetPreferredClsidByIndex(IMFPluginControl *iface, DWORD plugin_type,
         DWORD index, WCHAR **selector, CLSID *clsid)
 {
-    FIXME("(%ld %ld %p %p)\n", plugin_type, index, selector, clsid);
+    FIXME("(%d %d %p %p)\n", plugin_type, index, selector, clsid);
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI MFPluginControl_SetPreferredClsid(IMFPluginControl *iface, DWORD plugin_type,
         const WCHAR *selector, const CLSID *clsid)
 {
-    FIXME("(%ld %s %s)\n", plugin_type, debugstr_w(selector), debugstr_guid(clsid));
+    FIXME("(%d %s %s)\n", plugin_type, debugstr_w(selector), debugstr_guid(clsid));
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI MFPluginControl_IsDisabled(IMFPluginControl *iface, DWORD plugin_type, REFCLSID clsid)
 {
-    FIXME("(%ld %s)\n", plugin_type, debugstr_guid(clsid));
+    FIXME("(%d %s)\n", plugin_type, debugstr_guid(clsid));
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI MFPluginControl_GetDisabledByIndex(IMFPluginControl *iface, DWORD plugin_type, DWORD index, CLSID *clsid)
 {
-    FIXME("(%ld %ld %p)\n", plugin_type, index, clsid);
+    FIXME("(%d %d %p)\n", plugin_type, index, clsid);
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI MFPluginControl_SetDisabled(IMFPluginControl *iface, DWORD plugin_type, REFCLSID clsid, BOOL disabled)
 {
-    FIXME("(%ld %s %x)\n", plugin_type, debugstr_guid(clsid), disabled);
+    FIXME("(%d %s %x)\n", plugin_type, debugstr_guid(clsid), disabled);
     return E_NOTIMPL;
 }
 
@@ -6137,9 +6047,8 @@ static const IRtwqAsyncCallbackVtbl source_resolver_callback_url_vtbl =
 
 static HRESULT resolver_create_registered_handler(HKEY hkey, REFIID riid, void **handler)
 {
-    DWORD name_length, type;
+    unsigned int j = 0, name_length, type;
     HRESULT hr = E_FAIL;
-    unsigned int j = 0;
     WCHAR clsidW[39];
     CLSID clsid;
 
@@ -6162,15 +6071,40 @@ static HRESULT resolver_create_registered_handler(HKEY hkey, REFIID riid, void *
     return hr;
 }
 
-static HRESULT resolver_create_bytestream_handler(IMFByteStream *stream, DWORD flags, const WCHAR *mime,
-        const WCHAR *extension, IMFByteStreamHandler **handler)
+static HRESULT resolver_get_bytestream_handler(IMFByteStream *stream, const WCHAR *url, DWORD flags,
+        IMFByteStreamHandler **handler)
 {
     static const HKEY hkey_roots[2] = { HKEY_CURRENT_USER, HKEY_LOCAL_MACHINE };
+    WCHAR *mimeW = NULL, *urlW = NULL;
+    IMFAttributes *attributes;
+    const WCHAR *url_ext;
     HRESULT hr = E_FAIL;
     unsigned int i, j;
+    UINT32 length;
 
     *handler = NULL;
 
+    /* MIME type */
+    if (SUCCEEDED(IMFByteStream_QueryInterface(stream, &IID_IMFAttributes, (void **)&attributes)))
+    {
+        IMFAttributes_GetAllocatedString(attributes, &MF_BYTESTREAM_CONTENT_TYPE, &mimeW, &length);
+        if (!url)
+        {
+            IMFAttributes_GetAllocatedString(attributes, &MF_BYTESTREAM_ORIGIN_NAME, &urlW, &length);
+            url = urlW;
+        }
+        IMFAttributes_Release(attributes);
+    }
+
+    /* Extension */
+    url_ext = url ? wcsrchr(url, '.') : NULL;
+
+    if (!url_ext && !mimeW)
+    {
+        CoTaskMemFree(urlW);
+        return MF_E_UNSUPPORTED_BYTESTREAM_TYPE;
+    }
+
     if (!(flags & MF_RESOLUTION_DISABLE_LOCAL_PLUGINS))
     {
         struct local_handler *local_handler;
@@ -6179,8 +6113,8 @@ static HRESULT resolver_create_bytestream_handler(IMFByteStream *stream, DWORD f
 
         LIST_FOR_EACH_ENTRY(local_handler, &local_bytestream_handlers, struct local_handler, entry)
         {
-            if ((mime && !lstrcmpiW(mime, local_handler->u.bytestream.mime))
-                    || (extension && !lstrcmpiW(extension, local_handler->u.bytestream.extension)))
+            if ((mimeW && !lstrcmpiW(mimeW, local_handler->u.bytestream.mime))
+                    || (url_ext && !lstrcmpiW(url_ext, local_handler->u.bytestream.extension)))
             {
                 if (SUCCEEDED(hr = IMFActivate_ActivateObject(local_handler->activate, &IID_IMFByteStreamHandler,
                         (void **)handler)))
@@ -6191,12 +6125,16 @@ static HRESULT resolver_create_bytestream_handler(IMFByteStream *stream, DWORD f
         LeaveCriticalSection(&local_handlers_section);
 
         if (*handler)
+        {
+            CoTaskMemFree(mimeW);
+            CoTaskMemFree(urlW);
             return hr;
+        }
     }
 
     for (i = 0, hr = E_FAIL; i < ARRAY_SIZE(hkey_roots); ++i)
     {
-        const WCHAR *namesW[2] = { mime, extension };
+        const WCHAR *namesW[2] = { mimeW, url_ext };
         HKEY hkey, hkey_handler;
 
         if (RegOpenKeyW(hkey_roots[i], L"Software\\Microsoft\\Windows Media Foundation\\ByteStreamHandlers", &hkey))
@@ -6223,161 +6161,14 @@ static HRESULT resolver_create_bytestream_handler(IMFByteStream *stream, DWORD f
             break;
     }
 
-    return hr;
-}
-
-static HRESULT resolver_get_bytestream_url_hint(IMFByteStream *stream, WCHAR const **url)
-{
-    static const unsigned char asfmagic[]  = {0x30,0x26,0xb2,0x75,0x8e,0x66,0xcf,0x11,0xa6,0xd9,0x00,0xaa,0x00,0x62,0xce,0x6c};
-    static const unsigned char wavmagic[]  = { 'R', 'I', 'F', 'F',0x00,0x00,0x00,0x00, 'W', 'A', 'V', 'E', 'f', 'm', 't', ' '};
-    static const unsigned char wavmask[]   = {0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff};
-    static const unsigned char isommagic[] = {0x00,0x00,0x00,0x00, 'f', 't', 'y', 'p', 'i', 's', 'o', 'm',0x00,0x00,0x00,0x00};
-    static const unsigned char mp4_magic[] = {0x00,0x00,0x00,0x00, 'f', 't', 'y', 'p', 'M', 'S', 'N', 'V',0x00,0x00,0x00,0x00};
-    static const unsigned char mp42magic[] = {0x00,0x00,0x00,0x00, 'f', 't', 'y', 'p', 'm', 'p', '4', '2',0x00,0x00,0x00,0x00};
-    static const unsigned char mp4vmagic[] = {0x00,0x00,0x00,0x00, 'f', 't', 'y', 'p', 'M', '4', 'V', ' ',0x00,0x00,0x00,0x00};
-    static const unsigned char mp4mask[]   = {0x00,0x00,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00};
-    static const struct stream_content_url_hint
-    {
-        const unsigned char *magic;
-        const WCHAR *url;
-        const unsigned char *mask;
-    }
-    url_hints[] =
-    {
-        { asfmagic,  L".asf" },
-        { wavmagic,  L".wav", wavmask },
-        { isommagic, L".mp4", mp4mask },
-        { mp42magic, L".mp4", mp4mask },
-        { mp4_magic, L".mp4", mp4mask },
-        { mp4vmagic, L".m4v", mp4mask },
-    };
-    unsigned char buffer[4 * sizeof(unsigned int)], pattern[4 * sizeof(unsigned int)];
-    IMFAttributes *attributes;
-    DWORD length = 0, caps = 0;
-    unsigned int i, j;
-    QWORD position;
-    HRESULT hr;
-
-    *url = NULL;
-
-    if (SUCCEEDED(IMFByteStream_QueryInterface(stream, &IID_IMFAttributes, (void **)&attributes)))
-    {
-        UINT32 string_length = 0;
-        IMFAttributes_GetStringLength(attributes, &MF_BYTESTREAM_CONTENT_TYPE, &string_length);
-        IMFAttributes_Release(attributes);
-
-        if (string_length)
-            return S_OK;
-    }
-
-    if (FAILED(hr = IMFByteStream_GetCapabilities(stream, &caps)))
-        return hr;
-
-    if (!(caps & MFBYTESTREAM_IS_SEEKABLE))
-        return MF_E_UNSUPPORTED_BYTESTREAM_TYPE;
-
-    if (FAILED(hr = IMFByteStream_GetCurrentPosition(stream, &position)))
-        return hr;
-
-    hr = IMFByteStream_Read(stream, buffer, sizeof(buffer), &length);
-    IMFByteStream_SetCurrentPosition(stream, position);
     if (FAILED(hr))
-        return hr;
-
-    if (length < sizeof(buffer))
-        return S_OK;
-
-    for (i = 0; i < ARRAY_SIZE(url_hints); ++i)
-    {
-        memcpy(pattern, buffer, sizeof(buffer));
-        if (url_hints[i].mask)
-        {
-            unsigned int *mask = (unsigned int *)url_hints[i].mask;
-            unsigned int *data = (unsigned int *)pattern;
-
-            for (j = 0; j < sizeof(buffer) / sizeof(unsigned int); ++j)
-                data[j] &= mask[j];
-
-        }
-        if (!memcmp(pattern, url_hints[i].magic, sizeof(pattern)))
-        {
-            *url = url_hints[i].url;
-            break;
-        }
-    }
-
-    if (*url)
-        TRACE("Content type guessed as %s from %s.\n", debugstr_w(*url), debugstr_an((char *)buffer, length));
-    else
-        WARN("Unrecognized content type %s.\n", debugstr_an((char *)buffer, length));
-
-    return S_OK;
-}
-
-static HRESULT resolver_create_gstreamer_handler(IMFByteStreamHandler **handler)
-{
-    static const GUID CLSID_GStreamerByteStreamHandler = {0x317df618, 0x5e5a, 0x468a, {0x9f, 0x15, 0xd8, 0x27, 0xa9, 0xa0, 0x81, 0x62}};
-    return CoCreateInstance(&CLSID_GStreamerByteStreamHandler, NULL, CLSCTX_INPROC_SERVER, &IID_IMFByteStreamHandler, (void **)handler);
-}
-
-static HRESULT resolver_get_bytestream_handler(IMFByteStream *stream, const WCHAR *url, DWORD flags,
-        IMFByteStreamHandler **handler)
-{
-    WCHAR *mimeW = NULL, *urlW = NULL;
-    IMFAttributes *attributes;
-    const WCHAR *url_ext;
-    HRESULT hr = E_FAIL;
-    UINT32 length;
-
-    *handler = NULL;
-
-    /* MIME type */
-    if (SUCCEEDED(IMFByteStream_QueryInterface(stream, &IID_IMFAttributes, (void **)&attributes)))
     {
-        IMFAttributes_GetAllocatedString(attributes, &MF_BYTESTREAM_CONTENT_TYPE, &mimeW, &length);
-        if (!url)
-        {
-            IMFAttributes_GetAllocatedString(attributes, &MF_BYTESTREAM_ORIGIN_NAME, &urlW, &length);
-            url = urlW;
-        }
-        IMFAttributes_Release(attributes);
-    }
-
-    /* Extension */
-    url_ext = url ? wcsrchr(url, '.') : NULL;
-
-    /* If content type was provided by the caller, it's tried first. Otherwise an attempt to deduce
-       content type from the content itself is made.
-
-       TODO: wine specific fallback to predefined handler could be replaced by normally registering
-       this handler for all possible types.
-     */
-
-    if (url_ext || mimeW)
-    {
-        hr = resolver_create_bytestream_handler(stream, flags, mimeW, url_ext, handler);
-
-        if (FAILED(hr))
-            hr = resolver_create_gstreamer_handler(handler);
+        static const GUID CLSID_GStreamerByteStreamHandler = {0x317df618, 0x5e5a, 0x468a, {0x9f, 0x15, 0xd8, 0x27, 0xa9, 0xa0, 0x81, 0x62}};
+        hr = CoCreateInstance(&CLSID_GStreamerByteStreamHandler, NULL, CLSCTX_INPROC_SERVER, &IID_IMFByteStreamHandler, (void **)handler);
     }
 
     CoTaskMemFree(mimeW);
     CoTaskMemFree(urlW);
-
-    if (SUCCEEDED(hr))
-        return hr;
-
-    if (!(flags & MF_RESOLUTION_CONTENT_DOES_NOT_HAVE_TO_MATCH_EXTENSION_OR_MIME_TYPE))
-        return MF_E_UNSUPPORTED_BYTESTREAM_TYPE;
-
-    if (FAILED(hr = resolver_get_bytestream_url_hint(stream, &url_ext)))
-        return hr;
-
-    hr = resolver_create_bytestream_handler(stream, flags, NULL, url_ext, handler);
-
-    if (FAILED(hr))
-        hr = resolver_create_gstreamer_handler(handler);
-
     return hr;
 }
 
@@ -6387,7 +6178,7 @@ static HRESULT resolver_create_scheme_handler(const WCHAR *scheme, DWORD flags,
     HRESULT hr = MF_E_UNSUPPORTED_SCHEME;
     unsigned int i;
 
-    TRACE("%s, %#lx, %p.\n", debugstr_w(scheme), flags, handler);
+    TRACE("%s, %#x, %p.\n", debugstr_w(scheme), flags, handler);
 
     *handler = NULL;
 
@@ -6469,11 +6260,10 @@ static HRESULT resolver_get_scheme_handler(const WCHAR *url, DWORD flags, IMFSch
     if (ptr == url || *ptr != ':')
     {
         url = fileschemeW;
-        len = ARRAY_SIZE(fileschemeW) - 1;
+        ptr = fileschemeW + ARRAY_SIZE(fileschemeW) - 1;
     }
-    else
-        len = ptr - url + 1;
 
+    len = ptr - url;
     scheme = malloc((len + 1) * sizeof(WCHAR));
     if (!scheme)
         return E_OUTOFMEMORY;
@@ -6558,7 +6348,7 @@ static ULONG WINAPI source_resolver_AddRef(IMFSourceResolver *iface)
     struct source_resolver *resolver = impl_from_IMFSourceResolver(iface);
     ULONG refcount = InterlockedIncrement(&resolver->refcount);
 
-    TRACE("%p, refcount %ld.\n", iface, refcount);
+    TRACE("%p, refcount %d.\n", iface, refcount);
 
     return refcount;
 }
@@ -6569,7 +6359,7 @@ static ULONG WINAPI source_resolver_Release(IMFSourceResolver *iface)
     ULONG refcount = InterlockedDecrement(&resolver->refcount);
     struct resolver_queued_result *result, *result2;
 
-    TRACE("%p, refcount %ld.\n", iface, refcount);
+    TRACE("%p, refcount %d.\n", iface, refcount);
 
     if (!refcount)
     {
@@ -6596,7 +6386,7 @@ static HRESULT WINAPI source_resolver_CreateObjectFromURL(IMFSourceResolver *ifa
     RTWQASYNCRESULT *data;
     HRESULT hr;
 
-    TRACE("%p, %s, %#lx, %p, %p, %p.\n", iface, debugstr_w(url), flags, props, obj_type, object);
+    TRACE("%p, %s, %#x, %p, %p, %p.\n", iface, debugstr_w(url), flags, props, obj_type, object);
 
     if (!url || !obj_type || !object)
         return E_POINTER;
@@ -6637,7 +6427,7 @@ static HRESULT WINAPI source_resolver_CreateObjectFromByteStream(IMFSourceResolv
     RTWQASYNCRESULT *data;
     HRESULT hr;
 
-    TRACE("%p, %p, %s, %#lx, %p, %p, %p.\n", iface, stream, debugstr_w(url), flags, props, obj_type, object);
+    TRACE("%p, %p, %s, %#x, %p, %p, %p.\n", iface, stream, debugstr_w(url), flags, props, obj_type, object);
 
     if (!stream || !obj_type || !object)
         return E_POINTER;
@@ -6678,7 +6468,7 @@ static HRESULT WINAPI source_resolver_BeginCreateObjectFromURL(IMFSourceResolver
     IRtwqAsyncResult *result;
     HRESULT hr;
 
-    TRACE("%p, %s, %#lx, %p, %p, %p, %p.\n", iface, debugstr_w(url), flags, props, cancel_cookie, callback, state);
+    TRACE("%p, %s, %#x, %p, %p, %p, %p.\n", iface, debugstr_w(url), flags, props, cancel_cookie, callback, state);
 
     if (FAILED(hr = resolver_get_scheme_handler(url, flags, &handler)))
         return hr;
@@ -6722,7 +6512,7 @@ static HRESULT WINAPI source_resolver_BeginCreateObjectFromByteStream(IMFSourceR
     IRtwqAsyncResult *result;
     HRESULT hr;
 
-    TRACE("%p, %p, %s, %#lx, %p, %p, %p, %p.\n", iface, stream, debugstr_w(url), flags, props, cancel_cookie,
+    TRACE("%p, %p, %s, %#x, %p, %p, %p, %p.\n", iface, stream, debugstr_w(url), flags, props, cancel_cookie,
             callback, state);
 
     if (FAILED(hr = resolver_get_bytestream_handler(stream, url, flags, &handler)))
@@ -6868,7 +6658,7 @@ static ULONG WINAPI mfmediaevent_AddRef(IMFMediaEvent *iface)
     struct media_event *event = impl_from_IMFMediaEvent(iface);
     ULONG refcount = InterlockedIncrement(&event->attributes.ref);
 
-    TRACE("%p, refcount %lu.\n", iface, refcount);
+    TRACE("%p, refcount %u.\n", iface, refcount);
 
     return refcount;
 }
@@ -6878,7 +6668,7 @@ static ULONG WINAPI mfmediaevent_Release(IMFMediaEvent *iface)
     struct media_event *event = impl_from_IMFMediaEvent(iface);
     ULONG refcount = InterlockedDecrement(&event->attributes.ref);
 
-    TRACE("%p, refcount %lu.\n", iface, refcount);
+    TRACE("%p, refcount %u.\n", iface, refcount);
 
     if (!refcount)
     {
@@ -7258,7 +7048,7 @@ HRESULT WINAPI MFCreateMediaEvent(MediaEventType type, REFGUID extended_type, HR
     struct media_event *object;
     HRESULT hr;
 
-    TRACE("%s, %s, %#lx, %s, %p.\n", debugstr_eventid(type), debugstr_guid(extended_type), status,
+    TRACE("%s, %s, %#x, %s, %p.\n", debugstr_eventid(type), debugstr_guid(extended_type), status,
             debugstr_propvar(value), event);
 
     object = malloc(sizeof(*object));
@@ -7367,7 +7157,7 @@ static ULONG WINAPI eventqueue_AddRef(IMFMediaEventQueue *iface)
     struct event_queue *queue = impl_from_IMFMediaEventQueue(iface);
     ULONG refcount = InterlockedIncrement(&queue->refcount);
 
-    TRACE("%p, refcount %lu.\n", iface, refcount);
+    TRACE("%p, refcount %u.\n", iface, refcount);
 
     return refcount;
 }
@@ -7377,7 +7167,7 @@ static ULONG WINAPI eventqueue_Release(IMFMediaEventQueue *iface)
     struct event_queue *queue = impl_from_IMFMediaEventQueue(iface);
     ULONG refcount = InterlockedDecrement(&queue->refcount);
 
-    TRACE("%p, refcount %lu.\n", queue, refcount);
+    TRACE("%p, refcount %u.\n", queue, refcount);
 
     if (!refcount)
     {
@@ -7542,7 +7332,7 @@ static HRESULT WINAPI eventqueue_QueueEventParamVar(IMFMediaEventQueue *iface, M
     IMFMediaEvent *event;
     HRESULT hr;
 
-    TRACE("%p, %s, %s, %#lx, %s\n", iface, debugstr_eventid(event_type), debugstr_guid(extended_type), status,
+    TRACE("%p, %s, %s, %#x, %s\n", iface, debugstr_eventid(event_type), debugstr_guid(extended_type), status,
             debugstr_propvar(value));
 
     if (FAILED(hr = MFCreateMediaEvent(event_type, extended_type, status, value, &event)))
@@ -7561,7 +7351,7 @@ static HRESULT WINAPI eventqueue_QueueEventParamUnk(IMFMediaEventQueue *iface, M
     PROPVARIANT value;
     HRESULT hr;
 
-    TRACE("%p, %s, %s, %#lx, %p.\n", iface, debugstr_eventid(event_type), debugstr_guid(extended_type), status, unk);
+    TRACE("%p, %s, %s, %#x, %p.\n", iface, debugstr_eventid(event_type), debugstr_guid(extended_type), status, unk);
 
     value.vt = VT_UNKNOWN;
     value.punkVal = unk;
@@ -7684,7 +7474,7 @@ static ULONG WINAPI collection_AddRef(IMFCollection *iface)
     struct collection *collection = impl_from_IMFCollection(iface);
     ULONG refcount = InterlockedIncrement(&collection->refcount);
 
-    TRACE("%p, %ld.\n", collection, refcount);
+    TRACE("%p, %d.\n", collection, refcount);
 
     return refcount;
 }
@@ -7694,7 +7484,7 @@ static ULONG WINAPI collection_Release(IMFCollection *iface)
     struct collection *collection = impl_from_IMFCollection(iface);
     ULONG refcount = InterlockedDecrement(&collection->refcount);
 
-    TRACE("%p, %ld.\n", collection, refcount);
+    TRACE("%p, %d.\n", collection, refcount);
 
     if (!refcount)
     {
@@ -7724,7 +7514,7 @@ static HRESULT WINAPI collection_GetElement(IMFCollection *iface, DWORD idx, IUn
 {
     struct collection *collection = impl_from_IMFCollection(iface);
 
-    TRACE("%p, %lu, %p.\n", iface, idx, element);
+    TRACE("%p, %u, %p.\n", iface, idx, element);
 
     if (!element)
         return E_POINTER;
@@ -7761,7 +7551,7 @@ static HRESULT WINAPI collection_RemoveElement(IMFCollection *iface, DWORD idx,
     struct collection *collection = impl_from_IMFCollection(iface);
     size_t count;
 
-    TRACE("%p, %lu, %p.\n", iface, idx, element);
+    TRACE("%p, %u, %p.\n", iface, idx, element);
 
     if (!element)
         return E_POINTER;
@@ -7784,7 +7574,7 @@ static HRESULT WINAPI collection_InsertElementAt(IMFCollection *iface, DWORD idx
     struct collection *collection = impl_from_IMFCollection(iface);
     size_t i;
 
-    TRACE("%p, %lu, %p.\n", iface, idx, element);
+    TRACE("%p, %u, %p.\n", iface, idx, element);
 
     if (!mf_array_reserve((void **)&collection->elements, &collection->capacity, idx + 1,
             sizeof(*collection->elements)))
@@ -7862,7 +7652,7 @@ HRESULT WINAPI MFCreateCollection(IMFCollection **collection)
  */
 void *WINAPI MFHeapAlloc(SIZE_T size, ULONG flags, char *file, int line, EAllocationType type)
 {
-    TRACE("%Iu, %#lx, %s, %d, %#x.\n", size, flags, debugstr_a(file), line, type);
+    TRACE("%lu, %#x, %s, %d, %#x.\n", size, flags, debugstr_a(file), line, type);
     return HeapAlloc(GetProcessHeap(), flags, size);
 }
 
@@ -7907,7 +7697,7 @@ static ULONG WINAPI system_clock_AddRef(IMFClock *iface)
     struct system_clock *clock = impl_from_IMFClock(iface);
     ULONG refcount = InterlockedIncrement(&clock->refcount);
 
-    TRACE("%p, refcount %lu.\n", iface, refcount);
+    TRACE("%p, refcount %u.\n", iface, refcount);
 
     return refcount;
 }
@@ -7917,7 +7707,7 @@ static ULONG WINAPI system_clock_Release(IMFClock *iface)
     struct system_clock *clock = impl_from_IMFClock(iface);
     ULONG refcount = InterlockedDecrement(&clock->refcount);
 
-    TRACE("%p, refcount %lu.\n", iface, refcount);
+    TRACE("%p, refcount %u.\n", iface, refcount);
 
     if (!refcount)
         free(clock);
@@ -7938,7 +7728,7 @@ static HRESULT WINAPI system_clock_GetClockCharacteristics(IMFClock *iface, DWOR
 static HRESULT WINAPI system_clock_GetCorrelatedTime(IMFClock *iface, DWORD reserved, LONGLONG *clock_time,
         MFTIME *system_time)
 {
-    TRACE("%p, %#lx, %p, %p.\n", iface, reserved, clock_time, system_time);
+    TRACE("%p, %#x, %p, %p.\n", iface, reserved, clock_time, system_time);
 
     *clock_time = *system_time = MFGetSystemTime();
 
@@ -7956,7 +7746,7 @@ static HRESULT WINAPI system_clock_GetContinuityKey(IMFClock *iface, DWORD *key)
 
 static HRESULT WINAPI system_clock_GetState(IMFClock *iface, DWORD reserved, MFCLOCK_STATE *state)
 {
-    TRACE("%p, %#lx, %p.\n", iface, reserved, state);
+    TRACE("%p, %#x, %p.\n", iface, reserved, state);
 
     *state = MFCLOCK_STATE_RUNNING;
 
@@ -8036,7 +7826,7 @@ static ULONG WINAPI system_time_source_AddRef(IMFPresentationTimeSource *iface)
     struct system_time_source *source = impl_from_IMFPresentationTimeSource(iface);
     ULONG refcount = InterlockedIncrement(&source->refcount);
 
-    TRACE("%p, refcount %lu.\n", iface, refcount);
+    TRACE("%p, refcount %u.\n", iface, refcount);
 
     return refcount;
 }
@@ -8046,7 +7836,7 @@ static ULONG WINAPI system_time_source_Release(IMFPresentationTimeSource *iface)
     struct system_time_source *source = impl_from_IMFPresentationTimeSource(iface);
     ULONG refcount = InterlockedDecrement(&source->refcount);
 
-    TRACE("%p, refcount %lu.\n", iface, refcount);
+    TRACE("%p, refcount %u.\n", iface, refcount);
 
     if (!refcount)
     {
@@ -8074,14 +7864,18 @@ static HRESULT WINAPI system_time_source_GetCorrelatedTime(IMFPresentationTimeSo
     struct system_time_source *source = impl_from_IMFPresentationTimeSource(iface);
     HRESULT hr;
 
-    TRACE("%p, %#lx, %p, %p.\n", iface, reserved, clock_time, system_time);
+    TRACE("%p, %#x, %p, %p.\n", iface, reserved, clock_time, system_time);
 
     EnterCriticalSection(&source->cs);
     if (SUCCEEDED(hr = IMFClock_GetCorrelatedTime(source->clock, 0, clock_time, system_time)))
     {
         if (source->state == MFCLOCK_STATE_RUNNING)
-            system_time_source_update_clock_time(source, *system_time);
-        *clock_time = source->start_offset + source->clock_time;
+        {
+            system_time_source_apply_rate(source, clock_time);
+            *clock_time += source->start_offset;
+        }
+        else
+            *clock_time = source->start_offset;
     }
     LeaveCriticalSection(&source->cs);
 
@@ -8102,7 +7896,7 @@ static HRESULT WINAPI system_time_source_GetState(IMFPresentationTimeSource *ifa
 {
     struct system_time_source *source = impl_from_IMFPresentationTimeSource(iface);
 
-    TRACE("%p, %#lx, %p.\n", iface, reserved, state);
+    TRACE("%p, %#x, %p.\n", iface, reserved, state);
 
     EnterCriticalSection(&source->cs);
     *state = source->state;
@@ -8220,19 +8014,25 @@ static HRESULT WINAPI system_time_source_sink_OnClockStart(IMFClockStateSink *if
     state = source->state;
     if (SUCCEEDED(hr = system_time_source_change_state(source, CLOCK_CMD_START)))
     {
+        system_time_source_apply_rate(source, &system_time);
         if (start_offset == PRESENTATION_CURRENT_POSITION)
         {
-            if (state != MFCLOCK_STATE_RUNNING)
+            switch (state)
             {
-                source->start_offset -= system_time;
-                source->system_time = 0;
+                case MFCLOCK_STATE_RUNNING:
+                    break;
+                case MFCLOCK_STATE_PAUSED:
+                    source->start_offset -= system_time;
+                    break;
+                default:
+                    source->start_offset = -system_time;
+                    break;
+                    ;
             }
         }
         else
         {
-            source->start_offset = start_offset;
-            source->system_time = system_time;
-            source->clock_time = 0;
+            source->start_offset = -system_time + start_offset;
         }
     }
     LeaveCriticalSection(&source->cs);
@@ -8249,9 +8049,7 @@ static HRESULT WINAPI system_time_source_sink_OnClockStop(IMFClockStateSink *ifa
 
     EnterCriticalSection(&source->cs);
     if (SUCCEEDED(hr = system_time_source_change_state(source, CLOCK_CMD_STOP)))
-    {
-        source->start_offset = source->system_time = source->clock_time = 0;
-    }
+        source->start_offset = 0;
     LeaveCriticalSection(&source->cs);
 
     return hr;
@@ -8267,7 +8065,8 @@ static HRESULT WINAPI system_time_source_sink_OnClockPause(IMFClockStateSink *if
     EnterCriticalSection(&source->cs);
     if (SUCCEEDED(hr = system_time_source_change_state(source, CLOCK_CMD_PAUSE)))
     {
-        system_time_source_update_clock_time(source, system_time);
+        system_time_source_apply_rate(source, &system_time);
+        source->start_offset += system_time;
     }
     LeaveCriticalSection(&source->cs);
 
@@ -8284,7 +8083,8 @@ static HRESULT WINAPI system_time_source_sink_OnClockRestart(IMFClockStateSink *
     EnterCriticalSection(&source->cs);
     if (SUCCEEDED(hr = system_time_source_change_state(source, CLOCK_CMD_RESTART)))
     {
-        source->system_time = system_time;
+        system_time_source_apply_rate(source, &system_time);
+        source->start_offset -= system_time;
     }
     LeaveCriticalSection(&source->cs);
 
@@ -8399,7 +8199,7 @@ static ULONG WINAPI async_create_file_callback_AddRef(IRtwqAsyncCallback *iface)
     struct async_create_file *async = impl_from_create_file_IRtwqAsyncCallback(iface);
     ULONG refcount = InterlockedIncrement(&async->refcount);
 
-    TRACE("%p, refcount %lu.\n", iface, refcount);
+    TRACE("%p, refcount %u.\n", iface, refcount);
 
     return refcount;
 }
@@ -8409,7 +8209,7 @@ static ULONG WINAPI async_create_file_callback_Release(IRtwqAsyncCallback *iface
     struct async_create_file *async = impl_from_create_file_IRtwqAsyncCallback(iface);
     ULONG refcount = InterlockedDecrement(&async->refcount);
 
-    TRACE("%p, refcount %lu.\n", iface, refcount);
+    TRACE("%p, refcount %u.\n", iface, refcount);
 
     if (!refcount)
     {
@@ -8696,7 +8496,7 @@ static ULONG WINAPI property_store_AddRef(IPropertyStore *iface)
     struct property_store *store = impl_from_IPropertyStore(iface);
     ULONG refcount = InterlockedIncrement(&store->refcount);
 
-    TRACE("%p, refcount %ld.\n", iface, refcount);
+    TRACE("%p, refcount %d.\n", iface, refcount);
 
     return refcount;
 }
@@ -8706,7 +8506,7 @@ static ULONG WINAPI property_store_Release(IPropertyStore *iface)
     struct property_store *store = impl_from_IPropertyStore(iface);
     ULONG refcount = InterlockedDecrement(&store->refcount);
 
-    TRACE("%p, refcount %ld.\n", iface, refcount);
+    TRACE("%p, refcount %d.\n", iface, refcount);
 
     if (!refcount)
     {
@@ -8737,7 +8537,7 @@ static HRESULT WINAPI property_store_GetAt(IPropertyStore *iface, DWORD index, P
 {
     struct property_store *store = impl_from_IPropertyStore(iface);
 
-    TRACE("%p, %lu, %p.\n", iface, index, key);
+    TRACE("%p, %u, %p.\n", iface, index, key);
 
     EnterCriticalSection(&store->cs);
 
@@ -8929,7 +8729,7 @@ static ULONG WINAPI dxgi_device_manager_AddRef(IMFDXGIDeviceManager *iface)
     struct dxgi_device_manager *manager = impl_from_IMFDXGIDeviceManager(iface);
     ULONG refcount = InterlockedIncrement(&manager->refcount);
 
-    TRACE("%p, refcount %lu.\n", iface, refcount);
+    TRACE("%p, refcount %u.\n", iface, refcount);
 
     return refcount;
 }
@@ -8939,7 +8739,7 @@ static ULONG WINAPI dxgi_device_manager_Release(IMFDXGIDeviceManager *iface)
     struct dxgi_device_manager *manager = impl_from_IMFDXGIDeviceManager(iface);
     ULONG refcount = InterlockedDecrement(&manager->refcount);
 
-    TRACE("%p, refcount %lu.\n", iface, refcount);
+    TRACE("%p, refcount %u.\n", iface, refcount);
 
     if (!refcount)
     {
@@ -9232,9 +9032,21 @@ static const IMFDXGIDeviceManagerVtbl dxgi_device_manager_vtbl =
 HRESULT WINAPI MFCreateDXGIDeviceManager(UINT *token, IMFDXGIDeviceManager **manager)
 {
     struct dxgi_device_manager *object;
+    const char *do_not_create = getenv("WINE_DO_NOT_CREATE_DXGI_DEVICE_MANAGER");
 
     TRACE("%p, %p.\n", token, manager);
 
+    /* Returning a DXGI device manager triggers a bug and breaks The
+     * Long Dark and Trailmakers. This should be removed once CW bug
+     * #19126 is solved. Returning a DXGI device manager also breaks
+     * Age of Empires Definitive Edition - this gameid should be removed
+     * once CW bug #19741 is solved. */
+    if (do_not_create && do_not_create[0] != '\0')
+    {
+        FIXME("stubbing out\n");
+        return E_NOTIMPL;
+    }
+
     if (!token || !manager)
         return E_POINTER;
 
@@ -9360,7 +9172,7 @@ static ULONGLONG lldiv128(ULARGE_INTEGER c1, ULARGE_INTEGER c0, LONGLONG denom)
 {
     ULARGE_INTEGER q1, q0, rhat;
     ULARGE_INTEGER v, cmp1, cmp2;
-    DWORD s = 0;
+    unsigned int s = 0;
 
     v.QuadPart = llabs(denom);
 
diff --git a/dlls/mfplat/media_source.c b/dlls/mfplat/media_source.c
new file mode 100644
index 00000000000..82a6da1bcbf
--- /dev/null
+++ wine/dlls/mfplat/media_source.c
@@ -0,0 +1,2006 @@
+/* GStreamer Media Source
+ *
+ * Copyright 2020 Derek Lesho
+ * Copyright 2020 Zebediah Figura for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "gst_private.h"
+
+#include "mfapi.h"
+#include "mferror.h"
+
+#include "wine/list.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(mfplat);
+
+struct media_stream
+{
+    IMFMediaStream IMFMediaStream_iface;
+    LONG ref;
+    struct media_source *parent_source;
+    IMFMediaEventQueue *event_queue;
+    IMFStreamDescriptor *descriptor;
+
+    struct wg_parser_stream *wg_stream;
+
+    IUnknown **token_queue;
+    LONG token_queue_count;
+    LONG token_queue_cap;
+
+    enum
+    {
+        STREAM_INACTIVE,
+        STREAM_SHUTDOWN,
+        STREAM_RUNNING,
+    } state;
+    DWORD stream_id;
+    BOOL eos;
+};
+
+enum source_async_op
+{
+    SOURCE_ASYNC_START,
+    SOURCE_ASYNC_PAUSE,
+    SOURCE_ASYNC_STOP,
+    SOURCE_ASYNC_REQUEST_SAMPLE,
+};
+
+struct source_async_command
+{
+    IUnknown IUnknown_iface;
+    LONG refcount;
+    enum source_async_op op;
+    union
+    {
+        struct
+        {
+            IMFPresentationDescriptor *descriptor;
+            GUID format;
+            PROPVARIANT position;
+        } start;
+        struct
+        {
+            struct media_stream *stream;
+            IUnknown *token;
+        } request_sample;
+    } u;
+};
+
+struct media_source
+{
+    IMFMediaSource IMFMediaSource_iface;
+    IMFGetService IMFGetService_iface;
+    IMFRateSupport IMFRateSupport_iface;
+    IMFRateControl IMFRateControl_iface;
+    IMFAsyncCallback async_commands_callback;
+    LONG ref;
+    DWORD async_commands_queue;
+    IMFMediaEventQueue *event_queue;
+    IMFByteStream *byte_stream;
+
+    struct wg_parser *wg_parser;
+
+    struct media_stream **streams;
+    ULONG stream_count;
+    IMFPresentationDescriptor *pres_desc;
+    enum
+    {
+        SOURCE_OPENING,
+        SOURCE_STOPPED,
+        SOURCE_PAUSED,
+        SOURCE_RUNNING,
+        SOURCE_SHUTDOWN,
+    } state;
+
+    HANDLE read_thread;
+    bool read_thread_shutdown;
+};
+
+static inline struct media_stream *impl_from_IMFMediaStream(IMFMediaStream *iface)
+{
+    return CONTAINING_RECORD(iface, struct media_stream, IMFMediaStream_iface);
+}
+
+static inline struct media_source *impl_from_IMFMediaSource(IMFMediaSource *iface)
+{
+    return CONTAINING_RECORD(iface, struct media_source, IMFMediaSource_iface);
+}
+
+static inline struct media_source *impl_from_IMFGetService(IMFGetService *iface)
+{
+    return CONTAINING_RECORD(iface, struct media_source, IMFGetService_iface);
+}
+
+static inline struct media_source *impl_from_IMFRateSupport(IMFRateSupport *iface)
+{
+    return CONTAINING_RECORD(iface, struct media_source, IMFRateSupport_iface);
+}
+
+static inline struct media_source *impl_from_IMFRateControl(IMFRateControl *iface)
+{
+    return CONTAINING_RECORD(iface, struct media_source, IMFRateControl_iface);
+}
+
+static inline struct media_source *impl_from_async_commands_callback_IMFAsyncCallback(IMFAsyncCallback *iface)
+{
+    return CONTAINING_RECORD(iface, struct media_source, async_commands_callback);
+}
+
+static inline struct source_async_command *impl_from_async_command_IUnknown(IUnknown *iface)
+{
+    return CONTAINING_RECORD(iface, struct source_async_command, IUnknown_iface);
+}
+
+static HRESULT WINAPI source_async_command_QueryInterface(IUnknown *iface, REFIID riid, void **obj)
+{
+    if (IsEqualIID(riid, &IID_IUnknown))
+    {
+        *obj = iface;
+        IUnknown_AddRef(iface);
+        return S_OK;
+    }
+
+    WARN("Unsupported interface %s.\n", debugstr_guid(riid));
+    *obj = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI source_async_command_AddRef(IUnknown *iface)
+{
+    struct source_async_command *command = impl_from_async_command_IUnknown(iface);
+    return InterlockedIncrement(&command->refcount);
+}
+
+static ULONG WINAPI source_async_command_Release(IUnknown *iface)
+{
+    struct source_async_command *command = impl_from_async_command_IUnknown(iface);
+    ULONG refcount = InterlockedDecrement(&command->refcount);
+
+    if (!refcount)
+    {
+        if (command->op == SOURCE_ASYNC_START)
+            PropVariantClear(&command->u.start.position);
+        else if (command->op == SOURCE_ASYNC_REQUEST_SAMPLE)
+        {
+            if (command->u.request_sample.token)
+                IUnknown_Release(command->u.request_sample.token);
+        }
+        free(command);
+    }
+
+    return refcount;
+}
+
+static const IUnknownVtbl source_async_command_vtbl =
+{
+    source_async_command_QueryInterface,
+    source_async_command_AddRef,
+    source_async_command_Release,
+};
+
+static HRESULT source_create_async_op(enum source_async_op op, struct source_async_command **ret)
+{
+    struct source_async_command *command;
+
+    if (!(command = calloc(1, sizeof(*command))))
+        return E_OUTOFMEMORY;
+
+    command->IUnknown_iface.lpVtbl = &source_async_command_vtbl;
+    command->op = op;
+
+    *ret = command;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI callback_QueryInterface(IMFAsyncCallback *iface, REFIID riid, void **obj)
+{
+    TRACE("%p, %s, %p.\n", iface, debugstr_guid(riid), obj);
+
+    if (IsEqualIID(riid, &IID_IMFAsyncCallback) ||
+            IsEqualIID(riid, &IID_IUnknown))
+    {
+        *obj = iface;
+        IMFAsyncCallback_AddRef(iface);
+        return S_OK;
+    }
+
+    WARN("Unsupported %s.\n", debugstr_guid(riid));
+    *obj = NULL;
+    return E_NOINTERFACE;
+}
+
+static HRESULT WINAPI callback_GetParameters(IMFAsyncCallback *iface,
+        DWORD *flags, DWORD *queue)
+{
+    return E_NOTIMPL;
+}
+
+static ULONG WINAPI source_async_commands_callback_AddRef(IMFAsyncCallback *iface)
+{
+    struct media_source *source = impl_from_async_commands_callback_IMFAsyncCallback(iface);
+    return IMFMediaSource_AddRef(&source->IMFMediaSource_iface);
+}
+
+static ULONG WINAPI source_async_commands_callback_Release(IMFAsyncCallback *iface)
+{
+    struct media_source *source = impl_from_async_commands_callback_IMFAsyncCallback(iface);
+    return IMFMediaSource_Release(&source->IMFMediaSource_iface);
+}
+
+static IMFStreamDescriptor *stream_descriptor_from_id(IMFPresentationDescriptor *pres_desc, DWORD id, BOOL *selected)
+{
+    ULONG sd_count;
+    IMFStreamDescriptor *ret;
+    unsigned int i;
+
+    if (FAILED(IMFPresentationDescriptor_GetStreamDescriptorCount(pres_desc, &sd_count)))
+        return NULL;
+
+    for (i = 0; i < sd_count; i++)
+    {
+        DWORD stream_id;
+
+        if (FAILED(IMFPresentationDescriptor_GetStreamDescriptorByIndex(pres_desc, i, selected, &ret)))
+            return NULL;
+
+        if (SUCCEEDED(IMFStreamDescriptor_GetStreamIdentifier(ret, &stream_id)) && stream_id == id)
+            return ret;
+
+        IMFStreamDescriptor_Release(ret);
+    }
+    return NULL;
+}
+
+static BOOL enqueue_token(struct media_stream *stream, IUnknown *token)
+{
+    if (stream->token_queue_count == stream->token_queue_cap)
+    {
+        IUnknown **buf;
+        stream->token_queue_cap = stream->token_queue_cap * 2 + 1;
+        buf = realloc(stream->token_queue, stream->token_queue_cap * sizeof(*buf));
+        if (buf)
+            stream->token_queue = buf;
+        else
+        {
+            stream->token_queue_cap = stream->token_queue_count;
+            return FALSE;
+        }
+    }
+    stream->token_queue[stream->token_queue_count++] = token;
+    return TRUE;
+}
+
+static void flush_token_queue(struct media_stream *stream, BOOL send)
+{
+    LONG i;
+
+    for (i = 0; i < stream->token_queue_count; i++)
+    {
+        if (send)
+        {
+            HRESULT hr;
+            struct source_async_command *command;
+            if (SUCCEEDED(hr = source_create_async_op(SOURCE_ASYNC_REQUEST_SAMPLE, &command)))
+            {
+                command->u.request_sample.stream = stream;
+                command->u.request_sample.token = stream->token_queue[i];
+
+                hr = MFPutWorkItem(stream->parent_source->async_commands_queue,
+                        &stream->parent_source->async_commands_callback, &command->IUnknown_iface);
+            }
+            if (FAILED(hr))
+                WARN("Could not enqueue sample request, hr %#x\n", hr);
+        }
+        else if (stream->token_queue[i])
+            IUnknown_Release(stream->token_queue[i]);
+    }
+    free(stream->token_queue);
+    stream->token_queue = NULL;
+    stream->token_queue_count = 0;
+    stream->token_queue_cap = 0;
+}
+
+static void start_pipeline(struct media_source *source, struct source_async_command *command)
+{
+    PROPVARIANT *position = &command->u.start.position;
+    BOOL seek_message = source->state != SOURCE_STOPPED && position->vt != VT_EMPTY;
+    unsigned int i;
+
+    /* seek to beginning on stop->play */
+    if (source->state == SOURCE_STOPPED && position->vt == VT_EMPTY)
+    {
+        position->vt = VT_I8;
+        position->hVal.QuadPart = 0;
+    }
+
+    for (i = 0; i < source->stream_count; i++)
+    {
+        struct media_stream *stream;
+        IMFStreamDescriptor *sd;
+        IMFMediaTypeHandler *mth;
+        IMFMediaType *current_mt;
+        DWORD stream_id;
+        BOOL was_active;
+        BOOL selected;
+
+        stream = source->streams[i];
+
+        IMFStreamDescriptor_GetStreamIdentifier(stream->descriptor, &stream_id);
+
+        sd = stream_descriptor_from_id(command->u.start.descriptor, stream_id, &selected);
+        IMFStreamDescriptor_Release(sd);
+
+        was_active = stream->state != STREAM_INACTIVE;
+
+        stream->state = selected ? STREAM_RUNNING : STREAM_INACTIVE;
+
+        if (selected)
+        {
+            struct wg_format format;
+
+            IMFStreamDescriptor_GetMediaTypeHandler(stream->descriptor, &mth);
+            IMFMediaTypeHandler_GetCurrentMediaType(mth, &current_mt);
+
+            mf_media_type_to_wg_format(current_mt, &format);
+            wg_parser_stream_enable(stream->wg_stream, &format, NULL, 0);
+
+            IMFMediaType_Release(current_mt);
+            IMFMediaTypeHandler_Release(mth);
+        }
+
+        if (position->vt != VT_EMPTY)
+            stream->eos = FALSE;
+
+        if (selected)
+        {
+            TRACE("Stream %u (%p) selected\n", i, stream);
+            IMFMediaEventQueue_QueueEventParamUnk(source->event_queue,
+                was_active ? MEUpdatedStream : MENewStream, &GUID_NULL,
+                S_OK, (IUnknown*) &stream->IMFMediaStream_iface);
+
+            IMFMediaEventQueue_QueueEventParamVar(stream->event_queue,
+                seek_message ? MEStreamSeeked : MEStreamStarted, &GUID_NULL, S_OK, position);
+        }
+    }
+
+    IMFMediaEventQueue_QueueEventParamVar(source->event_queue,
+        seek_message ? MESourceSeeked : MESourceStarted,
+        &GUID_NULL, S_OK, position);
+
+    source->state = SOURCE_RUNNING;
+
+    if (position->vt == VT_I8)
+        wg_parser_stream_seek(source->streams[0]->wg_stream, 1.0, position->hVal.QuadPart, 0,
+                AM_SEEKING_AbsolutePositioning, AM_SEEKING_NoPositioning);
+
+    for (i = 0; i < source->stream_count; i++)
+        flush_token_queue(source->streams[i], position->vt == VT_EMPTY);
+}
+
+static void pause_pipeline(struct media_source *source)
+{
+    unsigned int i;
+
+    for (i = 0; i < source->stream_count; i++)
+    {
+        struct media_stream *stream = source->streams[i];
+        if (stream->state != STREAM_INACTIVE)
+        {
+            IMFMediaEventQueue_QueueEventParamVar(stream->event_queue, MEStreamPaused, &GUID_NULL, S_OK, NULL);
+        }
+    }
+
+    IMFMediaEventQueue_QueueEventParamVar(source->event_queue, MESourcePaused, &GUID_NULL, S_OK, NULL);
+
+    source->state = SOURCE_PAUSED;
+}
+
+static void stop_pipeline(struct media_source *source)
+{
+    unsigned int i;
+
+    for (i = 0; i < source->stream_count; i++)
+    {
+        struct media_stream *stream = source->streams[i];
+        if (stream->state != STREAM_INACTIVE)
+        {
+            IMFMediaEventQueue_QueueEventParamVar(stream->event_queue, MEStreamStopped, &GUID_NULL, S_OK, NULL);
+            wg_parser_stream_disable(stream->wg_stream);
+        }
+    }
+
+    IMFMediaEventQueue_QueueEventParamVar(source->event_queue, MESourceStopped, &GUID_NULL, S_OK, NULL);
+
+    source->state = SOURCE_STOPPED;
+
+    for (i = 0; i < source->stream_count; i++)
+        flush_token_queue(source->streams[i], FALSE);
+}
+
+static void dispatch_end_of_presentation(struct media_source *source)
+{
+    PROPVARIANT empty = {.vt = VT_EMPTY};
+    unsigned int i;
+
+    /* A stream has ended, check whether all have */
+    for (i = 0; i < source->stream_count; i++)
+    {
+        struct media_stream *stream = source->streams[i];
+
+        if (stream->state != STREAM_INACTIVE && !stream->eos)
+            return;
+    }
+
+    IMFMediaEventQueue_QueueEventParamVar(source->event_queue, MEEndOfPresentation, &GUID_NULL, S_OK, &empty);
+}
+
+static void send_buffer(struct media_stream *stream, const struct wg_parser_buffer *wg_buffer, IUnknown *token)
+{
+    IMFMediaBuffer *buffer;
+    IMFSample *sample;
+    HRESULT hr;
+    BYTE *data;
+
+    if (FAILED(hr = MFCreateSample(&sample)))
+    {
+        ERR("Failed to create sample, hr %#x.\n", hr);
+        return;
+    }
+
+    if (FAILED(hr = MFCreateMemoryBuffer(wg_buffer->size, &buffer)))
+    {
+        ERR("Failed to create buffer, hr %#x.\n", hr);
+        IMFSample_Release(sample);
+        return;
+    }
+
+    if (FAILED(hr = IMFSample_AddBuffer(sample, buffer)))
+    {
+        ERR("Failed to add buffer, hr %#x.\n", hr);
+        goto out;
+    }
+
+    if (FAILED(hr = IMFMediaBuffer_SetCurrentLength(buffer, wg_buffer->size)))
+    {
+        ERR("Failed to set size, hr %#x.\n", hr);
+        goto out;
+    }
+
+    if (FAILED(hr = IMFMediaBuffer_Lock(buffer, &data, NULL, NULL)))
+    {
+        ERR("Failed to lock buffer, hr %#x.\n", hr);
+        goto out;
+    }
+
+    if (!wg_parser_stream_copy_buffer(stream->wg_stream, data, 0, wg_buffer->size))
+    {
+        wg_parser_stream_release_buffer(stream->wg_stream);
+        IMFMediaBuffer_Unlock(buffer);
+        goto out;
+    }
+    wg_parser_stream_release_buffer(stream->wg_stream);
+
+    if (FAILED(hr = IMFMediaBuffer_Unlock(buffer)))
+    {
+        ERR("Failed to unlock buffer, hr %#x.\n", hr);
+        goto out;
+    }
+
+    if (FAILED(hr = IMFSample_SetSampleTime(sample, wg_buffer->pts)))
+    {
+        ERR("Failed to set sample time, hr %#x.\n", hr);
+        goto out;
+    }
+
+    if (FAILED(hr = IMFSample_SetSampleDuration(sample, wg_buffer->duration)))
+    {
+        ERR("Failed to set sample duration, hr %#x.\n", hr);
+        goto out;
+    }
+
+    if (token)
+        IMFSample_SetUnknown(sample, &MFSampleExtension_Token, token);
+
+    IMFMediaEventQueue_QueueEventParamUnk(stream->event_queue, MEMediaSample,
+            &GUID_NULL, S_OK, (IUnknown *)sample);
+
+out:
+    IMFMediaBuffer_Release(buffer);
+    IMFSample_Release(sample);
+}
+
+static void wait_on_sample(struct media_stream *stream, IUnknown *token)
+{
+    PROPVARIANT empty_var = {.vt = VT_EMPTY};
+    struct wg_parser_buffer buffer;
+
+    TRACE("%p, %p\n", stream, token);
+
+    if (wg_parser_stream_get_buffer(stream->wg_stream, &buffer))
+    {
+        send_buffer(stream, &buffer, token);
+    }
+    else
+    {
+        stream->eos = TRUE;
+        IMFMediaEventQueue_QueueEventParamVar(stream->event_queue, MEEndOfStream, &GUID_NULL, S_OK, &empty_var);
+        dispatch_end_of_presentation(stream->parent_source);
+    }
+}
+
+static HRESULT WINAPI source_async_commands_Invoke(IMFAsyncCallback *iface, IMFAsyncResult *result)
+{
+    struct media_source *source = impl_from_async_commands_callback_IMFAsyncCallback(iface);
+    struct source_async_command *command;
+    IUnknown *state;
+    HRESULT hr;
+
+    if (source->state == SOURCE_SHUTDOWN)
+        return S_OK;
+
+    if (FAILED(hr = IMFAsyncResult_GetState(result, &state)))
+        return hr;
+
+    command = impl_from_async_command_IUnknown(state);
+    switch (command->op)
+    {
+        case SOURCE_ASYNC_START:
+            start_pipeline(source, command);
+            break;
+        case SOURCE_ASYNC_PAUSE:
+            pause_pipeline(source);
+            break;
+        case SOURCE_ASYNC_STOP:
+            stop_pipeline(source);
+            break;
+        case SOURCE_ASYNC_REQUEST_SAMPLE:
+            if (source->state == SOURCE_PAUSED)
+                enqueue_token(command->u.request_sample.stream, command->u.request_sample.token);
+            else
+                wait_on_sample(command->u.request_sample.stream, command->u.request_sample.token);
+            break;
+    }
+
+    IUnknown_Release(state);
+
+    return S_OK;
+}
+
+static const IMFAsyncCallbackVtbl source_async_commands_callback_vtbl =
+{
+    callback_QueryInterface,
+    source_async_commands_callback_AddRef,
+    source_async_commands_callback_Release,
+    callback_GetParameters,
+    source_async_commands_Invoke,
+};
+
+static DWORD CALLBACK read_thread(void *arg)
+{
+    struct media_source *source = arg;
+    IMFByteStream *byte_stream = source->byte_stream;
+    size_t buffer_size = 4096;
+    uint64_t file_size;
+    void *data;
+
+    if (!(data = malloc(buffer_size)))
+        return 0;
+
+    IMFByteStream_GetLength(byte_stream, &file_size);
+
+    TRACE("Starting read thread for media source %p.\n", source);
+
+    while (!source->read_thread_shutdown)
+    {
+        uint64_t offset;
+        ULONG ret_size;
+        uint32_t size;
+        HRESULT hr;
+
+        if (!wg_parser_get_next_read_offset(source->wg_parser, &offset, &size))
+            continue;
+
+        if (offset >= file_size)
+            size = 0;
+        else if (offset + size >= file_size)
+            size = file_size - offset;
+
+        /* Some IMFByteStreams (including the standard file-based stream) return
+         * an error when reading past the file size. */
+        if (!size)
+        {
+            wg_parser_push_data(source->wg_parser, WG_READ_SUCCESS, data, 0);
+            continue;
+        }
+
+        if (!array_reserve(&data, &buffer_size, size, 1))
+        {
+            free(data);
+            return 0;
+        }
+
+        ret_size = 0;
+
+        if (SUCCEEDED(hr = IMFByteStream_SetCurrentPosition(byte_stream, offset)))
+            hr = IMFByteStream_Read(byte_stream, data, size, &ret_size);
+        if (FAILED(hr))
+            ERR("Failed to read %u bytes at offset %I64u, hr %#x.\n", size, offset, hr);
+        else if (ret_size != size)
+            ERR("Unexpected short read: requested %u bytes, got %u.\n", size, ret_size);
+        wg_parser_push_data(source->wg_parser, SUCCEEDED(hr) ? WG_READ_SUCCESS : WG_READ_FAILURE, data, ret_size);
+    }
+
+    free(data);
+    TRACE("Media source is shutting down; exiting.\n");
+    return 0;
+}
+
+static HRESULT WINAPI media_stream_QueryInterface(IMFMediaStream *iface, REFIID riid, void **out)
+{
+    struct media_stream *stream = impl_from_IMFMediaStream(iface);
+
+    TRACE("%p, %s, %p.\n", iface, debugstr_guid(riid), out);
+
+    if (IsEqualIID(riid, &IID_IMFMediaStream) ||
+        IsEqualIID(riid, &IID_IMFMediaEventGenerator) ||
+        IsEqualIID(riid, &IID_IUnknown))
+    {
+        *out = &stream->IMFMediaStream_iface;
+    }
+    else
+    {
+        FIXME("(%s, %p)\n", debugstr_guid(riid), out);
+        *out = NULL;
+        return E_NOINTERFACE;
+    }
+
+    IUnknown_AddRef((IUnknown*)*out);
+    return S_OK;
+}
+
+static ULONG WINAPI media_stream_AddRef(IMFMediaStream *iface)
+{
+    struct media_stream *stream = impl_from_IMFMediaStream(iface);
+    ULONG ref = InterlockedIncrement(&stream->ref);
+
+    TRACE("%p, refcount %u.\n", iface, ref);
+
+    return ref;
+}
+
+static ULONG WINAPI media_stream_Release(IMFMediaStream *iface)
+{
+    struct media_stream *stream = impl_from_IMFMediaStream(iface);
+    ULONG ref = InterlockedDecrement(&stream->ref);
+
+    TRACE("%p, refcount %u.\n", iface, ref);
+
+    if (!ref)
+    {
+        if (stream->event_queue)
+            IMFMediaEventQueue_Release(stream->event_queue);
+        flush_token_queue(stream, FALSE);
+        free(stream);
+    }
+
+    return ref;
+}
+
+static HRESULT WINAPI media_stream_GetEvent(IMFMediaStream *iface, DWORD flags, IMFMediaEvent **event)
+{
+    struct media_stream *stream = impl_from_IMFMediaStream(iface);
+
+    TRACE("%p, %#x, %p.\n", iface, flags, event);
+
+    return IMFMediaEventQueue_GetEvent(stream->event_queue, flags, event);
+}
+
+static HRESULT WINAPI media_stream_BeginGetEvent(IMFMediaStream *iface, IMFAsyncCallback *callback, IUnknown *state)
+{
+    struct media_stream *stream = impl_from_IMFMediaStream(iface);
+
+    TRACE("%p, %p, %p.\n", iface, callback, state);
+
+    return IMFMediaEventQueue_BeginGetEvent(stream->event_queue, callback, state);
+}
+
+static HRESULT WINAPI media_stream_EndGetEvent(IMFMediaStream *iface, IMFAsyncResult *result, IMFMediaEvent **event)
+{
+    struct media_stream *stream = impl_from_IMFMediaStream(iface);
+
+    TRACE("%p, %p, %p.\n", stream, result, event);
+
+    return IMFMediaEventQueue_EndGetEvent(stream->event_queue, result, event);
+}
+
+static HRESULT WINAPI media_stream_QueueEvent(IMFMediaStream *iface, MediaEventType event_type, REFGUID ext_type,
+        HRESULT hr, const PROPVARIANT *value)
+{
+    struct media_stream *stream = impl_from_IMFMediaStream(iface);
+
+    TRACE("%p, %d, %s, %#x, %p.\n", iface, event_type, debugstr_guid(ext_type), hr, value);
+
+    return IMFMediaEventQueue_QueueEventParamVar(stream->event_queue, event_type, ext_type, hr, value);
+}
+
+static HRESULT WINAPI media_stream_GetMediaSource(IMFMediaStream *iface, IMFMediaSource **source)
+{
+    struct media_stream *stream = impl_from_IMFMediaStream(iface);
+
+    TRACE("%p, %p.\n", iface, source);
+
+    if (stream->state == STREAM_SHUTDOWN)
+        return MF_E_SHUTDOWN;
+
+    IMFMediaSource_AddRef(&stream->parent_source->IMFMediaSource_iface);
+    *source = &stream->parent_source->IMFMediaSource_iface;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI media_stream_GetStreamDescriptor(IMFMediaStream* iface, IMFStreamDescriptor **descriptor)
+{
+    struct media_stream *stream = impl_from_IMFMediaStream(iface);
+
+    TRACE("%p, %p.\n", iface, descriptor);
+
+    if (stream->state == STREAM_SHUTDOWN)
+        return MF_E_SHUTDOWN;
+
+    IMFStreamDescriptor_AddRef(stream->descriptor);
+    *descriptor = stream->descriptor;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI media_stream_RequestSample(IMFMediaStream *iface, IUnknown *token)
+{
+    struct media_stream *stream = impl_from_IMFMediaStream(iface);
+    struct source_async_command *command;
+    HRESULT hr;
+
+    TRACE("%p, %p.\n", iface, token);
+
+    if (stream->state == STREAM_SHUTDOWN)
+        return MF_E_SHUTDOWN;
+
+    if (stream->state == STREAM_INACTIVE)
+    {
+        WARN("Stream isn't active\n");
+        return MF_E_MEDIA_SOURCE_WRONGSTATE;
+    }
+
+    if (stream->eos)
+    {
+        return MF_E_END_OF_STREAM;
+    }
+
+    if (SUCCEEDED(hr = source_create_async_op(SOURCE_ASYNC_REQUEST_SAMPLE, &command)))
+    {
+        command->u.request_sample.stream = stream;
+        if (token)
+            IUnknown_AddRef(token);
+        command->u.request_sample.token = token;
+
+        hr = MFPutWorkItem(stream->parent_source->async_commands_queue,
+                &stream->parent_source->async_commands_callback, &command->IUnknown_iface);
+    }
+
+    return hr;
+}
+
+static const IMFMediaStreamVtbl media_stream_vtbl =
+{
+    media_stream_QueryInterface,
+    media_stream_AddRef,
+    media_stream_Release,
+    media_stream_GetEvent,
+    media_stream_BeginGetEvent,
+    media_stream_EndGetEvent,
+    media_stream_QueueEvent,
+    media_stream_GetMediaSource,
+    media_stream_GetStreamDescriptor,
+    media_stream_RequestSample
+};
+
+static HRESULT new_media_stream(struct media_source *source,
+        struct wg_parser_stream *wg_stream, DWORD stream_id, struct media_stream **out_stream)
+{
+    struct media_stream *object = calloc(1, sizeof(*object));
+    HRESULT hr;
+
+    TRACE("source %p, wg_stream %p, stream_id %u.\n", source, wg_stream, stream_id);
+
+    object->IMFMediaStream_iface.lpVtbl = &media_stream_vtbl;
+    object->ref = 1;
+
+    if (FAILED(hr = MFCreateEventQueue(&object->event_queue)))
+    {
+        free(object);
+        return hr;
+    }
+
+    IMFMediaSource_AddRef(&source->IMFMediaSource_iface);
+    object->parent_source = source;
+    object->stream_id = stream_id;
+
+    object->state = STREAM_INACTIVE;
+    object->eos = FALSE;
+    object->wg_stream = wg_stream;
+
+    TRACE("Created stream object %p.\n", object);
+
+    *out_stream = object;
+
+    return S_OK;
+}
+
+static HRESULT media_stream_init_desc(struct media_stream *stream)
+{
+    IMFMediaTypeHandler *type_handler = NULL;
+    IMFMediaType *stream_types[8];
+    struct wg_format format;
+    DWORD type_count = 0;
+    unsigned int i;
+    HRESULT hr;
+
+    wg_parser_stream_get_preferred_format(stream->wg_stream, &format);
+
+    if (format.major_type == WG_MAJOR_TYPE_VIDEO)
+    {
+        /* These are the most common native output types of decoders:
+            https://docs.microsoft.com/en-us/windows/win32/medfound/mft-decoder-expose-output-types-in-native-order */
+        static const GUID *const video_types[] =
+        {
+            &MFVideoFormat_NV12,
+            &MFVideoFormat_YV12,
+            &MFVideoFormat_YUY2,
+            &MFVideoFormat_IYUV,
+            &MFVideoFormat_I420,
+            &MFVideoFormat_ARGB32,
+            &MFVideoFormat_RGB32,
+        };
+
+        IMFMediaType *base_type = mf_media_type_from_wg_format(&format);
+        GUID base_subtype;
+
+        IMFMediaType_GetGUID(base_type, &MF_MT_SUBTYPE, &base_subtype);
+
+        stream_types[0] = base_type;
+        type_count = 1;
+
+        for (i = 0; i < ARRAY_SIZE(video_types); i++)
+        {
+            IMFMediaType *new_type;
+
+            if (IsEqualGUID(&base_subtype, video_types[i]))
+                continue;
+
+            if (FAILED(hr = MFCreateMediaType(&new_type)))
+                goto done;
+            stream_types[type_count++] = new_type;
+
+            if (FAILED(hr = IMFMediaType_CopyAllItems(base_type, (IMFAttributes *) new_type)))
+                goto done;
+            if (FAILED(hr = IMFMediaType_SetGUID(new_type, &MF_MT_SUBTYPE, video_types[i])))
+                goto done;
+        }
+    }
+    else if (format.major_type == WG_MAJOR_TYPE_AUDIO)
+    {
+        /* Expose at least one PCM and one floating point type for the
+           consumer to pick from. */
+        static const enum wg_audio_format audio_types[] =
+        {
+            WG_AUDIO_FORMAT_S16LE,
+            WG_AUDIO_FORMAT_F32LE,
+        };
+
+        stream_types[0] = mf_media_type_from_wg_format(&format);
+        type_count = 1;
+
+        for (i = 0; i < ARRAY_SIZE(audio_types); i++)
+        {
+            struct wg_format new_format;
+            if (format.u.audio.format == audio_types[i])
+                continue;
+            new_format = format;
+            new_format.u.audio.format = audio_types[i];
+            stream_types[type_count++] = mf_media_type_from_wg_format(&new_format);
+        }
+    }
+    else
+    {
+        if ((stream_types[0] = mf_media_type_from_wg_format(&format)))
+            type_count = 1;
+    }
+
+    assert(type_count <= ARRAY_SIZE(stream_types));
+
+    if (!type_count)
+    {
+        ERR("Failed to establish an IMFMediaType from any of the possible stream caps!\n");
+        return E_FAIL;
+    }
+
+    if (FAILED(hr = MFCreateStreamDescriptor(stream->stream_id, type_count, stream_types, &stream->descriptor)))
+        goto done;
+
+    if (FAILED(hr = IMFStreamDescriptor_GetMediaTypeHandler(stream->descriptor, &type_handler)))
+    {
+        IMFStreamDescriptor_Release(stream->descriptor);
+        goto done;
+    }
+
+    if (FAILED(hr = IMFMediaTypeHandler_SetCurrentMediaType(type_handler, stream_types[0])))
+    {
+        IMFStreamDescriptor_Release(stream->descriptor);
+        goto done;
+    }
+
+done:
+    if (type_handler)
+        IMFMediaTypeHandler_Release(type_handler);
+    for (i = 0; i < type_count; i++)
+        IMFMediaType_Release(stream_types[i]);
+    return hr;
+}
+
+static HRESULT WINAPI media_source_get_service_QueryInterface(IMFGetService *iface, REFIID riid, void **obj)
+{
+    struct media_source *source = impl_from_IMFGetService(iface);
+    return IMFMediaSource_QueryInterface(&source->IMFMediaSource_iface, riid, obj);
+}
+
+static ULONG WINAPI media_source_get_service_AddRef(IMFGetService *iface)
+{
+    struct media_source *source = impl_from_IMFGetService(iface);
+    return IMFMediaSource_AddRef(&source->IMFMediaSource_iface);
+}
+
+static ULONG WINAPI media_source_get_service_Release(IMFGetService *iface)
+{
+    struct media_source *source = impl_from_IMFGetService(iface);
+    return IMFMediaSource_Release(&source->IMFMediaSource_iface);
+}
+
+static HRESULT WINAPI media_source_get_service_GetService(IMFGetService *iface, REFGUID service, REFIID riid, void **obj)
+{
+    struct media_source *source = impl_from_IMFGetService(iface);
+
+    TRACE("%p, %s, %s, %p.\n", iface, debugstr_guid(service), debugstr_guid(riid), obj);
+
+    *obj = NULL;
+
+    if (IsEqualGUID(service, &MF_RATE_CONTROL_SERVICE))
+    {
+        if (IsEqualIID(riid, &IID_IMFRateSupport))
+        {
+            *obj = &source->IMFRateSupport_iface;
+        }
+        else if (IsEqualIID(riid, &IID_IMFRateControl))
+        {
+            *obj = &source->IMFRateControl_iface;
+        }
+    }
+    else
+        FIXME("Unsupported service %s.\n", debugstr_guid(service));
+
+    if (*obj)
+        IUnknown_AddRef((IUnknown *)*obj);
+
+    return *obj ? S_OK : E_NOINTERFACE;
+}
+
+static const IMFGetServiceVtbl media_source_get_service_vtbl =
+{
+    media_source_get_service_QueryInterface,
+    media_source_get_service_AddRef,
+    media_source_get_service_Release,
+    media_source_get_service_GetService,
+};
+
+static HRESULT WINAPI media_source_rate_support_QueryInterface(IMFRateSupport *iface, REFIID riid, void **obj)
+{
+    struct media_source *source = impl_from_IMFRateSupport(iface);
+    return IMFMediaSource_QueryInterface(&source->IMFMediaSource_iface, riid, obj);
+}
+
+static ULONG WINAPI media_source_rate_support_AddRef(IMFRateSupport *iface)
+{
+    struct media_source *source = impl_from_IMFRateSupport(iface);
+    return IMFMediaSource_AddRef(&source->IMFMediaSource_iface);
+}
+
+static ULONG WINAPI media_source_rate_support_Release(IMFRateSupport *iface)
+{
+    struct media_source *source = impl_from_IMFRateSupport(iface);
+    return IMFMediaSource_Release(&source->IMFMediaSource_iface);
+}
+
+static HRESULT WINAPI media_source_rate_support_GetSlowestRate(IMFRateSupport *iface, MFRATE_DIRECTION direction, BOOL thin, float *rate)
+{
+    TRACE("%p, %d, %d, %p.\n", iface, direction, thin, rate);
+
+    *rate = 0.0f;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI media_source_rate_support_GetFastestRate(IMFRateSupport *iface, MFRATE_DIRECTION direction, BOOL thin, float *rate)
+{
+    TRACE("%p, %d, %d, %p.\n", iface, direction, thin, rate);
+
+    *rate = direction == MFRATE_FORWARD ? 1e6f : -1e6f;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI media_source_rate_support_IsRateSupported(IMFRateSupport *iface, BOOL thin, float rate,
+        float *nearest_rate)
+{
+    TRACE("%p, %d, %f, %p.\n", iface, thin, rate, nearest_rate);
+
+    if (nearest_rate)
+        *nearest_rate = rate;
+
+    return rate >= -1e6f && rate <= 1e6f ? S_OK : MF_E_UNSUPPORTED_RATE;
+}
+
+static const IMFRateSupportVtbl media_source_rate_support_vtbl =
+{
+    media_source_rate_support_QueryInterface,
+    media_source_rate_support_AddRef,
+    media_source_rate_support_Release,
+    media_source_rate_support_GetSlowestRate,
+    media_source_rate_support_GetFastestRate,
+    media_source_rate_support_IsRateSupported,
+};
+
+static HRESULT WINAPI media_source_rate_control_QueryInterface(IMFRateControl *iface, REFIID riid, void **obj)
+{
+    struct media_source *source = impl_from_IMFRateControl(iface);
+    return IMFMediaSource_QueryInterface(&source->IMFMediaSource_iface, riid, obj);
+}
+
+static ULONG WINAPI media_source_rate_control_AddRef(IMFRateControl *iface)
+{
+    struct media_source *source = impl_from_IMFRateControl(iface);
+    return IMFMediaSource_AddRef(&source->IMFMediaSource_iface);
+}
+
+static ULONG WINAPI media_source_rate_control_Release(IMFRateControl *iface)
+{
+    struct media_source *source = impl_from_IMFRateControl(iface);
+    return IMFMediaSource_Release(&source->IMFMediaSource_iface);
+}
+
+static HRESULT WINAPI media_source_rate_control_SetRate(IMFRateControl *iface, BOOL thin, float rate)
+{
+    FIXME("%p, %d, %f.\n", iface, thin, rate);
+
+    if (rate < 0.0f)
+        return MF_E_REVERSE_UNSUPPORTED;
+
+    if (thin)
+        return MF_E_THINNING_UNSUPPORTED;
+
+    if (rate != 1.0f)
+        return MF_E_UNSUPPORTED_RATE;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI media_source_rate_control_GetRate(IMFRateControl *iface, BOOL *thin, float *rate)
+{
+    TRACE("%p, %p, %p.\n", iface, thin, rate);
+
+    if (thin)
+        *thin = FALSE;
+
+    *rate = 1.0f;
+
+    return S_OK;
+}
+
+static const IMFRateControlVtbl media_source_rate_control_vtbl =
+{
+    media_source_rate_control_QueryInterface,
+    media_source_rate_control_AddRef,
+    media_source_rate_control_Release,
+    media_source_rate_control_SetRate,
+    media_source_rate_control_GetRate,
+};
+
+static HRESULT WINAPI media_source_QueryInterface(IMFMediaSource *iface, REFIID riid, void **out)
+{
+    struct media_source *source = impl_from_IMFMediaSource(iface);
+
+    TRACE("%p, %s, %p.\n", iface, debugstr_guid(riid), out);
+
+    if (IsEqualIID(riid, &IID_IMFMediaSource) ||
+        IsEqualIID(riid, &IID_IMFMediaEventGenerator) ||
+        IsEqualIID(riid, &IID_IUnknown))
+    {
+        *out = &source->IMFMediaSource_iface;
+    }
+    else if (IsEqualIID(riid, &IID_IMFGetService))
+    {
+        *out = &source->IMFGetService_iface;
+    }
+    else
+    {
+        FIXME("%s, %p.\n", debugstr_guid(riid), out);
+        *out = NULL;
+        return E_NOINTERFACE;
+    }
+
+    IUnknown_AddRef((IUnknown*)*out);
+    return S_OK;
+}
+
+static ULONG WINAPI media_source_AddRef(IMFMediaSource *iface)
+{
+    struct media_source *source = impl_from_IMFMediaSource(iface);
+    ULONG ref = InterlockedIncrement(&source->ref);
+
+    TRACE("%p, refcount %u.\n", iface, ref);
+
+    return ref;
+}
+
+static ULONG WINAPI media_source_Release(IMFMediaSource *iface)
+{
+    struct media_source *source = impl_from_IMFMediaSource(iface);
+    ULONG ref = InterlockedDecrement(&source->ref);
+
+    TRACE("%p, refcount %u.\n", iface, ref);
+
+    if (!ref)
+    {
+        IMFMediaSource_Shutdown(&source->IMFMediaSource_iface);
+        IMFMediaEventQueue_Release(source->event_queue);
+        free(source);
+    }
+
+    return ref;
+}
+
+static HRESULT WINAPI media_source_GetEvent(IMFMediaSource *iface, DWORD flags, IMFMediaEvent **event)
+{
+    struct media_source *source = impl_from_IMFMediaSource(iface);
+
+    TRACE("%p, %#x, %p.\n", iface, flags, event);
+
+    return IMFMediaEventQueue_GetEvent(source->event_queue, flags, event);
+}
+
+static HRESULT WINAPI media_source_BeginGetEvent(IMFMediaSource *iface, IMFAsyncCallback *callback, IUnknown *state)
+{
+    struct media_source *source = impl_from_IMFMediaSource(iface);
+
+    TRACE("%p, %p, %p.\n", iface, callback, state);
+
+    return IMFMediaEventQueue_BeginGetEvent(source->event_queue, callback, state);
+}
+
+static HRESULT WINAPI media_source_EndGetEvent(IMFMediaSource *iface, IMFAsyncResult *result, IMFMediaEvent **event)
+{
+    struct media_source *source = impl_from_IMFMediaSource(iface);
+
+    TRACE("%p, %p, %p.\n", iface, result, event);
+
+    return IMFMediaEventQueue_EndGetEvent(source->event_queue, result, event);
+}
+
+static HRESULT WINAPI media_source_QueueEvent(IMFMediaSource *iface, MediaEventType event_type, REFGUID ext_type,
+        HRESULT hr, const PROPVARIANT *value)
+{
+    struct media_source *source = impl_from_IMFMediaSource(iface);
+
+    TRACE("%p, %d, %s, %#x, %p.\n", iface, event_type, debugstr_guid(ext_type), hr, value);
+
+    return IMFMediaEventQueue_QueueEventParamVar(source->event_queue, event_type, ext_type, hr, value);
+}
+
+static HRESULT WINAPI media_source_GetCharacteristics(IMFMediaSource *iface, DWORD *characteristics)
+{
+    struct media_source *source = impl_from_IMFMediaSource(iface);
+
+    TRACE("%p, %p.\n", iface, characteristics);
+
+    if (source->state == SOURCE_SHUTDOWN)
+        return MF_E_SHUTDOWN;
+
+    *characteristics = MFMEDIASOURCE_CAN_SEEK | MFMEDIASOURCE_CAN_PAUSE;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI media_source_CreatePresentationDescriptor(IMFMediaSource *iface, IMFPresentationDescriptor **descriptor)
+{
+    struct media_source *source = impl_from_IMFMediaSource(iface);
+
+    TRACE("%p, %p.\n", iface, descriptor);
+
+    if (source->state == SOURCE_SHUTDOWN)
+        return MF_E_SHUTDOWN;
+
+    return IMFPresentationDescriptor_Clone(source->pres_desc, descriptor);
+}
+
+static HRESULT WINAPI media_source_Start(IMFMediaSource *iface, IMFPresentationDescriptor *descriptor,
+                                     const GUID *time_format, const PROPVARIANT *position)
+{
+    struct media_source *source = impl_from_IMFMediaSource(iface);
+    struct source_async_command *command;
+    HRESULT hr;
+
+    TRACE("%p, %p, %p, %p.\n", iface, descriptor, time_format, position);
+
+    if (source->state == SOURCE_SHUTDOWN)
+        return MF_E_SHUTDOWN;
+
+    if (!(IsEqualIID(time_format, &GUID_NULL)))
+        return MF_E_UNSUPPORTED_TIME_FORMAT;
+
+    if (SUCCEEDED(hr = source_create_async_op(SOURCE_ASYNC_START, &command)))
+    {
+        command->u.start.descriptor = descriptor;
+        command->u.start.format = *time_format;
+        PropVariantCopy(&command->u.start.position, position);
+
+        hr = MFPutWorkItem(source->async_commands_queue, &source->async_commands_callback, &command->IUnknown_iface);
+    }
+
+    return hr;
+}
+
+static HRESULT WINAPI media_source_Stop(IMFMediaSource *iface)
+{
+    struct media_source *source = impl_from_IMFMediaSource(iface);
+    struct source_async_command *command;
+    HRESULT hr;
+
+    TRACE("%p.\n", iface);
+
+    if (source->state == SOURCE_SHUTDOWN)
+        return MF_E_SHUTDOWN;
+
+    if (SUCCEEDED(hr = source_create_async_op(SOURCE_ASYNC_STOP, &command)))
+        hr = MFPutWorkItem(source->async_commands_queue, &source->async_commands_callback, &command->IUnknown_iface);
+
+    return hr;
+}
+
+static HRESULT WINAPI media_source_Pause(IMFMediaSource *iface)
+{
+    struct media_source *source = impl_from_IMFMediaSource(iface);
+    struct source_async_command *command;
+    HRESULT hr;
+
+    TRACE("%p.\n", iface);
+
+    if (source->state == SOURCE_SHUTDOWN)
+        return MF_E_SHUTDOWN;
+
+    if (source->state != SOURCE_RUNNING)
+        return MF_E_INVALID_STATE_TRANSITION;
+
+    if (SUCCEEDED(hr = source_create_async_op(SOURCE_ASYNC_PAUSE, &command)))
+        hr = MFPutWorkItem(source->async_commands_queue,
+                &source->async_commands_callback, &command->IUnknown_iface);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI media_source_Shutdown(IMFMediaSource *iface)
+{
+    struct media_source *source = impl_from_IMFMediaSource(iface);
+    unsigned int i;
+
+    TRACE("%p.\n", iface);
+
+    if (source->state == SOURCE_SHUTDOWN)
+        return MF_E_SHUTDOWN;
+
+    source->state = SOURCE_SHUTDOWN;
+
+    wg_parser_disconnect(source->wg_parser);
+
+    source->read_thread_shutdown = true;
+    WaitForSingleObject(source->read_thread, INFINITE);
+    CloseHandle(source->read_thread);
+
+    IMFPresentationDescriptor_Release(source->pres_desc);
+    IMFMediaEventQueue_Shutdown(source->event_queue);
+    IMFByteStream_Release(source->byte_stream);
+
+    for (i = 0; i < source->stream_count; i++)
+    {
+        struct media_stream *stream = source->streams[i];
+
+        stream->state = STREAM_SHUTDOWN;
+
+        IMFMediaEventQueue_Shutdown(stream->event_queue);
+        IMFStreamDescriptor_Release(stream->descriptor);
+        IMFMediaSource_Release(&stream->parent_source->IMFMediaSource_iface);
+
+        IMFMediaStream_Release(&stream->IMFMediaStream_iface);
+    }
+
+    wg_parser_destroy(source->wg_parser);
+
+    free(source->streams);
+
+    MFUnlockWorkQueue(source->async_commands_queue);
+
+    return S_OK;
+}
+
+static const IMFMediaSourceVtbl IMFMediaSource_vtbl =
+{
+    media_source_QueryInterface,
+    media_source_AddRef,
+    media_source_Release,
+    media_source_GetEvent,
+    media_source_BeginGetEvent,
+    media_source_EndGetEvent,
+    media_source_QueueEvent,
+    media_source_GetCharacteristics,
+    media_source_CreatePresentationDescriptor,
+    media_source_Start,
+    media_source_Stop,
+    media_source_Pause,
+    media_source_Shutdown,
+};
+
+static HRESULT media_source_constructor(IMFByteStream *bytestream, struct media_source **out_media_source)
+{
+    BOOL video_selected = FALSE, audio_selected = FALSE;
+    IMFStreamDescriptor **descriptors = NULL;
+    unsigned int stream_count = UINT_MAX;
+    struct media_source *object;
+    UINT64 total_pres_time = 0;
+    struct wg_parser *parser;
+    DWORD bytestream_caps;
+    uint64_t file_size;
+    unsigned int i;
+    HRESULT hr;
+
+    if (FAILED(hr = IMFByteStream_GetCapabilities(bytestream, &bytestream_caps)))
+        return hr;
+
+    if (!(bytestream_caps & MFBYTESTREAM_IS_SEEKABLE))
+    {
+        FIXME("Non-seekable bytestreams not supported.\n");
+        return MF_E_BYTESTREAM_NOT_SEEKABLE;
+    }
+
+    if (FAILED(hr = IMFByteStream_GetLength(bytestream, &file_size)))
+    {
+        FIXME("Failed to get byte stream length, hr %#x.\n", hr);
+        return hr;
+    }
+
+    if (!(object = calloc(1, sizeof(*object))))
+        return E_OUTOFMEMORY;
+
+    object->IMFMediaSource_iface.lpVtbl = &IMFMediaSource_vtbl;
+    object->IMFGetService_iface.lpVtbl = &media_source_get_service_vtbl;
+    object->IMFRateSupport_iface.lpVtbl = &media_source_rate_support_vtbl;
+    object->IMFRateControl_iface.lpVtbl = &media_source_rate_control_vtbl;
+    object->async_commands_callback.lpVtbl = &source_async_commands_callback_vtbl;
+    object->ref = 1;
+    object->byte_stream = bytestream;
+    IMFByteStream_AddRef(bytestream);
+
+    if (FAILED(hr = MFCreateEventQueue(&object->event_queue)))
+        goto fail;
+
+    if (FAILED(hr = MFAllocateWorkQueue(&object->async_commands_queue)))
+        goto fail;
+
+    /* In Media Foundation, sources may read from any media source stream
+     * without fear of blocking due to buffering limits on another. Trailmakers,
+     * a Unity3D Engine game, only reads one sample from the audio stream (and
+     * never deselects it). Remove buffering limits from decodebin in order to
+     * account for this. Note that this does leak memory, but the same memory
+     * leak occurs with native. */
+    if (!(parser = wg_parser_create(WG_PARSER_DECODEBIN, true)))
+    {
+        hr = E_OUTOFMEMORY;
+        goto fail;
+    }
+    object->wg_parser = parser;
+
+    object->read_thread = CreateThread(NULL, 0, read_thread, object, 0, NULL);
+
+    object->state = SOURCE_OPENING;
+
+    if (FAILED(hr = wg_parser_connect(parser, file_size)))
+        goto fail;
+
+    stream_count = wg_parser_get_stream_count(parser);
+
+    if (!(object->streams = calloc(stream_count, sizeof(*object->streams))))
+    {
+        hr = E_OUTOFMEMORY;
+        goto fail;
+    }
+
+    for (i = 0; i < stream_count; ++i)
+    {
+        if (FAILED(hr = new_media_stream(object, wg_parser_get_stream(parser, i), i, &object->streams[i])))
+            goto fail;
+
+        if (FAILED(hr = media_stream_init_desc(object->streams[i])))
+        {
+            ERR("Failed to finish initialization of media stream %p, hr %x.\n", object->streams[i], hr);
+            IMFMediaSource_Release(&object->streams[i]->parent_source->IMFMediaSource_iface);
+            IMFMediaEventQueue_Release(object->streams[i]->event_queue);
+            free(object->streams[i]);
+            goto fail;
+        }
+
+        object->stream_count++;
+    }
+
+    /* init presentation descriptor */
+
+    descriptors = malloc(object->stream_count * sizeof(IMFStreamDescriptor *));
+    for (i = 0; i < object->stream_count; i++)
+    {
+        IMFStreamDescriptor **descriptor = &descriptors[object->stream_count - 1 - i];
+        char language[128];
+        DWORD language_len;
+        WCHAR *languageW;
+
+        IMFMediaStream_GetStreamDescriptor(&object->streams[i]->IMFMediaStream_iface, descriptor);
+
+        if (wg_parser_stream_get_language(object->streams[i]->wg_stream, language, sizeof(language)))
+        {
+            if ((language_len = MultiByteToWideChar(CP_UTF8, 0, language, -1, NULL, 0)))
+            {
+                languageW = malloc(language_len * sizeof(WCHAR));
+                if (MultiByteToWideChar(CP_UTF8, 0, language, -1, languageW, language_len))
+                {
+                    IMFStreamDescriptor_SetString(*descriptor, &MF_SD_LANGUAGE, languageW);
+                }
+                free(languageW);
+            }
+        }
+    }
+
+    if (FAILED(hr = MFCreatePresentationDescriptor(object->stream_count, descriptors, &object->pres_desc)))
+        goto fail;
+
+    /* Select one of each major type. */
+    for (i = 0; i < object->stream_count; i++)
+    {
+        IMFMediaTypeHandler *handler;
+        GUID major_type;
+        BOOL select_stream = FALSE;
+
+        IMFStreamDescriptor_GetMediaTypeHandler(descriptors[i], &handler);
+        IMFMediaTypeHandler_GetMajorType(handler, &major_type);
+        if (IsEqualGUID(&major_type, &MFMediaType_Video) && !video_selected)
+        {
+            select_stream = TRUE;
+            video_selected = TRUE;
+        }
+        if (IsEqualGUID(&major_type, &MFMediaType_Audio) && !audio_selected)
+        {
+            select_stream = TRUE;
+            audio_selected = TRUE;
+        }
+        if (select_stream)
+            IMFPresentationDescriptor_SelectStream(object->pres_desc, i);
+        IMFMediaTypeHandler_Release(handler);
+        IMFStreamDescriptor_Release(descriptors[i]);
+    }
+    free(descriptors);
+    descriptors = NULL;
+
+    for (i = 0; i < object->stream_count; i++)
+        total_pres_time = max(total_pres_time,
+                wg_parser_stream_get_duration(object->streams[i]->wg_stream));
+
+    if (object->stream_count)
+        IMFPresentationDescriptor_SetUINT64(object->pres_desc, &MF_PD_DURATION, total_pres_time);
+
+    object->state = SOURCE_STOPPED;
+
+    *out_media_source = object;
+    return S_OK;
+
+    fail:
+    WARN("Failed to construct MFMediaSource, hr %#x.\n", hr);
+
+    if (descriptors)
+    {
+        for (i = 0; i < object->stream_count; i++)
+            IMFStreamDescriptor_Release(descriptors[i]);
+        free(descriptors);
+    }
+    for (i = 0; i < object->stream_count; i++)
+    {
+        struct media_stream *stream = object->streams[i];
+
+        IMFMediaEventQueue_Release(stream->event_queue);
+        IMFStreamDescriptor_Release(stream->descriptor);
+        IMFMediaSource_Release(&stream->parent_source->IMFMediaSource_iface);
+
+        free(stream);
+    }
+    free(object->streams);
+    if (stream_count != UINT_MAX)
+        wg_parser_disconnect(object->wg_parser);
+    if (object->read_thread)
+    {
+        object->read_thread_shutdown = true;
+        WaitForSingleObject(object->read_thread, INFINITE);
+        CloseHandle(object->read_thread);
+    }
+    if (object->wg_parser)
+        wg_parser_destroy(object->wg_parser);
+    if (object->async_commands_queue)
+        MFUnlockWorkQueue(object->async_commands_queue);
+    if (object->event_queue)
+        IMFMediaEventQueue_Release(object->event_queue);
+    IMFByteStream_Release(object->byte_stream);
+    free(object);
+    return hr;
+}
+
+struct winegstreamer_stream_handler_result
+{
+    struct list entry;
+    IMFAsyncResult *result;
+    MF_OBJECT_TYPE obj_type;
+    IUnknown *object;
+};
+
+struct winegstreamer_stream_handler
+{
+    IMFByteStreamHandler IMFByteStreamHandler_iface;
+    IMFAsyncCallback IMFAsyncCallback_iface;
+    LONG refcount;
+    struct list results;
+    CRITICAL_SECTION cs;
+};
+
+static struct winegstreamer_stream_handler *impl_from_IMFByteStreamHandler(IMFByteStreamHandler *iface)
+{
+    return CONTAINING_RECORD(iface, struct winegstreamer_stream_handler, IMFByteStreamHandler_iface);
+}
+
+static struct winegstreamer_stream_handler *impl_from_IMFAsyncCallback(IMFAsyncCallback *iface)
+{
+    return CONTAINING_RECORD(iface, struct winegstreamer_stream_handler, IMFAsyncCallback_iface);
+}
+
+static HRESULT WINAPI winegstreamer_stream_handler_QueryInterface(IMFByteStreamHandler *iface, REFIID riid, void **obj)
+{
+    TRACE("%p, %s, %p.\n", iface, debugstr_guid(riid), obj);
+
+    if (IsEqualIID(riid, &IID_IMFByteStreamHandler) ||
+            IsEqualIID(riid, &IID_IUnknown))
+    {
+        *obj = iface;
+        IMFByteStreamHandler_AddRef(iface);
+        return S_OK;
+    }
+
+    WARN("Unsupported %s.\n", debugstr_guid(riid));
+    *obj = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI winegstreamer_stream_handler_AddRef(IMFByteStreamHandler *iface)
+{
+    struct winegstreamer_stream_handler *handler = impl_from_IMFByteStreamHandler(iface);
+    ULONG refcount = InterlockedIncrement(&handler->refcount);
+
+    TRACE("%p, refcount %u.\n", handler, refcount);
+
+    return refcount;
+}
+
+static ULONG WINAPI winegstreamer_stream_handler_Release(IMFByteStreamHandler *iface)
+{
+    struct winegstreamer_stream_handler *handler = impl_from_IMFByteStreamHandler(iface);
+    ULONG refcount = InterlockedDecrement(&handler->refcount);
+    struct winegstreamer_stream_handler_result *result, *next;
+
+    TRACE("%p, refcount %u.\n", iface, refcount);
+
+    if (!refcount)
+    {
+        LIST_FOR_EACH_ENTRY_SAFE(result, next, &handler->results, struct winegstreamer_stream_handler_result, entry)
+        {
+            list_remove(&result->entry);
+            IMFAsyncResult_Release(result->result);
+            if (result->object)
+                IUnknown_Release(result->object);
+            free(result);
+        }
+        DeleteCriticalSection(&handler->cs);
+        free(handler);
+    }
+
+    return refcount;
+}
+
+struct create_object_context
+{
+    IUnknown IUnknown_iface;
+    LONG refcount;
+
+    IPropertyStore *props;
+    IMFByteStream *stream;
+    WCHAR *url;
+    DWORD flags;
+};
+
+static struct create_object_context *impl_from_IUnknown(IUnknown *iface)
+{
+    return CONTAINING_RECORD(iface, struct create_object_context, IUnknown_iface);
+}
+
+static HRESULT WINAPI create_object_context_QueryInterface(IUnknown *iface, REFIID riid, void **obj)
+{
+    TRACE("%p, %s, %p.\n", iface, debugstr_guid(riid), obj);
+
+    if (IsEqualIID(riid, &IID_IUnknown))
+    {
+        *obj = iface;
+        IUnknown_AddRef(iface);
+        return S_OK;
+    }
+
+    WARN("Unsupported %s.\n", debugstr_guid(riid));
+    *obj = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI create_object_context_AddRef(IUnknown *iface)
+{
+    struct create_object_context *context = impl_from_IUnknown(iface);
+    ULONG refcount = InterlockedIncrement(&context->refcount);
+
+    TRACE("%p, refcount %u.\n", iface, refcount);
+
+    return refcount;
+}
+
+static ULONG WINAPI create_object_context_Release(IUnknown *iface)
+{
+    struct create_object_context *context = impl_from_IUnknown(iface);
+    ULONG refcount = InterlockedDecrement(&context->refcount);
+
+    TRACE("%p, refcount %u.\n", iface, refcount);
+
+    if (!refcount)
+    {
+        if (context->props)
+            IPropertyStore_Release(context->props);
+        if (context->stream)
+            IMFByteStream_Release(context->stream);
+        free(context->url);
+        free(context);
+    }
+
+    return refcount;
+}
+
+static const IUnknownVtbl create_object_context_vtbl =
+{
+    create_object_context_QueryInterface,
+    create_object_context_AddRef,
+    create_object_context_Release,
+};
+
+static HRESULT WINAPI winegstreamer_stream_handler_BeginCreateObject(IMFByteStreamHandler *iface, IMFByteStream *stream, const WCHAR *url, DWORD flags,
+        IPropertyStore *props, IUnknown **cancel_cookie, IMFAsyncCallback *callback, IUnknown *state)
+{
+    struct winegstreamer_stream_handler *this = impl_from_IMFByteStreamHandler(iface);
+    struct create_object_context *context;
+    IMFAsyncResult *caller, *item;
+    HRESULT hr;
+
+    TRACE("%p, %s, %#x, %p, %p, %p, %p.\n", iface, debugstr_w(url), flags, props, cancel_cookie, callback, state);
+
+    if (cancel_cookie)
+        *cancel_cookie = NULL;
+
+    if (FAILED(hr = MFCreateAsyncResult(NULL, callback, state, &caller)))
+        return hr;
+
+    if (!(context = calloc(1, sizeof(*context))))
+    {
+        IMFAsyncResult_Release(caller);
+        return E_OUTOFMEMORY;
+    }
+
+    context->IUnknown_iface.lpVtbl = &create_object_context_vtbl;
+    context->refcount = 1;
+    context->props = props;
+    if (context->props)
+        IPropertyStore_AddRef(context->props);
+    context->flags = flags;
+    context->stream = stream;
+    if (context->stream)
+        IMFByteStream_AddRef(context->stream);
+    if (url)
+        context->url = wcsdup(url);
+    if (!context->stream)
+    {
+        IMFAsyncResult_Release(caller);
+        IUnknown_Release(&context->IUnknown_iface);
+        return E_OUTOFMEMORY;
+    }
+
+    hr = MFCreateAsyncResult(&context->IUnknown_iface, &this->IMFAsyncCallback_iface, (IUnknown *)caller, &item);
+    IUnknown_Release(&context->IUnknown_iface);
+    if (SUCCEEDED(hr))
+    {
+        if (SUCCEEDED(hr = MFPutWorkItemEx(MFASYNC_CALLBACK_QUEUE_IO, item)))
+        {
+            if (cancel_cookie)
+            {
+                *cancel_cookie = (IUnknown *)caller;
+                IUnknown_AddRef(*cancel_cookie);
+            }
+        }
+
+        IMFAsyncResult_Release(item);
+    }
+    IMFAsyncResult_Release(caller);
+
+    return hr;
+}
+
+static HRESULT WINAPI winegstreamer_stream_handler_EndCreateObject(IMFByteStreamHandler *iface, IMFAsyncResult *result,
+        MF_OBJECT_TYPE *obj_type, IUnknown **object)
+{
+    struct winegstreamer_stream_handler *this = impl_from_IMFByteStreamHandler(iface);
+    struct winegstreamer_stream_handler_result *found = NULL, *cur;
+    HRESULT hr;
+
+    TRACE("%p, %p, %p, %p.\n", iface, result, obj_type, object);
+
+    EnterCriticalSection(&this->cs);
+
+    LIST_FOR_EACH_ENTRY(cur, &this->results, struct winegstreamer_stream_handler_result, entry)
+    {
+        if (result == cur->result)
+        {
+            list_remove(&cur->entry);
+            found = cur;
+            break;
+        }
+    }
+
+    LeaveCriticalSection(&this->cs);
+
+    if (found)
+    {
+        *obj_type = found->obj_type;
+        *object = found->object;
+        hr = IMFAsyncResult_GetStatus(found->result);
+        IMFAsyncResult_Release(found->result);
+        free(found);
+    }
+    else
+    {
+        *obj_type = MF_OBJECT_INVALID;
+        *object = NULL;
+        hr = MF_E_UNEXPECTED;
+    }
+
+    return hr;
+}
+
+static HRESULT WINAPI winegstreamer_stream_handler_CancelObjectCreation(IMFByteStreamHandler *iface, IUnknown *cancel_cookie)
+{
+    struct winegstreamer_stream_handler *this = impl_from_IMFByteStreamHandler(iface);
+    struct winegstreamer_stream_handler_result *found = NULL, *cur;
+
+    TRACE("%p, %p.\n", iface, cancel_cookie);
+
+    EnterCriticalSection(&this->cs);
+
+    LIST_FOR_EACH_ENTRY(cur, &this->results, struct winegstreamer_stream_handler_result, entry)
+    {
+        if (cancel_cookie == (IUnknown *)cur->result)
+        {
+            list_remove(&cur->entry);
+            found = cur;
+            break;
+        }
+    }
+
+    LeaveCriticalSection(&this->cs);
+
+    if (found)
+    {
+        IMFAsyncResult_Release(found->result);
+        if (found->object)
+            IUnknown_Release(found->object);
+        free(found);
+    }
+
+    return found ? S_OK : MF_E_UNEXPECTED;
+}
+
+static HRESULT WINAPI winegstreamer_stream_handler_GetMaxNumberOfBytesRequiredForResolution(IMFByteStreamHandler *iface, QWORD *bytes)
+{
+    FIXME("stub (%p %p)\n", iface, bytes);
+    return E_NOTIMPL;
+}
+
+static const IMFByteStreamHandlerVtbl winegstreamer_stream_handler_vtbl =
+{
+    winegstreamer_stream_handler_QueryInterface,
+    winegstreamer_stream_handler_AddRef,
+    winegstreamer_stream_handler_Release,
+    winegstreamer_stream_handler_BeginCreateObject,
+    winegstreamer_stream_handler_EndCreateObject,
+    winegstreamer_stream_handler_CancelObjectCreation,
+    winegstreamer_stream_handler_GetMaxNumberOfBytesRequiredForResolution,
+};
+
+static HRESULT WINAPI winegstreamer_stream_handler_callback_QueryInterface(IMFAsyncCallback *iface, REFIID riid, void **obj)
+{
+    if (IsEqualIID(riid, &IID_IMFAsyncCallback) ||
+            IsEqualIID(riid, &IID_IUnknown))
+    {
+        *obj = iface;
+        IMFAsyncCallback_AddRef(iface);
+        return S_OK;
+    }
+
+    WARN("Unsupported %s.\n", debugstr_guid(riid));
+    *obj = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI winegstreamer_stream_handler_callback_AddRef(IMFAsyncCallback *iface)
+{
+    struct winegstreamer_stream_handler *handler = impl_from_IMFAsyncCallback(iface);
+    return IMFByteStreamHandler_AddRef(&handler->IMFByteStreamHandler_iface);
+}
+
+static ULONG WINAPI winegstreamer_stream_handler_callback_Release(IMFAsyncCallback *iface)
+{
+    struct winegstreamer_stream_handler *handler = impl_from_IMFAsyncCallback(iface);
+    return IMFByteStreamHandler_Release(&handler->IMFByteStreamHandler_iface);
+}
+
+static HRESULT WINAPI winegstreamer_stream_handler_callback_GetParameters(IMFAsyncCallback *iface, DWORD *flags, DWORD *queue)
+{
+    return E_NOTIMPL;
+}
+
+static HRESULT winegstreamer_stream_handler_create_object(struct winegstreamer_stream_handler *This, WCHAR *url, IMFByteStream *stream, DWORD flags,
+                                            IPropertyStore *props, IUnknown **out_object, MF_OBJECT_TYPE *out_obj_type)
+{
+    TRACE("%p, %s, %p, %u, %p, %p, %p.\n", This, debugstr_w(url), stream, flags, props, out_object, out_obj_type);
+
+    if (flags & MF_RESOLUTION_MEDIASOURCE)
+    {
+        HRESULT hr;
+        struct media_source *new_source;
+
+        if (FAILED(hr = media_source_constructor(stream, &new_source)))
+            return hr;
+
+        TRACE("->(%p)\n", new_source);
+
+        *out_object = (IUnknown*)&new_source->IMFMediaSource_iface;
+        *out_obj_type = MF_OBJECT_MEDIASOURCE;
+
+        return S_OK;
+    }
+    else
+    {
+        FIXME("flags = %08x\n", flags);
+        return E_NOTIMPL;
+    }
+}
+
+static HRESULT WINAPI winegstreamer_stream_handler_callback_Invoke(IMFAsyncCallback *iface, IMFAsyncResult *result)
+{
+    struct winegstreamer_stream_handler *handler = impl_from_IMFAsyncCallback(iface);
+    struct winegstreamer_stream_handler_result *handler_result;
+    MF_OBJECT_TYPE obj_type = MF_OBJECT_INVALID;
+    IUnknown *object = NULL, *context_object;
+    struct create_object_context *context;
+    IMFAsyncResult *caller;
+    HRESULT hr;
+
+    caller = (IMFAsyncResult *)IMFAsyncResult_GetStateNoAddRef(result);
+
+    if (FAILED(hr = IMFAsyncResult_GetObject(result, &context_object)))
+    {
+        WARN("Expected context set for callee result.\n");
+        return hr;
+    }
+
+    context = impl_from_IUnknown(context_object);
+
+    hr = winegstreamer_stream_handler_create_object(handler, context->url, context->stream, context->flags, context->props, &object, &obj_type);
+
+    if ((handler_result = malloc(sizeof(*handler_result))))
+    {
+        handler_result->result = caller;
+        IMFAsyncResult_AddRef(handler_result->result);
+        handler_result->obj_type = obj_type;
+        handler_result->object = object;
+
+        EnterCriticalSection(&handler->cs);
+        list_add_tail(&handler->results, &handler_result->entry);
+        LeaveCriticalSection(&handler->cs);
+    }
+    else
+    {
+        if (object)
+            IUnknown_Release(object);
+        hr = E_OUTOFMEMORY;
+    }
+
+    IUnknown_Release(&context->IUnknown_iface);
+
+    IMFAsyncResult_SetStatus(caller, hr);
+    MFInvokeCallback(caller);
+
+    return S_OK;
+}
+
+static const IMFAsyncCallbackVtbl winegstreamer_stream_handler_callback_vtbl =
+{
+    winegstreamer_stream_handler_callback_QueryInterface,
+    winegstreamer_stream_handler_callback_AddRef,
+    winegstreamer_stream_handler_callback_Release,
+    winegstreamer_stream_handler_callback_GetParameters,
+    winegstreamer_stream_handler_callback_Invoke,
+};
+
+HRESULT winegstreamer_stream_handler_create(REFIID riid, void **obj)
+{
+    struct winegstreamer_stream_handler *this;
+    HRESULT hr;
+
+    TRACE("%s, %p.\n", debugstr_guid(riid), obj);
+
+    if (!(this = calloc(1, sizeof(*this))))
+        return E_OUTOFMEMORY;
+
+    list_init(&this->results);
+    InitializeCriticalSection(&this->cs);
+
+    this->IMFByteStreamHandler_iface.lpVtbl = &winegstreamer_stream_handler_vtbl;
+    this->IMFAsyncCallback_iface.lpVtbl = &winegstreamer_stream_handler_callback_vtbl;
+    this->refcount = 1;
+
+    hr = IMFByteStreamHandler_QueryInterface(&this->IMFByteStreamHandler_iface, riid, obj);
+    IMFByteStreamHandler_Release(&this->IMFByteStreamHandler_iface);
+
+    return hr;
+}
diff --git a/dlls/mfplat/mediatype.c b/dlls/mfplat/mediatype.c
index b36a44d1e1c..4f24ccbd237 100644
--- wine/dlls/mfplat/mediatype.c
+++ wine/dlls/mfplat/mediatype.c
@@ -25,6 +25,8 @@
 #include "ks.h"
 #include "ksmedia.h"
 
+#include "wine/debug.h"
+
 WINE_DEFAULT_DEBUG_CHANNEL(mfplat);
 
 DEFINE_MEDIATYPE_GUID(MFVideoFormat_IMC1, MAKEFOURCC('I','M','C','1'));
@@ -138,7 +140,7 @@ static ULONG WINAPI mediatype_AddRef(IMFMediaType *iface)
     struct media_type *media_type = impl_from_IMFMediaType(iface);
     ULONG refcount = InterlockedIncrement(&media_type->attributes.ref);
 
-    TRACE("%p, refcount %lu.\n", iface, refcount);
+    TRACE("%p, refcount %u.\n", iface, refcount);
 
     return refcount;
 }
@@ -148,7 +150,7 @@ static ULONG WINAPI mediatype_Release(IMFMediaType *iface)
     struct media_type *media_type = impl_from_IMFMediaType(iface);
     ULONG refcount = InterlockedDecrement(&media_type->attributes.ref);
 
-    TRACE("%p, refcount %lu.\n", iface, refcount);
+    TRACE("%p, refcount %u.\n", iface, refcount);
 
     if (!refcount)
     {
@@ -976,9 +978,8 @@ static const MFVIDEOFORMAT * WINAPI video_mediatype_GetVideoFormat(IMFVideoMedia
     TRACE("%p.\n", iface);
 
     CoTaskMemFree(media_type->video_format);
-    media_type->video_format = NULL;
     if (FAILED(hr = MFCreateMFVideoFormatFromMFMediaType(&media_type->IMFMediaType_iface, &media_type->video_format, &size)))
-        WARN("Failed to create format description, hr %#lx.\n", hr);
+        WARN("Failed to create format description, hr %#x.\n", hr);
 
     return media_type->video_format;
 }
@@ -986,7 +987,7 @@ static const MFVIDEOFORMAT * WINAPI video_mediatype_GetVideoFormat(IMFVideoMedia
 static HRESULT WINAPI video_mediatype_GetVideoRepresentation(IMFVideoMediaType *iface, GUID representation,
         void **data, LONG stride)
 {
-    FIXME("%p, %s, %p, %ld.\n", iface, debugstr_guid(&representation), data, stride);
+    FIXME("%p, %s, %p, %d.\n", iface, debugstr_guid(&representation), data, stride);
 
     return E_NOTIMPL;
 }
@@ -1377,11 +1378,10 @@ static const WAVEFORMATEX * WINAPI audio_mediatype_GetAudioFormat(IMFAudioMediaT
     TRACE("%p.\n", iface);
 
     CoTaskMemFree(media_type->audio_format);
-    media_type->audio_format = NULL;
     if (FAILED(hr = MFCreateWaveFormatExFromMFMediaType(&media_type->IMFMediaType_iface, &media_type->audio_format,
             &size, MFWaveFormatExConvertFlag_Normal)))
     {
-        WARN("Failed to create wave format description, hr %#lx.\n", hr);
+        WARN("Failed to create wave format description, hr %#x.\n", hr);
     }
 
     return media_type->audio_format;
@@ -1498,7 +1498,7 @@ static ULONG WINAPI stream_descriptor_AddRef(IMFStreamDescriptor *iface)
     struct stream_desc *stream_desc = impl_from_IMFStreamDescriptor(iface);
     ULONG refcount = InterlockedIncrement(&stream_desc->attributes.ref);
 
-    TRACE("%p, refcount %lu.\n", iface, refcount);
+    TRACE("%p, refcount %u.\n", iface, refcount);
 
     return refcount;
 }
@@ -1509,7 +1509,7 @@ static ULONG WINAPI stream_descriptor_Release(IMFStreamDescriptor *iface)
     ULONG refcount = InterlockedDecrement(&stream_desc->attributes.ref);
     unsigned int i;
 
-    TRACE("%p, refcount %lu.\n", iface, refcount);
+    TRACE("%p, refcount %u.\n", iface, refcount);
 
     if (!refcount)
     {
@@ -1955,7 +1955,7 @@ static HRESULT WINAPI mediatype_handler_GetMediaTypeByIndex(IMFMediaTypeHandler
 {
     struct stream_desc *stream_desc = impl_from_IMFMediaTypeHandler(iface);
 
-    TRACE("%p, %lu, %p.\n", iface, index, type);
+    TRACE("%p, %u, %p.\n", iface, index, type);
 
     if (index >= stream_desc->media_types_count)
         return MF_E_NO_MORE_TYPES;
@@ -2046,7 +2046,7 @@ HRESULT WINAPI MFCreateStreamDescriptor(DWORD identifier, DWORD count,
     unsigned int i;
     HRESULT hr;
 
-    TRACE("%ld, %ld, %p, %p.\n", identifier, count, types, descriptor);
+    TRACE("%d, %d, %p, %p.\n", identifier, count, types, descriptor);
 
     if (!count)
         return E_INVALIDARG;
@@ -2104,7 +2104,7 @@ static ULONG WINAPI presentation_descriptor_AddRef(IMFPresentationDescriptor *if
     struct presentation_desc *presentation_desc = impl_from_IMFPresentationDescriptor(iface);
     ULONG refcount = InterlockedIncrement(&presentation_desc->attributes.ref);
 
-    TRACE("%p, refcount %lu.\n", iface, refcount);
+    TRACE("%p, refcount %u.\n", iface, refcount);
 
     return refcount;
 }
@@ -2115,7 +2115,7 @@ static ULONG WINAPI presentation_descriptor_Release(IMFPresentationDescriptor *i
     ULONG refcount = InterlockedDecrement(&presentation_desc->attributes.ref);
     unsigned int i;
 
-    TRACE("%p, refcount %lu.\n", iface, refcount);
+    TRACE("%p, refcount %u.\n", iface, refcount);
 
     if (!refcount)
     {
@@ -2433,7 +2433,7 @@ static HRESULT WINAPI presentation_descriptor_GetStreamDescriptorByIndex(IMFPres
 {
     struct presentation_desc *presentation_desc = impl_from_IMFPresentationDescriptor(iface);
 
-    TRACE("%p, %lu, %p, %p.\n", iface, index, selected, descriptor);
+    TRACE("%p, %u, %p, %p.\n", iface, index, selected, descriptor);
 
     if (index >= presentation_desc->count)
         return E_INVALIDARG;
@@ -2452,7 +2452,7 @@ static HRESULT WINAPI presentation_descriptor_SelectStream(IMFPresentationDescri
 {
     struct presentation_desc *presentation_desc = impl_from_IMFPresentationDescriptor(iface);
 
-    TRACE("%p, %lu.\n", iface, index);
+    TRACE("%p, %u.\n", iface, index);
 
     if (index >= presentation_desc->count)
         return E_INVALIDARG;
@@ -2468,7 +2468,7 @@ static HRESULT WINAPI presentation_descriptor_DeselectStream(IMFPresentationDesc
 {
     struct presentation_desc *presentation_desc = impl_from_IMFPresentationDescriptor(iface);
 
-    TRACE("%p, %lu.\n", iface, index);
+    TRACE("%p, %u.\n", iface, index);
 
     if (index >= presentation_desc->count)
         return E_INVALIDARG;
@@ -2580,7 +2580,7 @@ HRESULT WINAPI MFCreatePresentationDescriptor(DWORD count, IMFStreamDescriptor *
     unsigned int i;
     HRESULT hr;
 
-    TRACE("%lu, %p, %p.\n", count, descriptors, out);
+    TRACE("%u, %p, %p.\n", count, descriptors, out);
 
     if (!count)
         return E_INVALIDARG;
@@ -2685,7 +2685,7 @@ HRESULT WINAPI MFGetStrideForBitmapInfoHeader(DWORD fourcc, DWORD width, LONG *s
     struct uncompressed_video_format *format;
     GUID subtype;
 
-    TRACE("%s, %lu, %p.\n", debugstr_fourcc(fourcc), width, stride);
+    TRACE("%s, %u, %p.\n", debugstr_fourcc(fourcc), width, stride);
 
     memcpy(&subtype, &MFVideoFormat_Base, sizeof(subtype));
     subtype.Data1 = fourcc;
@@ -2752,15 +2752,15 @@ HRESULT WINAPI MFGetPlaneSize(DWORD fourcc, DWORD width, DWORD height, DWORD *si
     unsigned int stride;
     GUID subtype;
 
-    TRACE("%s, %lu, %lu, %p.\n", debugstr_fourcc(fourcc), width, height, size);
+    TRACE("%s, %u, %u, %p.\n", debugstr_fourcc(fourcc), width, height, size);
 
     memcpy(&subtype, &MFVideoFormat_Base, sizeof(subtype));
     subtype.Data1 = fourcc;
 
-    if ((format = mf_get_video_format(&subtype)))
-        stride = mf_get_stride_for_format(format, width);
-    else
-        stride = 0;
+    if (!(format = mf_get_video_format(&subtype)))
+        return MF_E_INVALIDMEDIATYPE;
+
+    stride = mf_get_stride_for_format(format, width);
 
     switch (fourcc)
     {
@@ -2926,10 +2926,8 @@ HRESULT WINAPI MFCreateWaveFormatExFromMFMediaType(IMFMediaType *mediatype, WAVE
 
     if (SUCCEEDED(IMFMediaType_GetUINT32(mediatype, &MF_MT_AUDIO_NUM_CHANNELS, &value)))
         format->nChannels = value;
-    if (SUCCEEDED(IMFMediaType_GetUINT32(mediatype, &MF_MT_AUDIO_SAMPLES_PER_SECOND, &value)))
-        format->nSamplesPerSec = value;
-    if (SUCCEEDED(IMFMediaType_GetUINT32(mediatype, &MF_MT_AUDIO_AVG_BYTES_PER_SECOND, &value)))
-        format->nAvgBytesPerSec = value;
+    IMFMediaType_GetUINT32(mediatype, &MF_MT_AUDIO_SAMPLES_PER_SECOND, &format->nSamplesPerSec);
+    IMFMediaType_GetUINT32(mediatype, &MF_MT_AUDIO_AVG_BYTES_PER_SECOND, &format->nAvgBytesPerSec);
     if (SUCCEEDED(IMFMediaType_GetUINT32(mediatype, &MF_MT_AUDIO_BLOCK_ALIGNMENT, &value)))
         format->nBlockAlign = value;
     if (SUCCEEDED(IMFMediaType_GetUINT32(mediatype, &MF_MT_AUDIO_BITS_PER_SAMPLE, &value)))
@@ -2941,8 +2939,7 @@ HRESULT WINAPI MFCreateWaveFormatExFromMFMediaType(IMFMediaType *mediatype, WAVE
         if (SUCCEEDED(IMFMediaType_GetUINT32(mediatype, &MF_MT_AUDIO_VALID_BITS_PER_SAMPLE, &value)))
             format_ext->Samples.wSamplesPerBlock = value;
 
-        if (SUCCEEDED(IMFMediaType_GetUINT32(mediatype, &MF_MT_AUDIO_CHANNEL_MASK, &value)))
-            format_ext->dwChannelMask = value;
+        IMFMediaType_GetUINT32(mediatype, &MF_MT_AUDIO_CHANNEL_MASK, &format_ext->dwChannelMask);
         memcpy(&format_ext->SubFormat, &KSDATAFORMAT_SUBTYPE_PCM, sizeof(format_ext->SubFormat));
     }
 
@@ -3088,8 +3085,8 @@ HRESULT WINAPI MFCreateAudioMediaType(const WAVEFORMATEX *format, IMFAudioMediaT
     return S_OK;
 }
 
-static void media_type_get_ratio(IMFMediaType *media_type, const GUID *attr, DWORD *numerator,
-        DWORD *denominator)
+static void media_type_get_ratio(IMFMediaType *media_type, const GUID *attr, UINT32 *numerator,
+        UINT32 *denominator)
 {
     UINT64 value;
 
@@ -3105,7 +3102,7 @@ static void media_type_get_ratio(IMFMediaType *media_type, const GUID *attr, DWO
  */
 HRESULT WINAPI MFCreateMFVideoFormatFromMFMediaType(IMFMediaType *media_type, MFVIDEOFORMAT **video_format, UINT32 *size)
 {
-    UINT32 flags, palette_size = 0, value;
+    UINT32 flags, palette_size = 0, avgrate;
     MFVIDEOFORMAT *format;
     INT32 stride;
     GUID guid;
@@ -3165,12 +3162,11 @@ HRESULT WINAPI MFCreateMFVideoFormatFromMFMediaType(IMFMediaType *media_type, MF
     if (SUCCEEDED(IMFMediaType_GetUINT32(media_type, &MF_MT_DEFAULT_STRIDE, (UINT32 *)&stride)) && stride < 0)
         format->videoInfo.VideoFlags |= MFVideoFlag_BottomUpLinearRep;
 
-    if (SUCCEEDED(IMFMediaType_GetUINT32(media_type, &MF_MT_AVG_BITRATE, &value)))
-        format->compressedInfo.AvgBitrate = value;
-    if (SUCCEEDED(IMFMediaType_GetUINT32(media_type, &MF_MT_AVG_BIT_ERROR_RATE, &value)))
-        format->compressedInfo.AvgBitErrorRate = value;
-    if (SUCCEEDED(IMFMediaType_GetUINT32(media_type, &MF_MT_MAX_KEYFRAME_SPACING, &value)))
-        format->compressedInfo.MaxKeyFrameSpacing = value;
+    if (SUCCEEDED(IMFMediaType_GetUINT32(media_type, &MF_MT_AVG_BITRATE, &avgrate)))
+        format->compressedInfo.AvgBitrate = avgrate;
+    if (SUCCEEDED(IMFMediaType_GetUINT32(media_type, &MF_MT_AVG_BIT_ERROR_RATE, &avgrate)))
+        format->compressedInfo.AvgBitErrorRate = avgrate;
+    IMFMediaType_GetUINT32(media_type, &MF_MT_MAX_KEYFRAME_SPACING, &format->compressedInfo.MaxKeyFrameSpacing);
 
     /* Palette. */
     if (palette_size)
@@ -3217,15 +3213,15 @@ HRESULT WINAPI MFConvertColorInfoToDXVA(DWORD *dxva_info, const MFVIDEOFORMAT *f
 
 struct frame_rate
 {
-    UINT64 key;
-    UINT64 value;
+    UINT64 rate;
+    UINT64 frame_time;
 };
 
 static int __cdecl frame_rate_compare(const void *a, const void *b)
 {
-    const UINT64 *key = a;
+    const UINT64 *rate = a;
     const struct frame_rate *known_rate = b;
-    return *key == known_rate->key ? 0 : ( *key < known_rate->key ? 1 : -1 );
+    return *rate == known_rate->rate ? 0 : ( *rate < known_rate->rate ? 1 : -1 );
 }
 
 /***********************************************************************
@@ -3254,7 +3250,7 @@ HRESULT WINAPI MFFrameRateToAverageTimePerFrame(UINT32 numerator, UINT32 denomin
     if ((entry = bsearch(&rate, known_rates, ARRAY_SIZE(known_rates), sizeof(*known_rates),
             frame_rate_compare)))
     {
-        *avgframetime = entry->value;
+        *avgframetime = entry->frame_time;
     }
     else
         *avgframetime = numerator ? denominator * (UINT64)10000000 / numerator : 0;
@@ -3262,64 +3258,6 @@ HRESULT WINAPI MFFrameRateToAverageTimePerFrame(UINT32 numerator, UINT32 denomin
     return S_OK;
 }
 
-static unsigned int get_gcd(unsigned int a, unsigned int b)
-{
-    unsigned int m;
-
-    while (b)
-    {
-        m = a % b;
-        a = b;
-        b = m;
-    }
-
-    return a;
-}
-
-/***********************************************************************
- *      MFAverageTimePerFrameToFrameRate (mfplat.@)
- */
-HRESULT WINAPI MFAverageTimePerFrameToFrameRate(UINT64 avgtime, UINT32 *numerator, UINT32 *denominator)
-{
-    static const struct frame_rate known_rates[] =
-    {
-#define KNOWN_RATE(ft,n,d) { ft, ((UINT64)n << 32) | d }
-        KNOWN_RATE(417188, 24000, 1001),
-        KNOWN_RATE(416667,    24,    1),
-        KNOWN_RATE(400000,    25,    1),
-        KNOWN_RATE(333667, 30000, 1001),
-        KNOWN_RATE(333333,    30,    1),
-        KNOWN_RATE(200000,    50,    1),
-        KNOWN_RATE(166833, 60000, 1001),
-        KNOWN_RATE(166667,    60,    1),
-#undef KNOWN_RATE
-    };
-    const struct frame_rate *entry;
-    unsigned int gcd;
-
-    TRACE("%s, %p, %p.\n", wine_dbgstr_longlong(avgtime), numerator, denominator);
-
-    if ((entry = bsearch(&avgtime, known_rates, ARRAY_SIZE(known_rates), sizeof(*known_rates),
-            frame_rate_compare)))
-    {
-        *numerator = entry->value >> 32;
-        *denominator = entry->value;
-    }
-    else if (avgtime)
-    {
-        if (avgtime > 100000000) avgtime = 100000000;
-        gcd = get_gcd(10000000, avgtime);
-        *numerator = 10000000 / gcd;
-        *denominator = avgtime / gcd;
-    }
-    else
-    {
-        *numerator = *denominator = 0;
-    }
-
-    return S_OK;
-}
-
 /***********************************************************************
  *      MFMapDXGIFormatToDX9Format (mfplat.@)
  */
@@ -3513,7 +3451,7 @@ HRESULT WINAPI MFInitVideoFormat_RGB(MFVIDEOFORMAT *format, DWORD width, DWORD h
 {
     unsigned int transfer_function;
 
-    TRACE("%p, %lu, %lu, %#lx.\n", format, width, height, d3dformat);
+    TRACE("%p, %u, %u, %#x.\n", format, width, height, d3dformat);
 
     if (!format)
         return E_INVALIDARG;
diff --git a/dlls/mfplat/mfplat.c b/dlls/mfplat/mfplat.c
new file mode 100644
index 00000000000..3ec45d7de4e
--- /dev/null
+++ wine/dlls/mfplat/mfplat.c
@@ -0,0 +1,1036 @@
+/*
+ * Copyright 2019 Nikolay Sivov for CodeWeavers
+ * Copyright 2020 Zebediah Figura for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "gst_private.h"
+
+#include "ks.h"
+#include "ksmedia.h"
+#include "wmcodecdsp.h"
+#include "initguid.h"
+#include "mfapi.h"
+
+#include "wine/debug.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(mfplat);
+
+DEFINE_MEDIATYPE_GUID(MFAudioFormat_XMAudio2, 0x0166);
+
+struct video_processor
+{
+    IMFTransform IMFTransform_iface;
+    LONG refcount;
+    IMFAttributes *attributes;
+    IMFAttributes *output_attributes;
+};
+
+static struct video_processor *impl_video_processor_from_IMFTransform(IMFTransform *iface)
+{
+    return CONTAINING_RECORD(iface, struct video_processor, IMFTransform_iface);
+}
+
+static HRESULT WINAPI video_processor_QueryInterface(IMFTransform *iface, REFIID riid, void **obj)
+{
+    TRACE("%p, %s, %p.\n", iface, debugstr_guid(riid), obj);
+
+    if (IsEqualIID(riid, &IID_IMFTransform) ||
+            IsEqualIID(riid, &IID_IUnknown))
+    {
+        *obj = iface;
+        IMFTransform_AddRef(iface);
+        return S_OK;
+    }
+
+    WARN("Unsupported %s.\n", debugstr_guid(riid));
+    *obj = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI video_processor_AddRef(IMFTransform *iface)
+{
+    struct video_processor *transform = impl_video_processor_from_IMFTransform(iface);
+    ULONG refcount = InterlockedIncrement(&transform->refcount);
+
+    TRACE("%p, refcount %u.\n", iface, refcount);
+
+    return refcount;
+}
+
+static ULONG WINAPI video_processor_Release(IMFTransform *iface)
+{
+    struct video_processor *transform = impl_video_processor_from_IMFTransform(iface);
+    ULONG refcount = InterlockedDecrement(&transform->refcount);
+
+    TRACE("%p, refcount %u.\n", iface, refcount);
+
+    if (!refcount)
+    {
+        if (transform->attributes)
+            IMFAttributes_Release(transform->attributes);
+        if (transform->output_attributes)
+            IMFAttributes_Release(transform->output_attributes);
+        free(transform);
+    }
+
+    return refcount;
+}
+
+static HRESULT WINAPI video_processor_GetStreamLimits(IMFTransform *iface, DWORD *input_minimum, DWORD *input_maximum,
+        DWORD *output_minimum, DWORD *output_maximum)
+{
+    TRACE("%p, %p, %p, %p, %p.\n", iface, input_minimum, input_maximum, output_minimum, output_maximum);
+
+    *input_minimum = *input_maximum = *output_minimum = *output_maximum = 1;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI video_processor_GetStreamCount(IMFTransform *iface, DWORD *inputs, DWORD *outputs)
+{
+    TRACE("%p, %p, %p.\n", iface, inputs, outputs);
+
+    *inputs = *outputs = 1;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI video_processor_GetStreamIDs(IMFTransform *iface, DWORD input_size, DWORD *inputs,
+        DWORD output_size, DWORD *outputs)
+{
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_processor_GetInputStreamInfo(IMFTransform *iface, DWORD id, MFT_INPUT_STREAM_INFO *info)
+{
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_processor_GetOutputStreamInfo(IMFTransform *iface, DWORD id, MFT_OUTPUT_STREAM_INFO *info)
+{
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_processor_GetAttributes(IMFTransform *iface, IMFAttributes **attributes)
+{
+    struct video_processor *transform = impl_video_processor_from_IMFTransform(iface);
+
+    TRACE("%p, %p.\n", iface, attributes);
+
+    *attributes = transform->attributes;
+    IMFAttributes_AddRef(*attributes);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI video_processor_GetInputStreamAttributes(IMFTransform *iface, DWORD id,
+        IMFAttributes **attributes)
+{
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_processor_GetOutputStreamAttributes(IMFTransform *iface, DWORD id,
+        IMFAttributes **attributes)
+{
+    struct video_processor *transform = impl_video_processor_from_IMFTransform(iface);
+
+    TRACE("%p, %u, %p.\n", iface, id, attributes);
+
+    *attributes = transform->output_attributes;
+    IMFAttributes_AddRef(*attributes);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI video_processor_DeleteInputStream(IMFTransform *iface, DWORD id)
+{
+    TRACE("%p, %u.\n", iface, id);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_processor_AddInputStreams(IMFTransform *iface, DWORD streams, DWORD *ids)
+{
+    TRACE("%p, %u, %p.\n", iface, streams, ids);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_processor_GetInputAvailableType(IMFTransform *iface, DWORD id, DWORD index,
+        IMFMediaType **type)
+{
+    FIXME("%p, %u, %u, %p.\n", iface, id, index, type);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_processor_GetOutputAvailableType(IMFTransform *iface, DWORD id, DWORD index,
+        IMFMediaType **type)
+{
+    FIXME("%p, %u, %u, %p.\n", iface, id, index, type);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_processor_SetInputType(IMFTransform *iface, DWORD id, IMFMediaType *type, DWORD flags)
+{
+    FIXME("%p, %u, %p, %#x.\n", iface, id, type, flags);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_processor_SetOutputType(IMFTransform *iface, DWORD id, IMFMediaType *type, DWORD flags)
+{
+    FIXME("%p, %u, %p, %#x.\n", iface, id, type, flags);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_processor_GetInputCurrentType(IMFTransform *iface, DWORD id, IMFMediaType **type)
+{
+    FIXME("%p, %u, %p.\n", iface, id, type);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_processor_GetOutputCurrentType(IMFTransform *iface, DWORD id, IMFMediaType **type)
+{
+    FIXME("%p, %u, %p.\n", iface, id, type);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_processor_GetInputStatus(IMFTransform *iface, DWORD id, DWORD *flags)
+{
+    FIXME("%p, %u, %p.\n", iface, id, flags);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_processor_GetOutputStatus(IMFTransform *iface, DWORD *flags)
+{
+    FIXME("%p, %p.\n", iface, flags);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_processor_SetOutputBounds(IMFTransform *iface, LONGLONG lower, LONGLONG upper)
+{
+    FIXME("%p, %s, %s.\n", iface, wine_dbgstr_longlong(lower), wine_dbgstr_longlong(upper));
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_processor_ProcessEvent(IMFTransform *iface, DWORD id, IMFMediaEvent *event)
+{
+    TRACE("%p, %u, %p.\n", iface, id, event);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_processor_ProcessMessage(IMFTransform *iface, MFT_MESSAGE_TYPE message, ULONG_PTR param)
+{
+    FIXME("%p, %u.\n", iface, message);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_processor_ProcessInput(IMFTransform *iface, DWORD id, IMFSample *sample, DWORD flags)
+{
+    FIXME("%p, %u, %p, %#x.\n", iface, id, sample, flags);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI video_processor_ProcessOutput(IMFTransform *iface, DWORD flags, DWORD count,
+        MFT_OUTPUT_DATA_BUFFER *samples, DWORD *status)
+{
+    FIXME("%p, %#x, %u, %p, %p.\n", iface, flags, count, samples, status);
+
+    return E_NOTIMPL;
+}
+
+static const IMFTransformVtbl video_processor_vtbl =
+{
+    video_processor_QueryInterface,
+    video_processor_AddRef,
+    video_processor_Release,
+    video_processor_GetStreamLimits,
+    video_processor_GetStreamCount,
+    video_processor_GetStreamIDs,
+    video_processor_GetInputStreamInfo,
+    video_processor_GetOutputStreamInfo,
+    video_processor_GetAttributes,
+    video_processor_GetInputStreamAttributes,
+    video_processor_GetOutputStreamAttributes,
+    video_processor_DeleteInputStream,
+    video_processor_AddInputStreams,
+    video_processor_GetInputAvailableType,
+    video_processor_GetOutputAvailableType,
+    video_processor_SetInputType,
+    video_processor_SetOutputType,
+    video_processor_GetInputCurrentType,
+    video_processor_GetOutputCurrentType,
+    video_processor_GetInputStatus,
+    video_processor_GetOutputStatus,
+    video_processor_SetOutputBounds,
+    video_processor_ProcessEvent,
+    video_processor_ProcessMessage,
+    video_processor_ProcessInput,
+    video_processor_ProcessOutput,
+};
+
+struct class_factory
+{
+    IClassFactory IClassFactory_iface;
+    LONG refcount;
+    HRESULT (*create_instance)(REFIID riid, void **obj);
+};
+
+static struct class_factory *impl_from_IClassFactory(IClassFactory *iface)
+{
+    return CONTAINING_RECORD(iface, struct class_factory, IClassFactory_iface);
+}
+
+static HRESULT WINAPI class_factory_QueryInterface(IClassFactory *iface, REFIID riid, void **obj)
+{
+    TRACE("%p, %s, %p.\n", iface, debugstr_guid(riid), obj);
+
+    if (IsEqualGUID(riid, &IID_IClassFactory) ||
+            IsEqualGUID(riid, &IID_IUnknown))
+    {
+        *obj = iface;
+        IClassFactory_AddRef(iface);
+        return S_OK;
+    }
+
+    WARN("%s is not supported.\n", debugstr_guid(riid));
+    *obj = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI class_factory_AddRef(IClassFactory *iface)
+{
+    struct class_factory *factory = impl_from_IClassFactory(iface);
+    return InterlockedIncrement(&factory->refcount);
+}
+
+static ULONG WINAPI class_factory_Release(IClassFactory *iface)
+{
+    struct class_factory *factory = impl_from_IClassFactory(iface);
+    ULONG refcount = InterlockedDecrement(&factory->refcount);
+
+    if (!refcount)
+        free(factory);
+
+    return refcount;
+}
+
+static HRESULT WINAPI class_factory_CreateInstance(IClassFactory *iface, IUnknown *outer, REFIID riid, void **obj)
+{
+    struct class_factory *factory = impl_from_IClassFactory(iface);
+
+    TRACE("%p, %p, %s, %p.\n", iface, outer, debugstr_guid(riid), obj);
+
+    if (outer)
+    {
+        *obj = NULL;
+        return CLASS_E_NOAGGREGATION;
+    }
+
+    return factory->create_instance(riid, obj);
+}
+
+static HRESULT WINAPI class_factory_LockServer(IClassFactory *iface, BOOL dolock)
+{
+    TRACE("%p, %d.\n", iface, dolock);
+    return S_OK;
+}
+
+static const IClassFactoryVtbl class_factory_vtbl =
+{
+    class_factory_QueryInterface,
+    class_factory_AddRef,
+    class_factory_Release,
+    class_factory_CreateInstance,
+    class_factory_LockServer,
+};
+
+static HRESULT video_processor_create(REFIID riid, void **ret)
+{
+    struct video_processor *object;
+    HRESULT hr;
+
+    if (!(object = calloc(1, sizeof(*object))))
+        return E_OUTOFMEMORY;
+
+    object->IMFTransform_iface.lpVtbl = &video_processor_vtbl;
+    object->refcount = 1;
+
+    if (FAILED(hr = MFCreateAttributes(&object->attributes, 0)))
+        goto failed;
+
+    if (FAILED(hr = MFCreateAttributes(&object->output_attributes, 0)))
+        goto failed;
+
+    *ret = &object->IMFTransform_iface;
+    return S_OK;
+
+failed:
+
+    IMFTransform_Release(&object->IMFTransform_iface);
+    return hr;
+}
+
+static const GUID CLSID_GStreamerByteStreamHandler = {0x317df618, 0x5e5a, 0x468a, {0x9f, 0x15, 0xd8, 0x27, 0xa9, 0xa0, 0x81, 0x62}};
+
+static const GUID CLSID_WINEAudioConverter = {0x6a170414,0xaad9,0x4693,{0xb8,0x06,0x3a,0x0c,0x47,0xc5,0x70,0xd6}};
+
+static const struct class_object
+{
+    const GUID *clsid;
+    HRESULT (*create_instance)(REFIID riid, void **obj);
+}
+class_objects[] =
+{
+    { &CLSID_VideoProcessorMFT, &video_processor_create },
+    { &CLSID_GStreamerByteStreamHandler, &winegstreamer_stream_handler_create },
+    { &CLSID_WINEAudioConverter, &audio_converter_create },
+    { &CLSID_CColorConvertDMO, &color_converter_create },
+    { &CLSID_MSH264DecoderMFT, &h264_decoder_create },
+    { &CLSID_MSAACDecMFT, &aac_decoder_create },
+};
+
+HRESULT mfplat_get_class_object(REFCLSID rclsid, REFIID riid, void **obj)
+{
+    struct class_factory *factory;
+    unsigned int i;
+    HRESULT hr;
+
+    for (i = 0; i < ARRAY_SIZE(class_objects); ++i)
+    {
+        if (IsEqualGUID(class_objects[i].clsid, rclsid))
+        {
+            if (!(factory = malloc(sizeof(*factory))))
+                return E_OUTOFMEMORY;
+
+            factory->IClassFactory_iface.lpVtbl = &class_factory_vtbl;
+            factory->refcount = 1;
+            factory->create_instance = class_objects[i].create_instance;
+
+            hr = IClassFactory_QueryInterface(&factory->IClassFactory_iface, riid, obj);
+            IClassFactory_Release(&factory->IClassFactory_iface);
+            return hr;
+        }
+    }
+
+    return CLASS_E_CLASSNOTAVAILABLE;
+}
+
+static WCHAR audio_converterW[] = L"Audio Converter";
+static const GUID *audio_converter_supported_types[] =
+{
+    &MFAudioFormat_PCM,
+    &MFAudioFormat_Float,
+};
+
+static WCHAR wma_decoderW[] = L"WMAudio Decoder MFT";
+static const GUID *wma_decoder_input_types[] =
+{
+    &MEDIASUBTYPE_MSAUDIO1,
+    &MFAudioFormat_WMAudioV8,
+    &MFAudioFormat_WMAudioV9,
+    &MFAudioFormat_WMAudio_Lossless,
+};
+static const GUID *wma_decoder_output_types[] =
+{
+    &MFAudioFormat_PCM,
+    &MFAudioFormat_Float,
+};
+
+static WCHAR video_processorW[] = L"Video Processor MFT";
+static const GUID *video_processor_supported_types[] =
+{
+    &MFVideoFormat_IYUV,
+};
+
+static WCHAR color_converterW[] = L"Color Converter";
+static const GUID *color_converter_supported_types[] =
+{
+    &MFVideoFormat_RGB24,
+    &MFVideoFormat_RGB32,
+    &MFVideoFormat_RGB555,
+    &MFVideoFormat_RGB8,
+    &MFVideoFormat_AYUV,
+    &MFVideoFormat_I420,
+    &MFVideoFormat_IYUV,
+    &MFVideoFormat_NV11,
+    &MFVideoFormat_NV12,
+    &MFVideoFormat_UYVY,
+    &MFVideoFormat_v216,
+    &MFVideoFormat_v410,
+    &MFVideoFormat_YUY2,
+    &MFVideoFormat_YVYU,
+    &MFVideoFormat_YVYU,
+};
+
+static WCHAR h264_decoderW[] = L"H.264 Decoder";
+static const GUID *h264_decoder_input_types[] =
+{
+    &MFVideoFormat_H264,
+};
+static const GUID *h264_decoder_output_types[] =
+{
+    &MFVideoFormat_NV12,
+    &MFVideoFormat_I420,
+    &MFVideoFormat_IYUV,
+    &MFVideoFormat_YUY2,
+    &MFVideoFormat_YV12,
+};
+
+static WCHAR aac_decoderW[] = L"AAC Decoder";
+static const GUID *aac_decoder_input_types[] =
+{
+    &MFAudioFormat_AAC,
+};
+static const GUID *aac_decoder_output_types[] =
+{
+    &MFAudioFormat_Float,
+    &MFAudioFormat_PCM,
+};
+
+static const struct mft
+{
+    const GUID *clsid;
+    const GUID *category;
+    LPWSTR name;
+    const UINT32 flags;
+    const GUID *major_type;
+    const UINT32 input_types_count;
+    const GUID **input_types;
+    const UINT32 output_types_count;
+    const GUID **output_types;
+}
+mfts[] =
+{
+    {
+        &CLSID_WINEAudioConverter,
+        &MFT_CATEGORY_AUDIO_EFFECT,
+        audio_converterW,
+        MFT_ENUM_FLAG_SYNCMFT,
+        &MFMediaType_Audio,
+        ARRAY_SIZE(audio_converter_supported_types),
+        audio_converter_supported_types,
+        ARRAY_SIZE(audio_converter_supported_types),
+        audio_converter_supported_types,
+    },
+    {
+        &CLSID_WMADecMediaObject,
+        &MFT_CATEGORY_AUDIO_DECODER,
+        wma_decoderW,
+        MFT_ENUM_FLAG_SYNCMFT,
+        &MFMediaType_Audio,
+        ARRAY_SIZE(wma_decoder_input_types),
+        wma_decoder_input_types,
+        ARRAY_SIZE(wma_decoder_output_types),
+        wma_decoder_output_types,
+    },
+    {
+        &CLSID_VideoProcessorMFT,
+        &MFT_CATEGORY_VIDEO_PROCESSOR,
+        video_processorW,
+        0,
+        &MFMediaType_Video,
+        ARRAY_SIZE(video_processor_supported_types),
+        video_processor_supported_types,
+        ARRAY_SIZE(video_processor_supported_types),
+        video_processor_supported_types,
+    },
+    {
+        &CLSID_CColorConvertDMO,
+        &MFT_CATEGORY_VIDEO_EFFECT,
+        color_converterW,
+        MFT_ENUM_FLAG_SYNCMFT,
+        &MFMediaType_Video,
+        ARRAY_SIZE(color_converter_supported_types),
+        color_converter_supported_types,
+        ARRAY_SIZE(color_converter_supported_types),
+        color_converter_supported_types,
+    },
+    {
+        &CLSID_MSH264DecoderMFT,
+        &MFT_CATEGORY_VIDEO_DECODER,
+        h264_decoderW,
+        MFT_ENUM_FLAG_SYNCMFT,
+        &MFMediaType_Video,
+        ARRAY_SIZE(h264_decoder_input_types),
+        h264_decoder_input_types,
+        ARRAY_SIZE(h264_decoder_output_types),
+        h264_decoder_output_types,
+    },
+    {
+        &CLSID_MSAACDecMFT,
+        &MFT_CATEGORY_AUDIO_DECODER,
+        aac_decoderW,
+        MFT_ENUM_FLAG_SYNCMFT,
+        &MFMediaType_Audio,
+        ARRAY_SIZE(aac_decoder_input_types),
+        aac_decoder_input_types,
+        ARRAY_SIZE(aac_decoder_output_types),
+        aac_decoder_output_types,
+    },
+};
+
+HRESULT mfplat_DllRegisterServer(void)
+{
+    unsigned int i, j;
+    HRESULT hr;
+    MFT_REGISTER_TYPE_INFO input_types[15], output_types[15];
+
+    for (i = 0; i < ARRAY_SIZE(mfts); i++)
+    {
+        const struct mft *cur = &mfts[i];
+
+        for (j = 0; j < cur->input_types_count; j++)
+        {
+            input_types[j].guidMajorType = *(cur->major_type);
+            input_types[j].guidSubtype = *(cur->input_types[j]);
+        }
+        for (j = 0; j < cur->output_types_count; j++)
+        {
+            output_types[j].guidMajorType = *(cur->major_type);
+            output_types[j].guidSubtype = *(cur->output_types[j]);
+        }
+
+        hr = MFTRegister(*(cur->clsid), *(cur->category), cur->name, cur->flags, cur->input_types_count,
+                    input_types, cur->output_types_count, output_types, NULL);
+
+        if (FAILED(hr))
+        {
+            FIXME("Failed to register MFT, hr %#x\n", hr);
+            return hr;
+        }
+    }
+    return S_OK;
+}
+
+static const struct
+{
+    const GUID *subtype;
+    enum wg_video_format format;
+}
+video_formats[] =
+{
+    {&MFVideoFormat_ARGB32, WG_VIDEO_FORMAT_BGRA},
+    {&MFVideoFormat_RGB32,  WG_VIDEO_FORMAT_BGRx},
+    {&MFVideoFormat_RGB24,  WG_VIDEO_FORMAT_BGR},
+    {&MFVideoFormat_RGB555, WG_VIDEO_FORMAT_RGB15},
+    {&MFVideoFormat_RGB565, WG_VIDEO_FORMAT_RGB16},
+    {&MFVideoFormat_AYUV,   WG_VIDEO_FORMAT_AYUV},
+    {&MFVideoFormat_I420,   WG_VIDEO_FORMAT_I420},
+    {&MFVideoFormat_IYUV,   WG_VIDEO_FORMAT_I420},
+    {&MFVideoFormat_NV12,   WG_VIDEO_FORMAT_NV12},
+    {&MFVideoFormat_UYVY,   WG_VIDEO_FORMAT_UYVY},
+    {&MFVideoFormat_YUY2,   WG_VIDEO_FORMAT_YUY2},
+    {&MFVideoFormat_YV12,   WG_VIDEO_FORMAT_YV12},
+    {&MFVideoFormat_YVYU,   WG_VIDEO_FORMAT_YVYU},
+};
+
+static const struct
+{
+    const GUID *subtype;
+    UINT32 depth;
+    enum wg_audio_format format;
+}
+audio_formats[] =
+{
+    {&MFAudioFormat_PCM,     8, WG_AUDIO_FORMAT_U8},
+    {&MFAudioFormat_PCM,    16, WG_AUDIO_FORMAT_S16LE},
+    {&MFAudioFormat_PCM,    24, WG_AUDIO_FORMAT_S24LE},
+    {&MFAudioFormat_PCM,    32, WG_AUDIO_FORMAT_S32LE},
+    {&MFAudioFormat_Float,  32, WG_AUDIO_FORMAT_F32LE},
+    {&MFAudioFormat_Float,  64, WG_AUDIO_FORMAT_F64LE},
+};
+
+static inline UINT64 make_uint64(UINT32 high, UINT32 low)
+{
+    return ((UINT64)high << 32) | low;
+}
+
+static IMFMediaType *mf_media_type_from_wg_format_audio(const struct wg_format *format)
+{
+    IMFMediaType *type;
+    unsigned int i;
+
+    for (i = 0; i < ARRAY_SIZE(audio_formats); ++i)
+    {
+        if (format->u.audio.format == audio_formats[i].format)
+        {
+            if (FAILED(MFCreateMediaType(&type)))
+                return NULL;
+
+            IMFMediaType_SetGUID(type, &MF_MT_MAJOR_TYPE, &MFMediaType_Audio);
+            IMFMediaType_SetGUID(type, &MF_MT_SUBTYPE, audio_formats[i].subtype);
+            IMFMediaType_SetUINT32(type, &MF_MT_AUDIO_BITS_PER_SAMPLE, audio_formats[i].depth);
+            IMFMediaType_SetUINT32(type, &MF_MT_AUDIO_SAMPLES_PER_SECOND, format->u.audio.rate);
+            IMFMediaType_SetUINT32(type, &MF_MT_AUDIO_NUM_CHANNELS, format->u.audio.channels);
+            if (format->u.audio.channel_mask)
+                IMFMediaType_SetUINT32(type, &MF_MT_AUDIO_CHANNEL_MASK, format->u.audio.channel_mask);
+            IMFMediaType_SetUINT32(type, &MF_MT_ALL_SAMPLES_INDEPENDENT, TRUE);
+            IMFMediaType_SetUINT32(type, &MF_MT_AUDIO_BLOCK_ALIGNMENT, format->u.audio.channels * audio_formats[i].depth / 8);
+
+            return type;
+        }
+    }
+
+    return NULL;
+}
+
+static IMFMediaType *mf_media_type_from_wg_format_video(const struct wg_format *format)
+{
+    IMFMediaType *type;
+    unsigned int i;
+
+    for (i = 0; i < ARRAY_SIZE(video_formats); ++i)
+    {
+        if (format->u.video.format == video_formats[i].format)
+        {
+            if (FAILED(MFCreateMediaType(&type)))
+                return NULL;
+
+            IMFMediaType_SetGUID(type, &MF_MT_MAJOR_TYPE, &MFMediaType_Video);
+            IMFMediaType_SetGUID(type, &MF_MT_SUBTYPE, video_formats[i].subtype);
+            IMFMediaType_SetUINT64(type, &MF_MT_FRAME_SIZE,
+                    make_uint64(format->u.video.width, format->u.video.height));
+            IMFMediaType_SetUINT64(type, &MF_MT_FRAME_RATE,
+                    make_uint64(format->u.video.fps_n, format->u.video.fps_d));
+            IMFMediaType_SetUINT32(type, &MF_MT_COMPRESSED, FALSE);
+            IMFMediaType_SetUINT32(type, &MF_MT_ALL_SAMPLES_INDEPENDENT, TRUE);
+            IMFMediaType_SetUINT32(type, &MF_MT_VIDEO_ROTATION, MFVideoRotationFormat_0);
+
+            return type;
+        }
+    }
+
+    return NULL;
+}
+
+IMFMediaType *mf_media_type_from_wg_format(const struct wg_format *format)
+{
+    switch (format->major_type)
+    {
+        case WG_MAJOR_TYPE_UNKNOWN:
+            return NULL;
+
+        case WG_MAJOR_TYPE_AUDIO:
+            return mf_media_type_from_wg_format_audio(format);
+
+        case WG_MAJOR_TYPE_VIDEO:
+            return mf_media_type_from_wg_format_video(format);
+    }
+
+    assert(0);
+    return NULL;
+}
+
+static void mf_media_type_to_wg_format_audio(IMFMediaType *type, struct wg_format *format)
+{
+    UINT32 rate, channels, channel_mask, depth;
+    unsigned int i;
+    GUID subtype;
+
+    if (FAILED(IMFMediaType_GetGUID(type, &MF_MT_SUBTYPE, &subtype)))
+    {
+        FIXME("Subtype is not set.\n");
+        return;
+    }
+    if (FAILED(IMFMediaType_GetUINT32(type, &MF_MT_AUDIO_SAMPLES_PER_SECOND, &rate)))
+    {
+        FIXME("Sample rate is not set.\n");
+        return;
+    }
+    if (FAILED(IMFMediaType_GetUINT32(type, &MF_MT_AUDIO_NUM_CHANNELS, &channels)))
+    {
+        FIXME("Channel count is not set.\n");
+        return;
+    }
+    if (FAILED(IMFMediaType_GetUINT32(type, &MF_MT_AUDIO_BITS_PER_SAMPLE, &depth)))
+    {
+        FIXME("Depth is not set.\n");
+        return;
+    }
+    if (FAILED(IMFMediaType_GetUINT32(type, &MF_MT_AUDIO_CHANNEL_MASK, &channel_mask)))
+    {
+        if (channels == 1)
+            channel_mask = KSAUDIO_SPEAKER_MONO;
+        else if (channels == 2)
+            channel_mask = KSAUDIO_SPEAKER_STEREO;
+        else if IsEqualGUID(&subtype, &MFAudioFormat_AAC)
+            channel_mask = 0;
+        else
+        {
+            FIXME("Channel mask is not set.\n");
+            return;
+        }
+    }
+
+    format->major_type = WG_MAJOR_TYPE_AUDIO;
+    format->u.audio.channels = channels;
+    format->u.audio.channel_mask = channel_mask;
+    format->u.audio.rate = rate;
+
+    for (i = 0; i < ARRAY_SIZE(audio_formats); ++i)
+    {
+        if (IsEqualGUID(&subtype, audio_formats[i].subtype) && depth == audio_formats[i].depth)
+        {
+            format->u.audio.format = audio_formats[i].format;
+            return;
+        }
+    }
+    FIXME("Unrecognized audio subtype %s, depth %u.\n", debugstr_guid(&subtype), depth);
+}
+
+static void mf_media_type_to_wg_format_video(IMFMediaType *type, struct wg_format *format)
+{
+    UINT64 frame_rate, frame_size;
+    unsigned int i;
+    GUID subtype;
+
+    if (FAILED(IMFMediaType_GetGUID(type, &MF_MT_SUBTYPE, &subtype)))
+    {
+        FIXME("Subtype is not set.\n");
+        return;
+    }
+    if (FAILED(IMFMediaType_GetUINT64(type, &MF_MT_FRAME_SIZE, &frame_size)))
+    {
+        FIXME("Frame size is not set.\n");
+        return;
+    }
+
+    format->major_type = WG_MAJOR_TYPE_VIDEO;
+    format->u.video.width = (UINT32)(frame_size >> 32);
+    format->u.video.height = (UINT32)frame_size;
+    format->u.video.fps_n = 1;
+    format->u.video.fps_d = 1;
+
+    if (SUCCEEDED(IMFMediaType_GetUINT64(type, &MF_MT_FRAME_RATE, &frame_rate)) && (UINT32)frame_rate)
+    {
+        format->u.video.fps_n = (UINT32)(frame_rate >> 32);
+        format->u.video.fps_d = (UINT32)frame_rate;
+    }
+
+    for (i = 0; i < ARRAY_SIZE(video_formats); ++i)
+    {
+        if (IsEqualGUID(&subtype, video_formats[i].subtype))
+        {
+            format->u.video.format = video_formats[i].format;
+            break;
+        }
+    }
+    if (i == ARRAY_SIZE(video_formats))
+        FIXME("Unrecognized video subtype %s.\n", debugstr_guid(&subtype));
+}
+
+void mf_media_type_to_wg_format(IMFMediaType *type, struct wg_format *format)
+{
+    GUID major_type;
+
+    memset(format, 0, sizeof(*format));
+
+    if (FAILED(IMFMediaType_GetMajorType(type, &major_type)))
+    {
+        FIXME("Major type is not set.\n");
+        return;
+    }
+
+    if (IsEqualGUID(&major_type, &MFMediaType_Audio))
+        mf_media_type_to_wg_format_audio(type, format);
+    else if (IsEqualGUID(&major_type, &MFMediaType_Video))
+        mf_media_type_to_wg_format_video(type, format);
+    else
+        FIXME("Unrecognized major type %s.\n", debugstr_guid(&major_type));
+}
+
+static void mf_media_type_to_wg_encoded_format_xwma(IMFMediaType *type, struct wg_encoded_format *format,
+        enum wg_encoded_type encoded_type, UINT32 version)
+{
+    UINT32 rate, depth, channels, block_align, bytes_per_second, codec_data_len;
+    BYTE codec_data[64];
+
+    if (FAILED(IMFMediaType_GetUINT32(type, &MF_MT_AUDIO_SAMPLES_PER_SECOND, &rate)))
+    {
+        FIXME("Sample rate is not set.\n");
+        return;
+    }
+    if (FAILED(IMFMediaType_GetUINT32(type, &MF_MT_AUDIO_NUM_CHANNELS, &channels)))
+    {
+        FIXME("Channel count is not set.\n");
+        return;
+    }
+    if (FAILED(IMFMediaType_GetUINT32(type, &MF_MT_AUDIO_AVG_BYTES_PER_SECOND, &bytes_per_second)))
+    {
+        FIXME("Bitrate is not set.\n");
+        return;
+    }
+    if (FAILED(IMFMediaType_GetUINT32(type, &MF_MT_AUDIO_BLOCK_ALIGNMENT, &block_align)))
+    {
+        FIXME("Block alignment is not set.\n");
+        return;
+    }
+    if (FAILED(IMFMediaType_GetUINT32(type, &MF_MT_AUDIO_BITS_PER_SAMPLE, &depth)))
+    {
+        FIXME("Depth is not set.\n");
+        return;
+    }
+    if (FAILED(IMFMediaType_GetBlob(type, &MF_MT_USER_DATA, codec_data, sizeof(codec_data), &codec_data_len)))
+    {
+        FIXME("Codec data is not set.\n");
+        return;
+    }
+
+    format->encoded_type = encoded_type;
+    format->u.xwma.version = version;
+    format->u.xwma.bitrate = bytes_per_second * 8;
+    format->u.xwma.rate = rate;
+    format->u.xwma.depth = depth;
+    format->u.xwma.channels = channels;
+    format->u.xwma.block_align = block_align;
+    format->u.xwma.codec_data_len = codec_data_len;
+    memcpy(format->u.xwma.codec_data, codec_data, codec_data_len);
+}
+
+static void mf_media_type_to_wg_encoded_format_aac(IMFMediaType *type, struct wg_encoded_format *format)
+{
+    UINT32 codec_data_len, payload_type, profile_level_indication;
+    BYTE codec_data[64];
+
+    /* Audio specific config is stored at after HEAACWAVEINFO in MF_MT_USER_DATA
+     * https://docs.microsoft.com/en-us/windows/win32/api/mmreg/ns-mmreg-heaacwaveformat
+     */
+    struct
+    {
+        WORD payload_type;
+        WORD profile_level_indication;
+        WORD type;
+        WORD reserved1;
+        DWORD reserved2;
+    } *aac_info = (void *)codec_data;
+
+    if (FAILED(IMFMediaType_GetBlob(type, &MF_MT_USER_DATA, codec_data, sizeof(codec_data), &codec_data_len)))
+    {
+        FIXME("Codec data is not set.\n");
+        return;
+    }
+    if (FAILED(IMFMediaType_GetUINT32(type, &MF_MT_AAC_PAYLOAD_TYPE, &payload_type)))
+    {
+        FIXME("AAC payload type is not set.\n");
+        payload_type = aac_info->payload_type;
+    }
+    if (FAILED(IMFMediaType_GetUINT32(type, &MF_MT_AAC_AUDIO_PROFILE_LEVEL_INDICATION, &profile_level_indication)))
+    {
+        FIXME("AAC provile level indication is not set.\n");
+        profile_level_indication = aac_info->profile_level_indication;
+    }
+
+    format->encoded_type = WG_ENCODED_TYPE_AAC;
+    format->u.aac.payload_type = payload_type;
+    format->u.aac.profile_level_indication = profile_level_indication;
+    format->u.aac.codec_data_len = 0;
+
+    if (codec_data_len > sizeof(*aac_info))
+    {
+        format->u.aac.codec_data_len = codec_data_len - sizeof(*aac_info);
+        memcpy(format->u.aac.codec_data, codec_data + sizeof(*aac_info), codec_data_len - sizeof(*aac_info));
+    }
+}
+
+static void mf_media_type_to_wg_encoded_format_h264(IMFMediaType *type, struct wg_encoded_format *format)
+{
+    UINT64 frame_rate, frame_size;
+    UINT32 profile, level;
+
+    format->encoded_type = WG_ENCODED_TYPE_H264;
+    format->u.h264.width = 0;
+    format->u.h264.height = 0;
+    format->u.h264.fps_n = 1;
+    format->u.h264.fps_d = 1;
+
+    if (SUCCEEDED(IMFMediaType_GetUINT64(type, &MF_MT_FRAME_SIZE, &frame_size)))
+    {
+        format->u.h264.width = (UINT32)(frame_size >> 32);
+        format->u.h264.height = (UINT32)frame_size;
+    }
+
+    if (SUCCEEDED(IMFMediaType_GetUINT64(type, &MF_MT_FRAME_RATE, &frame_rate)) && (UINT32)frame_rate)
+    {
+        format->u.h264.fps_n = (UINT32)(frame_rate >> 32);
+        format->u.h264.fps_d = (UINT32)frame_rate;
+    }
+
+    if (SUCCEEDED(IMFMediaType_GetUINT32(type, &MF_MT_MPEG2_PROFILE, &profile)))
+        format->u.h264.profile = profile;
+
+    if (SUCCEEDED(IMFMediaType_GetUINT32(type, &MF_MT_MPEG2_LEVEL, &level)))
+        format->u.h264.level = level;
+}
+
+void mf_media_type_to_wg_encoded_format(IMFMediaType *type, struct wg_encoded_format *format)
+{
+    GUID major_type, subtype;
+
+    memset(format, 0, sizeof(*format));
+
+    if (FAILED(IMFMediaType_GetMajorType(type, &major_type)))
+    {
+        FIXME("Major type is not set.\n");
+        return;
+    }
+    if (FAILED(IMFMediaType_GetGUID(type, &MF_MT_SUBTYPE, &subtype)))
+    {
+        FIXME("Subtype is not set.\n");
+        return;
+    }
+
+    if (IsEqualGUID(&major_type, &MFMediaType_Audio))
+    {
+        if (IsEqualGUID(&subtype, &MEDIASUBTYPE_MSAUDIO1))
+            mf_media_type_to_wg_encoded_format_xwma(type, format, WG_ENCODED_TYPE_WMA, 1);
+        else if (IsEqualGUID(&subtype, &MFAudioFormat_WMAudioV8))
+            mf_media_type_to_wg_encoded_format_xwma(type, format, WG_ENCODED_TYPE_WMA, 2);
+        else if (IsEqualGUID(&subtype, &MFAudioFormat_WMAudioV9))
+            mf_media_type_to_wg_encoded_format_xwma(type, format, WG_ENCODED_TYPE_WMA, 3);
+        else if (IsEqualGUID(&subtype, &MFAudioFormat_WMAudio_Lossless))
+            mf_media_type_to_wg_encoded_format_xwma(type, format, WG_ENCODED_TYPE_WMA, 4);
+        else if (IsEqualGUID(&subtype, &MFAudioFormat_XMAudio2))
+            mf_media_type_to_wg_encoded_format_xwma(type, format, WG_ENCODED_TYPE_XMA, 2);
+        else if (IsEqualGUID(&subtype, &MFAudioFormat_AAC))
+            mf_media_type_to_wg_encoded_format_aac(type, format);
+        else
+            FIXME("Unimplemented audio subtype %s.\n", debugstr_guid(&subtype));
+    }
+    else if (IsEqualGUID(&major_type, &MFMediaType_Video))
+    {
+        if (IsEqualGUID(&subtype, &MFVideoFormat_H264))
+            mf_media_type_to_wg_encoded_format_h264(type, format);
+        else
+            FIXME("Unimplemented audio subtype %s.\n", debugstr_guid(&subtype));
+    }
+    else
+    {
+        FIXME("Unimplemented major type %s.\n", debugstr_guid(&major_type));
+    }
+}
diff --git a/dlls/mfplat/mfplat.spec b/dlls/mfplat/mfplat.spec
index 31c80f596c2..44d98a957e2 100644
--- wine/dlls/mfplat/mfplat.spec
+++ wine/dlls/mfplat/mfplat.spec
@@ -20,7 +20,7 @@
 @ stdcall MFAllocateWorkQueue(ptr)
 @ stdcall MFAllocateWorkQueueEx(long ptr) rtworkq.RtwqAllocateWorkQueue
 @ stub MFAppendCollection
-@ stdcall MFAverageTimePerFrameToFrameRate(int64 ptr ptr)
+@ stub MFAverageTimePerFrameToFrameRate
 @ stdcall MFBeginCreateFile(long long long wstr ptr ptr ptr)
 @ stub MFBeginGetHostByName
 @ stdcall MFBeginRegisterWorkQueueWithMMCSS(long wstr long ptr ptr)
@@ -71,7 +71,7 @@
 @ stdcall MFCreateStreamDescriptor(long long ptr ptr)
 @ stdcall MFCreateSystemTimeSource(ptr)
 @ stub MFCreateSystemUnderlyingClock
-@ stdcall MFCreateTempFile(long long long ptr)
+@ stub MFCreateTempFile
 @ stdcall MFCreateTrackedSample(ptr)
 @ stdcall MFCreateTransformActivate(ptr)
 @ stub MFCreateURLFromPath
@@ -162,7 +162,7 @@
 @ stdcall MFTEnumEx(int128 long ptr ptr ptr ptr)
 @ stdcall MFTGetInfo(int128 ptr ptr ptr ptr ptr ptr)
 @ stdcall MFTRegister(int128 int128 wstr long long ptr long ptr ptr)
-@ stdcall MFTRegisterLocal(ptr ptr wstr long long ptr long ptr)
+@ stdcall MFTRegisterLocal(ptr ptr wstr long long  ptr long ptr)
 @ stdcall MFTRegisterLocalByCLSID(ptr ptr wstr long long ptr long ptr)
 @ stdcall MFTUnregister(int128)
 @ stdcall MFTUnregisterLocal(ptr)
diff --git a/dlls/mfplat/mfplat_private.h b/dlls/mfplat/mfplat_private.h
index 8418c8eb2ef..b646d9e7cbb 100644
--- wine/dlls/mfplat/mfplat_private.h
+++ wine/dlls/mfplat/mfplat_private.h
@@ -128,13 +128,11 @@ static inline const char *debugstr_propvar(const PROPVARIANT *v)
         case VT_NULL:
             return wine_dbg_sprintf("%p {VT_NULL}", v);
         case VT_UI4:
-            return wine_dbg_sprintf("%p {VT_UI4: %ld}", v, v->ulVal);
+            return wine_dbg_sprintf("%p {VT_UI4: %d}", v, v->ulVal);
         case VT_UI8:
             return wine_dbg_sprintf("%p {VT_UI8: %s}", v, wine_dbgstr_longlong(v->uhVal.QuadPart));
         case VT_I8:
             return wine_dbg_sprintf("%p {VT_I8: %s}", v, wine_dbgstr_longlong(v->hVal.QuadPart));
-        case VT_R4:
-            return wine_dbg_sprintf("%p {VT_R4: %.8e}", v, v->fltVal);
         case VT_R8:
             return wine_dbg_sprintf("%p {VT_R8: %lf}", v, v->dblVal);
         case VT_CLSID:
@@ -180,7 +178,7 @@ static inline const char *debugstr_fourcc(DWORD format)
                 return wine_dbg_sprintf("%s", wine_dbgstr_an(formats[i].name, -1));
         }
 
-        return wine_dbg_sprintf("%#lx", format);
+        return wine_dbg_sprintf("%#x", format);
     }
 
     return wine_dbgstr_an((char *)&format, 4);
diff --git a/dlls/mfplat/quartz_parser.c b/dlls/mfplat/quartz_parser.c
new file mode 100644
index 00000000000..e9a3b00016d
--- /dev/null
+++ wine/dlls/mfplat/quartz_parser.c
@@ -0,0 +1,1945 @@
+/*
+ * DirectShow parser filters
+ *
+ * Copyright 2010 Maarten Lankhorst for CodeWeavers
+ * Copyright 2010 Aric Stewart for CodeWeavers
+ * Copyright 2019-2020 Zebediah Figura
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "gst_private.h"
+#include "gst_guids.h"
+
+#include "amvideo.h"
+
+#include <limits.h>
+#include "dvdmedia.h"
+#include "mmreg.h"
+#include "ks.h"
+#include "initguid.h"
+#include "wmcodecdsp.h"
+#include "ksmedia.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(quartz);
+
+static const GUID MEDIASUBTYPE_CVID = {mmioFOURCC('c','v','i','d'), 0x0000, 0x0010, {0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71}};
+static const GUID MEDIASUBTYPE_MP3  = {WAVE_FORMAT_MPEGLAYER3, 0x0000, 0x0010, {0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71}};
+
+struct parser
+{
+    struct strmbase_filter filter;
+    IAMStreamSelect IAMStreamSelect_iface;
+
+    struct strmbase_sink sink;
+    IAsyncReader *reader;
+
+    struct parser_source **sources;
+    unsigned int source_count;
+    BOOL enum_sink_first;
+
+    struct wg_parser *wg_parser;
+
+    /* FIXME: It would be nice to avoid duplicating these with strmbase.
+     * However, synchronization is tricky; we need access to be protected by a
+     * separate lock. */
+    bool streaming, sink_connected;
+
+    HANDLE read_thread;
+
+    BOOL (*init_gst)(struct parser *filter);
+    HRESULT (*source_query_accept)(struct parser_source *pin, const AM_MEDIA_TYPE *mt);
+    HRESULT (*source_get_media_type)(struct parser_source *pin, unsigned int index, AM_MEDIA_TYPE *mt);
+};
+
+struct parser_source
+{
+    struct strmbase_source pin;
+    IQualityControl IQualityControl_iface;
+
+    struct wg_parser_stream *wg_stream;
+
+    SourceSeeking seek;
+
+    CRITICAL_SECTION flushing_cs;
+    CONDITION_VARIABLE eos_cv;
+    HANDLE thread;
+
+    /* This variable is read and written by both the streaming thread and
+     * application threads. However, it is only written by the application
+     * thread when the streaming thread is not running, or when it is blocked
+     * by flushing_cs. */
+    bool need_segment;
+
+    bool eos;
+};
+
+static inline struct parser *impl_from_strmbase_filter(struct strmbase_filter *iface)
+{
+    return CONTAINING_RECORD(iface, struct parser, filter);
+}
+
+static const IMediaSeekingVtbl GST_Seeking_Vtbl;
+static const IQualityControlVtbl GSTOutPin_QualityControl_Vtbl;
+
+static struct parser_source *create_pin(struct parser *filter,
+        struct wg_parser_stream *stream, const WCHAR *name);
+static HRESULT GST_RemoveOutputPins(struct parser *This);
+static HRESULT WINAPI GST_ChangeCurrent(IMediaSeeking *iface);
+static HRESULT WINAPI GST_ChangeStop(IMediaSeeking *iface);
+static HRESULT WINAPI GST_ChangeRate(IMediaSeeking *iface);
+
+static bool amt_from_wg_format_audio(AM_MEDIA_TYPE *mt, const struct wg_format *format)
+{
+    mt->majortype = MEDIATYPE_Audio;
+    mt->formattype = FORMAT_WaveFormatEx;
+
+    switch (format->u.audio.format)
+    {
+    case WG_AUDIO_FORMAT_UNKNOWN:
+        return false;
+
+    case WG_AUDIO_FORMAT_MPEG1_LAYER1:
+    case WG_AUDIO_FORMAT_MPEG1_LAYER2:
+    {
+        MPEG1WAVEFORMAT *wave_format;
+
+        if (!(wave_format = CoTaskMemAlloc(sizeof(*wave_format))))
+            return false;
+        memset(wave_format, 0, sizeof(*wave_format));
+
+        mt->subtype = MEDIASUBTYPE_MPEG1AudioPayload;
+        mt->cbFormat = sizeof(*wave_format);
+        mt->pbFormat = (BYTE *)wave_format;
+        wave_format->wfx.wFormatTag = WAVE_FORMAT_MPEG;
+        wave_format->wfx.nChannels = format->u.audio.channels;
+        wave_format->wfx.nSamplesPerSec = format->u.audio.rate;
+        wave_format->wfx.cbSize = sizeof(*wave_format) - sizeof(WAVEFORMATEX);
+        wave_format->fwHeadLayer = (format->u.audio.format == WG_AUDIO_FORMAT_MPEG1_LAYER1 ? 1 : 2);
+        return true;
+    }
+
+    case WG_AUDIO_FORMAT_MPEG1_LAYER3:
+    {
+        MPEGLAYER3WAVEFORMAT *wave_format;
+
+        if (!(wave_format = CoTaskMemAlloc(sizeof(*wave_format))))
+            return false;
+        memset(wave_format, 0, sizeof(*wave_format));
+
+        mt->subtype = MEDIASUBTYPE_MP3;
+        mt->cbFormat = sizeof(*wave_format);
+        mt->pbFormat = (BYTE *)wave_format;
+        wave_format->wfx.wFormatTag = WAVE_FORMAT_MPEGLAYER3;
+        wave_format->wfx.nChannels = format->u.audio.channels;
+        wave_format->wfx.nSamplesPerSec = format->u.audio.rate;
+        wave_format->wfx.cbSize = sizeof(*wave_format) - sizeof(WAVEFORMATEX);
+        /* FIXME: We can't get most of the MPEG data from the caps. We may have
+         * to manually parse the header. */
+        wave_format->wID = MPEGLAYER3_ID_MPEG;
+        wave_format->fdwFlags = MPEGLAYER3_FLAG_PADDING_ON;
+        wave_format->nFramesPerBlock = 1;
+        wave_format->nCodecDelay = 1393;
+        return true;
+    }
+
+    case WG_AUDIO_FORMAT_U8:
+    case WG_AUDIO_FORMAT_S16LE:
+    case WG_AUDIO_FORMAT_S24LE:
+    case WG_AUDIO_FORMAT_S32LE:
+    case WG_AUDIO_FORMAT_F32LE:
+    case WG_AUDIO_FORMAT_F64LE:
+    {
+        static const struct
+        {
+            bool is_float;
+            WORD depth;
+        }
+        format_table[] =
+        {
+            {0},
+            {false, 8},
+            {false, 16},
+            {false, 24},
+            {false, 32},
+            {true, 32},
+            {true, 64},
+        };
+
+        bool is_float;
+        WORD depth;
+
+        assert(format->u.audio.format < ARRAY_SIZE(format_table));
+        is_float = format_table[format->u.audio.format].is_float;
+        depth = format_table[format->u.audio.format].depth;
+
+        if (is_float || format->u.audio.channels > 2)
+        {
+            WAVEFORMATEXTENSIBLE *wave_format;
+
+            if (!(wave_format = CoTaskMemAlloc(sizeof(*wave_format))))
+                return false;
+            memset(wave_format, 0, sizeof(*wave_format));
+
+            mt->subtype = is_float ? MEDIASUBTYPE_IEEE_FLOAT : MEDIASUBTYPE_PCM;
+            mt->bFixedSizeSamples = TRUE;
+            mt->pbFormat = (BYTE *)wave_format;
+            mt->cbFormat = sizeof(*wave_format);
+            wave_format->Format.wFormatTag = WAVE_FORMAT_EXTENSIBLE;
+            wave_format->Format.nChannels = format->u.audio.channels;
+            wave_format->Format.nSamplesPerSec = format->u.audio.rate;
+            wave_format->Format.nAvgBytesPerSec = format->u.audio.rate * format->u.audio.channels * depth / 8;
+            wave_format->Format.nBlockAlign = format->u.audio.channels * depth / 8;
+            wave_format->Format.wBitsPerSample = depth;
+            wave_format->Format.cbSize = sizeof(*wave_format) - sizeof(WAVEFORMATEX);
+            wave_format->Samples.wValidBitsPerSample = depth;
+            wave_format->dwChannelMask = format->u.audio.channel_mask;
+            wave_format->SubFormat = is_float ? KSDATAFORMAT_SUBTYPE_IEEE_FLOAT : KSDATAFORMAT_SUBTYPE_PCM;
+            mt->lSampleSize = wave_format->Format.nBlockAlign;
+        }
+        else
+        {
+            WAVEFORMATEX *wave_format;
+
+            if (!(wave_format = CoTaskMemAlloc(sizeof(*wave_format))))
+                return false;
+            memset(wave_format, 0, sizeof(*wave_format));
+
+            mt->subtype = MEDIASUBTYPE_PCM;
+            mt->bFixedSizeSamples = TRUE;
+            mt->pbFormat = (BYTE *)wave_format;
+            mt->cbFormat = sizeof(*wave_format);
+            wave_format->wFormatTag = WAVE_FORMAT_PCM;
+            wave_format->nChannels = format->u.audio.channels;
+            wave_format->nSamplesPerSec = format->u.audio.rate;
+            wave_format->nAvgBytesPerSec = format->u.audio.rate * format->u.audio.channels * depth / 8;
+            wave_format->nBlockAlign = format->u.audio.channels * depth / 8;
+            wave_format->wBitsPerSample = depth;
+            wave_format->cbSize = 0;
+            mt->lSampleSize = wave_format->nBlockAlign;
+        }
+        return true;
+    }
+    }
+
+    assert(0);
+    return false;
+}
+
+#define ALIGN(n, alignment) (((n) + (alignment) - 1) & ~((alignment) - 1))
+
+unsigned int wg_format_get_max_size(const struct wg_format *format)
+{
+    switch (format->major_type)
+    {
+        case WG_MAJOR_TYPE_VIDEO:
+        {
+            unsigned int width = format->u.video.width, height = format->u.video.height;
+
+            switch (format->u.video.format)
+            {
+                case WG_VIDEO_FORMAT_BGRA:
+                case WG_VIDEO_FORMAT_BGRx:
+                case WG_VIDEO_FORMAT_AYUV:
+                    return width * height * 4;
+
+                case WG_VIDEO_FORMAT_BGR:
+                    return ALIGN(width * 3, 4) * height;
+
+                case WG_VIDEO_FORMAT_RGB15:
+                case WG_VIDEO_FORMAT_RGB16:
+                case WG_VIDEO_FORMAT_UYVY:
+                case WG_VIDEO_FORMAT_YUY2:
+                case WG_VIDEO_FORMAT_YVYU:
+                    return ALIGN(width * 2, 4) * height;
+
+                case WG_VIDEO_FORMAT_I420:
+                case WG_VIDEO_FORMAT_YV12:
+                    return ALIGN(width, 4) * ALIGN(height, 2) /* Y plane */
+                            + 2 * ALIGN((width + 1) / 2, 4) * ((height + 1) / 2); /* U and V planes */
+
+                case WG_VIDEO_FORMAT_NV12:
+                    return ALIGN(width, 4) * ALIGN(height, 2) /* Y plane */
+                            + ALIGN(width, 4) * ((height + 1) / 2); /* U/V plane */
+
+                case WG_VIDEO_FORMAT_CINEPAK:
+                    /* Both ffmpeg's encoder and a Cinepak file seen in the wild report
+                     * 24 bpp. ffmpeg sets biSizeImage as below; others may be smaller,
+                     * but as long as every sample fits into our allocator, we're fine. */
+                    return width * height * 3;
+
+                case WG_VIDEO_FORMAT_UNKNOWN:
+                    FIXME("Cannot guess maximum sample size for unknown video format.\n");
+                    return 0;
+            }
+            break;
+        }
+
+        case WG_MAJOR_TYPE_AUDIO:
+        {
+            unsigned int rate = format->u.audio.rate, channels = format->u.audio.channels;
+
+            /* Actually we don't know how large of a sample GStreamer will give
+             * us. Hopefully 1 second is enough... */
+
+            switch (format->u.audio.format)
+            {
+                case WG_AUDIO_FORMAT_U8:
+                    return rate * channels;
+
+                case WG_AUDIO_FORMAT_S16LE:
+                    return rate * channels * 2;
+
+                case WG_AUDIO_FORMAT_S24LE:
+                    return rate * channels * 3;
+
+                case WG_AUDIO_FORMAT_S32LE:
+                case WG_AUDIO_FORMAT_F32LE:
+                    return rate * channels * 4;
+
+                case WG_AUDIO_FORMAT_F64LE:
+                    return rate * channels * 8;
+
+                case WG_AUDIO_FORMAT_MPEG1_LAYER1:
+                    return 56000;
+
+                case WG_AUDIO_FORMAT_MPEG1_LAYER2:
+                    return 48000;
+
+                case WG_AUDIO_FORMAT_MPEG1_LAYER3:
+                    return 40000;
+
+                case WG_AUDIO_FORMAT_UNKNOWN:
+                    FIXME("Cannot guess maximum sample size for unknown audio format.\n");
+                    return 0;
+            }
+            break;
+        }
+
+        case WG_MAJOR_TYPE_UNKNOWN:
+            FIXME("Cannot guess maximum sample size for unknown format.\n");
+            return 0;
+    }
+
+    assert(0);
+    return 0;
+}
+
+static bool amt_from_wg_format_video(AM_MEDIA_TYPE *mt, const struct wg_format *format, bool wm)
+{
+    static const struct
+    {
+        const GUID *subtype;
+        DWORD compression;
+        WORD depth;
+    }
+    format_table[] =
+    {
+        {0},
+        {&MEDIASUBTYPE_ARGB32, BI_RGB,                      32},
+        {&MEDIASUBTYPE_RGB32,  BI_RGB,                      32},
+        {&MEDIASUBTYPE_RGB24,  BI_RGB,                      24},
+        {&MEDIASUBTYPE_RGB555, BI_RGB,                      16},
+        {&MEDIASUBTYPE_RGB565, BI_BITFIELDS,                16},
+        {&MEDIASUBTYPE_AYUV,   mmioFOURCC('A','Y','U','V'), 32},
+        {&MEDIASUBTYPE_I420,   mmioFOURCC('I','4','2','0'), 12},
+        {&MEDIASUBTYPE_NV12,   mmioFOURCC('N','V','1','2'), 12},
+        {&MEDIASUBTYPE_UYVY,   mmioFOURCC('U','Y','V','Y'), 16},
+        {&MEDIASUBTYPE_YUY2,   mmioFOURCC('Y','U','Y','2'), 16},
+        {&MEDIASUBTYPE_YV12,   mmioFOURCC('Y','V','1','2'), 12},
+        {&MEDIASUBTYPE_YVYU,   mmioFOURCC('Y','V','Y','U'), 16},
+        {&MEDIASUBTYPE_CVID,   mmioFOURCC('C','V','I','D'), 24},
+    };
+
+    VIDEOINFO *video_format;
+    uint32_t frame_time;
+
+    if (format->u.video.format == WG_VIDEO_FORMAT_UNKNOWN)
+        return false;
+
+    if (!(video_format = CoTaskMemAlloc(sizeof(*video_format))))
+        return false;
+
+    assert(format->u.video.format < ARRAY_SIZE(format_table));
+
+    mt->majortype = MEDIATYPE_Video;
+    mt->subtype = *format_table[format->u.video.format].subtype;
+    if (wm)
+        mt->bFixedSizeSamples = TRUE;
+    else
+        mt->bTemporalCompression = TRUE;
+    mt->lSampleSize = 1;
+    mt->formattype = FORMAT_VideoInfo;
+    mt->cbFormat = sizeof(VIDEOINFOHEADER);
+    mt->pbFormat = (BYTE *)video_format;
+
+    memset(video_format, 0, sizeof(*video_format));
+
+    if (wm)
+    {
+        SetRect(&video_format->rcSource, 0, 0, format->u.video.width, format->u.video.height);
+        video_format->rcTarget = video_format->rcSource;
+    }
+    if ((frame_time = MulDiv(10000000, format->u.video.fps_d, format->u.video.fps_n)) != -1)
+        video_format->AvgTimePerFrame = frame_time;
+    video_format->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
+    video_format->bmiHeader.biWidth = format->u.video.width;
+    video_format->bmiHeader.biHeight = format->u.video.height;
+    video_format->bmiHeader.biPlanes = 1;
+    video_format->bmiHeader.biBitCount = format_table[format->u.video.format].depth;
+    video_format->bmiHeader.biCompression = format_table[format->u.video.format].compression;
+    video_format->bmiHeader.biSizeImage = wg_format_get_max_size(format);
+
+    if (format->u.video.format == WG_VIDEO_FORMAT_RGB16)
+    {
+        mt->cbFormat = offsetof(VIDEOINFO, dwBitMasks[3]);
+        video_format->dwBitMasks[iRED]   = 0xf800;
+        video_format->dwBitMasks[iGREEN] = 0x07e0;
+        video_format->dwBitMasks[iBLUE]  = 0x001f;
+    }
+
+    return true;
+}
+
+bool amt_from_wg_format(AM_MEDIA_TYPE *mt, const struct wg_format *format, bool wm)
+{
+    memset(mt, 0, sizeof(*mt));
+
+    switch (format->major_type)
+    {
+    case WG_MAJOR_TYPE_UNKNOWN:
+        return false;
+
+    case WG_MAJOR_TYPE_AUDIO:
+        return amt_from_wg_format_audio(mt, format);
+
+    case WG_MAJOR_TYPE_VIDEO:
+        return amt_from_wg_format_video(mt, format, wm);
+    }
+
+    assert(0);
+    return false;
+}
+
+static bool amt_to_wg_format_audio(const AM_MEDIA_TYPE *mt, struct wg_format *format)
+{
+    static const struct
+    {
+        const GUID *subtype;
+        WORD depth;
+        enum wg_audio_format format;
+    }
+    format_map[] =
+    {
+        {&MEDIASUBTYPE_PCM,          8, WG_AUDIO_FORMAT_U8},
+        {&MEDIASUBTYPE_PCM,         16, WG_AUDIO_FORMAT_S16LE},
+        {&MEDIASUBTYPE_PCM,         24, WG_AUDIO_FORMAT_S24LE},
+        {&MEDIASUBTYPE_PCM,         32, WG_AUDIO_FORMAT_S32LE},
+        {&MEDIASUBTYPE_IEEE_FLOAT,  32, WG_AUDIO_FORMAT_F32LE},
+        {&MEDIASUBTYPE_IEEE_FLOAT,  64, WG_AUDIO_FORMAT_F64LE},
+    };
+
+    const WAVEFORMATEX *audio_format = (const WAVEFORMATEX *)mt->pbFormat;
+    unsigned int i;
+
+    if (!IsEqualGUID(&mt->formattype, &FORMAT_WaveFormatEx))
+    {
+        FIXME("Unknown format type %s.\n", debugstr_guid(&mt->formattype));
+        return false;
+    }
+    if (mt->cbFormat < sizeof(WAVEFORMATEX) || !mt->pbFormat)
+    {
+        ERR("Unexpected format size %u.\n", mt->cbFormat);
+        return false;
+    }
+
+    format->major_type = WG_MAJOR_TYPE_AUDIO;
+    format->u.audio.channels = audio_format->nChannels;
+    format->u.audio.rate = audio_format->nSamplesPerSec;
+
+    if (audio_format->wFormatTag == WAVE_FORMAT_EXTENSIBLE)
+    {
+        const WAVEFORMATEXTENSIBLE *ext_format = (const WAVEFORMATEXTENSIBLE *)mt->pbFormat;
+
+        format->u.audio.channel_mask = ext_format->dwChannelMask;
+    }
+    else
+    {
+        if (audio_format->nChannels == 1)
+            format->u.audio.channel_mask = KSAUDIO_SPEAKER_MONO;
+        else if (audio_format->nChannels == 2)
+            format->u.audio.channel_mask = KSAUDIO_SPEAKER_STEREO;
+        else
+        {
+            ERR("Unexpected channel count %u.\n", audio_format->nChannels);
+            return false;
+        }
+    }
+
+    for (i = 0; i < ARRAY_SIZE(format_map); ++i)
+    {
+        if (IsEqualGUID(&mt->subtype, format_map[i].subtype)
+                && audio_format->wBitsPerSample == format_map[i].depth)
+        {
+            format->u.audio.format = format_map[i].format;
+            return true;
+        }
+    }
+
+    FIXME("Unknown subtype %s, depth %u.\n", debugstr_guid(&mt->subtype), audio_format->wBitsPerSample);
+    return false;
+}
+
+static bool amt_to_wg_format_audio_mpeg1(const AM_MEDIA_TYPE *mt, struct wg_format *format)
+{
+    const MPEG1WAVEFORMAT *audio_format = (const MPEG1WAVEFORMAT *)mt->pbFormat;
+
+    if (!IsEqualGUID(&mt->formattype, &FORMAT_WaveFormatEx))
+    {
+        FIXME("Unknown format type %s.\n", debugstr_guid(&mt->formattype));
+        return false;
+    }
+    if (mt->cbFormat < sizeof(*audio_format) || !mt->pbFormat)
+    {
+        ERR("Unexpected format size %u.\n", mt->cbFormat);
+        return false;
+    }
+
+    format->major_type = WG_MAJOR_TYPE_AUDIO;
+    format->u.audio.channels = audio_format->wfx.nChannels;
+    format->u.audio.rate = audio_format->wfx.nSamplesPerSec;
+    if (audio_format->fwHeadLayer == 1)
+        format->u.audio.format = WG_AUDIO_FORMAT_MPEG1_LAYER1;
+    else if (audio_format->fwHeadLayer == 2)
+        format->u.audio.format = WG_AUDIO_FORMAT_MPEG1_LAYER2;
+    else if (audio_format->fwHeadLayer == 3)
+        format->u.audio.format = WG_AUDIO_FORMAT_MPEG1_LAYER3;
+    else
+        return false;
+    return true;
+}
+
+static bool amt_to_wg_format_audio_mpeg1_layer3(const AM_MEDIA_TYPE *mt, struct wg_format *format)
+{
+    const MPEGLAYER3WAVEFORMAT *audio_format = (const MPEGLAYER3WAVEFORMAT *)mt->pbFormat;
+
+    if (!IsEqualGUID(&mt->formattype, &FORMAT_WaveFormatEx))
+    {
+        FIXME("Unknown format type %s.\n", debugstr_guid(&mt->formattype));
+        return false;
+    }
+    if (mt->cbFormat < sizeof(*audio_format) || !mt->pbFormat)
+    {
+        ERR("Unexpected format size %u.\n", mt->cbFormat);
+        return false;
+    }
+
+    format->major_type = WG_MAJOR_TYPE_AUDIO;
+    format->u.audio.channels = audio_format->wfx.nChannels;
+    format->u.audio.rate = audio_format->wfx.nSamplesPerSec;
+    format->u.audio.format = WG_AUDIO_FORMAT_MPEG1_LAYER3;
+    return true;
+}
+
+static bool amt_to_wg_format_video(const AM_MEDIA_TYPE *mt, struct wg_format *format)
+{
+    static const struct
+    {
+        const GUID *subtype;
+        enum wg_video_format format;
+    }
+    format_map[] =
+    {
+        {&MEDIASUBTYPE_ARGB32,  WG_VIDEO_FORMAT_BGRA},
+        {&MEDIASUBTYPE_RGB32,   WG_VIDEO_FORMAT_BGRx},
+        {&MEDIASUBTYPE_RGB24,   WG_VIDEO_FORMAT_BGR},
+        {&MEDIASUBTYPE_RGB555,  WG_VIDEO_FORMAT_RGB15},
+        {&MEDIASUBTYPE_RGB565,  WG_VIDEO_FORMAT_RGB16},
+        {&MEDIASUBTYPE_AYUV,    WG_VIDEO_FORMAT_AYUV},
+        {&MEDIASUBTYPE_I420,    WG_VIDEO_FORMAT_I420},
+        {&MEDIASUBTYPE_NV12,    WG_VIDEO_FORMAT_NV12},
+        {&MEDIASUBTYPE_UYVY,    WG_VIDEO_FORMAT_UYVY},
+        {&MEDIASUBTYPE_YUY2,    WG_VIDEO_FORMAT_YUY2},
+        {&MEDIASUBTYPE_YV12,    WG_VIDEO_FORMAT_YV12},
+        {&MEDIASUBTYPE_YVYU,    WG_VIDEO_FORMAT_YVYU},
+        {&MEDIASUBTYPE_CVID,    WG_VIDEO_FORMAT_CINEPAK},
+    };
+
+    const VIDEOINFOHEADER *video_format = (const VIDEOINFOHEADER *)mt->pbFormat;
+    unsigned int i;
+
+    if (!IsEqualGUID(&mt->formattype, &FORMAT_VideoInfo))
+    {
+        FIXME("Unknown format type %s.\n", debugstr_guid(&mt->formattype));
+        return false;
+    }
+    if (mt->cbFormat < sizeof(VIDEOINFOHEADER) || !mt->pbFormat)
+    {
+        ERR("Unexpected format size %u.\n", mt->cbFormat);
+        return false;
+    }
+
+    format->major_type = WG_MAJOR_TYPE_VIDEO;
+    format->u.video.width = video_format->bmiHeader.biWidth;
+    format->u.video.height = video_format->bmiHeader.biHeight;
+    format->u.video.fps_n = 10000000;
+    format->u.video.fps_d = video_format->AvgTimePerFrame;
+
+    for (i = 0; i < ARRAY_SIZE(format_map); ++i)
+    {
+        if (IsEqualGUID(&mt->subtype, format_map[i].subtype))
+        {
+            format->u.video.format = format_map[i].format;
+            return true;
+        }
+    }
+
+    FIXME("Unknown subtype %s.\n", debugstr_guid(&mt->subtype));
+    return false;
+}
+
+bool amt_to_wg_format(const AM_MEDIA_TYPE *mt, struct wg_format *format)
+{
+    memset(format, 0, sizeof(*format));
+
+    if (IsEqualGUID(&mt->majortype, &MEDIATYPE_Video))
+        return amt_to_wg_format_video(mt, format);
+    if (IsEqualGUID(&mt->majortype, &MEDIATYPE_Audio))
+    {
+        if (IsEqualGUID(&mt->subtype, &MEDIASUBTYPE_MPEG1AudioPayload))
+            return amt_to_wg_format_audio_mpeg1(mt, format);
+        if (IsEqualGUID(&mt->subtype, &MEDIASUBTYPE_MP3))
+            return amt_to_wg_format_audio_mpeg1_layer3(mt, format);
+        return amt_to_wg_format_audio(mt, format);
+    }
+
+    FIXME("Unknown major type %s.\n", debugstr_guid(&mt->majortype));
+    return false;
+}
+
+/*
+ * scale_uint64() is based on gst_util_scale_int() from GStreamer, which is
+ * covered by the following license:
+ *
+ * GStreamer
+ * Copyright (C) 1999,2000 Erik Walthinsen <omega@cse.ogi.edu>
+ *                    2000 Wim Taymans <wtay@chello.be>
+ *                    2002 Thomas Vander Stichele <thomas@apestaart.org>
+ *                    2004 Wim Taymans <wim@fluendo.com>
+ *                    2015 Jan Schmidt <jan@centricular.com>
+ *
+ * gstutils.c: Utility functions
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+static uint64_t scale_uint64(uint64_t value, uint32_t numerator, uint32_t denominator)
+{
+    ULARGE_INTEGER i, high, low;
+
+    if (!value)
+        return 0;
+
+    i.QuadPart = value;
+    low.QuadPart = (ULONGLONG)i.u.LowPart * numerator;
+    high.QuadPart = (ULONGLONG)i.u.HighPart * numerator + low.u.HighPart;
+    low.u.HighPart = 0;
+
+    if (high.u.HighPart >= denominator)
+        return ULLONG_MAX;
+
+    low.QuadPart += (high.QuadPart % denominator) << 32;
+    return ((high.QuadPart / denominator) << 32) + (low.QuadPart / denominator);
+}
+
+/* Fill and send a single IMediaSample. */
+static HRESULT send_sample(struct parser_source *pin, IMediaSample *sample,
+        const struct wg_parser_buffer *buffer, uint32_t offset, uint32_t size, DWORD bytes_per_second)
+{
+    HRESULT hr;
+    BYTE *ptr = NULL;
+
+    TRACE("offset %u, size %u, sample size %u\n", offset, size, IMediaSample_GetSize(sample));
+
+    hr = IMediaSample_SetActualDataLength(sample, size);
+    if(FAILED(hr)){
+        WARN("SetActualDataLength failed: %08x\n", hr);
+        return hr;
+    }
+
+    IMediaSample_GetPointer(sample, &ptr);
+
+    if (!wg_parser_stream_copy_buffer(pin->wg_stream, ptr, offset, size))
+    {
+        /* The GStreamer pin has been flushed. */
+        return S_OK;
+    }
+
+    if (buffer->has_pts)
+    {
+        REFERENCE_TIME start_pts = buffer->pts;
+
+        if (offset)
+            start_pts += scale_uint64(offset, 10000000, bytes_per_second);
+        start_pts -= pin->seek.llCurrent;
+        start_pts *= pin->seek.dRate;
+
+        if (buffer->has_duration)
+        {
+            REFERENCE_TIME end_pts = buffer->pts + buffer->duration;
+
+            if (offset + size < buffer->size)
+                end_pts = buffer->pts + scale_uint64(offset + size, 10000000, bytes_per_second);
+            end_pts -= pin->seek.llCurrent;
+            end_pts *= pin->seek.dRate;
+
+            IMediaSample_SetTime(sample, &start_pts, &end_pts);
+            IMediaSample_SetMediaTime(sample, &start_pts, &end_pts);
+        }
+        else
+        {
+            IMediaSample_SetTime(sample, &start_pts, NULL);
+            IMediaSample_SetMediaTime(sample, NULL, NULL);
+        }
+    }
+    else
+    {
+        IMediaSample_SetTime(sample, NULL, NULL);
+        IMediaSample_SetMediaTime(sample, NULL, NULL);
+    }
+
+    IMediaSample_SetDiscontinuity(sample, !offset && buffer->discontinuity);
+    IMediaSample_SetPreroll(sample, buffer->preroll);
+    IMediaSample_SetSyncPoint(sample, !buffer->delta);
+
+    if (!pin->pin.pin.peer)
+        hr = VFW_E_NOT_CONNECTED;
+    else
+        hr = IMemInputPin_Receive(pin->pin.pMemInputPin, sample);
+
+    TRACE("sending sample returned: %08x\n", hr);
+
+    return hr;
+}
+
+/* Send a single GStreamer buffer (splitting it into multiple IMediaSamples if
+ * necessary). */
+static void send_buffer(struct parser_source *pin, const struct wg_parser_buffer *buffer)
+{
+    HRESULT hr;
+    IMediaSample *sample;
+
+    if (pin->need_segment)
+    {
+        if (FAILED(hr = IPin_NewSegment(pin->pin.pin.peer,
+                pin->seek.llCurrent, pin->seek.llStop, pin->seek.dRate)))
+            WARN("Failed to deliver new segment, hr %#x.\n", hr);
+        pin->need_segment = false;
+    }
+
+    if (IsEqualGUID(&pin->pin.pin.mt.formattype, &FORMAT_WaveFormatEx)
+            && (IsEqualGUID(&pin->pin.pin.mt.subtype, &MEDIASUBTYPE_PCM)
+            || IsEqualGUID(&pin->pin.pin.mt.subtype, &MEDIASUBTYPE_IEEE_FLOAT)))
+    {
+        WAVEFORMATEX *format = (WAVEFORMATEX *)pin->pin.pin.mt.pbFormat;
+        uint32_t offset = 0;
+
+        while (offset < buffer->size)
+        {
+            uint32_t advance;
+
+            hr = BaseOutputPinImpl_GetDeliveryBuffer(&pin->pin, &sample, NULL, NULL, 0);
+
+            if (FAILED(hr))
+            {
+                if (hr != VFW_E_NOT_CONNECTED)
+                    ERR("Could not get a delivery buffer (%x), returning GST_FLOW_FLUSHING\n", hr);
+                break;
+            }
+
+            advance = min(IMediaSample_GetSize(sample), buffer->size - offset);
+
+            hr = send_sample(pin, sample, buffer, offset, advance, format->nAvgBytesPerSec);
+
+            IMediaSample_Release(sample);
+
+            if (FAILED(hr))
+                break;
+
+            offset += advance;
+        }
+    }
+    else
+    {
+        hr = BaseOutputPinImpl_GetDeliveryBuffer(&pin->pin, &sample, NULL, NULL, 0);
+
+        if (FAILED(hr))
+        {
+            if (hr != VFW_E_NOT_CONNECTED)
+                ERR("Could not get a delivery buffer (%x), returning GST_FLOW_FLUSHING\n", hr);
+        }
+        else
+        {
+            hr = send_sample(pin, sample, buffer, 0, buffer->size, 0);
+
+            IMediaSample_Release(sample);
+        }
+    }
+
+    wg_parser_stream_release_buffer(pin->wg_stream);
+}
+
+static DWORD CALLBACK stream_thread(void *arg)
+{
+    struct parser_source *pin = arg;
+    struct parser *filter = impl_from_strmbase_filter(pin->pin.pin.filter);
+
+    TRACE("Starting streaming thread for pin %p.\n", pin);
+
+    while (filter->streaming)
+    {
+        struct wg_parser_buffer buffer;
+
+        EnterCriticalSection(&pin->flushing_cs);
+
+        if (pin->eos)
+        {
+            SleepConditionVariableCS(&pin->eos_cv, &pin->flushing_cs, INFINITE);
+            LeaveCriticalSection(&pin->flushing_cs);
+            continue;
+        }
+
+        if (wg_parser_stream_get_buffer(pin->wg_stream, &buffer))
+        {
+            send_buffer(pin, &buffer);
+        }
+        else
+        {
+            TRACE("Got EOS.\n");
+            IPin_EndOfStream(pin->pin.pin.peer);
+            pin->eos = true;
+        }
+
+        LeaveCriticalSection(&pin->flushing_cs);
+    }
+
+    TRACE("Streaming stopped; exiting.\n");
+    return 0;
+}
+
+static DWORD CALLBACK read_thread(void *arg)
+{
+    struct parser *filter = arg;
+    LONGLONG file_size, unused;
+    size_t buffer_size = 4096;
+    void *data = NULL;
+
+    if (!(data = malloc(buffer_size)))
+        return 0;
+
+    IAsyncReader_Length(filter->reader, &file_size, &unused);
+
+    TRACE("Starting read thread for filter %p.\n", filter);
+
+    while (filter->sink_connected)
+    {
+        uint64_t offset;
+        uint32_t size;
+        HRESULT hr;
+
+        if (!wg_parser_get_next_read_offset(filter->wg_parser, &offset, &size))
+            continue;
+
+        if (offset >= file_size)
+            size = 0;
+        else if (offset + size >= file_size)
+            size = file_size - offset;
+
+        if (!array_reserve(&data, &buffer_size, size, 1))
+        {
+            free(data);
+            return 0;
+        }
+
+        hr = IAsyncReader_SyncRead(filter->reader, offset, size, data);
+        if (FAILED(hr))
+            ERR("Failed to read %u bytes at offset %I64u, hr %#x.\n", size, offset, hr);
+
+        wg_parser_push_data(filter->wg_parser, SUCCEEDED(hr) ? WG_READ_SUCCESS : WG_READ_FAILURE, data, size);
+    }
+
+    free(data);
+    TRACE("Streaming stopped; exiting.\n");
+    return 0;
+}
+
+static inline struct parser_source *impl_from_IMediaSeeking(IMediaSeeking *iface)
+{
+    return CONTAINING_RECORD(iface, struct parser_source, seek.IMediaSeeking_iface);
+}
+
+static struct strmbase_pin *parser_get_pin(struct strmbase_filter *base, unsigned int index)
+{
+    struct parser *filter = impl_from_strmbase_filter(base);
+
+    if (filter->enum_sink_first)
+    {
+        if (!index)
+            return &filter->sink.pin;
+        else if (index <= filter->source_count)
+            return &filter->sources[index - 1]->pin.pin;
+    }
+    else
+    {
+        if (index < filter->source_count)
+            return &filter->sources[index]->pin.pin;
+        else if (index == filter->source_count)
+            return &filter->sink.pin;
+    }
+    return NULL;
+}
+
+static void parser_destroy(struct strmbase_filter *iface)
+{
+    struct parser *filter = impl_from_strmbase_filter(iface);
+    HRESULT hr;
+
+    /* Don't need to clean up output pins, disconnecting input pin will do that */
+    if (filter->sink.pin.peer)
+    {
+        hr = IPin_Disconnect(filter->sink.pin.peer);
+        assert(hr == S_OK);
+        hr = IPin_Disconnect(&filter->sink.pin.IPin_iface);
+        assert(hr == S_OK);
+    }
+
+    if (filter->reader)
+        IAsyncReader_Release(filter->reader);
+    filter->reader = NULL;
+
+    wg_parser_destroy(filter->wg_parser);
+
+    strmbase_sink_cleanup(&filter->sink);
+    strmbase_filter_cleanup(&filter->filter);
+    free(filter);
+}
+
+static HRESULT parser_init_stream(struct strmbase_filter *iface)
+{
+    struct parser *filter = impl_from_strmbase_filter(iface);
+    DWORD stop_flags = AM_SEEKING_NoPositioning;
+    const SourceSeeking *seeking;
+    unsigned int i;
+
+    if (!filter->sink_connected)
+        return S_OK;
+
+    filter->streaming = true;
+
+    /* DirectShow retains the old seek positions, but resets to them every time
+     * it transitions from stopped -> paused. */
+
+    seeking = &filter->sources[0]->seek;
+    if (seeking->llStop)
+        stop_flags = AM_SEEKING_AbsolutePositioning;
+    wg_parser_stream_seek(filter->sources[0]->wg_stream, seeking->dRate,
+            seeking->llCurrent, seeking->llStop, AM_SEEKING_AbsolutePositioning, stop_flags);
+
+    for (i = 0; i < filter->source_count; ++i)
+    {
+        struct parser_source *pin = filter->sources[i];
+        HRESULT hr;
+
+        if (!pin->pin.pin.peer)
+            continue;
+
+        if (FAILED(hr = IMemAllocator_Commit(pin->pin.pAllocator)))
+            ERR("Failed to commit allocator, hr %#x.\n", hr);
+
+        pin->need_segment = true;
+        pin->eos = false;
+
+        pin->thread = CreateThread(NULL, 0, stream_thread, pin, 0, NULL);
+    }
+
+    return S_OK;
+}
+
+static HRESULT parser_cleanup_stream(struct strmbase_filter *iface)
+{
+    struct parser *filter = impl_from_strmbase_filter(iface);
+    unsigned int i;
+
+    if (!filter->sink_connected)
+        return S_OK;
+
+    filter->streaming = false;
+
+    for (i = 0; i < filter->source_count; ++i)
+    {
+        struct parser_source *pin = filter->sources[i];
+
+        if (!pin->pin.pin.peer)
+            continue;
+
+        IMemAllocator_Decommit(pin->pin.pAllocator);
+
+        WakeConditionVariable(&pin->eos_cv);
+        WaitForSingleObject(pin->thread, INFINITE);
+        CloseHandle(pin->thread);
+        pin->thread = NULL;
+    }
+
+    return S_OK;
+}
+
+static const struct strmbase_filter_ops filter_ops =
+{
+    .filter_get_pin = parser_get_pin,
+    .filter_destroy = parser_destroy,
+    .filter_init_stream = parser_init_stream,
+    .filter_cleanup_stream = parser_cleanup_stream,
+};
+
+static inline struct parser *impl_from_strmbase_sink(struct strmbase_sink *iface)
+{
+    return CONTAINING_RECORD(iface, struct parser, sink);
+}
+
+static HRESULT sink_query_accept(struct strmbase_pin *iface, const AM_MEDIA_TYPE *mt)
+{
+    if (IsEqualGUID(&mt->majortype, &MEDIATYPE_Stream))
+        return S_OK;
+    return S_FALSE;
+}
+
+static HRESULT parser_sink_connect(struct strmbase_sink *iface, IPin *peer, const AM_MEDIA_TYPE *pmt)
+{
+    struct parser *filter = impl_from_strmbase_sink(iface);
+    LONGLONG file_size, unused;
+    HRESULT hr = S_OK;
+    unsigned int i;
+
+    filter->reader = NULL;
+    if (FAILED(hr = IPin_QueryInterface(peer, &IID_IAsyncReader, (void **)&filter->reader)))
+        return hr;
+
+    IAsyncReader_Length(filter->reader, &file_size, &unused);
+
+    filter->sink_connected = true;
+    filter->read_thread = CreateThread(NULL, 0, read_thread, filter, 0, NULL);
+
+    if (FAILED(hr = wg_parser_connect(filter->wg_parser, file_size)))
+        goto err;
+
+    if (!filter->init_gst(filter))
+    {
+        hr = E_FAIL;
+        goto err;
+    }
+
+    for (i = 0; i < filter->source_count; ++i)
+    {
+        struct parser_source *pin = filter->sources[i];
+
+        pin->seek.llDuration = pin->seek.llStop = wg_parser_stream_get_duration(pin->wg_stream);
+        pin->seek.llCurrent = 0;
+    }
+
+    return S_OK;
+err:
+    GST_RemoveOutputPins(filter);
+    IAsyncReader_Release(filter->reader);
+    filter->reader = NULL;
+    return hr;
+}
+
+static void parser_sink_disconnect(struct strmbase_sink *iface)
+{
+    struct parser *filter = impl_from_strmbase_sink(iface);
+
+    GST_RemoveOutputPins(filter);
+
+    IAsyncReader_Release(filter->reader);
+    filter->reader = NULL;
+}
+
+static const struct strmbase_sink_ops sink_ops =
+{
+    .base.pin_query_accept = sink_query_accept,
+    .sink_connect = parser_sink_connect,
+    .sink_disconnect = parser_sink_disconnect,
+};
+
+static BOOL decodebin_parser_filter_init_gst(struct parser *filter)
+{
+    struct wg_parser *parser = filter->wg_parser;
+    const char *sgi = getenv("SteamGameId");
+    const WCHAR *format;
+    unsigned int i, stream_count;
+    WCHAR source_name[20];
+
+    /* King of Fighters XIII requests the WMV decoder filter pins by name
+     * to connect them to a Sample Grabber filter.
+     */
+    format = (sgi && !strcmp(sgi, "222940")) ? L"out%u" : L"Stream %02u";
+
+    stream_count = wg_parser_get_stream_count(parser);
+    for (i = 0; i < stream_count; ++i)
+    {
+        swprintf(source_name, ARRAY_SIZE(source_name), format, i);
+        if (!create_pin(filter, wg_parser_get_stream(parser, i), source_name))
+            return FALSE;
+    }
+
+    return TRUE;
+}
+
+static HRESULT decodebin_parser_source_query_accept(struct parser_source *pin, const AM_MEDIA_TYPE *mt)
+{
+    struct wg_format format;
+
+    /* At least make sure we can convert it to wg_format. */
+    return amt_to_wg_format(mt, &format) ? S_OK : S_FALSE;
+}
+
+static HRESULT decodebin_parser_source_get_media_type(struct parser_source *pin,
+        unsigned int index, AM_MEDIA_TYPE *mt)
+{
+    struct wg_format format;
+
+    static const enum wg_video_format video_formats[] =
+    {
+        /* Try to prefer YUV formats over RGB ones. Most decoders output in the
+         * YUV color space, and it's generally much less expensive for
+         * videoconvert to do YUV -> YUV transformations. */
+        WG_VIDEO_FORMAT_AYUV,
+        WG_VIDEO_FORMAT_I420,
+        WG_VIDEO_FORMAT_YV12,
+        WG_VIDEO_FORMAT_YUY2,
+        WG_VIDEO_FORMAT_UYVY,
+        WG_VIDEO_FORMAT_YVYU,
+        WG_VIDEO_FORMAT_NV12,
+        WG_VIDEO_FORMAT_BGRA,
+        WG_VIDEO_FORMAT_BGRx,
+        WG_VIDEO_FORMAT_BGR,
+        WG_VIDEO_FORMAT_RGB16,
+        WG_VIDEO_FORMAT_RGB15,
+    };
+
+    wg_parser_stream_get_preferred_format(pin->wg_stream, &format);
+
+    memset(mt, 0, sizeof(AM_MEDIA_TYPE));
+
+    if (amt_from_wg_format(mt, &format, false))
+    {
+        if (!index--)
+            return S_OK;
+        FreeMediaType(mt);
+    }
+
+    if (format.major_type == WG_MAJOR_TYPE_VIDEO && index < ARRAY_SIZE(video_formats))
+    {
+        format.u.video.format = video_formats[index];
+        if (!amt_from_wg_format(mt, &format, false))
+            return E_OUTOFMEMORY;
+        return S_OK;
+    }
+    else if (format.major_type == WG_MAJOR_TYPE_AUDIO && !index)
+    {
+        format.u.audio.format = WG_AUDIO_FORMAT_S16LE;
+        if (!amt_from_wg_format(mt, &format, false))
+            return E_OUTOFMEMORY;
+        return S_OK;
+    }
+
+    return VFW_S_NO_MORE_ITEMS;
+}
+
+static BOOL parser_init_gstreamer(void)
+{
+    if (!init_gstreamer())
+        return FALSE;
+    return TRUE;
+}
+
+HRESULT decodebin_parser_create(IUnknown *outer, IUnknown **out)
+{
+    struct parser *object;
+
+    if (!parser_init_gstreamer())
+        return E_FAIL;
+
+    if (!(object = calloc(1, sizeof(*object))))
+        return E_OUTOFMEMORY;
+
+    if (!(object->wg_parser = wg_parser_create(WG_PARSER_DECODEBIN, true)))
+    {
+        free(object);
+        return E_OUTOFMEMORY;
+    }
+
+    strmbase_filter_init(&object->filter, outer, &CLSID_decodebin_parser, &filter_ops);
+    strmbase_sink_init(&object->sink, &object->filter, L"input pin", &sink_ops, NULL);
+
+    object->init_gst = decodebin_parser_filter_init_gst;
+    object->source_query_accept = decodebin_parser_source_query_accept;
+    object->source_get_media_type = decodebin_parser_source_get_media_type;
+
+    TRACE("Created GStreamer demuxer %p.\n", object);
+    *out = &object->filter.IUnknown_inner;
+    return S_OK;
+}
+
+static struct parser *impl_from_IAMStreamSelect(IAMStreamSelect *iface)
+{
+    return CONTAINING_RECORD(iface, struct parser, IAMStreamSelect_iface);
+}
+
+static HRESULT WINAPI stream_select_QueryInterface(IAMStreamSelect *iface, REFIID iid, void **out)
+{
+    struct parser *filter = impl_from_IAMStreamSelect(iface);
+    return IUnknown_QueryInterface(filter->filter.outer_unk, iid, out);
+}
+
+static ULONG WINAPI stream_select_AddRef(IAMStreamSelect *iface)
+{
+    struct parser *filter = impl_from_IAMStreamSelect(iface);
+    return IUnknown_AddRef(filter->filter.outer_unk);
+}
+
+static ULONG WINAPI stream_select_Release(IAMStreamSelect *iface)
+{
+    struct parser *filter = impl_from_IAMStreamSelect(iface);
+    return IUnknown_Release(filter->filter.outer_unk);
+}
+
+static HRESULT WINAPI stream_select_Count(IAMStreamSelect *iface, DWORD *count)
+{
+    FIXME("iface %p, count %p, stub!\n", iface, count);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI stream_select_Info(IAMStreamSelect *iface, LONG index,
+        AM_MEDIA_TYPE **mt, DWORD *flags, LCID *lcid, DWORD *group, WCHAR **name,
+        IUnknown **object, IUnknown **unknown)
+{
+    FIXME("iface %p, index %d, mt %p, flags %p, lcid %p, group %p, name %p, object %p, unknown %p, stub!\n",
+            iface, index, mt, flags, lcid, group, name, object, unknown);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI stream_select_Enable(IAMStreamSelect *iface, LONG index, DWORD flags)
+{
+    FIXME("iface %p, index %d, flags %#x, stub!\n", iface, index, flags);
+    return E_NOTIMPL;
+}
+
+static const IAMStreamSelectVtbl stream_select_vtbl =
+{
+    stream_select_QueryInterface,
+    stream_select_AddRef,
+    stream_select_Release,
+    stream_select_Count,
+    stream_select_Info,
+    stream_select_Enable,
+};
+
+static HRESULT WINAPI GST_ChangeCurrent(IMediaSeeking *iface)
+{
+    struct parser_source *This = impl_from_IMediaSeeking(iface);
+    TRACE("(%p)\n", This);
+    return S_OK;
+}
+
+static HRESULT WINAPI GST_ChangeStop(IMediaSeeking *iface)
+{
+    struct parser_source *This = impl_from_IMediaSeeking(iface);
+    TRACE("(%p)\n", This);
+    return S_OK;
+}
+
+static HRESULT WINAPI GST_ChangeRate(IMediaSeeking *iface)
+{
+    struct parser_source *pin = impl_from_IMediaSeeking(iface);
+
+    wg_parser_stream_seek(pin->wg_stream, pin->seek.dRate, 0, 0,
+            AM_SEEKING_NoPositioning, AM_SEEKING_NoPositioning);
+    return S_OK;
+}
+
+static HRESULT WINAPI GST_Seeking_QueryInterface(IMediaSeeking *iface, REFIID riid, void **ppv)
+{
+    struct parser_source *This = impl_from_IMediaSeeking(iface);
+    return IPin_QueryInterface(&This->pin.pin.IPin_iface, riid, ppv);
+}
+
+static ULONG WINAPI GST_Seeking_AddRef(IMediaSeeking *iface)
+{
+    struct parser_source *This = impl_from_IMediaSeeking(iface);
+    return IPin_AddRef(&This->pin.pin.IPin_iface);
+}
+
+static ULONG WINAPI GST_Seeking_Release(IMediaSeeking *iface)
+{
+    struct parser_source *This = impl_from_IMediaSeeking(iface);
+    return IPin_Release(&This->pin.pin.IPin_iface);
+}
+
+static HRESULT WINAPI GST_Seeking_SetPositions(IMediaSeeking *iface,
+        LONGLONG *current, DWORD current_flags, LONGLONG *stop, DWORD stop_flags)
+{
+    struct parser_source *pin = impl_from_IMediaSeeking(iface);
+    struct parser *filter = impl_from_strmbase_filter(pin->pin.pin.filter);
+    int i;
+
+    TRACE("pin %p, current %s, current_flags %#x, stop %s, stop_flags %#x.\n",
+            pin, current ? debugstr_time(*current) : "<null>", current_flags,
+            stop ? debugstr_time(*stop) : "<null>", stop_flags);
+
+    if (pin->pin.pin.filter->state == State_Stopped)
+    {
+        SourceSeekingImpl_SetPositions(iface, current, current_flags, stop, stop_flags);
+        return S_OK;
+    }
+
+    if (!(current_flags & AM_SEEKING_NoFlush))
+    {
+        for (i = 0; i < filter->source_count; ++i)
+        {
+            if (filter->sources[i]->pin.pin.peer)
+                IPin_BeginFlush(filter->sources[i]->pin.pin.peer);
+        }
+
+        if (filter->reader)
+            IAsyncReader_BeginFlush(filter->reader);
+    }
+
+    /* Acquire the flushing locks. This blocks the streaming threads, and
+     * ensures the seek is serialized between flushes. */
+    for (i = 0; i < filter->source_count; ++i)
+    {
+        struct parser_source *flush_pin = filter->sources[i];
+
+        if (flush_pin->pin.pin.peer)
+            EnterCriticalSection(&flush_pin->flushing_cs);
+    }
+
+    SourceSeekingImpl_SetPositions(iface, current, current_flags, stop, stop_flags);
+
+    wg_parser_stream_seek(pin->wg_stream, pin->seek.dRate,
+            pin->seek.llCurrent, pin->seek.llStop, current_flags, stop_flags);
+
+    if (!(current_flags & AM_SEEKING_NoFlush))
+    {
+        for (i = 0; i < filter->source_count; ++i)
+        {
+            struct parser_source *flush_pin = filter->sources[i];
+
+            if (flush_pin->pin.pin.peer)
+                IPin_EndFlush(flush_pin->pin.pin.peer);
+        }
+
+        if (filter->reader)
+            IAsyncReader_EndFlush(filter->reader);
+    }
+
+    /* Release the flushing locks. */
+    for (i = filter->source_count - 1; i >= 0; --i)
+    {
+        struct parser_source *flush_pin = filter->sources[i];
+
+        flush_pin->need_segment = true;
+        flush_pin->eos = false;
+
+        if (flush_pin->pin.pin.peer)
+        {
+            LeaveCriticalSection(&flush_pin->flushing_cs);
+            WakeConditionVariable(&flush_pin->eos_cv);
+        }
+    }
+
+    return S_OK;
+}
+
+static const IMediaSeekingVtbl GST_Seeking_Vtbl =
+{
+    GST_Seeking_QueryInterface,
+    GST_Seeking_AddRef,
+    GST_Seeking_Release,
+    SourceSeekingImpl_GetCapabilities,
+    SourceSeekingImpl_CheckCapabilities,
+    SourceSeekingImpl_IsFormatSupported,
+    SourceSeekingImpl_QueryPreferredFormat,
+    SourceSeekingImpl_GetTimeFormat,
+    SourceSeekingImpl_IsUsingTimeFormat,
+    SourceSeekingImpl_SetTimeFormat,
+    SourceSeekingImpl_GetDuration,
+    SourceSeekingImpl_GetStopPosition,
+    SourceSeekingImpl_GetCurrentPosition,
+    SourceSeekingImpl_ConvertTimeFormat,
+    GST_Seeking_SetPositions,
+    SourceSeekingImpl_GetPositions,
+    SourceSeekingImpl_GetAvailable,
+    SourceSeekingImpl_SetRate,
+    SourceSeekingImpl_GetRate,
+    SourceSeekingImpl_GetPreroll
+};
+
+static inline struct parser_source *impl_from_IQualityControl( IQualityControl *iface )
+{
+    return CONTAINING_RECORD(iface, struct parser_source, IQualityControl_iface);
+}
+
+static HRESULT WINAPI GST_QualityControl_QueryInterface(IQualityControl *iface, REFIID riid, void **ppv)
+{
+    struct parser_source *pin = impl_from_IQualityControl(iface);
+    return IPin_QueryInterface(&pin->pin.pin.IPin_iface, riid, ppv);
+}
+
+static ULONG WINAPI GST_QualityControl_AddRef(IQualityControl *iface)
+{
+    struct parser_source *pin = impl_from_IQualityControl(iface);
+    return IPin_AddRef(&pin->pin.pin.IPin_iface);
+}
+
+static ULONG WINAPI GST_QualityControl_Release(IQualityControl *iface)
+{
+    struct parser_source *pin = impl_from_IQualityControl(iface);
+    return IPin_Release(&pin->pin.pin.IPin_iface);
+}
+
+static HRESULT WINAPI GST_QualityControl_Notify(IQualityControl *iface, IBaseFilter *sender, Quality q)
+{
+    struct parser_source *pin = impl_from_IQualityControl(iface);
+    uint64_t timestamp;
+    int64_t diff;
+
+    TRACE("pin %p, sender %p, type %s, proportion %u, late %s, timestamp %s.\n",
+            pin, sender, q.Type == Famine ? "Famine" : "Flood", q.Proportion,
+            debugstr_time(q.Late), debugstr_time(q.TimeStamp));
+
+    /* DirectShow filters sometimes pass negative timestamps (Audiosurf uses the
+     * current time instead of the time of the last buffer). GstClockTime is
+     * unsigned, so clamp it to 0. */
+    timestamp = max(q.TimeStamp, 0);
+
+    /* The documentation specifies that timestamp + diff must be nonnegative. */
+    diff = q.Late;
+    if (diff < 0 && timestamp < (uint64_t)-diff)
+        diff = -timestamp;
+
+    /* DirectShow "Proportion" describes what percentage of buffers the upstream
+     * filter should keep (i.e. dropping the rest). If frames are late, the
+     * proportion will be less than 1. For example, a proportion of 500 means
+     * that the element should drop half of its frames, essentially because
+     * frames are taking twice as long as they should to arrive.
+     *
+     * GStreamer "proportion" is the inverse of this; it describes how much
+     * faster the upstream element should produce frames. I.e. if frames are
+     * taking twice as long as they should to arrive, we want the frames to be
+     * decoded twice as fast, and so we pass 2.0 to GStreamer. */
+
+    if (!q.Proportion)
+    {
+        WARN("Ignoring quality message with zero proportion.\n");
+        return S_OK;
+    }
+
+    /* GST_QOS_TYPE_OVERFLOW is also used for buffers that arrive on time, but
+     * DirectShow filters might use Famine, so check that there actually is an
+     * underrun. */
+    wg_parser_stream_notify_qos(pin->wg_stream, q.Type == Famine && q.Proportion < 1000,
+            1000.0 / q.Proportion, diff, timestamp);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI GST_QualityControl_SetSink(IQualityControl *iface, IQualityControl *tonotify)
+{
+    struct parser_source *pin = impl_from_IQualityControl(iface);
+    TRACE("(%p)->(%p)\n", pin, pin);
+    /* Do nothing */
+    return S_OK;
+}
+
+static const IQualityControlVtbl GSTOutPin_QualityControl_Vtbl = {
+    GST_QualityControl_QueryInterface,
+    GST_QualityControl_AddRef,
+    GST_QualityControl_Release,
+    GST_QualityControl_Notify,
+    GST_QualityControl_SetSink
+};
+
+static inline struct parser_source *impl_source_from_IPin(IPin *iface)
+{
+    return CONTAINING_RECORD(iface, struct parser_source, pin.pin.IPin_iface);
+}
+
+static HRESULT source_query_interface(struct strmbase_pin *iface, REFIID iid, void **out)
+{
+    struct parser_source *pin = impl_source_from_IPin(&iface->IPin_iface);
+
+    if (IsEqualGUID(iid, &IID_IMediaSeeking))
+        *out = &pin->seek.IMediaSeeking_iface;
+    else if (IsEqualGUID(iid, &IID_IQualityControl))
+        *out = &pin->IQualityControl_iface;
+    else
+        return E_NOINTERFACE;
+
+    IUnknown_AddRef((IUnknown *)*out);
+    return S_OK;
+}
+
+static HRESULT source_query_accept(struct strmbase_pin *iface, const AM_MEDIA_TYPE *mt)
+{
+    struct parser_source *pin = impl_source_from_IPin(&iface->IPin_iface);
+    struct parser *filter = impl_from_strmbase_filter(iface->filter);
+    return filter->source_query_accept(pin, mt);
+}
+
+static HRESULT source_get_media_type(struct strmbase_pin *iface, unsigned int index, AM_MEDIA_TYPE *mt)
+{
+    struct parser_source *pin = impl_source_from_IPin(&iface->IPin_iface);
+    struct parser *filter = impl_from_strmbase_filter(iface->filter);
+    return filter->source_get_media_type(pin, index, mt);
+}
+
+static HRESULT WINAPI GSTOutPin_DecideBufferSize(struct strmbase_source *iface,
+        IMemAllocator *allocator, ALLOCATOR_PROPERTIES *props)
+{
+    struct parser_source *pin = impl_source_from_IPin(&iface->pin.IPin_iface);
+    unsigned int buffer_size = 16384;
+    ALLOCATOR_PROPERTIES ret_props;
+    struct wg_format format;
+    bool ret;
+
+    if (IsEqualGUID(&pin->pin.pin.mt.formattype, &FORMAT_VideoInfo))
+    {
+        VIDEOINFOHEADER *format = (VIDEOINFOHEADER *)pin->pin.pin.mt.pbFormat;
+        buffer_size = format->bmiHeader.biSizeImage;
+    }
+    else if (IsEqualGUID(&pin->pin.pin.mt.formattype, &FORMAT_WaveFormatEx)
+            && (IsEqualGUID(&pin->pin.pin.mt.subtype, &MEDIASUBTYPE_PCM)
+            || IsEqualGUID(&pin->pin.pin.mt.subtype, &MEDIASUBTYPE_IEEE_FLOAT)))
+    {
+        WAVEFORMATEX *format = (WAVEFORMATEX *)pin->pin.pin.mt.pbFormat;
+        buffer_size = format->nAvgBytesPerSec;
+    }
+
+    ret = amt_to_wg_format(&pin->pin.pin.mt, &format);
+    assert(ret);
+    wg_parser_stream_enable(pin->wg_stream, &format, NULL, STREAM_ENABLE_FLAG_FLIP_RGB);
+
+    /* We do need to drop any buffers that might have been sent with the old
+     * caps, but this will be handled in parser_init_stream(). */
+
+    props->cBuffers = max(props->cBuffers, 1);
+    props->cbBuffer = max(props->cbBuffer, buffer_size);
+    props->cbAlign = max(props->cbAlign, 1);
+    return IMemAllocator_SetProperties(allocator, props, &ret_props);
+}
+
+static void source_disconnect(struct strmbase_source *iface)
+{
+    struct parser_source *pin = impl_source_from_IPin(&iface->pin.IPin_iface);
+
+    wg_parser_stream_disable(pin->wg_stream);
+}
+
+static void free_source_pin(struct parser_source *pin)
+{
+    if (pin->pin.pin.peer)
+    {
+        if (SUCCEEDED(IMemAllocator_Decommit(pin->pin.pAllocator)))
+            IPin_Disconnect(pin->pin.pin.peer);
+        IPin_Disconnect(&pin->pin.pin.IPin_iface);
+    }
+
+    pin->flushing_cs.DebugInfo->Spare[0] = 0;
+    DeleteCriticalSection(&pin->flushing_cs);
+
+    strmbase_seeking_cleanup(&pin->seek);
+    strmbase_source_cleanup(&pin->pin);
+    free(pin);
+}
+
+static const struct strmbase_source_ops source_ops =
+{
+    .base.pin_query_interface = source_query_interface,
+    .base.pin_query_accept = source_query_accept,
+    .base.pin_get_media_type = source_get_media_type,
+    .pfnAttemptConnection = BaseOutputPinImpl_AttemptConnection,
+    .pfnDecideAllocator = BaseOutputPinImpl_DecideAllocator,
+    .pfnDecideBufferSize = GSTOutPin_DecideBufferSize,
+    .source_disconnect = source_disconnect,
+};
+
+static struct parser_source *create_pin(struct parser *filter,
+        struct wg_parser_stream *stream, const WCHAR *name)
+{
+    struct parser_source *pin, **new_array;
+
+    if (!(new_array = realloc(filter->sources, (filter->source_count + 1) * sizeof(*filter->sources))))
+        return NULL;
+    filter->sources = new_array;
+
+    if (!(pin = calloc(1, sizeof(*pin))))
+        return NULL;
+
+    pin->wg_stream = stream;
+    strmbase_source_init(&pin->pin, &filter->filter, name, &source_ops);
+    pin->IQualityControl_iface.lpVtbl = &GSTOutPin_QualityControl_Vtbl;
+    strmbase_seeking_init(&pin->seek, &GST_Seeking_Vtbl, GST_ChangeStop,
+            GST_ChangeCurrent, GST_ChangeRate);
+    BaseFilterImpl_IncrementPinVersion(&filter->filter);
+
+    InitializeCriticalSection(&pin->flushing_cs);
+    pin->flushing_cs.DebugInfo->Spare[0] = (DWORD_PTR)(__FILE__ ": pin.flushing_cs");
+    InitializeConditionVariable(&pin->eos_cv);
+
+    filter->sources[filter->source_count++] = pin;
+    return pin;
+}
+
+static HRESULT GST_RemoveOutputPins(struct parser *This)
+{
+    unsigned int i;
+
+    TRACE("(%p)\n", This);
+
+    if (!This->sink_connected)
+        return S_OK;
+
+    wg_parser_disconnect(This->wg_parser);
+
+    /* read_thread() needs to stay alive to service any read requests GStreamer
+     * sends, so we can only shut it down after GStreamer stops. */
+    This->sink_connected = false;
+    WaitForSingleObject(This->read_thread, INFINITE);
+    CloseHandle(This->read_thread);
+
+    for (i = 0; i < This->source_count; ++i)
+    {
+        if (This->sources[i])
+            free_source_pin(This->sources[i]);
+    }
+
+    This->source_count = 0;
+    free(This->sources);
+    This->sources = NULL;
+
+    BaseFilterImpl_IncrementPinVersion(&This->filter);
+    return S_OK;
+}
+
+static BOOL compare_media_types(const AM_MEDIA_TYPE *a, const AM_MEDIA_TYPE *b)
+{
+    return IsEqualGUID(&a->majortype, &b->majortype)
+            && IsEqualGUID(&a->subtype, &b->subtype)
+            && IsEqualGUID(&a->formattype, &b->formattype)
+            && a->cbFormat == b->cbFormat
+            && !memcmp(a->pbFormat, b->pbFormat, a->cbFormat);
+}
+
+static HRESULT wave_parser_sink_query_accept(struct strmbase_pin *iface, const AM_MEDIA_TYPE *mt)
+{
+    if (!IsEqualGUID(&mt->majortype, &MEDIATYPE_Stream))
+        return S_FALSE;
+    if (IsEqualGUID(&mt->subtype, &MEDIASUBTYPE_WAVE))
+        return S_OK;
+    if (IsEqualGUID(&mt->subtype, &MEDIASUBTYPE_AU) || IsEqualGUID(&mt->subtype, &MEDIASUBTYPE_AIFF))
+        FIXME("AU and AIFF files are not yet supported.\n");
+    return S_FALSE;
+}
+
+static const struct strmbase_sink_ops wave_parser_sink_ops =
+{
+    .base.pin_query_accept = wave_parser_sink_query_accept,
+    .sink_connect = parser_sink_connect,
+    .sink_disconnect = parser_sink_disconnect,
+};
+
+static BOOL wave_parser_filter_init_gst(struct parser *filter)
+{
+    struct wg_parser *parser = filter->wg_parser;
+
+    if (!create_pin(filter, wg_parser_get_stream(parser, 0), L"output"))
+        return FALSE;
+
+    return TRUE;
+}
+
+static HRESULT wave_parser_source_query_accept(struct parser_source *pin, const AM_MEDIA_TYPE *mt)
+{
+    struct wg_format format;
+    AM_MEDIA_TYPE pad_mt;
+    HRESULT hr;
+
+    wg_parser_stream_get_preferred_format(pin->wg_stream, &format);
+    if (!amt_from_wg_format(&pad_mt, &format, false))
+        return E_OUTOFMEMORY;
+    hr = compare_media_types(mt, &pad_mt) ? S_OK : S_FALSE;
+    FreeMediaType(&pad_mt);
+    return hr;
+}
+
+static HRESULT wave_parser_source_get_media_type(struct parser_source *pin,
+        unsigned int index, AM_MEDIA_TYPE *mt)
+{
+    struct wg_format format;
+
+    if (index > 0)
+        return VFW_S_NO_MORE_ITEMS;
+    wg_parser_stream_get_preferred_format(pin->wg_stream, &format);
+    if (!amt_from_wg_format(mt, &format, false))
+        return E_OUTOFMEMORY;
+    return S_OK;
+}
+
+HRESULT wave_parser_create(IUnknown *outer, IUnknown **out)
+{
+    struct parser *object;
+
+    if (!parser_init_gstreamer())
+        return E_FAIL;
+
+    if (!(object = calloc(1, sizeof(*object))))
+        return E_OUTOFMEMORY;
+
+    if (!(object->wg_parser = wg_parser_create(WG_PARSER_WAVPARSE, false)))
+    {
+        free(object);
+        return E_OUTOFMEMORY;
+    }
+
+    strmbase_filter_init(&object->filter, outer, &CLSID_WAVEParser, &filter_ops);
+    strmbase_sink_init(&object->sink, &object->filter, L"input pin", &wave_parser_sink_ops, NULL);
+    object->init_gst = wave_parser_filter_init_gst;
+    object->source_query_accept = wave_parser_source_query_accept;
+    object->source_get_media_type = wave_parser_source_get_media_type;
+
+    TRACE("Created WAVE parser %p.\n", object);
+    *out = &object->filter.IUnknown_inner;
+    return S_OK;
+}
+
+static HRESULT avi_splitter_sink_query_accept(struct strmbase_pin *iface, const AM_MEDIA_TYPE *mt)
+{
+    if (IsEqualGUID(&mt->majortype, &MEDIATYPE_Stream)
+            && IsEqualGUID(&mt->subtype, &MEDIASUBTYPE_Avi))
+        return S_OK;
+    return S_FALSE;
+}
+
+static const struct strmbase_sink_ops avi_splitter_sink_ops =
+{
+    .base.pin_query_accept = avi_splitter_sink_query_accept,
+    .sink_connect = parser_sink_connect,
+    .sink_disconnect = parser_sink_disconnect,
+};
+
+static BOOL avi_splitter_filter_init_gst(struct parser *filter)
+{
+    struct wg_parser *parser = filter->wg_parser;
+    uint32_t i, stream_count;
+    WCHAR source_name[20];
+
+    stream_count = wg_parser_get_stream_count(parser);
+    for (i = 0; i < stream_count; ++i)
+    {
+        swprintf(source_name, ARRAY_SIZE(source_name), L"Stream %02u", i);
+        if (!create_pin(filter, wg_parser_get_stream(parser, i), source_name))
+            return FALSE;
+    }
+
+    return TRUE;
+}
+
+static HRESULT avi_splitter_source_query_accept(struct parser_source *pin, const AM_MEDIA_TYPE *mt)
+{
+    struct wg_format format;
+    AM_MEDIA_TYPE pad_mt;
+    HRESULT hr;
+
+    wg_parser_stream_get_preferred_format(pin->wg_stream, &format);
+    if (!amt_from_wg_format(&pad_mt, &format, false))
+        return E_OUTOFMEMORY;
+    hr = compare_media_types(mt, &pad_mt) ? S_OK : S_FALSE;
+    FreeMediaType(&pad_mt);
+    return hr;
+}
+
+static HRESULT avi_splitter_source_get_media_type(struct parser_source *pin,
+        unsigned int index, AM_MEDIA_TYPE *mt)
+{
+    struct wg_format format;
+
+    if (index > 0)
+        return VFW_S_NO_MORE_ITEMS;
+    wg_parser_stream_get_preferred_format(pin->wg_stream, &format);
+    if (!amt_from_wg_format(mt, &format, false))
+        return E_OUTOFMEMORY;
+    return S_OK;
+}
+
+HRESULT avi_splitter_create(IUnknown *outer, IUnknown **out)
+{
+    struct parser *object;
+
+    if (!parser_init_gstreamer())
+        return E_FAIL;
+
+    if (!(object = calloc(1, sizeof(*object))))
+        return E_OUTOFMEMORY;
+
+    if (!(object->wg_parser = wg_parser_create(WG_PARSER_AVIDEMUX, false)))
+    {
+        free(object);
+        return E_OUTOFMEMORY;
+    }
+
+    strmbase_filter_init(&object->filter, outer, &CLSID_AviSplitter, &filter_ops);
+    strmbase_sink_init(&object->sink, &object->filter, L"input pin", &avi_splitter_sink_ops, NULL);
+    object->init_gst = avi_splitter_filter_init_gst;
+    object->source_query_accept = avi_splitter_source_query_accept;
+    object->source_get_media_type = avi_splitter_source_get_media_type;
+
+    TRACE("Created AVI splitter %p.\n", object);
+    *out = &object->filter.IUnknown_inner;
+    return S_OK;
+}
+
+static HRESULT mpeg_splitter_sink_query_accept(struct strmbase_pin *iface, const AM_MEDIA_TYPE *mt)
+{
+    if (!IsEqualGUID(&mt->majortype, &MEDIATYPE_Stream))
+        return S_FALSE;
+    if (IsEqualGUID(&mt->subtype, &MEDIASUBTYPE_MPEG1Audio))
+        return S_OK;
+    if (IsEqualGUID(&mt->subtype, &MEDIASUBTYPE_MPEG1Video)
+            || IsEqualGUID(&mt->subtype, &MEDIASUBTYPE_MPEG1System)
+            || IsEqualGUID(&mt->subtype, &MEDIASUBTYPE_MPEG1VideoCD))
+        FIXME("Unsupported subtype %s.\n", wine_dbgstr_guid(&mt->subtype));
+    return S_FALSE;
+}
+
+static const struct strmbase_sink_ops mpeg_splitter_sink_ops =
+{
+    .base.pin_query_accept = mpeg_splitter_sink_query_accept,
+    .sink_connect = parser_sink_connect,
+    .sink_disconnect = parser_sink_disconnect,
+};
+
+static BOOL mpeg_splitter_filter_init_gst(struct parser *filter)
+{
+    struct wg_parser *parser = filter->wg_parser;
+
+    if (!create_pin(filter, wg_parser_get_stream(parser, 0), L"Audio"))
+        return FALSE;
+
+    return TRUE;
+}
+
+static HRESULT mpeg_splitter_source_query_accept(struct parser_source *pin, const AM_MEDIA_TYPE *mt)
+{
+    struct wg_format format;
+    AM_MEDIA_TYPE pad_mt;
+    HRESULT hr;
+
+    wg_parser_stream_get_preferred_format(pin->wg_stream, &format);
+    if (!amt_from_wg_format(&pad_mt, &format, false))
+        return E_OUTOFMEMORY;
+    hr = compare_media_types(mt, &pad_mt) ? S_OK : S_FALSE;
+    FreeMediaType(&pad_mt);
+    return hr;
+}
+
+static HRESULT mpeg_splitter_source_get_media_type(struct parser_source *pin,
+        unsigned int index, AM_MEDIA_TYPE *mt)
+{
+    struct wg_format format;
+
+    if (index > 0)
+        return VFW_S_NO_MORE_ITEMS;
+    wg_parser_stream_get_preferred_format(pin->wg_stream, &format);
+    if (!amt_from_wg_format(mt, &format, false))
+        return E_OUTOFMEMORY;
+    return S_OK;
+}
+
+static HRESULT mpeg_splitter_query_interface(struct strmbase_filter *iface, REFIID iid, void **out)
+{
+    struct parser *filter = impl_from_strmbase_filter(iface);
+
+    if (IsEqualGUID(iid, &IID_IAMStreamSelect))
+    {
+        *out = &filter->IAMStreamSelect_iface;
+        IUnknown_AddRef((IUnknown *)*out);
+        return S_OK;
+    }
+
+    return E_NOINTERFACE;
+}
+
+static const struct strmbase_filter_ops mpeg_splitter_ops =
+{
+    .filter_query_interface = mpeg_splitter_query_interface,
+    .filter_get_pin = parser_get_pin,
+    .filter_destroy = parser_destroy,
+    .filter_init_stream = parser_init_stream,
+    .filter_cleanup_stream = parser_cleanup_stream,
+};
+
+HRESULT mpeg_splitter_create(IUnknown *outer, IUnknown **out)
+{
+    struct parser *object;
+
+    if (!parser_init_gstreamer())
+        return E_FAIL;
+
+    if (!(object = calloc(1, sizeof(*object))))
+        return E_OUTOFMEMORY;
+
+    if (!(object->wg_parser = wg_parser_create(WG_PARSER_MPEGAUDIOPARSE, false)))
+    {
+        free(object);
+        return E_OUTOFMEMORY;
+    }
+
+    strmbase_filter_init(&object->filter, outer, &CLSID_MPEG1Splitter, &mpeg_splitter_ops);
+    strmbase_sink_init(&object->sink, &object->filter, L"Input", &mpeg_splitter_sink_ops, NULL);
+    object->IAMStreamSelect_iface.lpVtbl = &stream_select_vtbl;
+
+    object->init_gst = mpeg_splitter_filter_init_gst;
+    object->source_query_accept = mpeg_splitter_source_query_accept;
+    object->source_get_media_type = mpeg_splitter_source_get_media_type;
+    object->enum_sink_first = TRUE;
+
+    TRACE("Created MPEG-1 splitter %p.\n", object);
+    *out = &object->filter.IUnknown_inner;
+    return S_OK;
+}
diff --git a/dlls/mfplat/queue.c b/dlls/mfplat/queue.c
index 6ee0df37dce..8279929b46e 100644
--- wine/dlls/mfplat/queue.c
+++ wine/dlls/mfplat/queue.c
@@ -16,7 +16,13 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
+#include <stdarg.h>
+
 #define COBJMACROS
+#define NONAMELESSUNION
+
+#include "wine/debug.h"
+#include "wine/list.h"
 
 #include "mfplat_private.h"
 #include "rtworkq.h"
@@ -41,7 +47,7 @@ HRESULT WINAPI MFPutWorkItem(DWORD queue, IMFAsyncCallback *callback, IUnknown *
     IRtwqAsyncResult *result;
     HRESULT hr;
 
-    TRACE("%#lx, %p, %p.\n", queue, callback, state);
+    TRACE("%#x, %p, %p.\n", queue, callback, state);
 
     if (FAILED(hr = RtwqCreateAsyncResult(NULL, (IRtwqAsyncCallback *)callback, state, &result)))
         return hr;
@@ -61,7 +67,7 @@ HRESULT WINAPI MFPutWorkItem2(DWORD queue, LONG priority, IMFAsyncCallback *call
     IRtwqAsyncResult *result;
     HRESULT hr;
 
-    TRACE("%#lx, %ld, %p, %p.\n", queue, priority, callback, state);
+    TRACE("%#x, %d, %p, %p.\n", queue, priority, callback, state);
 
     if (FAILED(hr = RtwqCreateAsyncResult(NULL, (IRtwqAsyncCallback *)callback, state, &result)))
         return hr;
@@ -78,7 +84,7 @@ HRESULT WINAPI MFPutWorkItem2(DWORD queue, LONG priority, IMFAsyncCallback *call
  */
 HRESULT WINAPI MFPutWorkItemEx(DWORD queue, IMFAsyncResult *result)
 {
-    TRACE("%#lx, %p\n", queue, result);
+    TRACE("%#x, %p\n", queue, result);
 
     return RtwqPutWorkItem(queue, 0, (IRtwqAsyncResult *)result);
 }
@@ -88,7 +94,7 @@ HRESULT WINAPI MFPutWorkItemEx(DWORD queue, IMFAsyncResult *result)
  */
 HRESULT WINAPI MFPutWorkItemEx2(DWORD queue, LONG priority, IMFAsyncResult *result)
 {
-    TRACE("%#lx, %ld, %p\n", queue, priority, result);
+    TRACE("%#x, %d, %p\n", queue, priority, result);
 
     return RtwqPutWorkItem(queue, priority, (IRtwqAsyncResult *)result);
 }
diff --git a/dlls/mfplat/rsrc.rc b/dlls/mfplat/rsrc.rc
new file mode 100644
index 00000000000..592bcb01138
--- /dev/null
+++ wine/dlls/mfplat/rsrc.rc
@@ -0,0 +1,28 @@
+/*
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#define WINE_FILEDESCRIPTION_STR "Wine GStreamer"
+#define WINE_FILENAME_STR "winegstreamer.dll"
+#define WINE_FILEVERSION 0,0,1,0
+#define WINE_FILEVERSION_STR "0.0.1.0"
+#define WINE_PRODUCTVERSION 0,0,1,0
+#define WINE_PRODUCTVERSION_STR "1.0.1.0"
+#define WINE_EXTRAVALUES VALUE "OLESelfRegister",""
+
+#include "wine/wine_common_ver.rc"
+
+/* @makedep: winegstreamer.rgs */
+1 WINE_REGISTRY winegstreamer.rgs
diff --git a/dlls/mfplat/sample.c b/dlls/mfplat/sample.c
index 8ef80eb5f24..04c68c87199 100644
--- wine/dlls/mfplat/sample.c
+++ wine/dlls/mfplat/sample.c
@@ -25,6 +25,7 @@
 #include "initguid.h"
 #include "dxva2api.h"
 
+#include "wine/debug.h"
 #include "wine/list.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(mfplat);
@@ -150,7 +151,7 @@ static ULONG WINAPI sample_AddRef(IMFSample *iface)
     struct sample *sample = impl_from_IMFSample(iface);
     ULONG refcount = InterlockedIncrement(&sample->attributes.ref);
 
-    TRACE("%p, refcount %lu.\n", iface, refcount);
+    TRACE("%p, refcount %u.\n", iface, refcount);
 
     return refcount;
 }
@@ -171,7 +172,7 @@ static ULONG WINAPI sample_Release(IMFSample *iface)
     struct sample *sample = impl_from_IMFSample(iface);
     ULONG refcount = InterlockedDecrement(&sample->attributes.ref);
 
-    TRACE("%p, refcount %lu.\n", iface, refcount);
+    TRACE("%p, refcount %u.\n", iface, refcount);
 
     if (!refcount)
         release_sample_object(sample);
@@ -194,14 +195,14 @@ static ULONG WINAPI sample_tracked_Release(IMFSample *iface)
 
         /* Call could fail if queue system is not initialized, it's not critical. */
         if (FAILED(hr = RtwqInvokeCallback(tracked_result)))
-            WARN("Failed to invoke tracking callback, hr %#lx.\n", hr);
+            WARN("Failed to invoke tracking callback, hr %#x.\n", hr);
         IRtwqAsyncResult_Release(tracked_result);
     }
     LeaveCriticalSection(&sample->attributes.cs);
 
     refcount = InterlockedDecrement(&sample->attributes.ref);
 
-    TRACE("%p, refcount %lu.\n", iface, refcount);
+    TRACE("%p, refcount %u.\n", iface, refcount);
 
     if (!refcount)
         release_sample_object(sample);
@@ -497,7 +498,7 @@ static HRESULT WINAPI sample_SetSampleFlags(IMFSample *iface, DWORD flags)
 {
     struct sample *sample = impl_from_IMFSample(iface);
 
-    TRACE("%p, %#lx.\n", iface, flags);
+    TRACE("%p, %#x.\n", iface, flags);
 
     EnterCriticalSection(&sample->attributes.cs);
     sample->flags = flags;
@@ -589,7 +590,7 @@ static HRESULT WINAPI sample_GetBufferByIndex(IMFSample *iface, DWORD index, IMF
     struct sample *sample = impl_from_IMFSample(iface);
     HRESULT hr = S_OK;
 
-    TRACE("%p, %lu, %p.\n", iface, index, buffer);
+    TRACE("%p, %u, %p.\n", iface, index, buffer);
 
     EnterCriticalSection(&sample->attributes.cs);
     if (index < sample->buffer_count)
@@ -741,7 +742,7 @@ static HRESULT WINAPI sample_RemoveBufferByIndex(IMFSample *iface, DWORD index)
     struct sample *sample = impl_from_IMFSample(iface);
     HRESULT hr = S_OK;
 
-    TRACE("%p, %lu.\n", iface, index);
+    TRACE("%p, %u.\n", iface, index);
 
     EnterCriticalSection(&sample->attributes.cs);
     if (index < sample->buffer_count)
@@ -1097,7 +1098,7 @@ static ULONG WINAPI sample_allocator_AddRef(IMFVideoSampleAllocatorEx *iface)
     struct sample_allocator *allocator = impl_from_IMFVideoSampleAllocatorEx(iface);
     ULONG refcount = InterlockedIncrement(&allocator->refcount);
 
-    TRACE("%p, refcount %lu.\n", iface, refcount);
+    TRACE("%p, refcount %u.\n", iface, refcount);
 
     return refcount;
 }
@@ -1167,7 +1168,7 @@ static ULONG WINAPI sample_allocator_Release(IMFVideoSampleAllocatorEx *iface)
     struct sample_allocator *allocator = impl_from_IMFVideoSampleAllocatorEx(iface);
     ULONG refcount = InterlockedDecrement(&allocator->refcount);
 
-    TRACE("%p, refcount %lu.\n", iface, refcount);
+    TRACE("%p, refcount %u.\n", iface, refcount);
 
     if (!refcount)
     {
@@ -1265,7 +1266,7 @@ static HRESULT sample_allocator_get_surface_service(struct sample_allocator *all
             if (FAILED(hr = IDirect3DDeviceManager9_GetVideoService(allocator->d3d9_device_manager, service->hdevice,
                     &IID_IDirectXVideoProcessorService, (void **)&service->dxva_service)))
             {
-                WARN("Failed to get DXVA processor service, hr %#lx.\n", hr);
+                WARN("Failed to get DXVA processor service, hr %#x.\n", hr);
                 IDirect3DDeviceManager9_CloseDeviceHandle(allocator->d3d9_device_manager, service->hdevice);
             }
         }
@@ -1277,7 +1278,7 @@ static HRESULT sample_allocator_get_surface_service(struct sample_allocator *all
             if (FAILED(hr = IMFDXGIDeviceManager_GetVideoService(allocator->dxgi_device_manager, service->hdevice,
                     &IID_ID3D11Device, (void **)&service->d3d11_device)))
             {
-                WARN("Failed to get D3D11 device, hr %#lx.\n", hr);
+                WARN("Failed to get D3D11 device, hr %#x.\n", hr);
                 IMFDXGIDeviceManager_CloseDeviceHandle(allocator->dxgi_device_manager, service->hdevice);
             }
         }
@@ -1487,7 +1488,7 @@ static HRESULT WINAPI sample_allocator_InitializeSampleAllocator(IMFVideoSampleA
     struct sample_allocator *allocator = impl_from_IMFVideoSampleAllocatorEx(iface);
     HRESULT hr;
 
-    TRACE("%p, %lu, %p.\n", iface, sample_count, media_type);
+    TRACE("%p, %u, %p.\n", iface, sample_count, media_type);
 
     if (!sample_count)
         return E_INVALIDARG;
@@ -1584,7 +1585,7 @@ static HRESULT WINAPI sample_allocator_InitializeSampleAllocatorEx(IMFVideoSampl
     struct sample_allocator *allocator = impl_from_IMFVideoSampleAllocatorEx(iface);
     HRESULT hr;
 
-    TRACE("%p, %lu, %lu, %p, %p.\n", iface, initial_sample_count, max_sample_count, attributes, media_type);
+    TRACE("%p, %u, %u, %p, %p.\n", iface, initial_sample_count, max_sample_count, attributes, media_type);
 
     EnterCriticalSection(&allocator->cs);
 
diff --git a/dlls/mfplat/tests/Makefile.in b/dlls/mfplat/tests/Makefile.in
index ae9cc378933..d5ef14e88f0 100644
--- wine/dlls/mfplat/tests/Makefile.in
+++ wine/dlls/mfplat/tests/Makefile.in
@@ -1,3 +1,4 @@
+EXTRADEFS = -DWINE_NO_LONG_TYPES
 TESTDLL   = mfplat.dll
 IMPORTS   = ole32 mfplat user32 d3d9 dxva2 mfuuid propsys uuid strmiids
 
diff --git a/dlls/mfplat/tests/mfplat.c b/dlls/mfplat/tests/mfplat.c
index 8d21f2ed60e..20577453fe3 100644
--- wine/dlls/mfplat/tests/mfplat.c
+++ wine/dlls/mfplat/tests/mfplat.c
@@ -72,7 +72,7 @@ static void _expect_ref(IUnknown *obj, ULONG ref, int line)
     ULONG rc;
     IUnknown_AddRef(obj);
     rc = IUnknown_Release(obj);
-    ok_(__FILE__,line)(rc == ref, "Unexpected refcount %ld, expected %ld.\n", rc, ref);
+    ok_(__FILE__,line)(rc == ref, "Unexpected refcount %d, expected %d.\n", rc, ref);
 }
 
 static ULONG get_refcount(void *iface)
@@ -92,7 +92,7 @@ static void check_interface_(unsigned int line, void *iface_ptr, REFIID iid, BOO
     expected_hr = supported ? S_OK : E_NOINTERFACE;
 
     hr = IUnknown_QueryInterface(iface, iid, (void **)&unk);
-    ok_(__FILE__, line)(hr == expected_hr, "Got hr %#lx, expected %#lx.\n", hr, expected_hr);
+    ok_(__FILE__, line)(hr == expected_hr, "Got hr %#x, expected %#x.\n", hr, expected_hr);
     if (SUCCEEDED(hr))
         IUnknown_Release(unk);
 }
@@ -112,7 +112,7 @@ static void check_service_interface_(unsigned int line, void *iface_ptr, REFGUID
         hr = IMFGetService_GetService(gs, service, iid, (void **)&unk);
         IMFGetService_Release(gs);
     }
-    ok_(__FILE__, line)(hr == expected_hr, "Got hr %#lx, expected %#lx.\n", hr, expected_hr);
+    ok_(__FILE__, line)(hr == expected_hr, "Got hr %#x, expected %#x.\n", hr, expected_hr);
     if (SUCCEEDED(hr))
         IUnknown_Release(unk);
 }
@@ -143,7 +143,7 @@ static void init_d3d11_resource_readback(ID3D11Resource *resource, ID3D11Resourc
     if (FAILED(hr = ID3D11DeviceContext_Map(rb->immediate_context,
             rb->resource, sub_resource_idx, D3D11_MAP_READ, 0, &rb->map_desc)))
     {
-        trace("Failed to map resource, hr %#lx.\n", hr);
+        trace("Failed to map resource, hr %#x.\n", hr);
         ID3D11Resource_Release(rb->resource);
         rb->resource = NULL;
         ID3D11DeviceContext_Release(rb->immediate_context);
@@ -171,7 +171,7 @@ static void get_d3d11_texture2d_readback(ID3D11Texture2D *texture, unsigned int
     texture_desc.MiscFlags = 0;
     if (FAILED(hr = ID3D11Device_CreateTexture2D(device, &texture_desc, NULL, (ID3D11Texture2D **)&rb_texture)))
     {
-        trace("Failed to create texture, hr %#lx.\n", hr);
+        trace("Failed to create texture, hr %#x.\n", hr);
         ID3D11Device_Release(device);
         return;
     }
@@ -317,7 +317,7 @@ static WCHAR *load_resource(const WCHAR *name)
 
     file = CreateFileW(pathW, GENERIC_READ|GENERIC_WRITE, 0,
                        NULL, CREATE_ALWAYS, 0, 0);
-    ok(file != INVALID_HANDLE_VALUE, "file creation failed, at %s, error %ld\n",
+    ok(file != INVALID_HANDLE_VALUE, "file creation failed, at %s, error %d\n",
        wine_dbgstr_w(pathW), GetLastError());
 
     res = FindResourceW(NULL, name, (LPCWSTR)RT_RCDATA);
@@ -418,57 +418,57 @@ static void test_register(void)
         win_skip("Not enough permissions to register a transform.\n");
         return;
     }
-    ok(ret == S_OK, "Failed to register dummy transform, hr %#lx.\n", ret);
+    ok(ret == S_OK, "Failed to register dummy transform, hr %#x.\n", ret);
 
 if(0)
 {
     /* NULL name crashes on windows */
     ret = MFTRegister(DUMMY_CLSID, MFT_CATEGORY_OTHER, NULL, 0, 1, input, 1, output, NULL);
-    ok(ret == E_INVALIDARG, "Unexpected hr %#lx.\n", ret);
+    ok(ret == E_INVALIDARG, "got %x\n", ret);
 }
 
     ret = MFTRegister(DUMMY_CLSID, MFT_CATEGORY_OTHER, name, 0, 0, NULL, 0, NULL, NULL);
-    ok(ret == S_OK, "Failed to register dummy filter: %lx\n", ret);
+    ok(ret == S_OK, "Failed to register dummy filter: %x\n", ret);
 
     ret = MFTRegister(DUMMY_CLSID, MFT_CATEGORY_OTHER, name, 0, 1, NULL, 0, NULL, NULL);
-    ok(ret == S_OK, "Failed to register dummy filter: %lx\n", ret);
+    ok(ret == S_OK, "Failed to register dummy filter: %x\n", ret);
 
     ret = MFTRegister(DUMMY_CLSID, MFT_CATEGORY_OTHER, name, 0, 0, NULL, 1, NULL, NULL);
-    ok(ret == S_OK, "Failed to register dummy filter: %lx\n", ret);
+    ok(ret == S_OK, "Failed to register dummy filter: %x\n", ret);
 
 if(0)
 {
     /* NULL clsids/count crashes on windows (vista) */
     count = 0;
     ret = MFTEnum(MFT_CATEGORY_OTHER, 0, NULL, NULL, NULL, NULL, &count);
-    ok(ret == E_POINTER, "Failed to enumerate filters: %lx\n", ret);
+    ok(ret == E_POINTER, "Failed to enumerate filters: %x\n", ret);
     ok(count == 0, "Expected count == 0\n");
 
     clsids = NULL;
     ret = MFTEnum(MFT_CATEGORY_OTHER, 0, NULL, NULL, NULL, &clsids, NULL);
-    ok(ret == E_POINTER, "Failed to enumerate filters: %lx\n", ret);
+    ok(ret == E_POINTER, "Failed to enumerate filters: %x\n", ret);
 }
     hr = MFTGetInfo(DUMMY_CLSID, &mft_name, NULL, NULL, NULL, NULL, NULL);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(!lstrcmpW(mft_name, L"Wine test"), "Unexpected name %s.\n", wine_dbgstr_w(mft_name));
     CoTaskMemFree(mft_name);
 
     hr = MFTGetInfo(DUMMY_CLSID, NULL, NULL, NULL, NULL, NULL, NULL);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     in_count = out_count = 1;
     hr = MFTGetInfo(DUMMY_CLSID, NULL, NULL, &in_count, NULL, &out_count, NULL);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(!in_count, "Unexpected count %u.\n", in_count);
     ok(!out_count, "Unexpected count %u.\n", out_count);
 
     hr = MFTGetInfo(DUMMY_CLSID, NULL, NULL, NULL, NULL, NULL, &attributes);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(!!attributes, "Unexpected attributes.\n");
     IMFAttributes_Release(attributes);
 
     hr = MFTGetInfo(DUMMY_CLSID, &mft_name, &in_types, &in_count, &out_types, &out_count, &attributes);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(!lstrcmpW(mft_name, L"Wine test"), "Unexpected name %s.\n", wine_dbgstr_w(mft_name));
     ok(!!in_types, "Unexpected pointer.\n");
     ok(!!out_types, "Unexpected pointer.\n");
@@ -485,7 +485,7 @@ if(0)
     ok(!!attributes, "Unexpected attributes.\n");
     count = 1;
     hr = IMFAttributes_GetCount(attributes, &count);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(!count, "Unexpected count %u.\n", count);
     CoTaskMemFree(mft_name);
     CoTaskMemFree(in_types);
@@ -495,7 +495,7 @@ if(0)
     count = 0;
     clsids = NULL;
     ret = MFTEnum(MFT_CATEGORY_OTHER, 0, NULL, NULL, NULL, &clsids, &count);
-    ok(ret == S_OK, "Failed to enumerate filters: %lx\n", ret);
+    ok(ret == S_OK, "Failed to enumerate filters: %x\n", ret);
     ok(count > 0, "Expected count > 0\n");
     ok(clsids != NULL, "Expected clsids != NULL\n");
     ok(check_clsid(clsids, count), "Filter was not part of enumeration\n");
@@ -504,7 +504,7 @@ if(0)
     count = 0;
     clsids = NULL;
     ret = MFTEnum(MFT_CATEGORY_OTHER, 0, input, NULL, NULL, &clsids, &count);
-    ok(ret == S_OK, "Failed to enumerate filters: %lx\n", ret);
+    ok(ret == S_OK, "Failed to enumerate filters: %x\n", ret);
     ok(count > 0, "Expected count > 0\n");
     ok(clsids != NULL, "Expected clsids != NULL\n");
     ok(check_clsid(clsids, count), "Filter was not part of enumeration\n");
@@ -513,7 +513,7 @@ if(0)
     count = 0;
     clsids = NULL;
     ret = MFTEnum(MFT_CATEGORY_OTHER, 0, NULL, output, NULL, &clsids, &count);
-    ok(ret == S_OK, "Failed to enumerate filters: %lx\n", ret);
+    ok(ret == S_OK, "Failed to enumerate filters: %x\n", ret);
     ok(count > 0, "Expected count > 0\n");
     ok(clsids != NULL, "Expected clsids != NULL\n");
     ok(check_clsid(clsids, count), "Filter was not part of enumeration\n");
@@ -522,7 +522,7 @@ if(0)
     count = 0;
     clsids = NULL;
     ret = MFTEnum(MFT_CATEGORY_OTHER, 0, input, output, NULL, &clsids, &count);
-    ok(ret == S_OK, "Failed to enumerate filters: %lx\n", ret);
+    ok(ret == S_OK, "Failed to enumerate filters: %x\n", ret);
     ok(count > 0, "Expected count > 0\n");
     ok(clsids != NULL, "Expected clsids != NULL\n");
     ok(check_clsid(clsids, count), "Filter was not part of enumeration\n");
@@ -532,17 +532,17 @@ if(0)
     count = 0;
     clsids = NULL;
     ret = MFTEnum(MFT_CATEGORY_OTHER, 0, output, input, NULL, &clsids, &count);
-    ok(ret == S_OK, "Failed to enumerate filters: %lx\n", ret);
+    ok(ret == S_OK, "Failed to enumerate filters: %x\n", ret);
     ok(!count, "got %d\n", count);
     ok(clsids == NULL, "Expected clsids == NULL\n");
 
     ret = MFTUnregister(DUMMY_CLSID);
     ok(ret == S_OK ||
        /* w7pro64 */
-       broken(ret == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)), "Unexpected hr %#lx.\n", ret);
+       broken(ret == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)), "got %x\n", ret);
 
     ret = MFTUnregister(DUMMY_CLSID);
-    ok(ret == S_OK || broken(ret == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)), "Unexpected hr %#lx.\n", ret);
+    ok(ret == S_OK || broken(ret == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)), "got %x\n", ret);
 }
 
 static HRESULT WINAPI test_create_from_url_callback_Invoke(IMFAsyncCallback *iface, IMFAsyncResult *result)
@@ -559,10 +559,10 @@ static HRESULT WINAPI test_create_from_url_callback_Invoke(IMFAsyncCallback *ifa
 
     object = NULL;
     hr = IMFSourceResolver_EndCreateObjectFromURL(resolver, result, &obj_type, &object);
-    ok(hr == S_OK, "Failed to create an object, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to create an object, hr %#x.\n", hr);
 
     hr = IMFAsyncResult_GetObject(result, &object2);
-    ok(hr == S_OK, "Failed to get result object, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get result object, hr %#x.\n", hr);
     ok(object2 == object, "Unexpected object.\n");
 
     if (object)
@@ -596,12 +596,12 @@ static HRESULT WINAPI test_create_from_file_handler_callback_Invoke(IMFAsyncCall
     handler = (IMFSchemeHandler *)IMFAsyncResult_GetStateNoAddRef(result);
 
     hr = IMFSchemeHandler_EndCreateObject(handler, result, &obj_type, &object);
-    ok(hr == S_OK, "Failed to create an object, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to create an object, hr %#x.\n", hr);
 
     if (SUCCEEDED(hr))
     {
         hr = IMFAsyncResult_GetObject(result, &object2);
-        ok(hr == E_POINTER, "Unexpected hr %#lx.\n", hr);
+        ok(hr == E_POINTER, "Unexpected hr %#x.\n", hr);
 
         IUnknown_Release(object);
     }
@@ -631,7 +631,7 @@ static HRESULT WINAPI source_events_callback_Invoke(IMFAsyncCallback *iface, IMF
     generator = (IMFMediaEventGenerator *)IMFAsyncResult_GetStateNoAddRef(result);
 
     hr = IMFMediaEventGenerator_EndGetEvent(generator, result, &callback->media_event);
-    ok(hr == S_OK, "Failed to create an object, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to create an object, hr %#x.\n", hr);
 
     SetEvent(callback->event);
 
@@ -673,7 +673,7 @@ static BOOL get_event(IMFMediaEventGenerator *generator, MediaEventType expected
     {
         hr = IMFMediaEventGenerator_BeginGetEvent(generator, &callback->IMFAsyncCallback_iface,
                 (IUnknown *)generator);
-        ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+        ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
         if (WaitForSingleObject(callback->event, 1000) == WAIT_TIMEOUT)
         {
@@ -684,14 +684,14 @@ static BOOL get_event(IMFMediaEventGenerator *generator, MediaEventType expected
         Sleep(10);
 
         hr = IMFMediaEvent_GetType(callback->media_event, &event_type);
-        ok(hr == S_OK, "Failed to event type, hr %#lx.\n", hr);
+        ok(hr == S_OK, "Failed to event type, hr %#x.\n", hr);
 
         if ((ret = (event_type == expected_event_type)))
         {
             if (value)
             {
                 hr = IMFMediaEvent_GetValue(callback->media_event, value);
-                ok(hr == S_OK, "Failed to get value of event, hr %#lx.\n", hr);
+                ok(hr == S_OK, "Failed to get value of event, hr %#x.\n", hr);
             }
 
             break;
@@ -743,16 +743,16 @@ static void test_source_resolver(void)
     callback2 = create_test_callback(&test_create_from_file_handler_callback_vtbl);
 
     hr = MFStartup(MF_VERSION, MFSTARTUP_FULL);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "got 0x%08x\n", hr);
 
     hr = pMFCreateSourceResolver(NULL);
-    ok(hr == E_POINTER, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "got %#x\n", hr);
 
     hr = pMFCreateSourceResolver(&resolver);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "got %#x\n", hr);
 
     hr = pMFCreateSourceResolver(&resolver2);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "got %#x\n", hr);
     ok(resolver != resolver2, "Expected new instance\n");
 
     IMFSourceResolver_Release(resolver2);
@@ -760,20 +760,20 @@ static void test_source_resolver(void)
     filename = load_resource(L"test.mp4");
 
     hr = MFCreateFile(MF_ACCESSMODE_READ, MF_OPENMODE_FAIL_IF_NOT_EXIST, MF_FILEFLAGS_NONE, filename, &stream);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "got 0x%08x\n", hr);
 
     hr = IMFSourceResolver_CreateObjectFromByteStream(
         resolver, NULL, NULL, MF_RESOLUTION_MEDIASOURCE, NULL,
         &obj_type, (IUnknown **)&mediasource);
-    ok(hr == E_POINTER, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "got 0x%08x\n", hr);
 
     hr = IMFSourceResolver_CreateObjectFromByteStream(resolver, stream, NULL, MF_RESOLUTION_MEDIASOURCE, NULL,
             NULL, (IUnknown **)&mediasource);
-    ok(hr == E_POINTER, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "got 0x%08x\n", hr);
 
     hr = IMFSourceResolver_CreateObjectFromByteStream(resolver, stream, NULL, MF_RESOLUTION_MEDIASOURCE, NULL,
             &obj_type, NULL);
-    ok(hr == E_POINTER, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "got 0x%08x\n", hr);
 
     IMFByteStream_Release(stream);
 
@@ -782,16 +782,16 @@ static void test_source_resolver(void)
 
     hr = IMFSourceResolver_CreateObjectFromURL(resolver, L"nonexisting.mp4", MF_RESOLUTION_BYTESTREAM, NULL, &obj_type,
             (IUnknown **)&stream);
-    ok(hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND), "Unexpected hr %#lx.\n", hr);
+    ok(hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND), "Unexpected hr %#x.\n", hr);
 
     hr = IMFSourceResolver_CreateObjectFromURL(resolver, filename, MF_RESOLUTION_BYTESTREAM, NULL, &obj_type,
             (IUnknown **)&stream);
-    ok(hr == S_OK, "Failed to resolve url, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to resolve url, hr %#x.\n", hr);
     IMFByteStream_Release(stream);
 
     hr = IMFSourceResolver_BeginCreateObjectFromURL(resolver, filename, MF_RESOLUTION_BYTESTREAM, NULL,
             &cancel_cookie, &callback->IMFAsyncCallback_iface, (IUnknown *)resolver);
-    ok(hr == S_OK, "Create request failed, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Create request failed, hr %#x.\n", hr);
     ok(cancel_cookie != NULL, "Unexpected cancel object.\n");
     IUnknown_Release(cancel_cookie);
 
@@ -804,18 +804,18 @@ static void test_source_resolver(void)
 
     hr = IMFSourceResolver_CreateObjectFromURL(resolver, pathW, MF_RESOLUTION_BYTESTREAM, NULL, &obj_type,
             (IUnknown **)&stream);
-    ok(hr == S_OK, "Failed to resolve url, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to resolve url, hr %#x.\n", hr);
     IMFByteStream_Release(stream);
 
     /* We have to create a new bytestream here, because all following
      * calls to CreateObjectFromByteStream will fail. */
     hr = MFCreateFile(MF_ACCESSMODE_READ, MF_OPENMODE_FAIL_IF_NOT_EXIST, MF_FILEFLAGS_NONE, filename, &stream);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "got 0x%08x\n", hr);
 
     hr = IMFByteStream_QueryInterface(stream, &IID_IMFAttributes, (void **)&attributes);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "got 0x%08x\n", hr);
     hr = IMFAttributes_SetString(attributes, &MF_BYTESTREAM_CONTENT_TYPE, L"video/mp4");
-    ok(hr == S_OK, "Failed to set string value, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to set string value, hr %#x.\n", hr);
     IMFAttributes_Release(attributes);
 
     /* Start of gstreamer dependent tests */
@@ -823,14 +823,14 @@ static void test_source_resolver(void)
     hr = IMFSourceResolver_CreateObjectFromByteStream(resolver, stream, NULL, MF_RESOLUTION_MEDIASOURCE, NULL,
             &obj_type, (IUnknown **)&mediasource);
     if (strcmp(winetest_platform, "wine"))
-        ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+        ok(hr == S_OK, "got 0x%08x\n", hr);
     if (FAILED(hr))
     {
         IMFByteStream_Release(stream);
         IMFSourceResolver_Release(resolver);
 
         hr = MFShutdown();
-        ok(hr == S_OK, "Failed to shut down, hr %#lx.\n", hr);
+        ok(hr == S_OK, "Failed to shut down, hr %#x.\n", hr);
 
         DeleteFileW(filename);
         return;
@@ -842,98 +842,98 @@ static void test_source_resolver(void)
     check_service_interface(mediasource, &MF_RATE_CONTROL_SERVICE, &IID_IMFRateSupport, TRUE);
 
     hr = IMFMediaSource_QueryInterface(mediasource, &IID_IMFGetService, (void**)&get_service);
-    ok(hr == S_OK, "Failed to get service interface, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get service interface, hr %#x.\n", hr);
 
     hr = IMFGetService_GetService(get_service, &MF_RATE_CONTROL_SERVICE, &IID_IMFRateSupport, (void**)&rate_support);
-    ok(hr == S_OK, "Failed to get rate support interface, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get rate support interface, hr %#x.\n", hr);
 
     hr = IMFRateSupport_GetFastestRate(rate_support, MFRATE_FORWARD, FALSE, &rate);
-    ok(hr == S_OK, "Failed to query fastest rate, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to query fastest rate, hr %#x.\n", hr);
     ok(rate == 1e6f, "Unexpected fastest rate %f.\n", rate);
     hr = IMFRateSupport_GetFastestRate(rate_support, MFRATE_FORWARD, TRUE, &rate);
-    ok(hr == S_OK, "Failed to query fastest rate, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to query fastest rate, hr %#x.\n", hr);
     ok(rate == 1e6f, "Unexpected fastest rate %f.\n", rate);
     hr = IMFRateSupport_GetFastestRate(rate_support, MFRATE_REVERSE, FALSE, &rate);
-    ok(hr == S_OK, "Failed to query fastest rate, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to query fastest rate, hr %#x.\n", hr);
     ok(rate == -1e6f, "Unexpected fastest rate %f.\n", rate);
     hr = IMFRateSupport_GetFastestRate(rate_support, MFRATE_REVERSE, TRUE, &rate);
-    ok(hr == S_OK, "Failed to query fastest rate, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to query fastest rate, hr %#x.\n", hr);
     ok(rate == -1e6f, "Unexpected fastest rate %f.\n", rate);
 
     hr = IMFRateSupport_GetSlowestRate(rate_support, MFRATE_FORWARD, FALSE, &rate);
-    ok(hr == S_OK, "Failed to query slowest rate, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to query slowest rate, hr %#x.\n", hr);
     ok(rate == 0.0f, "Unexpected slowest rate %f.\n", rate);
     hr = IMFRateSupport_GetSlowestRate(rate_support, MFRATE_FORWARD, TRUE, &rate);
-    ok(hr == S_OK, "Failed to query slowest rate, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to query slowest rate, hr %#x.\n", hr);
     ok(rate == 0.0f, "Unexpected slowest rate %f.\n", rate);
     hr = IMFRateSupport_GetSlowestRate(rate_support, MFRATE_REVERSE, FALSE, &rate);
-    ok(hr == S_OK, "Failed to query slowest rate, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to query slowest rate, hr %#x.\n", hr);
     ok(rate == 0.0f, "Unexpected slowest rate %f.\n", rate);
     hr = IMFRateSupport_GetSlowestRate(rate_support, MFRATE_REVERSE, TRUE, &rate);
-    ok(hr == S_OK, "Failed to query slowest rate, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to query slowest rate, hr %#x.\n", hr);
     ok(rate == 0.0f, "Unexpected slowest rate %f.\n", rate);
 
     hr = IMFRateSupport_IsRateSupported(rate_support, FALSE, 0.0f, NULL);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     hr = IMFRateSupport_IsRateSupported(rate_support, FALSE, 0.0f, &rate);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(rate == 0.0f, "Unexpected rate %f.\n", rate);
 
     hr = IMFRateSupport_IsRateSupported(rate_support, FALSE, 1.0f, &rate);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(rate == 1.0f, "Unexpected rate %f.\n", rate);
     hr = IMFRateSupport_IsRateSupported(rate_support, FALSE, -1.0f, &rate);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(rate == -1.0f, "Unexpected rate %f.\n", rate);
     hr = IMFRateSupport_IsRateSupported(rate_support, FALSE, 1e6f + 1.0f, &rate);
-    ok(hr == MF_E_UNSUPPORTED_RATE, "Unexpected hr %#lx.\n", hr);
+    ok(hr == MF_E_UNSUPPORTED_RATE, "Unexpected hr %#x.\n", hr);
     ok(rate == 1e6f + 1.0f || broken(rate == 1e6f) /* Win7 */, "Unexpected %f.\n", rate);
     hr = IMFRateSupport_IsRateSupported(rate_support, FALSE, -1e6f, &rate);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(rate == -1e6f, "Unexpected rate %f.\n", rate);
 
     hr = IMFRateSupport_IsRateSupported(rate_support, FALSE, -1e6f - 1.0f, &rate);
-    ok(hr == MF_E_UNSUPPORTED_RATE, "Unexpected hr %#lx.\n", hr);
+    ok(hr == MF_E_UNSUPPORTED_RATE, "Unexpected hr %#x.\n", hr);
     ok(rate == -1e6f - 1.0f || broken(rate == -1e6f) /* Win7 */, "Unexpected rate %f.\n", rate);
 
     check_service_interface(mediasource, &MF_RATE_CONTROL_SERVICE, &IID_IMFRateControl, TRUE);
     hr = IMFMediaSource_CreatePresentationDescriptor(mediasource, &descriptor);
-    ok(hr == S_OK, "Failed to get presentation descriptor, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get presentation descriptor, hr %#x.\n", hr);
     ok(descriptor != NULL, "got %p\n", descriptor);
 
     hr = IMFPresentationDescriptor_GetStreamDescriptorByIndex(descriptor, 0, &selected, &sd);
-    ok(hr == S_OK, "Failed to get stream descriptor, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get stream descriptor, hr %#x.\n", hr);
 
     hr = IMFStreamDescriptor_GetMediaTypeHandler(sd, &handler);
-    ok(hr == S_OK, "Failed to get type handler, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get type handler, hr %#x.\n", hr);
     IMFStreamDescriptor_Release(sd);
 
     hr = IMFMediaTypeHandler_GetMajorType(handler, &guid);
-    ok(hr == S_OK, "Failed to get stream major type, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get stream major type, hr %#x.\n", hr);
 
     /* Check major/minor type for the test media. */
     ok(IsEqualGUID(&guid, &MFMediaType_Video), "Unexpected major type %s.\n", debugstr_guid(&guid));
 
     hr = IMFMediaTypeHandler_GetCurrentMediaType(handler, &media_type);
-    ok(hr == S_OK, "Failed to get current media type, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get current media type, hr %#x.\n", hr);
     hr = IMFMediaType_GetGUID(media_type, &MF_MT_SUBTYPE, &guid);
-    ok(hr == S_OK, "Failed to get media sub type, hr %#lx.\n", hr);
-    todo_wine
+    ok(hr == S_OK, "Failed to get media sub type, hr %#x.\n", hr);
+todo_wine
     ok(IsEqualGUID(&guid, &MFVideoFormat_M4S2), "Unexpected sub type %s.\n", debugstr_guid(&guid));
 
     hr = IMFMediaType_GetUINT32(media_type, &MF_MT_VIDEO_ROTATION, &rotation);
-    ok(hr == S_OK || broken(hr == MF_E_ATTRIBUTENOTFOUND) /* Win7 */, "Failed to get rotation, hr %#lx.\n", hr);
+    ok(hr == S_OK || broken(hr == MF_E_ATTRIBUTENOTFOUND) /* Win7 */, "Failed to get rotation, hr %#x.\n", hr);
     if (hr == S_OK)
         ok(rotation == MFVideoRotationFormat_0, "Got wrong rotation %u.\n", rotation);
 
     IMFMediaType_Release(media_type);
 
     hr = IMFPresentationDescriptor_SelectStream(descriptor, 0);
-    ok(hr == S_OK, "Failed to select video stream, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to select video stream, hr %#x.\n", hr);
 
     var.vt = VT_EMPTY;
     hr = IMFMediaSource_Start(mediasource, descriptor, &GUID_NULL, &var);
-    ok(hr == S_OK, "Failed to start media source, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to start media source, hr %#x.\n", hr);
 
     video_stream = NULL;
     if (get_event((IMFMediaEventGenerator *)mediasource, MENewStream, &var))
@@ -943,39 +943,39 @@ static void test_source_resolver(void)
     }
 
     hr = IMFMediaSource_Pause(mediasource);
-    ok(hr == S_OK, "Failed to pause media source, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to pause media source, hr %#x.\n", hr);
     if (get_event((IMFMediaEventGenerator *)mediasource, MESourcePaused, &var))
         ok(var.vt == VT_EMPTY, "Unexpected value type.\n");
 
     var.vt = VT_EMPTY;
     hr = IMFMediaSource_Start(mediasource, descriptor, &GUID_NULL, &var);
-    ok(hr == S_OK, "Failed to start media source, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to start media source, hr %#x.\n", hr);
 
     if (get_event((IMFMediaEventGenerator *)mediasource, MESourceStarted, &var))
         ok(var.vt == VT_EMPTY, "Unexpected value type.\n");
 
     hr = IMFMediaSource_Pause(mediasource);
-    ok(hr == S_OK, "Failed to pause media source, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to pause media source, hr %#x.\n", hr);
     if (get_event((IMFMediaEventGenerator *)mediasource, MESourcePaused, &var))
         ok(var.vt == VT_EMPTY, "Unexpected value type.\n");
 
     var.vt = VT_I8;
     var.uhVal.QuadPart = 0;
     hr = IMFMediaSource_Start(mediasource, descriptor, &GUID_NULL, &var);
-    ok(hr == S_OK, "Failed to start media source, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to start media source, hr %#x.\n", hr);
 
     if (get_event((IMFMediaEventGenerator *)mediasource, MESourceSeeked, &var))
         ok(var.vt == VT_I8, "Unexpected value type.\n");
 
     hr = IMFMediaSource_Stop(mediasource);
-    ok(hr == S_OK, "Failed to pause media source, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to pause media source, hr %#x.\n", hr);
     if (get_event((IMFMediaEventGenerator *)mediasource, MESourceStopped, &var))
         ok(var.vt == VT_EMPTY, "Unexpected value type.\n");
 
     var.vt = VT_I8;
     var.uhVal.QuadPart = 0;
     hr = IMFMediaSource_Start(mediasource, descriptor, &GUID_NULL, &var);
-    ok(hr == S_OK, "Failed to start media source, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to start media source, hr %#x.\n", hr);
 
     if (get_event((IMFMediaEventGenerator *)mediasource, MESourceStarted, &var))
         ok(var.vt == VT_I8, "Unexpected value type.\n");
@@ -985,7 +985,7 @@ static void test_source_resolver(void)
     for (i = 0; i < sample_count; ++i)
     {
         hr = IMFMediaStream_RequestSample(video_stream, NULL);
-        ok(hr == S_OK, "Failed to request sample %u, hr %#lx.\n", i + 1, hr);
+        ok(hr == S_OK, "Failed to request sample %u, hr %#x.\n", i + 1, hr);
         if (hr != S_OK)
             break;
     }
@@ -1007,15 +1007,15 @@ static void test_source_resolver(void)
         sample = (IMFSample *)var.punkVal;
 
         hr = IMFSample_GetBufferCount(sample, &buffer_count);
-        ok(hr == S_OK, "Failed to get buffer count, hr %#lx.\n", hr);
-        ok(buffer_count == 1, "Unexpected buffer count %lu.\n", buffer_count);
+        ok(hr == S_OK, "Failed to get buffer count, hr %#x.\n", hr);
+        ok(buffer_count == 1, "Unexpected buffer count %u.\n", buffer_count);
 
         hr = IMFSample_GetSampleDuration(sample, &duration);
-        ok(hr == S_OK, "Failed to get sample duration, hr %#lx.\n", hr);
+        ok(hr == S_OK, "Failed to get sample duration, hr %#x.\n", hr);
         ok(duration == 40 * MILLI_TO_100_NANO, "Unexpected duration %s.\n", wine_dbgstr_longlong(duration));
 
         hr = IMFSample_GetSampleTime(sample, &time);
-        ok(hr == S_OK, "Failed to get sample time, hr %#lx.\n", hr);
+        ok(hr == S_OK, "Failed to get sample time, hr %#x.\n", hr);
         ok(time == i * 40 * MILLI_TO_100_NANO, "Unexpected time %s.\n", wine_dbgstr_longlong(time));
 
         IMFSample_Release(sample);
@@ -1028,16 +1028,16 @@ static void test_source_resolver(void)
         /* MEEndOfStream isn't queued until after a one request beyond the last frame is submitted */
         Sleep(100);
         hr = IMFMediaEventGenerator_GetEvent((IMFMediaEventGenerator *)video_stream, MF_EVENT_FLAG_NO_WAIT, &event);
-        ok (hr == MF_E_NO_EVENTS_AVAILABLE, "Unexpected hr %#lx.\n", hr);
+        ok (hr == MF_E_NO_EVENTS_AVAILABLE, "Unexpected hr %#x.\n", hr);
 
         hr = IMFMediaStream_RequestSample(video_stream, NULL);
-        ok (hr == S_OK || hr == MF_E_END_OF_STREAM, "Unexpected hr %#lx.\n", hr);
+        ok (hr == S_OK || hr == MF_E_END_OF_STREAM, "Unexpected hr %#x.\n", hr);
         get_event((IMFMediaEventGenerator *)video_stream, MEEndOfStream, NULL);
     }
 
 
     hr = IMFMediaStream_RequestSample(video_stream, NULL);
-    ok(hr == MF_E_END_OF_STREAM, "Unexpected hr %#lx.\n", hr);
+    ok(hr == MF_E_END_OF_STREAM, "Unexpected hr %#x.\n", hr);
 
     get_event((IMFMediaEventGenerator *)mediasource, MEEndOfPresentation, NULL);
 
@@ -1046,10 +1046,10 @@ static void test_source_resolver(void)
     IMFPresentationDescriptor_Release(descriptor);
 
     hr = IMFMediaSource_Shutdown(mediasource);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IMFMediaSource_CreatePresentationDescriptor(mediasource, NULL);
-    ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#lx.\n", hr);
+    ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#x.\n", hr);
 
     IMFRateSupport_Release(rate_support);
     IMFGetService_Release(get_service);
@@ -1058,18 +1058,18 @@ static void test_source_resolver(void)
 
     /* Create directly through scheme handler. */
     hr = CoInitialize(NULL);
-    ok(SUCCEEDED(hr), "Failed to initialize, hr %#lx.\n", hr);
+    ok(SUCCEEDED(hr), "Failed to initialize, hr %#x.\n", hr);
     do_uninit = hr == S_OK;
 
     hr = CoCreateInstance(&CLSID_FileSchemePlugin, NULL, CLSCTX_INPROC_SERVER, &IID_IMFSchemeHandler,
             (void **)&scheme_handler);
-    ok(hr == S_OK, "Failed to create handler object, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to create handler object, hr %#x.\n", hr);
 
     callback2->event = callback->event;
     cancel_cookie = NULL;
     hr = IMFSchemeHandler_BeginCreateObject(scheme_handler, pathW, MF_RESOLUTION_MEDIASOURCE, NULL, &cancel_cookie,
             &callback2->IMFAsyncCallback_iface, (IUnknown *)scheme_handler);
-    ok(hr == S_OK, "Create request failed, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Create request failed, hr %#x.\n", hr);
     ok(!!cancel_cookie, "Unexpected cancel object.\n");
     IUnknown_Release(cancel_cookie);
 
@@ -1085,7 +1085,7 @@ static void test_source_resolver(void)
     IMFSourceResolver_Release(resolver);
 
     hr = MFShutdown();
-    ok(hr == S_OK, "Failed to shut down, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to shut down, hr %#x.\n", hr);
 
     IMFAsyncCallback_Release(&callback->IMFAsyncCallback_iface);
     IMFAsyncCallback_Release(&callback2->IMFAsyncCallback_iface);
@@ -1154,9 +1154,8 @@ static void test_media_type(void)
     IMFMediaType *mediatype, *mediatype2;
     IMFVideoMediaType *video_type;
     IUnknown *unk, *unk2;
+    DWORD count, flags;
     BOOL compressed;
-    DWORD flags;
-    UINT count;
     HRESULT hr;
     GUID guid;
 
@@ -1164,140 +1163,140 @@ if(0)
 {
     /* Crash on Windows Vista/7 */
     hr = MFCreateMediaType(NULL);
-    ok(hr == E_INVALIDARG, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "got 0x%08x\n", hr);
 }
 
     hr = MFCreateMediaType(&mediatype);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "got 0x%08x\n", hr);
 
     hr = IMFMediaType_GetMajorType(mediatype, &guid);
-    ok(hr == MF_E_ATTRIBUTENOTFOUND, "Unexpected hr %#lx.\n", hr);
+    ok(hr == MF_E_ATTRIBUTENOTFOUND, "Unexpected hr %#x.\n", hr);
 
     compressed = FALSE;
     hr = IMFMediaType_IsCompressedFormat(mediatype, &compressed);
-    ok(hr == S_OK, "Failed to get media type property, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get media type property, hr %#x.\n", hr);
     ok(compressed, "Unexpected value %d.\n", compressed);
 
     hr = IMFMediaType_SetUINT32(mediatype, &MF_MT_ALL_SAMPLES_INDEPENDENT, 0);
-    ok(hr == S_OK, "Failed to set attribute, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to set attribute, hr %#x.\n", hr);
 
     compressed = FALSE;
     hr = IMFMediaType_IsCompressedFormat(mediatype, &compressed);
-    ok(hr == S_OK, "Failed to get media type property, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get media type property, hr %#x.\n", hr);
     ok(compressed, "Unexpected value %d.\n", compressed);
 
     hr = IMFMediaType_SetUINT32(mediatype, &MF_MT_COMPRESSED, 0);
-    ok(hr == S_OK, "Failed to set attribute, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to set attribute, hr %#x.\n", hr);
 
     compressed = FALSE;
     hr = IMFMediaType_IsCompressedFormat(mediatype, &compressed);
-    ok(hr == S_OK, "Failed to get media type property, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get media type property, hr %#x.\n", hr);
     ok(compressed, "Unexpected value %d.\n", compressed);
 
     hr = IMFMediaType_SetUINT32(mediatype, &MF_MT_ALL_SAMPLES_INDEPENDENT, 1);
-    ok(hr == S_OK, "Failed to set attribute, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to set attribute, hr %#x.\n", hr);
 
     hr = IMFMediaType_SetUINT32(mediatype, &MF_MT_COMPRESSED, 1);
-    ok(hr == S_OK, "Failed to set attribute, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to set attribute, hr %#x.\n", hr);
 
     compressed = TRUE;
     hr = IMFMediaType_IsCompressedFormat(mediatype, &compressed);
-    ok(hr == S_OK, "Failed to get media type property, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get media type property, hr %#x.\n", hr);
     ok(!compressed, "Unexpected value %d.\n", compressed);
 
     hr = IMFMediaType_DeleteItem(mediatype, &MF_MT_COMPRESSED);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IMFMediaType_SetGUID(mediatype, &MF_MT_MAJOR_TYPE, &MFMediaType_Video);
-    ok(hr == S_OK, "Failed to set GUID value, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to set GUID value, hr %#x.\n", hr);
 
     hr = IMFMediaType_GetMajorType(mediatype, &guid);
-    ok(hr == S_OK, "Failed to get major type, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get major type, hr %#x.\n", hr);
     ok(IsEqualGUID(&guid, &MFMediaType_Video), "Unexpected major type.\n");
 
     /* IsEqual() */
     hr = MFCreateMediaType(&mediatype2);
-    ok(hr == S_OK, "Failed to create media type, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to create media type, hr %#x.\n", hr);
 
     flags = 0xdeadbeef;
     hr = IMFMediaType_IsEqual(mediatype, mediatype2, &flags);
-    ok(hr == E_INVALIDARG, "Unexpected hr %#lx.\n", hr);
-    ok(flags == 0, "Unexpected flags %#lx.\n", flags);
+    ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
+    ok(flags == 0, "Unexpected flags %#x.\n", flags);
 
     /* Different major types. */
     hr = IMFMediaType_SetGUID(mediatype2, &MF_MT_MAJOR_TYPE, &MFMediaType_Audio);
-    ok(hr == S_OK, "Failed to set major type, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to set major type, hr %#x.\n", hr);
 
     flags = 0;
     hr = IMFMediaType_IsEqual(mediatype, mediatype2, &flags);
-    ok(hr == S_FALSE, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Unexpected hr %#x.\n", hr);
     ok(flags == (MF_MEDIATYPE_EQUAL_FORMAT_TYPES | MF_MEDIATYPE_EQUAL_FORMAT_USER_DATA),
-            "Unexpected flags %#lx.\n", flags);
+            "Unexpected flags %#x.\n", flags);
 
     /* Same major types, different subtypes. */
     hr = IMFMediaType_SetGUID(mediatype2, &MF_MT_MAJOR_TYPE, &MFMediaType_Video);
-    ok(hr == S_OK, "Failed to set major type, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to set major type, hr %#x.\n", hr);
 
     flags = 0;
     hr = IMFMediaType_IsEqual(mediatype, mediatype2, &flags);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(flags == (MF_MEDIATYPE_EQUAL_MAJOR_TYPES | MF_MEDIATYPE_EQUAL_FORMAT_TYPES | MF_MEDIATYPE_EQUAL_FORMAT_DATA
-            | MF_MEDIATYPE_EQUAL_FORMAT_USER_DATA), "Unexpected flags %#lx.\n", flags);
+            | MF_MEDIATYPE_EQUAL_FORMAT_USER_DATA), "Unexpected flags %#x.\n", flags);
 
     /* Different user data. */
     hr = IMFMediaType_SetBlob(mediatype, &MF_MT_USER_DATA, (const UINT8 *)&flags, sizeof(flags));
-    ok(hr == S_OK, "Failed to set attribute, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to set attribute, hr %#x.\n", hr);
 
     flags = 0;
     hr = IMFMediaType_IsEqual(mediatype, mediatype2, &flags);
-    ok(hr == S_FALSE, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Unexpected hr %#x.\n", hr);
     ok(flags == (MF_MEDIATYPE_EQUAL_MAJOR_TYPES | MF_MEDIATYPE_EQUAL_FORMAT_TYPES | MF_MEDIATYPE_EQUAL_FORMAT_DATA),
-            "Unexpected flags %#lx.\n", flags);
+            "Unexpected flags %#x.\n", flags);
 
     hr = IMFMediaType_DeleteItem(mediatype, &MF_MT_USER_DATA);
-    ok(hr == S_OK, "Failed to delete item, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to delete item, hr %#x.\n", hr);
 
     hr = IMFMediaType_SetGUID(mediatype, &MF_MT_SUBTYPE, &MFVideoFormat_RGB32);
-    ok(hr == S_OK, "Failed to set subtype, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to set subtype, hr %#x.\n", hr);
 
     flags = 0;
     hr = IMFMediaType_IsEqual(mediatype, mediatype2, &flags);
-    ok(hr == S_FALSE, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Unexpected hr %#x.\n", hr);
     ok(flags == (MF_MEDIATYPE_EQUAL_MAJOR_TYPES | MF_MEDIATYPE_EQUAL_FORMAT_DATA | MF_MEDIATYPE_EQUAL_FORMAT_USER_DATA),
-            "Unexpected flags %#lx.\n", flags);
+            "Unexpected flags %#x.\n", flags);
 
     IMFMediaType_Release(mediatype2);
     IMFMediaType_Release(mediatype);
 
     /* IMFVideoMediaType */
     hr = MFCreateMediaType(&mediatype);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     check_interface(mediatype, &IID_IMFVideoMediaType, FALSE);
 
     hr = IMFMediaType_QueryInterface(mediatype, &IID_IUnknown, (void **)&unk);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(unk == (IUnknown *)mediatype, "Unexpected pointer.\n");
     IUnknown_Release(unk);
 
     hr = IMFMediaType_SetGUID(mediatype, &MF_MT_MAJOR_TYPE, &MFMediaType_Video);
-    ok(hr == S_OK, "Failed to set GUID value, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to set GUID value, hr %#x.\n", hr);
 
     hr = IMFMediaType_QueryInterface(mediatype, &IID_IMFVideoMediaType, (void **)&unk);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IUnknown_QueryInterface(unk, &IID_IUnknown, (void **)&unk2);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(unk2 == (IUnknown *)mediatype, "Unexpected pointer.\n");
     IUnknown_Release(unk2);
 
     hr = IUnknown_QueryInterface(unk, &IID_IMFAttributes, (void **)&unk2);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(unk2 == (IUnknown *)mediatype, "Unexpected pointer.\n");
     IUnknown_Release(unk2);
 
     hr = IUnknown_QueryInterface(unk, &IID_IMFMediaType, (void **)&unk2);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(unk2 == (IUnknown *)mediatype, "Unexpected pointer.\n");
     IUnknown_Release(unk2);
 
@@ -1307,20 +1306,20 @@ if(0)
     if (pMFCreateVideoMediaTypeFromSubtype)
     {
         hr = pMFCreateVideoMediaTypeFromSubtype(&MFVideoFormat_RGB555, &video_type);
-        ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+        ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
         check_interface(video_type, &IID_IMFMediaType, TRUE);
         check_interface(video_type, &IID_IMFVideoMediaType, TRUE);
 
         /* Major and subtype are set on creation. */
         hr = IMFVideoMediaType_GetCount(video_type, &count);
-        ok(count == 2, "Unexpected attribute count %#lx.\n", hr);
+        ok(count == 2, "Unexpected attribute count %#x.\n", hr);
 
         hr = IMFVideoMediaType_DeleteAllItems(video_type);
-        ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+        ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
         hr = IMFVideoMediaType_GetCount(video_type, &count);
-        ok(!count, "Unexpected attribute count %#lx.\n", hr);
+        ok(!count, "Unexpected attribute count %#x.\n", hr);
 
         check_interface(video_type, &IID_IMFVideoMediaType, FALSE);
 
@@ -1331,33 +1330,33 @@ if(0)
 
     /* IMFAudioMediaType */
     hr = MFCreateMediaType(&mediatype);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     check_interface(mediatype, &IID_IMFAudioMediaType, FALSE);
 
     hr = IMFMediaType_QueryInterface(mediatype, &IID_IUnknown, (void **)&unk);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(unk == (IUnknown *)mediatype, "Unexpected pointer.\n");
     IUnknown_Release(unk);
 
     hr = IMFMediaType_SetGUID(mediatype, &MF_MT_MAJOR_TYPE, &MFMediaType_Audio);
-    ok(hr == S_OK, "Failed to set GUID value, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to set GUID value, hr %#x.\n", hr);
 
     hr = IMFMediaType_QueryInterface(mediatype, &IID_IMFAudioMediaType, (void **)&unk);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IUnknown_QueryInterface(unk, &IID_IUnknown, (void **)&unk2);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(unk2 == (IUnknown *)mediatype, "Unexpected pointer.\n");
     IUnknown_Release(unk2);
 
     hr = IUnknown_QueryInterface(unk, &IID_IMFAttributes, (void **)&unk2);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(unk2 == (IUnknown *)mediatype, "Unexpected pointer.\n");
     IUnknown_Release(unk2);
 
     hr = IUnknown_QueryInterface(unk, &IID_IMFMediaType, (void **)&unk2);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(unk2 == (IUnknown *)mediatype, "Unexpected pointer.\n");
     IUnknown_Release(unk2);
 
@@ -1380,50 +1379,50 @@ static void test_MFCreateMediaEvent(void)
     value.vt = VT_UNKNOWN;
 
     hr = MFCreateMediaEvent(MEError, &GUID_NULL, E_FAIL, &value, &mediaevent);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "got 0x%08x\n", hr);
 
     PropVariantClear(&value);
 
     hr = IMFMediaEvent_GetType(mediaevent, &type);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
-    ok(type == MEError, "got %#lx\n", type);
+    ok(hr == S_OK, "got 0x%08x\n", hr);
+    ok(type == MEError, "got %#x\n", type);
 
     hr = IMFMediaEvent_GetExtendedType(mediaevent, &extended_type);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "got 0x%08x\n", hr);
     ok(IsEqualGUID(&extended_type, &GUID_NULL), "got %s\n",
        wine_dbgstr_guid(&extended_type));
 
     hr = IMFMediaEvent_GetStatus(mediaevent, &status);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
-    ok(status == E_FAIL, "Unexpected hr %#lx.\n", status);
+    ok(hr == S_OK, "got 0x%08x\n", hr);
+    ok(status == E_FAIL, "got 0x%08x\n", status);
 
     PropVariantInit(&value);
     hr = IMFMediaEvent_GetValue(mediaevent, &value);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "got 0x%08x\n", hr);
     ok(value.vt == VT_UNKNOWN, "got %#x\n", value.vt);
     PropVariantClear(&value);
 
     IMFMediaEvent_Release(mediaevent);
 
     hr = MFCreateMediaEvent(MEUnknown, &DUMMY_GUID1, S_OK, NULL, &mediaevent);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "got 0x%08x\n", hr);
 
     hr = IMFMediaEvent_GetType(mediaevent, &type);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
-    ok(type == MEUnknown, "got %#lx\n", type);
+    ok(hr == S_OK, "got 0x%08x\n", hr);
+    ok(type == MEUnknown, "got %#x\n", type);
 
     hr = IMFMediaEvent_GetExtendedType(mediaevent, &extended_type);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "got 0x%08x\n", hr);
     ok(IsEqualGUID(&extended_type, &DUMMY_GUID1), "got %s\n",
        wine_dbgstr_guid(&extended_type));
 
     hr = IMFMediaEvent_GetStatus(mediaevent, &status);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
-    ok(status == S_OK, "Unexpected hr %#lx.\n", status);
+    ok(hr == S_OK, "got 0x%08x\n", hr);
+    ok(status == S_OK, "got 0x%08x\n", status);
 
     PropVariantInit(&value);
     hr = IMFMediaEvent_GetValue(mediaevent, &value);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "got 0x%08x\n", hr);
     ok(value.vt == VT_EMPTY, "got %#x\n", value.vt);
     PropVariantClear(&value);
 
@@ -1435,7 +1434,7 @@ static void check_attr_count(IMFAttributes* obj, UINT32 expected, int line)
 {
     UINT32 count = expected + 1;
     HRESULT hr = IMFAttributes_GetCount(obj, &count);
-    ok_(__FILE__, line)(hr == S_OK, "Failed to get attributes count, hr %#lx.\n", hr);
+    ok_(__FILE__, line)(hr == S_OK, "Failed to get attributes count, hr %#x.\n", hr);
     ok_(__FILE__, line)(count == expected, "Unexpected count %u, expected %u.\n", count, expected);
 }
 
@@ -1446,7 +1445,7 @@ static void check_attr_type(IMFAttributes *obj, const GUID *key, MF_ATTRIBUTE_TY
     HRESULT hr;
 
     hr = IMFAttributes_GetItemType(obj, key, &type);
-    ok_(__FILE__, line)(hr == S_OK, "Failed to get item type, hr %#lx.\n", hr);
+    ok_(__FILE__, line)(hr == S_OK, "Failed to get item type, hr %#x.\n", hr);
     ok_(__FILE__, line)(type == expected, "Unexpected item type %d, expected %d.\n", type, expected);
 }
 
@@ -1470,71 +1469,71 @@ static void test_attributes(void)
     GUID key;
 
     hr = MFCreateAttributes( &attributes, 3 );
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "got 0x%08x\n", hr);
 
     hr = IMFAttributes_GetItemType(attributes, &GUID_NULL, &type);
-    ok(hr == MF_E_ATTRIBUTENOTFOUND, "Unexpected hr %#lx.\n", hr);
+    ok(hr == MF_E_ATTRIBUTENOTFOUND, "Unexpected hr %#x.\n", hr);
 
     CHECK_ATTR_COUNT(attributes, 0);
     hr = IMFAttributes_SetUINT32(attributes, &MF_READWRITE_ENABLE_HARDWARE_TRANSFORMS, 123);
-    ok(hr == S_OK, "Failed to set UINT32 value, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to set UINT32 value, hr %#x.\n", hr);
     CHECK_ATTR_COUNT(attributes, 1);
     CHECK_ATTR_TYPE(attributes, &MF_READWRITE_ENABLE_HARDWARE_TRANSFORMS, MF_ATTRIBUTE_UINT32);
 
     value = 0xdeadbeef;
     hr = IMFAttributes_GetUINT32(attributes, &MF_READWRITE_ENABLE_HARDWARE_TRANSFORMS, &value);
-    ok(hr == S_OK, "Failed to get UINT32 value, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get UINT32 value, hr %#x.\n", hr);
     ok(value == 123, "Unexpected value %u, expected: 123.\n", value);
 
     value64 = 0xdeadbeef;
     hr = IMFAttributes_GetUINT64(attributes, &MF_READWRITE_ENABLE_HARDWARE_TRANSFORMS, &value64);
-    ok(hr == MF_E_INVALIDTYPE, "Unexpected hr %#lx.\n", hr);
+    ok(hr == MF_E_INVALIDTYPE, "Unexpected hr %#x.\n", hr);
     ok(value64 == 0xdeadbeef, "Unexpected value.\n");
 
     hr = IMFAttributes_SetUINT64(attributes, &MF_READWRITE_ENABLE_HARDWARE_TRANSFORMS, 65536);
-    ok(hr == S_OK, "Failed to set UINT64 value, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to set UINT64 value, hr %#x.\n", hr);
     CHECK_ATTR_COUNT(attributes, 1);
     CHECK_ATTR_TYPE(attributes, &MF_READWRITE_ENABLE_HARDWARE_TRANSFORMS, MF_ATTRIBUTE_UINT64);
 
     hr = IMFAttributes_GetUINT64(attributes, &MF_READWRITE_ENABLE_HARDWARE_TRANSFORMS, &value64);
-    ok(hr == S_OK, "Failed to get UINT64 value, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get UINT64 value, hr %#x.\n", hr);
     ok(value64 == 65536, "Unexpected value.\n");
 
     value = 0xdeadbeef;
     hr = IMFAttributes_GetUINT32(attributes, &MF_READWRITE_ENABLE_HARDWARE_TRANSFORMS, &value);
-    ok(hr == MF_E_INVALIDTYPE, "Unexpected hr %#lx.\n", hr);
+    ok(hr == MF_E_INVALIDTYPE, "Unexpected hr %#x.\n", hr);
     ok(value == 0xdeadbeef, "Unexpected value.\n");
 
     IMFAttributes_Release(attributes);
 
     hr = MFCreateAttributes(&attributes, 0);
-    ok(hr == S_OK, "Failed to create attributes object, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to create attributes object, hr %#x.\n", hr);
 
     PropVariantInit(&propvar);
     propvar.vt = MF_ATTRIBUTE_UINT32;
     U(propvar).ulVal = 123;
     hr = IMFAttributes_SetItem(attributes, &DUMMY_GUID1, &propvar);
-    ok(hr == S_OK, "Failed to set item, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to set item, hr %#x.\n", hr);
     PropVariantInit(&ret_propvar);
     ret_propvar.vt = MF_ATTRIBUTE_UINT32;
     U(ret_propvar).ulVal = 0xdeadbeef;
     hr = IMFAttributes_GetItem(attributes, &DUMMY_GUID1, &ret_propvar);
-    ok(hr == S_OK, "Failed to get item, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get item, hr %#x.\n", hr);
     ok(!PropVariantCompareEx(&propvar, &ret_propvar, 0, 0), "Unexpected item value.\n");
     PropVariantClear(&ret_propvar);
     CHECK_ATTR_COUNT(attributes, 1);
 
     hr = IMFAttributes_GetItem(attributes, &DUMMY_GUID1, NULL);
-    ok(hr == S_OK, "Item check failed, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Item check failed, hr %#x.\n", hr);
 
     hr = IMFAttributes_GetItem(attributes, &DUMMY_GUID2, NULL);
-    ok(hr == MF_E_ATTRIBUTENOTFOUND, "Unexpected hr %#lx.\n", hr);
+    ok(hr == MF_E_ATTRIBUTENOTFOUND, "Unexpected hr %#x.\n", hr);
 
     PropVariantInit(&ret_propvar);
     ret_propvar.vt = MF_ATTRIBUTE_STRING;
     U(ret_propvar).pwszVal = NULL;
     hr = IMFAttributes_GetItem(attributes, &DUMMY_GUID1, &ret_propvar);
-    ok(hr == S_OK, "Failed to get item, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get item, hr %#x.\n", hr);
     ok(!PropVariantCompareEx(&propvar, &ret_propvar, 0, 0), "Unexpected item value.\n");
     PropVariantClear(&ret_propvar);
 
@@ -1544,12 +1543,12 @@ static void test_attributes(void)
     propvar.vt = MF_ATTRIBUTE_UINT64;
     U(propvar).uhVal.QuadPart = 65536;
     hr = IMFAttributes_SetItem(attributes, &DUMMY_GUID1, &propvar);
-    ok(hr == S_OK, "Failed to set item, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to set item, hr %#x.\n", hr);
     PropVariantInit(&ret_propvar);
     ret_propvar.vt = MF_ATTRIBUTE_UINT32;
     U(ret_propvar).ulVal = 0xdeadbeef;
     hr = IMFAttributes_GetItem(attributes, &DUMMY_GUID1, &ret_propvar);
-    ok(hr == S_OK, "Failed to get item, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get item, hr %#x.\n", hr);
     ok(!PropVariantCompareEx(&propvar, &ret_propvar, 0, 0), "Unexpected item value.\n");
     PropVariantClear(&ret_propvar);
     PropVariantClear(&propvar);
@@ -1559,12 +1558,12 @@ static void test_attributes(void)
     propvar.vt = VT_I4;
     U(propvar).lVal = 123;
     hr = IMFAttributes_SetItem(attributes, &DUMMY_GUID2, &propvar);
-    ok(hr == MF_E_INVALIDTYPE, "Failed to set item, hr %#lx.\n", hr);
+    ok(hr == MF_E_INVALIDTYPE, "Failed to set item, hr %#x.\n", hr);
     PropVariantInit(&ret_propvar);
     ret_propvar.vt = MF_ATTRIBUTE_UINT32;
     U(ret_propvar).lVal = 0xdeadbeef;
     hr = IMFAttributes_GetItem(attributes, &DUMMY_GUID2, &ret_propvar);
-    ok(hr == S_OK, "Failed to get item, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get item, hr %#x.\n", hr);
     PropVariantClear(&propvar);
     ok(!PropVariantCompareEx(&propvar, &ret_propvar, 0, 0), "Unexpected item value.\n");
     PropVariantClear(&ret_propvar);
@@ -1573,18 +1572,18 @@ static void test_attributes(void)
     propvar.vt = MF_ATTRIBUTE_UINT32;
     U(propvar).ulVal = 123;
     hr = IMFAttributes_SetItem(attributes, &DUMMY_GUID3, &propvar);
-    ok(hr == S_OK, "Failed to set item, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to set item, hr %#x.\n", hr);
 
     hr = IMFAttributes_DeleteItem(attributes, &DUMMY_GUID2);
-    ok(hr == S_OK, "Failed to delete item, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to delete item, hr %#x.\n", hr);
     CHECK_ATTR_COUNT(attributes, 2);
 
     hr = IMFAttributes_DeleteItem(attributes, &DUMMY_GUID2);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     CHECK_ATTR_COUNT(attributes, 2);
 
     hr = IMFAttributes_GetItem(attributes, &DUMMY_GUID3, &ret_propvar);
-    ok(hr == S_OK, "Failed to get item, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get item, hr %#x.\n", hr);
     ok(!PropVariantCompareEx(&propvar, &ret_propvar, 0, 0), "Unexpected item value.\n");
     PropVariantClear(&ret_propvar);
     PropVariantClear(&propvar);
@@ -1593,358 +1592,363 @@ static void test_attributes(void)
     U(propvar).uhVal.QuadPart = 65536;
 
     hr = IMFAttributes_GetItem(attributes, &DUMMY_GUID1, &ret_propvar);
-    ok(hr == S_OK, "Failed to get item, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get item, hr %#x.\n", hr);
     ok(!PropVariantCompareEx(&propvar, &ret_propvar, 0, 0), "Unexpected item value.\n");
     PropVariantClear(&ret_propvar);
     PropVariantClear(&propvar);
 
     /* Item ordering is not consistent across Windows version. */
     hr = IMFAttributes_GetItemByIndex(attributes, 0, &key, &ret_propvar);
-    ok(hr == S_OK, "Failed to get item, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get item, hr %#x.\n", hr);
     PropVariantClear(&ret_propvar);
 
     hr = IMFAttributes_GetItemByIndex(attributes, 100, &key, &ret_propvar);
-    ok(hr == E_INVALIDARG, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
     PropVariantClear(&ret_propvar);
 
     hr = IMFAttributes_SetDouble(attributes, &GUID_NULL, 22.0);
-    ok(hr == S_OK, "Failed to set double value, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to set double value, hr %#x.\n", hr);
     CHECK_ATTR_COUNT(attributes, 3);
     CHECK_ATTR_TYPE(attributes, &GUID_NULL, MF_ATTRIBUTE_DOUBLE);
 
     double_value = 0xdeadbeef;
     hr = IMFAttributes_GetDouble(attributes, &GUID_NULL, &double_value);
-    ok(hr == S_OK, "Failed to get double value, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get double value, hr %#x.\n", hr);
     ok(double_value == 22.0, "Unexpected value: %f, expected: 22.0.\n", double_value);
 
     propvar.vt = MF_ATTRIBUTE_UINT64;
     U(propvar).uhVal.QuadPart = 22;
     hr = IMFAttributes_CompareItem(attributes, &GUID_NULL, &propvar, &result);
-    ok(hr == S_OK, "Failed to compare items, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to compare items, hr %#x.\n", hr);
     ok(!result, "Unexpected result.\n");
 
     propvar.vt = MF_ATTRIBUTE_DOUBLE;
     U(propvar).dblVal = 22.0;
     hr = IMFAttributes_CompareItem(attributes, &GUID_NULL, &propvar, &result);
-    ok(hr == S_OK, "Failed to compare items, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to compare items, hr %#x.\n", hr);
     ok(result, "Unexpected result.\n");
 
     hr = IMFAttributes_SetString(attributes, &DUMMY_GUID1, stringW);
-    ok(hr == S_OK, "Failed to set string attribute, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to set string attribute, hr %#x.\n", hr);
     CHECK_ATTR_COUNT(attributes, 3);
     CHECK_ATTR_TYPE(attributes, &DUMMY_GUID1, MF_ATTRIBUTE_STRING);
 
     hr = IMFAttributes_GetStringLength(attributes, &DUMMY_GUID1, &string_length);
-    ok(hr == S_OK, "Failed to get string length, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get string length, hr %#x.\n", hr);
     ok(string_length == lstrlenW(stringW), "Unexpected length %u.\n", string_length);
 
+    hr = IMFAttributes_GetAllocatedString(attributes, &DUMMY_GUID1, &string, NULL);
+    ok(hr == S_OK, "Failed to get allocated string, hr %#lx.\n", hr);
+    ok(!lstrcmpW(string, stringW), "Unexpected string %s.\n", wine_dbgstr_w(string));
+    CoTaskMemFree(string);
+
     string_length = 0xdeadbeef;
     hr = IMFAttributes_GetAllocatedString(attributes, &DUMMY_GUID1, &string, &string_length);
-    ok(hr == S_OK, "Failed to get allocated string, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get allocated string, hr %#x.\n", hr);
     ok(!lstrcmpW(string, stringW), "Unexpected string %s.\n", wine_dbgstr_w(string));
     ok(string_length == lstrlenW(stringW), "Unexpected length %u.\n", string_length);
     CoTaskMemFree(string);
 
     string_length = 0xdeadbeef;
     hr = IMFAttributes_GetString(attributes, &DUMMY_GUID1, bufferW, ARRAY_SIZE(bufferW), &string_length);
-    ok(hr == S_OK, "Failed to get string value, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get string value, hr %#x.\n", hr);
     ok(!lstrcmpW(bufferW, stringW), "Unexpected string %s.\n", wine_dbgstr_w(bufferW));
     ok(string_length == lstrlenW(stringW), "Unexpected length %u.\n", string_length);
     memset(bufferW, 0, sizeof(bufferW));
 
     hr = IMFAttributes_GetString(attributes, &DUMMY_GUID1, bufferW, ARRAY_SIZE(bufferW), NULL);
-    ok(hr == S_OK, "Failed to get string value, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get string value, hr %#x.\n", hr);
     ok(!lstrcmpW(bufferW, stringW), "Unexpected string %s.\n", wine_dbgstr_w(bufferW));
     memset(bufferW, 0, sizeof(bufferW));
 
     string_length = 0;
     hr = IMFAttributes_GetString(attributes, &DUMMY_GUID1, bufferW, 1, &string_length);
-    ok(hr == STRSAFE_E_INSUFFICIENT_BUFFER, "Unexpected hr %#lx.\n", hr);
+    ok(hr == STRSAFE_E_INSUFFICIENT_BUFFER, "Unexpected hr %#x.\n", hr);
     ok(!bufferW[0], "Unexpected string %s.\n", wine_dbgstr_w(bufferW));
     ok(string_length, "Unexpected length.\n");
 
     string_length = 0xdeadbeef;
     hr = IMFAttributes_GetStringLength(attributes, &GUID_NULL, &string_length);
-    ok(hr == MF_E_INVALIDTYPE, "Unexpected hr %#lx.\n", hr);
+    ok(hr == MF_E_INVALIDTYPE, "Unexpected hr %#x.\n", hr);
     ok(string_length == 0xdeadbeef, "Unexpected length %u.\n", string_length);
 
     /* VT_UNKNOWN */
     hr = IMFAttributes_SetUnknown(attributes, &DUMMY_GUID2, (IUnknown *)attributes);
-    ok(hr == S_OK, "Failed to set value, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to set value, hr %#x.\n", hr);
     CHECK_ATTR_COUNT(attributes, 4);
     CHECK_ATTR_TYPE(attributes, &DUMMY_GUID2, MF_ATTRIBUTE_IUNKNOWN);
 
     hr = IMFAttributes_GetUnknown(attributes, &DUMMY_GUID2, &IID_IUnknown, (void **)&unk_value);
-    ok(hr == S_OK, "Failed to get value, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get value, hr %#x.\n", hr);
     IUnknown_Release(unk_value);
 
     hr = IMFAttributes_GetUnknown(attributes, &DUMMY_GUID2, &IID_IMFAttributes, (void **)&unk_value);
-    ok(hr == S_OK, "Failed to get value, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get value, hr %#x.\n", hr);
     IUnknown_Release(unk_value);
 
     hr = IMFAttributes_GetUnknown(attributes, &DUMMY_GUID2, &IID_IStream, (void **)&unk_value);
-    ok(hr == E_NOINTERFACE, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_NOINTERFACE, "Unexpected hr %#x.\n", hr);
 
     hr = IMFAttributes_SetUnknown(attributes, &DUMMY_CLSID, NULL);
-    ok(hr == S_OK, "Failed to set value, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to set value, hr %#x.\n", hr);
     CHECK_ATTR_COUNT(attributes, 5);
 
     unk_value = NULL;
     hr = IMFAttributes_GetUnknown(attributes, &DUMMY_CLSID, &IID_IUnknown, (void **)&unk_value);
-    ok(hr == MF_E_INVALIDTYPE, "Unexpected hr %#lx.\n", hr);
+    ok(hr == MF_E_INVALIDTYPE, "Unexpected hr %#x.\n", hr);
 
     /* CopyAllItems() */
     hr = MFCreateAttributes(&attributes1, 0);
-    ok(hr == S_OK, "Failed to create attributes object, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to create attributes object, hr %#x.\n", hr);
     hr = IMFAttributes_CopyAllItems(attributes, attributes1);
-    ok(hr == S_OK, "Failed to copy items, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to copy items, hr %#x.\n", hr);
     CHECK_ATTR_COUNT(attributes, 5);
     CHECK_ATTR_COUNT(attributes1, 5);
 
     hr = IMFAttributes_DeleteAllItems(attributes1);
-    ok(hr == S_OK, "Failed to delete items, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to delete items, hr %#x.\n", hr);
     CHECK_ATTR_COUNT(attributes1, 0);
 
     propvar.vt = MF_ATTRIBUTE_UINT64;
     U(propvar).uhVal.QuadPart = 22;
     hr = IMFAttributes_CompareItem(attributes, &GUID_NULL, &propvar, &result);
-    ok(hr == S_OK, "Failed to compare items, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to compare items, hr %#x.\n", hr);
     ok(!result, "Unexpected result.\n");
 
     hr = IMFAttributes_CopyAllItems(attributes1, attributes);
-    ok(hr == S_OK, "Failed to copy items, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to copy items, hr %#x.\n", hr);
     CHECK_ATTR_COUNT(attributes, 0);
 
     /* Blob */
     hr = IMFAttributes_SetBlob(attributes, &DUMMY_GUID1, blob, sizeof(blob));
-    ok(hr == S_OK, "Failed to set blob attribute, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to set blob attribute, hr %#x.\n", hr);
     CHECK_ATTR_COUNT(attributes, 1);
     CHECK_ATTR_TYPE(attributes, &DUMMY_GUID1, MF_ATTRIBUTE_BLOB);
     hr = IMFAttributes_GetBlobSize(attributes, &DUMMY_GUID1, &size);
-    ok(hr == S_OK, "Failed to get blob size, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get blob size, hr %#x.\n", hr);
     ok(size == sizeof(blob), "Unexpected blob size %u.\n", size);
 
     hr = IMFAttributes_GetBlobSize(attributes, &DUMMY_GUID2, &size);
-    ok(hr == MF_E_ATTRIBUTENOTFOUND, "Unexpected hr %#lx.\n", hr);
+    ok(hr == MF_E_ATTRIBUTENOTFOUND, "Unexpected hr %#x.\n", hr);
 
     size = 0;
     hr = IMFAttributes_GetBlob(attributes, &DUMMY_GUID1, blob_value, sizeof(blob_value), &size);
-    ok(hr == S_OK, "Failed to get blob, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get blob, hr %#x.\n", hr);
     ok(size == sizeof(blob), "Unexpected blob size %u.\n", size);
     ok(!memcmp(blob_value, blob, size), "Unexpected blob.\n");
 
     hr = IMFAttributes_GetBlob(attributes, &DUMMY_GUID2, blob_value, sizeof(blob_value), &size);
-    ok(hr == MF_E_ATTRIBUTENOTFOUND, "Unexpected hr %#lx.\n", hr);
+    ok(hr == MF_E_ATTRIBUTENOTFOUND, "Unexpected hr %#x.\n", hr);
 
     memset(blob_value, 0, sizeof(blob_value));
     size = 0;
     hr = IMFAttributes_GetAllocatedBlob(attributes, &DUMMY_GUID1, &blob_buf, &size);
-    ok(hr == S_OK, "Failed to get allocated blob, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get allocated blob, hr %#x.\n", hr);
     ok(size == sizeof(blob), "Unexpected blob size %u.\n", size);
     ok(!memcmp(blob_buf, blob, size), "Unexpected blob.\n");
     CoTaskMemFree(blob_buf);
 
     hr = IMFAttributes_GetAllocatedBlob(attributes, &DUMMY_GUID2, &blob_buf, &size);
-    ok(hr == MF_E_ATTRIBUTENOTFOUND, "Unexpected hr %#lx.\n", hr);
+    ok(hr == MF_E_ATTRIBUTENOTFOUND, "Unexpected hr %#x.\n", hr);
 
     hr = IMFAttributes_GetBlob(attributes, &DUMMY_GUID1, blob_value, sizeof(blob) - 1, NULL);
-    ok(hr == E_NOT_SUFFICIENT_BUFFER, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_NOT_SUFFICIENT_BUFFER, "Unexpected hr %#x.\n", hr);
 
     IMFAttributes_Release(attributes);
     IMFAttributes_Release(attributes1);
 
     /* Compare() */
     hr = MFCreateAttributes(&attributes, 0);
-    ok(hr == S_OK, "Failed to create attributes object, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to create attributes object, hr %#x.\n", hr);
     hr = MFCreateAttributes(&attributes1, 0);
-    ok(hr == S_OK, "Failed to create attributes object, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to create attributes object, hr %#x.\n", hr);
 
     hr = IMFAttributes_Compare(attributes, attributes, MF_ATTRIBUTES_MATCH_SMALLER + 1, &result);
-    ok(hr == E_INVALIDARG, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
 
     for (match_type = MF_ATTRIBUTES_MATCH_OUR_ITEMS; match_type <= MF_ATTRIBUTES_MATCH_SMALLER; ++match_type)
     {
         result = FALSE;
         hr = IMFAttributes_Compare(attributes, attributes, match_type, &result);
-        ok(hr == S_OK, "Failed to compare, hr %#lx.\n", hr);
+        ok(hr == S_OK, "Failed to compare, hr %#x.\n", hr);
         ok(result, "Unexpected result %d.\n", result);
 
         result = FALSE;
         hr = IMFAttributes_Compare(attributes, attributes1, match_type, &result);
-        ok(hr == S_OK, "Failed to compare, hr %#lx.\n", hr);
+        ok(hr == S_OK, "Failed to compare, hr %#x.\n", hr);
         ok(result, "Unexpected result %d.\n", result);
     }
 
     hr = IMFAttributes_SetUINT32(attributes, &DUMMY_GUID1, 1);
-    ok(hr == S_OK, "Failed to set value, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to set value, hr %#x.\n", hr);
 
     result = TRUE;
     hr = IMFAttributes_Compare(attributes, attributes1, MF_ATTRIBUTES_MATCH_OUR_ITEMS, &result);
-    ok(hr == S_OK, "Failed to compare, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to compare, hr %#x.\n", hr);
     ok(!result, "Unexpected result %d.\n", result);
 
     result = TRUE;
     hr = IMFAttributes_Compare(attributes, attributes1, MF_ATTRIBUTES_MATCH_ALL_ITEMS, &result);
-    ok(hr == S_OK, "Failed to compare, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to compare, hr %#x.\n", hr);
     ok(!result, "Unexpected result %d.\n", result);
 
     result = FALSE;
     hr = IMFAttributes_Compare(attributes, attributes1, MF_ATTRIBUTES_MATCH_INTERSECTION, &result);
-    ok(hr == S_OK, "Failed to compare, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to compare, hr %#x.\n", hr);
     ok(result, "Unexpected result %d.\n", result);
 
     result = FALSE;
     hr = IMFAttributes_Compare(attributes, attributes1, MF_ATTRIBUTES_MATCH_SMALLER, &result);
-    ok(hr == S_OK, "Failed to compare, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to compare, hr %#x.\n", hr);
     ok(result, "Unexpected result %d.\n", result);
 
     hr = IMFAttributes_SetUINT32(attributes1, &DUMMY_GUID1, 2);
-    ok(hr == S_OK, "Failed to set value, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to set value, hr %#x.\n", hr);
 
     result = TRUE;
     hr = IMFAttributes_Compare(attributes, attributes1, MF_ATTRIBUTES_MATCH_ALL_ITEMS, &result);
-    ok(hr == S_OK, "Failed to compare, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to compare, hr %#x.\n", hr);
     ok(!result, "Unexpected result %d.\n", result);
 
     result = TRUE;
     hr = IMFAttributes_Compare(attributes, attributes1, MF_ATTRIBUTES_MATCH_OUR_ITEMS, &result);
-    ok(hr == S_OK, "Failed to compare, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to compare, hr %#x.\n", hr);
     ok(!result, "Unexpected result %d.\n", result);
 
     result = TRUE;
     hr = IMFAttributes_Compare(attributes, attributes1, MF_ATTRIBUTES_MATCH_THEIR_ITEMS, &result);
-    ok(hr == S_OK, "Failed to compare, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to compare, hr %#x.\n", hr);
     ok(!result, "Unexpected result %d.\n", result);
 
     result = TRUE;
     hr = IMFAttributes_Compare(attributes, attributes1, MF_ATTRIBUTES_MATCH_INTERSECTION, &result);
-    ok(hr == S_OK, "Failed to compare, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to compare, hr %#x.\n", hr);
     ok(!result, "Unexpected result %d.\n", result);
 
     result = TRUE;
     hr = IMFAttributes_Compare(attributes, attributes1, MF_ATTRIBUTES_MATCH_SMALLER, &result);
-    ok(hr == S_OK, "Failed to compare, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to compare, hr %#x.\n", hr);
     ok(!result, "Unexpected result %d.\n", result);
 
     result = TRUE;
     hr = IMFAttributes_Compare(attributes1, attributes, MF_ATTRIBUTES_MATCH_ALL_ITEMS, &result);
-    ok(hr == S_OK, "Failed to compare, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to compare, hr %#x.\n", hr);
     ok(!result, "Unexpected result %d.\n", result);
 
     result = TRUE;
     hr = IMFAttributes_Compare(attributes1, attributes, MF_ATTRIBUTES_MATCH_OUR_ITEMS, &result);
-    ok(hr == S_OK, "Failed to compare, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to compare, hr %#x.\n", hr);
     ok(!result, "Unexpected result %d.\n", result);
 
     result = TRUE;
     hr = IMFAttributes_Compare(attributes1, attributes, MF_ATTRIBUTES_MATCH_THEIR_ITEMS, &result);
-    ok(hr == S_OK, "Failed to compare, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to compare, hr %#x.\n", hr);
     ok(!result, "Unexpected result %d.\n", result);
 
     result = TRUE;
     hr = IMFAttributes_Compare(attributes1, attributes, MF_ATTRIBUTES_MATCH_INTERSECTION, &result);
-    ok(hr == S_OK, "Failed to compare, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to compare, hr %#x.\n", hr);
     ok(!result, "Unexpected result %d.\n", result);
 
     result = TRUE;
     hr = IMFAttributes_Compare(attributes1, attributes, MF_ATTRIBUTES_MATCH_SMALLER, &result);
-    ok(hr == S_OK, "Failed to compare, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to compare, hr %#x.\n", hr);
     ok(!result, "Unexpected result %d.\n", result);
 
     hr = IMFAttributes_SetUINT32(attributes1, &DUMMY_GUID1, 1);
-    ok(hr == S_OK, "Failed to set value, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to set value, hr %#x.\n", hr);
 
     result = FALSE;
     hr = IMFAttributes_Compare(attributes, attributes1, MF_ATTRIBUTES_MATCH_ALL_ITEMS, &result);
-    ok(hr == S_OK, "Failed to compare, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to compare, hr %#x.\n", hr);
     ok(result, "Unexpected result %d.\n", result);
 
     result = FALSE;
     hr = IMFAttributes_Compare(attributes, attributes1, MF_ATTRIBUTES_MATCH_THEIR_ITEMS, &result);
-    ok(hr == S_OK, "Failed to compare, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to compare, hr %#x.\n", hr);
     ok(result, "Unexpected result %d.\n", result);
 
     result = FALSE;
     hr = IMFAttributes_Compare(attributes, attributes1, MF_ATTRIBUTES_MATCH_INTERSECTION, &result);
-    ok(hr == S_OK, "Failed to compare, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to compare, hr %#x.\n", hr);
     ok(result, "Unexpected result %d.\n", result);
 
     result = FALSE;
     hr = IMFAttributes_Compare(attributes, attributes1, MF_ATTRIBUTES_MATCH_SMALLER, &result);
-    ok(hr == S_OK, "Failed to compare, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to compare, hr %#x.\n", hr);
     ok(result, "Unexpected result %d.\n", result);
 
     result = FALSE;
     hr = IMFAttributes_Compare(attributes1, attributes, MF_ATTRIBUTES_MATCH_ALL_ITEMS, &result);
-    ok(hr == S_OK, "Failed to compare, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to compare, hr %#x.\n", hr);
     ok(result, "Unexpected result %d.\n", result);
 
     result = FALSE;
     hr = IMFAttributes_Compare(attributes1, attributes, MF_ATTRIBUTES_MATCH_THEIR_ITEMS, &result);
-    ok(hr == S_OK, "Failed to compare, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to compare, hr %#x.\n", hr);
     ok(result, "Unexpected result %d.\n", result);
 
     result = FALSE;
     hr = IMFAttributes_Compare(attributes1, attributes, MF_ATTRIBUTES_MATCH_INTERSECTION, &result);
-    ok(hr == S_OK, "Failed to compare, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to compare, hr %#x.\n", hr);
     ok(result, "Unexpected result %d.\n", result);
 
     result = FALSE;
     hr = IMFAttributes_Compare(attributes1, attributes, MF_ATTRIBUTES_MATCH_SMALLER, &result);
-    ok(hr == S_OK, "Failed to compare, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to compare, hr %#x.\n", hr);
     ok(result, "Unexpected result %d.\n", result);
 
     hr = IMFAttributes_SetUINT32(attributes1, &DUMMY_GUID2, 2);
-    ok(hr == S_OK, "Failed to set value, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to set value, hr %#x.\n", hr);
 
     result = TRUE;
     hr = IMFAttributes_Compare(attributes, attributes1, MF_ATTRIBUTES_MATCH_ALL_ITEMS, &result);
-    ok(hr == S_OK, "Failed to compare, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to compare, hr %#x.\n", hr);
     ok(!result, "Unexpected result %d.\n", result);
 
     result = TRUE;
     hr = IMFAttributes_Compare(attributes, attributes1, MF_ATTRIBUTES_MATCH_THEIR_ITEMS, &result);
-    ok(hr == S_OK, "Failed to compare, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to compare, hr %#x.\n", hr);
     ok(!result, "Unexpected result %d.\n", result);
 
     result = FALSE;
     hr = IMFAttributes_Compare(attributes, attributes1, MF_ATTRIBUTES_MATCH_OUR_ITEMS, &result);
-    ok(hr == S_OK, "Failed to compare, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to compare, hr %#x.\n", hr);
     ok(result, "Unexpected result %d.\n", result);
 
     result = FALSE;
     hr = IMFAttributes_Compare(attributes, attributes1, MF_ATTRIBUTES_MATCH_INTERSECTION, &result);
-    ok(hr == S_OK, "Failed to compare, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to compare, hr %#x.\n", hr);
     ok(result, "Unexpected result %d.\n", result);
 
     result = FALSE;
     hr = IMFAttributes_Compare(attributes, attributes1, MF_ATTRIBUTES_MATCH_SMALLER, &result);
-    ok(hr == S_OK, "Failed to compare, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to compare, hr %#x.\n", hr);
     ok(result, "Unexpected result %d.\n", result);
 
     result = TRUE;
     hr = IMFAttributes_Compare(attributes1, attributes, MF_ATTRIBUTES_MATCH_ALL_ITEMS, &result);
-    ok(hr == S_OK, "Failed to compare, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to compare, hr %#x.\n", hr);
     ok(!result, "Unexpected result %d.\n", result);
 
     result = FALSE;
     hr = IMFAttributes_Compare(attributes1, attributes, MF_ATTRIBUTES_MATCH_THEIR_ITEMS, &result);
-    ok(hr == S_OK, "Failed to compare, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to compare, hr %#x.\n", hr);
     ok(result, "Unexpected result %d.\n", result);
 
     result = TRUE;
     hr = IMFAttributes_Compare(attributes1, attributes, MF_ATTRIBUTES_MATCH_OUR_ITEMS, &result);
-    ok(hr == S_OK, "Failed to compare, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to compare, hr %#x.\n", hr);
     ok(!result, "Unexpected result %d.\n", result);
 
     result = FALSE;
     hr = IMFAttributes_Compare(attributes1, attributes, MF_ATTRIBUTES_MATCH_INTERSECTION, &result);
-    ok(hr == S_OK, "Failed to compare, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to compare, hr %#x.\n", hr);
     ok(result, "Unexpected result %d.\n", result);
 
     result = FALSE;
     hr = IMFAttributes_Compare(attributes1, attributes, MF_ATTRIBUTES_MATCH_SMALLER, &result);
-    ok(hr == S_OK, "Failed to compare, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to compare, hr %#x.\n", hr);
     ok(result, "Unexpected result %d.\n", result);
 
     IMFAttributes_Release(attributes);
@@ -1957,11 +1961,10 @@ static void test_MFCreateMFByteStreamOnStream(void)
     IMFByteStream *bytestream2;
     IStream *stream;
     IMFAttributes *attributes = NULL;
-    DWORD caps, written;
+    DWORD caps, written, count;
     IUnknown *unknown;
     ULONG ref, size;
     HRESULT hr;
-    UINT count;
 
     if(!pMFCreateMFByteStreamOnStream)
     {
@@ -1970,34 +1973,34 @@ static void test_MFCreateMFByteStreamOnStream(void)
     }
 
     hr = CreateStreamOnHGlobal(NULL, TRUE, &stream);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "got 0x%08x\n", hr);
 
     caps = 0xffff0000;
     hr = IStream_Write(stream, &caps, sizeof(caps), &written);
-    ok(hr == S_OK, "Failed to write, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to write, hr %#x.\n", hr);
 
     hr = pMFCreateMFByteStreamOnStream(stream, &bytestream);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "got 0x%08x\n", hr);
 
     hr = IMFByteStream_QueryInterface(bytestream, &IID_IUnknown,
                                  (void **)&unknown);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "got 0x%08x\n", hr);
     ok((void *)unknown == (void *)bytestream, "got %p\n", unknown);
     ref = IUnknown_Release(unknown);
-    ok(ref == 1, "got %lu\n", ref);
+    ok(ref == 1, "got %u\n", ref);
 
     hr = IUnknown_QueryInterface(unknown, &IID_IMFByteStream,
                                  (void **)&bytestream2);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "got 0x%08x\n", hr);
     ok(bytestream2 == bytestream, "got %p\n", bytestream2);
     ref = IMFByteStream_Release(bytestream2);
-    ok(ref == 1, "got %lu\n", ref);
+    ok(ref == 1, "got %u\n", ref);
 
     hr = IMFByteStream_QueryInterface(bytestream, &IID_IMFAttributes,
                                  (void **)&attributes);
     ok(hr == S_OK ||
        /* w7pro64 */
-       broken(hr == E_NOINTERFACE), "Unexpected hr %#lx.\n", hr);
+       broken(hr == E_NOINTERFACE), "got 0x%08x\n", hr);
 
     if (hr != S_OK)
     {
@@ -2009,22 +2012,22 @@ static void test_MFCreateMFByteStreamOnStream(void)
 
     ok(attributes != NULL, "got NULL\n");
     hr = IMFAttributes_GetCount(attributes, &count);
-    ok(hr == S_OK, "Failed to get attributes count, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get attributes count, hr %#x.\n", hr);
     ok(count == 0, "Unexpected attributes count %u.\n", count);
 
     hr = IMFAttributes_QueryInterface(attributes, &IID_IUnknown,
                                  (void **)&unknown);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "got 0x%08x\n", hr);
     ok((void *)unknown == (void *)bytestream, "got %p\n", unknown);
     ref = IUnknown_Release(unknown);
-    ok(ref == 2, "got %lu\n", ref);
+    ok(ref == 2, "got %u\n", ref);
 
     hr = IMFAttributes_QueryInterface(attributes, &IID_IMFByteStream,
                                  (void **)&bytestream2);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "got 0x%08x\n", hr);
     ok(bytestream2 == bytestream, "got %p\n", bytestream2);
     ref = IMFByteStream_Release(bytestream2);
-    ok(ref == 2, "got %lu\n", ref);
+    ok(ref == 2, "got %u\n", ref);
 
     check_interface(bytestream, &IID_IMFByteStreamBuffering, FALSE);
     check_interface(bytestream, &IID_IMFByteStreamCacheControl, FALSE);
@@ -2032,22 +2035,22 @@ static void test_MFCreateMFByteStreamOnStream(void)
     check_interface(bytestream, &IID_IMFGetService, FALSE);
 
     hr = IMFByteStream_GetCapabilities(bytestream, &caps);
-    ok(hr == S_OK, "Failed to get stream capabilities, hr %#lx.\n", hr);
-    ok(caps == (MFBYTESTREAM_IS_READABLE | MFBYTESTREAM_IS_SEEKABLE), "Unexpected caps %#lx.\n", caps);
+    ok(hr == S_OK, "Failed to get stream capabilities, hr %#x.\n", hr);
+    ok(caps == (MFBYTESTREAM_IS_READABLE | MFBYTESTREAM_IS_SEEKABLE), "Unexpected caps %#x.\n", caps);
 
     hr = IMFByteStream_Close(bytestream);
-    ok(hr == S_OK, "Failed to close, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to close, hr %#x.\n", hr);
 
     hr = IMFByteStream_Close(bytestream);
-    ok(hr == S_OK, "Failed to close, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to close, hr %#x.\n", hr);
 
     hr = IMFByteStream_GetCapabilities(bytestream, &caps);
-    ok(hr == S_OK, "Failed to get stream capabilities, hr %#lx.\n", hr);
-    ok(caps == (MFBYTESTREAM_IS_READABLE | MFBYTESTREAM_IS_SEEKABLE), "Unexpected caps %#lx.\n", caps);
+    ok(hr == S_OK, "Failed to get stream capabilities, hr %#x.\n", hr);
+    ok(caps == (MFBYTESTREAM_IS_READABLE | MFBYTESTREAM_IS_SEEKABLE), "Unexpected caps %#x.\n", caps);
 
     caps = 0;
     hr = IMFByteStream_Read(bytestream, (BYTE *)&caps, sizeof(caps), &size);
-    ok(hr == S_OK, "Failed to read from stream, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to read from stream, hr %#x.\n", hr);
     ok(caps == 0xffff0000, "Unexpected content.\n");
 
     IMFAttributes_Release(attributes);
@@ -2063,21 +2066,20 @@ static void test_file_stream(void)
     IMFAttributes *attributes = NULL;
     MF_ATTRIBUTE_TYPE item_type;
     WCHAR pathW[MAX_PATH];
+    DWORD caps, count;
     WCHAR *filename;
     HRESULT hr;
     WCHAR *str;
-    DWORD caps;
-    UINT count;
     BOOL eos;
 
     filename = load_resource(L"test.mp4");
 
     hr = MFStartup(MF_VERSION, MFSTARTUP_FULL);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "got 0x%08x\n", hr);
 
     hr = MFCreateFile(MF_ACCESSMODE_READ, MF_OPENMODE_FAIL_IF_NOT_EXIST,
                       MF_FILEFLAGS_NONE, filename, &bytestream);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "got 0x%08x\n", hr);
 
     check_interface(bytestream, &IID_IMFByteStreamBuffering, FALSE);
     check_interface(bytestream, &IID_IMFByteStreamCacheControl, FALSE);
@@ -2085,108 +2087,108 @@ static void test_file_stream(void)
     check_interface(bytestream, &IID_IMFGetService, TRUE);
 
     hr = IMFByteStream_GetCapabilities(bytestream, &caps);
-    ok(hr == S_OK, "Failed to get stream capabilities, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get stream capabilities, hr %#x.\n", hr);
     if (is_win8_plus)
     {
         ok(caps == (MFBYTESTREAM_IS_READABLE | MFBYTESTREAM_IS_SEEKABLE | MFBYTESTREAM_DOES_NOT_USE_NETWORK),
-            "Unexpected caps %#lx.\n", caps);
+            "Unexpected caps %#x.\n", caps);
     }
     else
-        ok(caps == (MFBYTESTREAM_IS_READABLE | MFBYTESTREAM_IS_SEEKABLE), "Unexpected caps %#lx.\n", caps);
+        ok(caps == (MFBYTESTREAM_IS_READABLE | MFBYTESTREAM_IS_SEEKABLE), "Unexpected caps %#x.\n", caps);
 
     hr = IMFByteStream_QueryInterface(bytestream, &IID_IMFAttributes,
                                  (void **)&attributes);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "got 0x%08x\n", hr);
     ok(attributes != NULL, "got NULL\n");
 
     hr = IMFAttributes_GetCount(attributes, &count);
-    ok(hr == S_OK, "Failed to get attributes count, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get attributes count, hr %#x.\n", hr);
     ok(count == 2, "Unexpected attributes count %u.\n", count);
 
     /* Original file name. */
     hr = IMFAttributes_GetAllocatedString(attributes, &MF_BYTESTREAM_ORIGIN_NAME, &str, &count);
-    ok(hr == S_OK, "Failed to get attribute, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get attribute, hr %#x.\n", hr);
     ok(!lstrcmpW(str, filename), "Unexpected name %s.\n", wine_dbgstr_w(str));
     CoTaskMemFree(str);
 
     /* Modification time. */
     hr = IMFAttributes_GetItemType(attributes, &MF_BYTESTREAM_LAST_MODIFIED_TIME, &item_type);
-    ok(hr == S_OK, "Failed to get item type, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get item type, hr %#x.\n", hr);
     ok(item_type == MF_ATTRIBUTE_BLOB, "Unexpected item type.\n");
 
     IMFAttributes_Release(attributes);
 
     /* Length. */
     hr = IMFByteStream_GetLength(bytestream, NULL);
-    ok(hr == E_INVALIDARG, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
 
     bytestream_length = 0;
     hr = IMFByteStream_GetLength(bytestream, &bytestream_length);
-    ok(hr == S_OK, "Failed to get bytestream length, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get bytestream length, hr %#x.\n", hr);
     ok(bytestream_length > 0, "Unexpected bytestream length %s.\n", wine_dbgstr_longlong(bytestream_length));
 
     hr = IMFByteStream_SetCurrentPosition(bytestream, bytestream_length);
-    ok(hr == S_OK, "Failed to set bytestream position, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to set bytestream position, hr %#x.\n", hr);
 
     hr = IMFByteStream_IsEndOfStream(bytestream, &eos);
-    ok(hr == S_OK, "Failed query end of stream, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed query end of stream, hr %#x.\n", hr);
     ok(eos == TRUE, "Unexpected IsEndOfStream result, %u.\n", eos);
 
     hr = IMFByteStream_SetCurrentPosition(bytestream, 2 * bytestream_length);
-    ok(hr == S_OK, "Failed to set bytestream position, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to set bytestream position, hr %#x.\n", hr);
 
     hr = IMFByteStream_GetCurrentPosition(bytestream, NULL);
-    ok(hr == E_INVALIDARG, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
 
     hr = IMFByteStream_GetCurrentPosition(bytestream, &position);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(position == 2 * bytestream_length, "Unexpected position.\n");
 
     hr = MFCreateFile(MF_ACCESSMODE_READ, MF_OPENMODE_FAIL_IF_NOT_EXIST,
                       MF_FILEFLAGS_NONE, filename, &bytestream2);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "got 0x%08x\n", hr);
     IMFByteStream_Release(bytestream2);
 
     hr = MFCreateFile(MF_ACCESSMODE_WRITE, MF_OPENMODE_FAIL_IF_NOT_EXIST, MF_FILEFLAGS_NONE, filename, &bytestream2);
-    ok(hr == HRESULT_FROM_WIN32(ERROR_SHARING_VIOLATION), "Unexpected hr %#lx.\n", hr);
+    ok(hr == HRESULT_FROM_WIN32(ERROR_SHARING_VIOLATION), "Unexpected hr %#x.\n", hr);
 
     hr = MFCreateFile(MF_ACCESSMODE_READWRITE, MF_OPENMODE_FAIL_IF_NOT_EXIST, MF_FILEFLAGS_NONE, filename, &bytestream2);
-    ok(hr == HRESULT_FROM_WIN32(ERROR_SHARING_VIOLATION), "Unexpected hr %#lx.\n", hr);
+    ok(hr == HRESULT_FROM_WIN32(ERROR_SHARING_VIOLATION), "Unexpected hr %#x.\n", hr);
 
     IMFByteStream_Release(bytestream);
 
     hr = MFCreateFile(MF_ACCESSMODE_READ, MF_OPENMODE_FAIL_IF_NOT_EXIST,
                       MF_FILEFLAGS_NONE, newfilename, &bytestream);
-    ok(hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND), "Unexpected hr %#lx.\n", hr);
+    ok(hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND), "got 0x%08x\n", hr);
 
     hr = MFCreateFile(MF_ACCESSMODE_WRITE, MF_OPENMODE_FAIL_IF_EXIST,
                       MF_FILEFLAGS_NONE, filename, &bytestream);
-    ok(hr == HRESULT_FROM_WIN32(ERROR_FILE_EXISTS), "Unexpected hr %#lx.\n", hr);
+    ok(hr == HRESULT_FROM_WIN32(ERROR_FILE_EXISTS), "got 0x%08x\n", hr);
 
     hr = MFCreateFile(MF_ACCESSMODE_WRITE, MF_OPENMODE_FAIL_IF_EXIST,
                       MF_FILEFLAGS_NONE, newfilename, &bytestream);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "got 0x%08x\n", hr);
 
     hr = MFCreateFile(MF_ACCESSMODE_READ, MF_OPENMODE_FAIL_IF_NOT_EXIST, MF_FILEFLAGS_NONE, newfilename, &bytestream2);
-    ok(hr == HRESULT_FROM_WIN32(ERROR_SHARING_VIOLATION), "Unexpected hr %#lx.\n", hr);
+    ok(hr == HRESULT_FROM_WIN32(ERROR_SHARING_VIOLATION), "Unexpected hr %#x.\n", hr);
 
     hr = MFCreateFile(MF_ACCESSMODE_WRITE, MF_OPENMODE_FAIL_IF_NOT_EXIST, MF_FILEFLAGS_NONE, newfilename, &bytestream2);
-    ok(hr == HRESULT_FROM_WIN32(ERROR_SHARING_VIOLATION), "Unexpected hr %#lx.\n", hr);
+    ok(hr == HRESULT_FROM_WIN32(ERROR_SHARING_VIOLATION), "Unexpected hr %#x.\n", hr);
 
     hr = MFCreateFile(MF_ACCESSMODE_WRITE, MF_OPENMODE_FAIL_IF_NOT_EXIST, MF_FILEFLAGS_ALLOW_WRITE_SHARING,
             newfilename, &bytestream2);
-    ok(hr == HRESULT_FROM_WIN32(ERROR_SHARING_VIOLATION), "Unexpected hr %#lx.\n", hr);
+    ok(hr == HRESULT_FROM_WIN32(ERROR_SHARING_VIOLATION), "Unexpected hr %#x.\n", hr);
 
     IMFByteStream_Release(bytestream);
 
     hr = MFCreateFile(MF_ACCESSMODE_WRITE, MF_OPENMODE_FAIL_IF_NOT_EXIST,
                       MF_FILEFLAGS_ALLOW_WRITE_SHARING, newfilename, &bytestream);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "got 0x%08x\n", hr);
 
     /* Opening the file again fails even though MF_FILEFLAGS_ALLOW_WRITE_SHARING is set. */
     hr = MFCreateFile(MF_ACCESSMODE_WRITE, MF_OPENMODE_FAIL_IF_NOT_EXIST, MF_FILEFLAGS_ALLOW_WRITE_SHARING,
             newfilename, &bytestream2);
-    ok(hr == HRESULT_FROM_WIN32(ERROR_SHARING_VIOLATION), "Unexpected hr %#lx.\n", hr);
+    ok(hr == HRESULT_FROM_WIN32(ERROR_SHARING_VIOLATION), "Unexpected hr %#x.\n", hr);
 
     IMFByteStream_Release(bytestream);
 
@@ -2194,15 +2196,15 @@ static void test_file_stream(void)
     lstrcpyW(pathW, fileschemeW);
     lstrcatW(pathW, filename);
     hr = MFCreateFile(MF_ACCESSMODE_READ, MF_OPENMODE_FAIL_IF_NOT_EXIST, MF_FILEFLAGS_NONE, pathW, &bytestream);
-    ok(FAILED(hr), "Unexpected hr %#lx.\n", hr);
+    ok(FAILED(hr), "Unexpected hr %#x.\n", hr);
 
     hr = MFCreateFile(MF_ACCESSMODE_READ, MF_OPENMODE_FAIL_IF_NOT_EXIST, MF_FILEFLAGS_NONE, filename, &bytestream);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "got 0x%08x\n", hr);
     ok(DeleteFileW(filename), "failed to delete file\n");
     IMFByteStream_Release(bytestream);
 
     hr = MFShutdown();
-    ok(hr == S_OK, "Failed to shut down, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to shut down, hr %#x.\n", hr);
 
     DeleteFileW(newfilename);
 }
@@ -2215,151 +2217,115 @@ static void test_system_memory_buffer(void)
     BYTE *data, *data2;
 
     hr = MFCreateMemoryBuffer(1024, NULL);
-    ok(hr == E_INVALIDARG || hr == E_POINTER, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG || hr == E_POINTER, "got 0x%08x\n", hr);
 
     hr = MFCreateMemoryBuffer(0, &buffer);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "got 0x%08x\n", hr);
     if(buffer)
     {
         hr = IMFMediaBuffer_GetMaxLength(buffer, &length);
-        ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
-        ok(length == 0, "got %lu\n", length);
+        ok(hr == S_OK, "got 0x%08x\n", hr);
+        ok(length == 0, "got %u\n", length);
 
         IMFMediaBuffer_Release(buffer);
     }
 
     hr = MFCreateMemoryBuffer(1024, &buffer);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "got 0x%08x\n", hr);
 
     check_interface(buffer, &IID_IMFGetService, FALSE);
 
     hr = IMFMediaBuffer_GetMaxLength(buffer, NULL);
-    ok(hr == E_INVALIDARG || hr == E_POINTER, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG || hr == E_POINTER, "got 0x%08x\n", hr);
 
     hr = IMFMediaBuffer_GetMaxLength(buffer, &length);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
-    ok(length == 1024, "got %lu\n", length);
+    ok(hr == S_OK, "got 0x%08x\n", hr);
+    ok(length == 1024, "got %u\n", length);
 
     hr = IMFMediaBuffer_SetCurrentLength(buffer, 1025);
-    ok(hr == E_INVALIDARG, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "got 0x%08x\n", hr);
 
     hr = IMFMediaBuffer_SetCurrentLength(buffer, 10);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "got 0x%08x\n", hr);
 
     hr = IMFMediaBuffer_GetCurrentLength(buffer, NULL);
-    ok(hr == E_INVALIDARG || hr == E_POINTER, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG || hr == E_POINTER, "got 0x%08x\n", hr);
 
     hr = IMFMediaBuffer_GetCurrentLength(buffer, &length);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
-    ok(length == 10, "got %lu\n", length);
+    ok(hr == S_OK, "got 0x%08x\n", hr);
+    ok(length == 10, "got %u\n", length);
 
     length = 0;
     max = 0;
     hr = IMFMediaBuffer_Lock(buffer, NULL, &length, &max);
-    ok(hr == E_INVALIDARG || hr == E_POINTER, "Unexpected hr %#lx.\n", hr);
-    ok(length == 0, "got %lu\n", length);
-    ok(max == 0, "got %lu\n", length);
+    ok(hr == E_INVALIDARG || hr == E_POINTER, "got 0x%08x\n", hr);
+    ok(length == 0, "got %u\n", length);
+    ok(max == 0, "got %u\n", length);
 
     hr = IMFMediaBuffer_Lock(buffer, &data, &max, &length);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
-    ok(length == 10, "got %lu\n", length);
-    ok(max == 1024, "got %lu\n", max);
+    ok(hr == S_OK, "got 0x%08x\n", hr);
+    ok(length == 10, "got %u\n", length);
+    ok(max == 1024, "got %u\n", max);
 
     /* Attempt to lock the buffer twice */
     hr = IMFMediaBuffer_Lock(buffer, &data2, &max, &length);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
-    ok(data == data2, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "got 0x%08x\n", hr);
+    ok(data == data2, "got 0x%08x\n", hr);
 
     hr = IMFMediaBuffer_Unlock(buffer);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "got 0x%08x\n", hr);
 
     hr = IMFMediaBuffer_Unlock(buffer);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "got 0x%08x\n", hr);
 
     hr = IMFMediaBuffer_Lock(buffer, &data, NULL, NULL);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "got 0x%08x\n", hr);
 
     hr = IMFMediaBuffer_Unlock(buffer);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "got 0x%08x\n", hr);
 
     /* Extra Unlock */
     hr = IMFMediaBuffer_Unlock(buffer);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "got 0x%08x\n", hr);
 
     IMFMediaBuffer_Release(buffer);
-}
-
-static void test_system_memory_aligned_buffer(void)
-{
-    static const DWORD alignments[] =
-    {
-        MF_16_BYTE_ALIGNMENT,
-        MF_32_BYTE_ALIGNMENT,
-        MF_64_BYTE_ALIGNMENT,
-        MF_128_BYTE_ALIGNMENT,
-        MF_256_BYTE_ALIGNMENT,
-        MF_512_BYTE_ALIGNMENT,
-    };
-    IMFMediaBuffer *buffer;
-    DWORD length, max;
-    unsigned int i;
-    BYTE *data;
-    HRESULT hr;
 
+    /* Aligned buffer. */
     hr = MFCreateAlignedMemoryBuffer(16, MF_8_BYTE_ALIGNMENT, NULL);
-    ok(FAILED(hr), "Unexpected hr %#lx.\n", hr);
+    ok(FAILED(hr), "Unexpected hr %#x.\n", hr);
 
     hr = MFCreateAlignedMemoryBuffer(201, MF_8_BYTE_ALIGNMENT, &buffer);
-    ok(hr == S_OK, "Failed to create memory buffer, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to create memory buffer, hr %#x.\n", hr);
 
     hr = IMFMediaBuffer_GetCurrentLength(buffer, &length);
-    ok(hr == S_OK, "Failed to get current length, hr %#lx.\n", hr);
-    ok(length == 0, "Unexpected current length %lu.\n", length);
+    ok(hr == S_OK, "Failed to get current length, hr %#x.\n", hr);
+    ok(length == 0, "Unexpected current length %u.\n", length);
 
     hr = IMFMediaBuffer_SetCurrentLength(buffer, 1);
-    ok(hr == S_OK, "Failed to set current length, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to set current length, hr %#x.\n", hr);
     hr = IMFMediaBuffer_GetCurrentLength(buffer, &length);
-    ok(hr == S_OK, "Failed to get current length, hr %#lx.\n", hr);
-    ok(length == 1, "Unexpected current length %lu.\n", length);
+    ok(hr == S_OK, "Failed to get current length, hr %#x.\n", hr);
+    ok(length == 1, "Unexpected current length %u.\n", length);
 
     hr = IMFMediaBuffer_GetMaxLength(buffer, &length);
-    ok(hr == S_OK, "Failed to get max length, hr %#lx.\n", hr);
-    ok(length == 201, "Unexpected max length %lu.\n", length);
+    ok(hr == S_OK, "Failed to get max length, hr %#x.\n", hr);
+    ok(length == 201, "Unexpected max length %u.\n", length);
 
     hr = IMFMediaBuffer_SetCurrentLength(buffer, 202);
-    ok(hr == E_INVALIDARG, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
     hr = IMFMediaBuffer_GetMaxLength(buffer, &length);
-    ok(hr == S_OK, "Failed to get max length, hr %#lx.\n", hr);
-    ok(length == 201, "Unexpected max length %lu.\n", length);
+    ok(hr == S_OK, "Failed to get max length, hr %#x.\n", hr);
+    ok(length == 201, "Unexpected max length %u.\n", length);
     hr = IMFMediaBuffer_SetCurrentLength(buffer, 10);
-    ok(hr == S_OK, "Failed to set current length, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to set current length, hr %#x.\n", hr);
 
     hr = IMFMediaBuffer_Lock(buffer, &data, &max, &length);
-    ok(hr == S_OK, "Failed to lock, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to lock, hr %#x.\n", hr);
     ok(max == 201 && length == 10, "Unexpected length.\n");
     hr = IMFMediaBuffer_Unlock(buffer);
-    ok(hr == S_OK, "Failed to unlock, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to unlock, hr %#x.\n", hr);
 
     IMFMediaBuffer_Release(buffer);
-
-    for (i = 0; i < ARRAY_SIZE(alignments); ++i)
-    {
-        hr = MFCreateAlignedMemoryBuffer(200, alignments[i], &buffer);
-        ok(hr == S_OK, "Failed to create memory buffer, hr %#lx.\n", hr);
-
-        hr = IMFMediaBuffer_Lock(buffer, &data, &max, &length);
-        ok(hr == S_OK, "Failed to lock, hr %#lx.\n", hr);
-        ok(max == 200 && !length, "Unexpected length.\n");
-        ok(!((uintptr_t)data & alignments[i]), "Data at %p is misaligned.\n", data);
-        hr = IMFMediaBuffer_Unlock(buffer);
-        ok(hr == S_OK, "Failed to unlock, hr %#lx.\n", hr);
-
-        IMFMediaBuffer_Release(buffer);
-    }
-
-    hr = MFCreateAlignedMemoryBuffer(200, 0, &buffer);
-    ok(hr == S_OK, "Failed to create memory buffer, hr %#lx.\n", hr);
-    IMFMediaBuffer_Release(buffer);
 }
 
 static void test_sample(void)
@@ -2374,101 +2340,101 @@ static void test_sample(void)
     BYTE *data;
 
     hr = MFCreateSample( &sample );
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "got 0x%08x\n", hr);
 
     hr = IMFSample_QueryInterface(sample, &IID_IMFAttributes, (void **)&attributes);
-    ok(hr == S_OK, "Failed to get attributes interface, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get attributes interface, hr %#x.\n", hr);
 
     CHECK_ATTR_COUNT(attributes, 0);
 
     hr = IMFSample_GetBufferCount(sample, NULL);
-    ok(hr == E_INVALIDARG, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
 
     hr = IMFSample_GetBufferCount(sample, &count);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
-    ok(count == 0, "got %ld\n", count);
+    ok(hr == S_OK, "got 0x%08x\n", hr);
+    ok(count == 0, "got %d\n", count);
 
     hr = IMFSample_GetSampleFlags(sample, &flags);
-    ok(hr == S_OK, "Failed to get sample flags, hr %#lx.\n", hr);
-    ok(!flags, "Unexpected flags %#lx.\n", flags);
+    ok(hr == S_OK, "Failed to get sample flags, hr %#x.\n", hr);
+    ok(!flags, "Unexpected flags %#x.\n", flags);
 
     hr = IMFSample_SetSampleFlags(sample, 0x123);
-    ok(hr == S_OK, "Failed to set sample flags, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to set sample flags, hr %#x.\n", hr);
     hr = IMFSample_GetSampleFlags(sample, &flags);
-    ok(hr == S_OK, "Failed to get sample flags, hr %#lx.\n", hr);
-    ok(flags == 0x123, "Unexpected flags %#lx.\n", flags);
+    ok(hr == S_OK, "Failed to get sample flags, hr %#x.\n", hr);
+    ok(flags == 0x123, "Unexpected flags %#x.\n", flags);
 
     hr = IMFSample_GetSampleTime(sample, &time);
-    ok(hr == MF_E_NO_SAMPLE_TIMESTAMP, "Unexpected hr %#lx.\n", hr);
+    ok(hr == MF_E_NO_SAMPLE_TIMESTAMP, "Unexpected hr %#x.\n", hr);
 
     hr = IMFSample_GetSampleDuration(sample, &time);
-    ok(hr == MF_E_NO_SAMPLE_DURATION, "Unexpected hr %#lx.\n", hr);
+    ok(hr == MF_E_NO_SAMPLE_DURATION, "Unexpected hr %#x.\n", hr);
 
     hr = IMFSample_GetBufferByIndex(sample, 0, &buffer);
-    ok(hr == E_INVALIDARG, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
 
     hr = IMFSample_RemoveBufferByIndex(sample, 0);
-    ok(hr == E_INVALIDARG, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
 
     hr = IMFSample_RemoveAllBuffers(sample);
-    ok(hr == S_OK, "Failed to remove all, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to remove all, hr %#x.\n", hr);
 
     hr = IMFSample_GetTotalLength(sample, &length);
-    ok(hr == S_OK, "Failed to get total length, hr %#lx.\n", hr);
-    ok(!length, "Unexpected total length %lu.\n", length);
+    ok(hr == S_OK, "Failed to get total length, hr %#x.\n", hr);
+    ok(!length, "Unexpected total length %u.\n", length);
 
     hr = MFCreateMemoryBuffer(16, &buffer);
-    ok(hr == S_OK, "Failed to create buffer, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to create buffer, hr %#x.\n", hr);
 
     hr = IMFSample_AddBuffer(sample, buffer);
-    ok(hr == S_OK, "Failed to add buffer, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to add buffer, hr %#x.\n", hr);
 
     hr = IMFSample_AddBuffer(sample, buffer);
-    ok(hr == S_OK, "Failed to add buffer, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to add buffer, hr %#x.\n", hr);
 
     hr = IMFSample_GetBufferCount(sample, &count);
-    ok(hr == S_OK, "Failed to get buffer count, hr %#lx.\n", hr);
-    ok(count == 2, "Unexpected buffer count %lu.\n", count);
+    ok(hr == S_OK, "Failed to get buffer count, hr %#x.\n", hr);
+    ok(count == 2, "Unexpected buffer count %u.\n", count);
 
     hr = IMFSample_GetBufferByIndex(sample, 0, &buffer2);
-    ok(hr == S_OK, "Failed to get buffer, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get buffer, hr %#x.\n", hr);
     ok(buffer2 == buffer, "Unexpected object.\n");
     IMFMediaBuffer_Release(buffer2);
 
     hr = IMFSample_GetTotalLength(sample, &length);
-    ok(hr == S_OK, "Failed to get total length, hr %#lx.\n", hr);
-    ok(!length, "Unexpected total length %lu.\n", length);
+    ok(hr == S_OK, "Failed to get total length, hr %#x.\n", hr);
+    ok(!length, "Unexpected total length %u.\n", length);
 
     hr = IMFMediaBuffer_SetCurrentLength(buffer, 2);
-    ok(hr == S_OK, "Failed to set current length, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to set current length, hr %#x.\n", hr);
 
     hr = IMFSample_GetTotalLength(sample, &length);
-    ok(hr == S_OK, "Failed to get total length, hr %#lx.\n", hr);
-    ok(length == 4, "Unexpected total length %lu.\n", length);
+    ok(hr == S_OK, "Failed to get total length, hr %#x.\n", hr);
+    ok(length == 4, "Unexpected total length %u.\n", length);
 
     hr = IMFSample_RemoveBufferByIndex(sample, 1);
-    ok(hr == S_OK, "Failed to remove buffer, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to remove buffer, hr %#x.\n", hr);
 
     hr = IMFSample_GetTotalLength(sample, &length);
-    ok(hr == S_OK, "Failed to get total length, hr %#lx.\n", hr);
-    ok(length == 2, "Unexpected total length %lu.\n", length);
+    ok(hr == S_OK, "Failed to get total length, hr %#x.\n", hr);
+    ok(length == 2, "Unexpected total length %u.\n", length);
 
     IMFMediaBuffer_Release(buffer);
 
     /* Duration */
     hr = IMFSample_SetSampleDuration(sample, 10);
-    ok(hr == S_OK, "Failed to set duration, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to set duration, hr %#x.\n", hr);
     CHECK_ATTR_COUNT(attributes, 0);
     hr = IMFSample_GetSampleDuration(sample, &time);
-    ok(hr == S_OK, "Failed to get sample duration, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get sample duration, hr %#x.\n", hr);
     ok(time == 10, "Unexpected duration.\n");
 
     /* Timestamp */
     hr = IMFSample_SetSampleTime(sample, 1);
-    ok(hr == S_OK, "Failed to set timestamp, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to set timestamp, hr %#x.\n", hr);
     CHECK_ATTR_COUNT(attributes, 0);
     hr = IMFSample_GetSampleTime(sample, &time);
-    ok(hr == S_OK, "Failed to get sample time, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get sample time, hr %#x.\n", hr);
     ok(time == 1, "Unexpected timestamp.\n");
 
     IMFAttributes_Release(attributes);
@@ -2476,165 +2442,165 @@ static void test_sample(void)
 
     /* CopyToBuffer() */
     hr = MFCreateSample(&sample);
-    ok(hr == S_OK, "Failed to create a sample, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to create a sample, hr %#x.\n", hr);
 
     hr = MFCreateMemoryBuffer(16, &buffer2);
-    ok(hr == S_OK, "Failed to create a buffer, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to create a buffer, hr %#x.\n", hr);
 
     /* Sample with no buffers. */
     hr = IMFMediaBuffer_SetCurrentLength(buffer2, 1);
-    ok(hr == S_OK, "Failed to set current length, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to set current length, hr %#x.\n", hr);
     hr = IMFSample_CopyToBuffer(sample, buffer2);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     hr = IMFMediaBuffer_GetCurrentLength(buffer2, &length);
-    ok(hr == S_OK, "Failed to get current length, hr %#lx.\n", hr);
-    ok(!length, "Unexpected length %lu.\n", length);
+    ok(hr == S_OK, "Failed to get current length, hr %#x.\n", hr);
+    ok(!length, "Unexpected length %u.\n", length);
 
     /* Single buffer, larger destination. */
     hr = MFCreateMemoryBuffer(8, &buffer);
-    ok(hr == S_OK, "Failed to create a buffer, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to create a buffer, hr %#x.\n", hr);
 
     hr = IMFMediaBuffer_Lock(buffer, &data, NULL, NULL);
-    ok(hr == S_OK, "Failed to lock buffer, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to lock buffer, hr %#x.\n", hr);
     *(DWORD *)data = 0x11111111;
     hr = IMFMediaBuffer_Unlock(buffer);
-    ok(hr == S_OK, "Failed to unlock, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to unlock, hr %#x.\n", hr);
     hr = IMFMediaBuffer_SetCurrentLength(buffer, 4);
-    ok(hr == S_OK, "Failed to set current length, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to set current length, hr %#x.\n", hr);
 
     hr = IMFSample_AddBuffer(sample, buffer);
-    ok(hr == S_OK, "Failed to add buffer, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to add buffer, hr %#x.\n", hr);
 
     /* Existing content is overwritten. */
     hr = IMFMediaBuffer_SetCurrentLength(buffer2, 8);
-    ok(hr == S_OK, "Failed to set length, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to set length, hr %#x.\n", hr);
 
     hr = IMFSample_CopyToBuffer(sample, buffer2);
-    ok(hr == S_OK, "Failed to copy to buffer, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to copy to buffer, hr %#x.\n", hr);
 
     hr = IMFMediaBuffer_GetCurrentLength(buffer2, &length);
-    ok(hr == S_OK, "Failed to get length, hr %#lx.\n", hr);
-    ok(length == 4, "Unexpected buffer length %lu.\n", length);
+    ok(hr == S_OK, "Failed to get length, hr %#x.\n", hr);
+    ok(length == 4, "Unexpected buffer length %u.\n", length);
 
     /* Multiple buffers, matching total size. */
     hr = IMFSample_AddBuffer(sample, buffer);
-    ok(hr == S_OK, "Failed to add buffer, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to add buffer, hr %#x.\n", hr);
 
     hr = IMFSample_GetBufferCount(sample, &count);
-    ok(hr == S_OK, "Failed to get buffer count, hr %#lx.\n", hr);
-    ok(count == 2, "Unexpected buffer count %lu.\n", count);
+    ok(hr == S_OK, "Failed to get buffer count, hr %#x.\n", hr);
+    ok(count == 2, "Unexpected buffer count %u.\n", count);
 
     hr = IMFMediaBuffer_SetCurrentLength(buffer, 8);
-    ok(hr == S_OK, "Failed to set current length, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to set current length, hr %#x.\n", hr);
 
     hr = IMFSample_CopyToBuffer(sample, buffer2);
-    ok(hr == S_OK, "Failed to copy to buffer, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to copy to buffer, hr %#x.\n", hr);
 
     hr = IMFMediaBuffer_GetCurrentLength(buffer2, &length);
-    ok(hr == S_OK, "Failed to get length, hr %#lx.\n", hr);
-    ok(length == 16, "Unexpected buffer length %lu.\n", length);
+    ok(hr == S_OK, "Failed to get length, hr %#x.\n", hr);
+    ok(length == 16, "Unexpected buffer length %u.\n", length);
 
     hr = IMFSample_AddBuffer(sample, buffer);
-    ok(hr == S_OK, "Failed to add buffer, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to add buffer, hr %#x.\n", hr);
 
     hr = IMFMediaBuffer_SetCurrentLength(buffer2, 1);
-    ok(hr == S_OK, "Failed to set buffer length, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to set buffer length, hr %#x.\n", hr);
 
     hr = IMFMediaBuffer_Lock(buffer2, &data, NULL, NULL);
-    ok(hr == S_OK, "Failed to lock buffer, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to lock buffer, hr %#x.\n", hr);
     *(DWORD *)data = test_pattern;
     hr = IMFMediaBuffer_Unlock(buffer2);
-    ok(hr == S_OK, "Failed to unlock buffer, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to unlock buffer, hr %#x.\n", hr);
 
     hr = IMFSample_CopyToBuffer(sample, buffer2);
-    ok(hr == MF_E_BUFFERTOOSMALL, "Unexpected hr %#lx.\n", hr);
+    ok(hr == MF_E_BUFFERTOOSMALL, "Unexpected hr %#x.\n", hr);
 
     hr = IMFMediaBuffer_Lock(buffer2, &data, NULL, NULL);
-    ok(hr == S_OK, "Failed to lock buffer, hr %#lx.\n", hr);
-    ok(!memcmp(data, &test_pattern, sizeof(test_pattern)), "Unexpected contents, %#lx\n", *(DWORD *)data);
+    ok(hr == S_OK, "Failed to lock buffer, hr %#x.\n", hr);
+    ok(!memcmp(data, &test_pattern, sizeof(test_pattern)), "Unexpected contents, %#x\n", *(DWORD *)data);
     hr = IMFMediaBuffer_Unlock(buffer2);
-    ok(hr == S_OK, "Failed to unlock buffer, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to unlock buffer, hr %#x.\n", hr);
 
     hr = IMFMediaBuffer_GetCurrentLength(buffer2, &length);
-    ok(hr == S_OK, "Failed to get length, hr %#lx.\n", hr);
-    ok(!length, "Unexpected buffer length %lu.\n", length);
+    ok(hr == S_OK, "Failed to get length, hr %#x.\n", hr);
+    ok(!length, "Unexpected buffer length %u.\n", length);
 
     IMFMediaBuffer_Release(buffer2);
     IMFSample_Release(sample);
 
     /* ConvertToContiguousBuffer() */
     hr = MFCreateSample(&sample);
-    ok(hr == S_OK, "Failed to create a sample, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to create a sample, hr %#x.\n", hr);
 
     hr = IMFSample_ConvertToContiguousBuffer(sample, &buffer);
-    ok(hr == E_UNEXPECTED, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_UNEXPECTED, "Unexpected hr %#x.\n", hr);
 
     hr = MFCreateMemoryBuffer(16, &buffer);
-    ok(hr == S_OK, "Failed to create a buffer, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to create a buffer, hr %#x.\n", hr);
 
     hr = IMFSample_AddBuffer(sample, buffer);
-    ok(hr == S_OK, "Failed to add buffer, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to add buffer, hr %#x.\n", hr);
 
     hr = IMFSample_ConvertToContiguousBuffer(sample, &buffer2);
-    ok(hr == S_OK, "Failed to convert, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to convert, hr %#x.\n", hr);
     ok(buffer2 == buffer, "Unexpected buffer instance.\n");
     IMFMediaBuffer_Release(buffer2);
 
     hr = IMFSample_ConvertToContiguousBuffer(sample, NULL);
-    ok(hr == S_OK, "Failed to convert, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to convert, hr %#x.\n", hr);
 
     hr = IMFSample_ConvertToContiguousBuffer(sample, &buffer2);
-    ok(hr == S_OK, "Failed to convert, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to convert, hr %#x.\n", hr);
     ok(buffer2 == buffer, "Unexpected buffer instance.\n");
     IMFMediaBuffer_Release(buffer2);
 
     hr = IMFMediaBuffer_SetCurrentLength(buffer, 3);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = MFCreateMemoryBuffer(16, &buffer2);
-    ok(hr == S_OK, "Failed to create a buffer, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to create a buffer, hr %#x.\n", hr);
 
     hr = IMFMediaBuffer_SetCurrentLength(buffer2, 4);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IMFSample_AddBuffer(sample, buffer2);
-    ok(hr == S_OK, "Failed to add buffer, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to add buffer, hr %#x.\n", hr);
     IMFMediaBuffer_Release(buffer2);
 
     hr = IMFSample_GetBufferCount(sample, &count);
-    ok(hr == S_OK, "Failed to get buffer count, hr %#lx.\n", hr);
-    ok(count == 2, "Unexpected buffer count %lu.\n", count);
+    ok(hr == S_OK, "Failed to get buffer count, hr %#x.\n", hr);
+    ok(count == 2, "Unexpected buffer count %u.\n", count);
 
     hr = IMFSample_ConvertToContiguousBuffer(sample, &buffer3);
-    ok(hr == S_OK, "Failed to convert, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to convert, hr %#x.\n", hr);
 
     hr = IMFMediaBuffer_GetMaxLength(buffer3, &length);
-    ok(hr == S_OK, "Failed to get maximum length, hr %#lx.\n", hr);
-    ok(length == 7, "Unexpected length %lu.\n", length);
+    ok(hr == S_OK, "Failed to get maximum length, hr %#x.\n", hr);
+    ok(length == 7, "Unexpected length %u.\n", length);
 
     hr = IMFMediaBuffer_GetCurrentLength(buffer3, &length);
-    ok(hr == S_OK, "Failed to get maximum length, hr %#lx.\n", hr);
-    ok(length == 7, "Unexpected length %lu.\n", length);
+    ok(hr == S_OK, "Failed to get maximum length, hr %#x.\n", hr);
+    ok(length == 7, "Unexpected length %u.\n", length);
 
     IMFMediaBuffer_Release(buffer3);
 
     hr = IMFSample_GetBufferCount(sample, &count);
-    ok(hr == S_OK, "Failed to get buffer count, hr %#lx.\n", hr);
-    ok(count == 1, "Unexpected buffer count %lu.\n", count);
+    ok(hr == S_OK, "Failed to get buffer count, hr %#x.\n", hr);
+    ok(count == 1, "Unexpected buffer count %u.\n", count);
 
     hr = IMFSample_AddBuffer(sample, buffer);
-    ok(hr == S_OK, "Failed to add buffer, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to add buffer, hr %#x.\n", hr);
 
     hr = IMFSample_GetBufferCount(sample, &count);
-    ok(hr == S_OK, "Failed to get buffer count, hr %#lx.\n", hr);
-    ok(count == 2, "Unexpected buffer count %lu.\n", count);
+    ok(hr == S_OK, "Failed to get buffer count, hr %#x.\n", hr);
+    ok(count == 2, "Unexpected buffer count %u.\n", count);
 
     hr = IMFSample_ConvertToContiguousBuffer(sample, NULL);
-    ok(hr == S_OK, "Failed to convert, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to convert, hr %#x.\n", hr);
 
     hr = IMFSample_GetBufferCount(sample, &count);
-    ok(hr == S_OK, "Failed to get buffer count, hr %#lx.\n", hr);
-    ok(count == 1, "Unexpected buffer count %lu.\n", count);
+    ok(hr == S_OK, "Failed to get buffer count, hr %#x.\n", hr);
+    ok(count == 1, "Unexpected buffer count %u.\n", count);
 
     IMFMediaBuffer_Release(buffer);
 
@@ -2658,23 +2624,23 @@ static HRESULT WINAPI testcallback_Invoke(IMFAsyncCallback *iface, IMFAsyncResul
         if (is_win8_plus)
         {
             hr = IMFMediaEventQueue_GetEvent(queue, MF_EVENT_FLAG_NO_WAIT, &event);
-            ok(hr == MF_E_MULTIPLE_SUBSCRIBERS, "Failed to get event, hr %#lx.\n", hr);
+            ok(hr == MF_E_MULTIPLE_SUBSCRIBERS, "Failed to get event, hr %#x.\n", hr);
 
             hr = IMFMediaEventQueue_GetEvent(queue, 0, &event);
-            ok(hr == MF_E_MULTIPLE_SUBSCRIBERS, "Failed to get event, hr %#lx.\n", hr);
+            ok(hr == MF_E_MULTIPLE_SUBSCRIBERS, "Failed to get event, hr %#x.\n", hr);
 
             hr = IMFMediaEventQueue_EndGetEvent(queue, result, &event);
-            ok(hr == S_OK, "Failed to finalize GetEvent, hr %#lx.\n", hr);
+            ok(hr == S_OK, "Failed to finalize GetEvent, hr %#x.\n", hr);
 
             hr = IMFMediaEventQueue_EndGetEvent(queue, result, &event2);
-            ok(hr == E_FAIL, "Unexpected result, hr %#lx.\n", hr);
+            ok(hr == E_FAIL, "Unexpected result, hr %#x.\n", hr);
 
             if (event)
                 IMFMediaEvent_Release(event);
         }
 
         hr = IMFAsyncResult_GetObject(result, &obj);
-        ok(hr == E_POINTER, "Unexpected hr %#lx.\n", hr);
+        ok(hr == E_POINTER, "Unexpected hr %#x.\n", hr);
 
         IMFMediaEventQueue_Release(queue);
 
@@ -2708,42 +2674,42 @@ static void test_MFCreateAsyncResult(void)
     callback = create_test_callback(NULL);
 
     hr = MFCreateAsyncResult(NULL, NULL, NULL, NULL);
-    ok(FAILED(hr), "Unexpected hr %#lx.\n", hr);
+    ok(FAILED(hr), "Unexpected hr %#x.\n", hr);
 
     hr = MFCreateAsyncResult(NULL, NULL, NULL, &result);
-    ok(hr == S_OK, "Failed to create object, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to create object, hr %#x.\n", hr);
 
     data = (MFASYNCRESULT *)result;
     ok(data->pCallback == NULL, "Unexpected callback value.\n");
-    ok(data->hrStatusResult == S_OK, "Unexpected status %#lx.\n", data->hrStatusResult);
-    ok(data->dwBytesTransferred == 0, "Unexpected byte length %lu.\n", data->dwBytesTransferred);
+    ok(data->hrStatusResult == S_OK, "Unexpected status %#x.\n", data->hrStatusResult);
+    ok(data->dwBytesTransferred == 0, "Unexpected byte length %u.\n", data->dwBytesTransferred);
     ok(data->hEvent == NULL, "Unexpected event.\n");
 
     hr = IMFAsyncResult_GetState(result, NULL);
-    ok(hr == E_POINTER, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Unexpected hr %#x.\n", hr);
 
     state = (void *)0xdeadbeef;
     hr = IMFAsyncResult_GetState(result, &state);
-    ok(hr == E_POINTER, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Unexpected hr %#x.\n", hr);
     ok(state == (void *)0xdeadbeef, "Unexpected state.\n");
 
     hr = IMFAsyncResult_GetStatus(result);
-    ok(hr == S_OK, "Unexpected status %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected status %#x.\n", hr);
 
     data->hrStatusResult = 123;
     hr = IMFAsyncResult_GetStatus(result);
-    ok(hr == 123, "Unexpected status %#lx.\n", hr);
+    ok(hr == 123, "Unexpected status %#x.\n", hr);
 
     hr = IMFAsyncResult_SetStatus(result, E_FAIL);
-    ok(hr == S_OK, "Failed to set status, hr %#lx.\n", hr);
-    ok(data->hrStatusResult == E_FAIL, "Unexpected status %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to set status, hr %#x.\n", hr);
+    ok(data->hrStatusResult == E_FAIL, "Unexpected status %#x.\n", hr);
 
     hr = IMFAsyncResult_GetObject(result, NULL);
-    ok(hr == E_POINTER, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Unexpected hr %#x.\n", hr);
 
     object = (void *)0xdeadbeef;
     hr = IMFAsyncResult_GetObject(result, &object);
-    ok(hr == E_POINTER, "Failed to get object, hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Failed to get object, hr %#x.\n", hr);
     ok(object == (void *)0xdeadbeef, "Unexpected object.\n");
 
     state = IMFAsyncResult_GetStateNoAddRef(result);
@@ -2751,17 +2717,17 @@ static void test_MFCreateAsyncResult(void)
 
     /* Object. */
     hr = MFCreateAsyncResult((IUnknown *)result, &callback->IMFAsyncCallback_iface, NULL, &result2);
-    ok(hr == S_OK, "Failed to create object, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to create object, hr %#x.\n", hr);
 
     data = (MFASYNCRESULT *)result2;
     ok(data->pCallback == &callback->IMFAsyncCallback_iface, "Unexpected callback value.\n");
-    ok(data->hrStatusResult == S_OK, "Unexpected status %#lx.\n", data->hrStatusResult);
-    ok(data->dwBytesTransferred == 0, "Unexpected byte length %lu.\n", data->dwBytesTransferred);
+    ok(data->hrStatusResult == S_OK, "Unexpected status %#x.\n", data->hrStatusResult);
+    ok(data->dwBytesTransferred == 0, "Unexpected byte length %u.\n", data->dwBytesTransferred);
     ok(data->hEvent == NULL, "Unexpected event.\n");
 
     object = NULL;
     hr = IMFAsyncResult_GetObject(result2, &object);
-    ok(hr == S_OK, "Failed to get object, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get object, hr %#x.\n", hr);
     ok(object == (IUnknown *)result, "Unexpected object.\n");
     IUnknown_Release(object);
 
@@ -2769,17 +2735,17 @@ static void test_MFCreateAsyncResult(void)
 
     /* State object. */
     hr = MFCreateAsyncResult(NULL, &callback->IMFAsyncCallback_iface, (IUnknown *)result, &result2);
-    ok(hr == S_OK, "Failed to create object, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to create object, hr %#x.\n", hr);
 
     data = (MFASYNCRESULT *)result2;
     ok(data->pCallback == &callback->IMFAsyncCallback_iface, "Unexpected callback value.\n");
-    ok(data->hrStatusResult == S_OK, "Unexpected status %#lx.\n", data->hrStatusResult);
-    ok(data->dwBytesTransferred == 0, "Unexpected byte length %lu.\n", data->dwBytesTransferred);
+    ok(data->hrStatusResult == S_OK, "Unexpected status %#x.\n", data->hrStatusResult);
+    ok(data->dwBytesTransferred == 0, "Unexpected byte length %u.\n", data->dwBytesTransferred);
     ok(data->hEvent == NULL, "Unexpected event.\n");
 
     state = NULL;
     hr = IMFAsyncResult_GetState(result2, &state);
-    ok(hr == S_OK, "Failed to get state object, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get state object, hr %#x.\n", hr);
     ok(state == (IUnknown *)result, "Unexpected state.\n");
     IUnknown_Release(state);
 
@@ -2787,13 +2753,13 @@ static void test_MFCreateAsyncResult(void)
     ok(state == (IUnknown *)result, "Unexpected state.\n");
 
     refcount = IMFAsyncResult_Release(result2);
-    ok(!refcount, "Unexpected refcount %lu.\n", refcount);
+    ok(!refcount, "Unexpected refcount %u.\n", refcount);
     refcount = IMFAsyncResult_Release(result);
-    ok(!refcount, "Unexpected refcount %lu.\n", refcount);
+    ok(!refcount, "Unexpected refcount %u.\n", refcount);
 
     /* Event handle is closed on release. */
     hr = MFCreateAsyncResult(NULL, NULL, NULL, &result);
-    ok(hr == S_OK, "Failed to create object, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to create object, hr %#x.\n", hr);
 
     data = (MFASYNCRESULT *)result;
     data->hEvent = event = CreateEventA(NULL, FALSE, FALSE, NULL);
@@ -2802,12 +2768,12 @@ static void test_MFCreateAsyncResult(void)
     ok(ret, "Failed to get handle info.\n");
 
     refcount = IMFAsyncResult_Release(result);
-    ok(!refcount, "Unexpected refcount %lu.\n", refcount);
+    ok(!refcount, "Unexpected refcount %u.\n", refcount);
     ret = GetHandleInformation(event, &flags);
     ok(!ret, "Expected handle to be closed.\n");
 
     hr = MFCreateAsyncResult(NULL, &callback->IMFAsyncCallback_iface, NULL, &result);
-    ok(hr == S_OK, "Failed to create object, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to create object, hr %#x.\n", hr);
 
     data = (MFASYNCRESULT *)result;
     data->hEvent = event = CreateEventA(NULL, FALSE, FALSE, NULL);
@@ -2816,7 +2782,7 @@ static void test_MFCreateAsyncResult(void)
     ok(ret, "Failed to get handle info.\n");
 
     refcount = IMFAsyncResult_Release(result);
-    ok(!refcount, "Unexpected refcount %lu.\n", refcount);
+    ok(!refcount, "Unexpected refcount %u.\n", refcount);
     ret = GetHandleInformation(event, &flags);
     ok(!ret, "Expected handle to be closed.\n");
 
@@ -2829,63 +2795,63 @@ static void test_startup(void)
     HRESULT hr;
 
     hr = MFStartup(MAKELONG(MF_API_VERSION, 0xdead), MFSTARTUP_FULL);
-    ok(hr == MF_E_BAD_STARTUP_VERSION, "Unexpected hr %#lx.\n", hr);
+    ok(hr == MF_E_BAD_STARTUP_VERSION, "Unexpected hr %#x.\n", hr);
 
     hr = MFStartup(MF_VERSION, MFSTARTUP_FULL);
-    ok(hr == S_OK, "Failed to start up, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to start up, hr %#x.\n", hr);
 
     hr = MFAllocateWorkQueue(&queue);
-    ok(hr == S_OK, "Failed to allocate a queue, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to allocate a queue, hr %#x.\n", hr);
     hr = MFUnlockWorkQueue(queue);
-    ok(hr == S_OK, "Failed to unlock the queue, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to unlock the queue, hr %#x.\n", hr);
 
     hr = MFShutdown();
-    ok(hr == S_OK, "Failed to shut down, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to shut down, hr %#x.\n", hr);
 
     hr = MFAllocateWorkQueue(&queue);
-    ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#lx.\n", hr);
+    ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#x.\n", hr);
 
     /* Already shut down, has no effect. */
     hr = MFShutdown();
-    ok(hr == S_OK, "Failed to shut down, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to shut down, hr %#x.\n", hr);
 
     hr = MFStartup(MF_VERSION, MFSTARTUP_FULL);
-    ok(hr == S_OK, "Failed to start up, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to start up, hr %#x.\n", hr);
 
     hr = MFAllocateWorkQueue(&queue);
-    ok(hr == S_OK, "Failed to allocate a queue, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to allocate a queue, hr %#x.\n", hr);
     hr = MFUnlockWorkQueue(queue);
-    ok(hr == S_OK, "Failed to unlock the queue, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to unlock the queue, hr %#x.\n", hr);
 
     hr = MFShutdown();
-    ok(hr == S_OK, "Failed to shut down, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to shut down, hr %#x.\n", hr);
 
     /* Platform lock. */
     hr = MFStartup(MF_VERSION, MFSTARTUP_FULL);
-    ok(hr == S_OK, "Failed to start up, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to start up, hr %#x.\n", hr);
 
     hr = MFAllocateWorkQueue(&queue);
-    ok(hr == S_OK, "Failed to allocate a queue, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to allocate a queue, hr %#x.\n", hr);
     hr = MFUnlockWorkQueue(queue);
-    ok(hr == S_OK, "Failed to unlock the queue, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to unlock the queue, hr %#x.\n", hr);
 
     /* Unlocking implies shutdown. */
     hr = MFUnlockPlatform();
-    ok(hr == S_OK, "Failed to unlock, %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to unlock, %#x.\n", hr);
 
     hr = MFAllocateWorkQueue(&queue);
-    ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#lx.\n", hr);
+    ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#x.\n", hr);
 
     hr = MFLockPlatform();
-    ok(hr == S_OK, "Failed to lock, %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to lock, %#x.\n", hr);
 
     hr = MFAllocateWorkQueue(&queue);
-    ok(hr == S_OK, "Failed to allocate a queue, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to allocate a queue, hr %#x.\n", hr);
     hr = MFUnlockWorkQueue(queue);
-    ok(hr == S_OK, "Failed to unlock the queue, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to unlock the queue, hr %#x.\n", hr);
 
     hr = MFShutdown();
-    ok(hr == S_OK, "Failed to shut down, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to shut down, hr %#x.\n", hr);
 }
 
 static void test_allocate_queue(void)
@@ -2894,37 +2860,37 @@ static void test_allocate_queue(void)
     HRESULT hr;
 
     hr = MFStartup(MF_VERSION, MFSTARTUP_FULL);
-    ok(hr == S_OK, "Failed to start up, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to start up, hr %#x.\n", hr);
 
     hr = MFAllocateWorkQueue(&queue);
-    ok(hr == S_OK, "Failed to allocate a queue, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to allocate a queue, hr %#x.\n", hr);
     ok(queue & MFASYNC_CALLBACK_QUEUE_PRIVATE_MASK, "Unexpected queue id.\n");
 
     hr = MFUnlockWorkQueue(queue);
-    ok(hr == S_OK, "Failed to unlock the queue, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to unlock the queue, hr %#x.\n", hr);
 
     hr = MFUnlockWorkQueue(queue);
-    ok(FAILED(hr), "Unexpected hr %#lx.\n", hr);
+    ok(FAILED(hr), "Unexpected hr %#x.\n", hr);
 
     hr = MFAllocateWorkQueue(&queue2);
-    ok(hr == S_OK, "Failed to allocate a queue, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to allocate a queue, hr %#x.\n", hr);
     ok(queue2 & MFASYNC_CALLBACK_QUEUE_PRIVATE_MASK, "Unexpected queue id.\n");
 
     hr = MFUnlockWorkQueue(queue2);
-    ok(hr == S_OK, "Failed to unlock the queue, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to unlock the queue, hr %#x.\n", hr);
 
     /* Unlock in system queue range. */
     hr = MFUnlockWorkQueue(MFASYNC_CALLBACK_QUEUE_STANDARD);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = MFUnlockWorkQueue(MFASYNC_CALLBACK_QUEUE_UNDEFINED);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = MFUnlockWorkQueue(0x20);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = MFShutdown();
-    ok(hr == S_OK, "Failed to shut down, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to shut down, hr %#x.\n", hr);
 }
 
 static void test_MFCopyImage(void)
@@ -2942,21 +2908,21 @@ static void test_MFCopyImage(void)
     memset(src, 0x11, sizeof(src));
 
     hr = pMFCopyImage(dest, 8, src, 8, 4, 1);
-    ok(hr == S_OK, "Failed to copy image %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to copy image %#x.\n", hr);
     ok(!memcmp(dest, src, 4) && dest[4] == 0xaa, "Unexpected buffer contents.\n");
 
     memset(dest, 0xaa, sizeof(dest));
     memset(src, 0x11, sizeof(src));
 
     hr = pMFCopyImage(dest, 8, src, 8, 16, 1);
-    ok(hr == S_OK, "Failed to copy image %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to copy image %#x.\n", hr);
     ok(!memcmp(dest, src, 16), "Unexpected buffer contents.\n");
 
     memset(dest, 0xaa, sizeof(dest));
     memset(src, 0x11, sizeof(src));
 
     hr = pMFCopyImage(dest, 8, src, 8, 8, 2);
-    ok(hr == S_OK, "Failed to copy image %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to copy image %#x.\n", hr);
     ok(!memcmp(dest, src, 16), "Unexpected buffer contents.\n");
 }
 
@@ -2968,96 +2934,96 @@ static void test_MFCreateCollection(void)
     HRESULT hr;
 
     hr = MFCreateCollection(NULL);
-    ok(hr == E_POINTER, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Unexpected hr %#x.\n", hr);
 
     hr = MFCreateCollection(&collection);
-    ok(hr == S_OK, "Failed to create collection, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to create collection, hr %#x.\n", hr);
 
     hr = IMFCollection_GetElementCount(collection, NULL);
-    ok(hr == E_POINTER, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Unexpected hr %#x.\n", hr);
 
     count = 1;
     hr = IMFCollection_GetElementCount(collection, &count);
-    ok(hr == S_OK, "Failed to get element count, hr %#lx.\n", hr);
-    ok(count == 0, "Unexpected count %lu.\n", count);
+    ok(hr == S_OK, "Failed to get element count, hr %#x.\n", hr);
+    ok(count == 0, "Unexpected count %u.\n", count);
 
     hr = IMFCollection_GetElement(collection, 0, NULL);
-    ok(hr == E_POINTER, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Unexpected hr %#x.\n", hr);
 
     element = (void *)0xdeadbeef;
     hr = IMFCollection_GetElement(collection, 0, &element);
-    ok(hr == E_INVALIDARG, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
     ok(element == (void *)0xdeadbeef, "Unexpected pointer.\n");
 
     hr = IMFCollection_RemoveElement(collection, 0, NULL);
-    ok(hr == E_POINTER, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Unexpected hr %#x.\n", hr);
 
     element = (void *)0xdeadbeef;
     hr = IMFCollection_RemoveElement(collection, 0, &element);
-    ok(hr == E_INVALIDARG, "Failed to remove element, hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Failed to remove element, hr %#x.\n", hr);
     ok(element == (void *)0xdeadbeef, "Unexpected pointer.\n");
 
     hr = IMFCollection_RemoveAllElements(collection);
-    ok(hr == S_OK, "Failed to clear, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to clear, hr %#x.\n", hr);
 
     hr = IMFCollection_AddElement(collection, (IUnknown *)collection);
-    ok(hr == S_OK, "Failed to add element, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to add element, hr %#x.\n", hr);
 
     count = 0;
     hr = IMFCollection_GetElementCount(collection, &count);
-    ok(hr == S_OK, "Failed to get element count, hr %#lx.\n", hr);
-    ok(count == 1, "Unexpected count %lu.\n", count);
+    ok(hr == S_OK, "Failed to get element count, hr %#x.\n", hr);
+    ok(count == 1, "Unexpected count %u.\n", count);
 
     hr = IMFCollection_AddElement(collection, NULL);
-    ok(hr == S_OK, "Failed to add element, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to add element, hr %#x.\n", hr);
 
     count = 0;
     hr = IMFCollection_GetElementCount(collection, &count);
-    ok(hr == S_OK, "Failed to get element count, hr %#lx.\n", hr);
-    ok(count == 2, "Unexpected count %lu.\n", count);
+    ok(hr == S_OK, "Failed to get element count, hr %#x.\n", hr);
+    ok(count == 2, "Unexpected count %u.\n", count);
 
     hr = IMFCollection_InsertElementAt(collection, 10, (IUnknown *)collection);
-    ok(hr == S_OK, "Failed to insert element, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to insert element, hr %#x.\n", hr);
 
     count = 0;
     hr = IMFCollection_GetElementCount(collection, &count);
-    ok(hr == S_OK, "Failed to get element count, hr %#lx.\n", hr);
-    ok(count == 11, "Unexpected count %lu.\n", count);
+    ok(hr == S_OK, "Failed to get element count, hr %#x.\n", hr);
+    ok(count == 11, "Unexpected count %u.\n", count);
 
     hr = IMFCollection_GetElement(collection, 0, &element);
-    ok(hr == S_OK, "Failed to get element, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get element, hr %#x.\n", hr);
     ok(element == (IUnknown *)collection, "Unexpected element.\n");
     IUnknown_Release(element);
 
     hr = IMFCollection_GetElement(collection, 1, &element);
-    ok(hr == E_UNEXPECTED, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_UNEXPECTED, "Unexpected hr %#x.\n", hr);
     ok(!element, "Unexpected element.\n");
 
     hr = IMFCollection_GetElement(collection, 2, &element);
-    ok(hr == E_UNEXPECTED, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_UNEXPECTED, "Unexpected hr %#x.\n", hr);
     ok(!element, "Unexpected element.\n");
 
     hr = IMFCollection_GetElement(collection, 10, &element);
-    ok(hr == S_OK, "Failed to get element, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get element, hr %#x.\n", hr);
     ok(element == (IUnknown *)collection, "Unexpected element.\n");
     IUnknown_Release(element);
 
     hr = IMFCollection_InsertElementAt(collection, 0, NULL);
-    ok(hr == S_OK, "Failed to insert element, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to insert element, hr %#x.\n", hr);
 
     hr = IMFCollection_GetElement(collection, 0, &element);
-    ok(hr == E_UNEXPECTED, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_UNEXPECTED, "Unexpected hr %#x.\n", hr);
 
     hr = IMFCollection_RemoveAllElements(collection);
-    ok(hr == S_OK, "Failed to clear, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to clear, hr %#x.\n", hr);
 
     count = 1;
     hr = IMFCollection_GetElementCount(collection, &count);
-    ok(hr == S_OK, "Failed to get element count, hr %#lx.\n", hr);
-    ok(count == 0, "Unexpected count %lu.\n", count);
+    ok(hr == S_OK, "Failed to get element count, hr %#x.\n", hr);
+    ok(count == 0, "Unexpected count %u.\n", count);
 
     hr = IMFCollection_InsertElementAt(collection, 0, NULL);
-    ok(hr == S_OK, "Failed to insert element, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to insert element, hr %#x.\n", hr);
 
     IMFCollection_Release(collection);
 }
@@ -3082,16 +3048,16 @@ static void test_scheduled_items(void)
     callback = create_test_callback(NULL);
 
     hr = MFStartup(MF_VERSION, MFSTARTUP_FULL);
-    ok(hr == S_OK, "Failed to start up, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to start up, hr %#x.\n", hr);
 
     hr = MFScheduleWorkItem(&callback->IMFAsyncCallback_iface, NULL, -5000, &key);
-    ok(hr == S_OK, "Failed to schedule item, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to schedule item, hr %#x.\n", hr);
 
     hr = MFCancelWorkItem(key);
-    ok(hr == S_OK, "Failed to cancel item, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to cancel item, hr %#x.\n", hr);
 
     hr = MFCancelWorkItem(key);
-    ok(hr == MF_E_NOT_FOUND || broken(hr == S_OK) /* < win10 */, "Unexpected hr %#lx.\n", hr);
+    ok(hr == MF_E_NOT_FOUND || broken(hr == S_OK) /* < win10 */, "Unexpected hr %#x.\n", hr);
 
     if (!pMFPutWaitingWorkItem)
     {
@@ -3100,30 +3066,30 @@ static void test_scheduled_items(void)
     }
 
     hr = MFCreateAsyncResult(NULL, &callback->IMFAsyncCallback_iface, NULL, &result);
-    ok(hr == S_OK, "Failed to create result, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to create result, hr %#x.\n", hr);
 
     hr = pMFPutWaitingWorkItem(NULL, 0, result, &key);
-    ok(hr == S_OK, "Failed to add waiting item, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to add waiting item, hr %#x.\n", hr);
 
     hr = pMFPutWaitingWorkItem(NULL, 0, result, &key2);
-    ok(hr == S_OK, "Failed to add waiting item, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to add waiting item, hr %#x.\n", hr);
 
     hr = MFCancelWorkItem(key);
-    ok(hr == S_OK, "Failed to cancel item, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to cancel item, hr %#x.\n", hr);
 
     hr = MFCancelWorkItem(key2);
-    ok(hr == S_OK, "Failed to cancel item, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to cancel item, hr %#x.\n", hr);
 
     IMFAsyncResult_Release(result);
 
     hr = MFScheduleWorkItem(&callback->IMFAsyncCallback_iface, NULL, -5000, &key);
-    ok(hr == S_OK, "Failed to schedule item, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to schedule item, hr %#x.\n", hr);
 
     hr = MFCancelWorkItem(key);
-    ok(hr == S_OK, "Failed to cancel item, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to cancel item, hr %#x.\n", hr);
 
     hr = MFShutdown();
-    ok(hr == S_OK, "Failed to shut down, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to shut down, hr %#x.\n", hr);
 
     IMFAsyncCallback_Release(&callback->IMFAsyncCallback_iface);
 }
@@ -3150,7 +3116,7 @@ static void test_serial_queue(void)
     }
 
     hr = MFStartup(MF_VERSION, MFSTARTUP_FULL);
-    ok(hr == S_OK, "Failed to start up, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to start up, hr %#x.\n", hr);
 
     for (i = 0; i < ARRAY_SIZE(queue_ids); ++i)
     {
@@ -3159,30 +3125,30 @@ static void test_serial_queue(void)
 
         hr = pMFAllocateSerialWorkQueue(queue_ids[i], &serial_queue);
         ok(hr == S_OK || broken(broken_types && hr == E_INVALIDARG) /* Win8 */,
-                "%u: failed to allocate a queue, hr %#lx.\n", i, hr);
+                "%u: failed to allocate a queue, hr %#x.\n", i, hr);
 
         if (SUCCEEDED(hr))
         {
             hr = MFUnlockWorkQueue(serial_queue);
-            ok(hr == S_OK, "%u: failed to unlock the queue, hr %#lx.\n", i, hr);
+            ok(hr == S_OK, "%u: failed to unlock the queue, hr %#x.\n", i, hr);
         }
     }
 
     /* Chain them together. */
     hr = pMFAllocateSerialWorkQueue(MFASYNC_CALLBACK_QUEUE_STANDARD, &serial_queue);
-    ok(hr == S_OK, "Failed to allocate a queue, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to allocate a queue, hr %#x.\n", hr);
 
     hr = pMFAllocateSerialWorkQueue(serial_queue, &queue);
-    ok(hr == S_OK, "Failed to allocate a queue, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to allocate a queue, hr %#x.\n", hr);
 
     hr = MFUnlockWorkQueue(serial_queue);
-    ok(hr == S_OK, "Failed to unlock the queue, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to unlock the queue, hr %#x.\n", hr);
 
     hr = MFUnlockWorkQueue(queue);
-    ok(hr == S_OK, "Failed to unlock the queue, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to unlock the queue, hr %#x.\n", hr);
 
     hr = MFShutdown();
-    ok(hr == S_OK, "Failed to shut down, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to shut down, hr %#x.\n", hr);
 }
 
 static LONG periodic_counter;
@@ -3197,36 +3163,36 @@ static void test_periodic_callback(void)
     HRESULT hr;
 
     hr = MFStartup(MF_VERSION, MFSTARTUP_FULL);
-    ok(hr == S_OK, "Failed to start up, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to start up, hr %#x.\n", hr);
 
     period = 0;
     hr = MFGetTimerPeriodicity(&period);
-    ok(hr == S_OK, "Failed to get timer perdiod, hr %#lx.\n", hr);
-    ok(period == 10, "Unexpected period %lu.\n", period);
+    ok(hr == S_OK, "Failed to get timer perdiod, hr %#x.\n", hr);
+    ok(period == 10, "Unexpected period %u.\n", period);
 
     if (!pMFAddPeriodicCallback)
     {
         win_skip("Periodic callbacks are not supported.\n");
         hr = MFShutdown();
-        ok(hr == S_OK, "Failed to shut down, hr %#lx.\n", hr);
+        ok(hr == S_OK, "Failed to shut down, hr %#x.\n", hr);
         return;
     }
 
-    ok(periodic_counter == 0, "Unexpected counter value %lu.\n", periodic_counter);
+    ok(periodic_counter == 0, "Unexpected counter value %u.\n", periodic_counter);
 
     hr = pMFAddPeriodicCallback(periodic_callback, NULL, &key);
-    ok(hr == S_OK, "Failed to add periodic callback, hr %#lx.\n", hr);
-    ok(key != 0, "Unexpected key %#lx.\n", key);
+    ok(hr == S_OK, "Failed to add periodic callback, hr %#x.\n", hr);
+    ok(key != 0, "Unexpected key %#x.\n", key);
 
     Sleep(10 * period);
 
     hr = pMFRemovePeriodicCallback(key);
-    ok(hr == S_OK, "Failed to remove callback, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to remove callback, hr %#x.\n", hr);
 
-    ok(periodic_counter > 0, "Unexpected counter value %lu.\n", periodic_counter);
+    ok(periodic_counter > 0, "Unexpected counter value %u.\n", periodic_counter);
 
     hr = MFShutdown();
-    ok(hr == S_OK, "Failed to shut down, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to shut down, hr %#x.\n", hr);
 }
 
 static void test_event_queue(void)
@@ -3242,108 +3208,108 @@ static void test_event_queue(void)
     callback2 = create_test_callback(NULL);
 
     hr = MFStartup(MF_VERSION, MFSTARTUP_FULL);
-    ok(hr == S_OK, "Failed to start up, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to start up, hr %#x.\n", hr);
 
     hr = MFCreateEventQueue(&queue);
-    ok(hr == S_OK, "Failed to create event queue, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to create event queue, hr %#x.\n", hr);
 
     hr = IMFMediaEventQueue_GetEvent(queue, MF_EVENT_FLAG_NO_WAIT, &event);
-    ok(hr == MF_E_NO_EVENTS_AVAILABLE, "Unexpected hr %#lx.\n", hr);
+    ok(hr == MF_E_NO_EVENTS_AVAILABLE, "Unexpected hr %#x.\n", hr);
 
     hr = MFCreateMediaEvent(MEError, &GUID_NULL, E_FAIL, NULL, &event);
-    ok(hr == S_OK, "Failed to create event object, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to create event object, hr %#x.\n", hr);
 
     if (is_win8_plus)
     {
         hr = IMFMediaEventQueue_QueueEvent(queue, event);
-        ok(hr == S_OK, "Failed to queue event, hr %#lx.\n", hr);
+        ok(hr == S_OK, "Failed to queue event, hr %#x.\n", hr);
 
         hr = IMFMediaEventQueue_GetEvent(queue, MF_EVENT_FLAG_NO_WAIT, &event2);
-        ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+        ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
         ok(event2 == event, "Unexpected event object.\n");
         IMFMediaEvent_Release(event2);
 
         hr = IMFMediaEventQueue_QueueEvent(queue, event);
-        ok(hr == S_OK, "Failed to queue event, hr %#lx.\n", hr);
+        ok(hr == S_OK, "Failed to queue event, hr %#x.\n", hr);
 
         hr = IMFMediaEventQueue_GetEvent(queue, 0, &event2);
-        ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+        ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
         IMFMediaEvent_Release(event2);
     }
 
     /* Async case. */
     hr = IMFMediaEventQueue_BeginGetEvent(queue, NULL, NULL);
-    ok(hr == E_INVALIDARG, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
 
     hr = IMFMediaEventQueue_BeginGetEvent(queue, &callback->IMFAsyncCallback_iface, (IUnknown *)queue);
-    ok(hr == S_OK, "Failed to Begin*, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to Begin*, hr %#x.\n", hr);
 
     /* Same callback, same state. */
     hr = IMFMediaEventQueue_BeginGetEvent(queue, &callback->IMFAsyncCallback_iface, (IUnknown *)queue);
-    ok(hr == MF_S_MULTIPLE_BEGIN, "Unexpected hr %#lx.\n", hr);
+    ok(hr == MF_S_MULTIPLE_BEGIN, "Unexpected hr %#x.\n", hr);
 
     /* Same callback, different state. */
     hr = IMFMediaEventQueue_BeginGetEvent(queue, &callback->IMFAsyncCallback_iface, (IUnknown *)&callback->IMFAsyncCallback_iface);
-    ok(hr == MF_E_MULTIPLE_BEGIN, "Unexpected hr %#lx.\n", hr);
+    ok(hr == MF_E_MULTIPLE_BEGIN, "Unexpected hr %#x.\n", hr);
 
     /* Different callback, same state. */
     hr = IMFMediaEventQueue_BeginGetEvent(queue, &callback2->IMFAsyncCallback_iface, (IUnknown *)queue);
-    ok(hr == MF_E_MULTIPLE_SUBSCRIBERS, "Unexpected hr %#lx.\n", hr);
+    ok(hr == MF_E_MULTIPLE_SUBSCRIBERS, "Unexpected hr %#x.\n", hr);
 
     /* Different callback, different state. */
     hr = IMFMediaEventQueue_BeginGetEvent(queue, &callback2->IMFAsyncCallback_iface, (IUnknown *)&callback->IMFAsyncCallback_iface);
-    ok(hr == MF_E_MULTIPLE_SUBSCRIBERS, "Unexpected hr %#lx.\n", hr);
+    ok(hr == MF_E_MULTIPLE_SUBSCRIBERS, "Unexpected hr %#x.\n", hr);
 
     callback->event = CreateEventA(NULL, FALSE, FALSE, NULL);
 
     hr = IMFMediaEventQueue_QueueEvent(queue, event);
-    ok(hr == S_OK, "Failed to queue event, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to queue event, hr %#x.\n", hr);
 
     ret = WaitForSingleObject(callback->event, 500);
-    ok(ret == WAIT_OBJECT_0, "Unexpected return value %#lx.\n", ret);
+    ok(ret == WAIT_OBJECT_0, "Unexpected return value %#x.\n", ret);
 
     CloseHandle(callback->event);
 
     IMFMediaEvent_Release(event);
 
     hr = MFCreateAsyncResult(NULL, &callback->IMFAsyncCallback_iface, NULL, &result);
-    ok(hr == S_OK, "Failed to create result, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to create result, hr %#x.\n", hr);
 
     hr = IMFMediaEventQueue_EndGetEvent(queue, result, &event);
-    ok(hr == E_FAIL, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_FAIL, "Unexpected hr %#x.\n", hr);
 
     /* Shutdown behavior. */
     hr = IMFMediaEventQueue_Shutdown(queue);
-    ok(hr == S_OK, "Failed to shut down, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to shut down, hr %#x.\n", hr);
 
     hr = IMFMediaEventQueue_GetEvent(queue, MF_EVENT_FLAG_NO_WAIT, &event);
-    ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#lx.\n", hr);
+    ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#x.\n", hr);
 
     hr = MFCreateMediaEvent(MEError, &GUID_NULL, E_FAIL, NULL, &event);
-    ok(hr == S_OK, "Failed to create event object, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to create event object, hr %#x.\n", hr);
     hr = IMFMediaEventQueue_QueueEvent(queue, event);
-    ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#lx.\n", hr);
+    ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#x.\n", hr);
     IMFMediaEvent_Release(event);
 
     hr = IMFMediaEventQueue_QueueEventParamUnk(queue, MEError, &GUID_NULL, E_FAIL, NULL);
-    ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#lx.\n", hr);
+    ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#x.\n", hr);
 
     hr = IMFMediaEventQueue_QueueEventParamVar(queue, MEError, &GUID_NULL, E_FAIL, NULL);
-    ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#lx.\n", hr);
+    ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#x.\n", hr);
 
     hr = IMFMediaEventQueue_BeginGetEvent(queue, &callback->IMFAsyncCallback_iface, NULL);
-    ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#lx.\n", hr);
+    ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#x.\n", hr);
 
     hr = IMFMediaEventQueue_BeginGetEvent(queue, NULL, NULL);
-    ok(hr == E_INVALIDARG, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
 
     hr = IMFMediaEventQueue_EndGetEvent(queue, result, &event);
-    ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#lx.\n", hr);
+    ok(hr == MF_E_SHUTDOWN, "Unexpected hr %#x.\n", hr);
     IMFAsyncResult_Release(result);
 
     /* Already shut down. */
     hr = IMFMediaEventQueue_Shutdown(queue);
-    ok(hr == S_OK, "Failed to shut down, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to shut down, hr %#x.\n", hr);
 
     IMFMediaEventQueue_Release(queue);
     IMFAsyncCallback_Release(&callback->IMFAsyncCallback_iface);
@@ -3352,20 +3318,20 @@ static void test_event_queue(void)
     callback = create_test_callback(NULL);
 
     hr = MFCreateEventQueue(&queue);
-    ok(hr == S_OK, "Failed to create event queue, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to create event queue, hr %#x.\n", hr);
 
     hr = IMFMediaEventQueue_BeginGetEvent(queue, &callback->IMFAsyncCallback_iface, NULL);
-    ok(hr == S_OK, "Failed to Begin*, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to Begin*, hr %#x.\n", hr);
     EXPECT_REF(&callback->IMFAsyncCallback_iface, 2);
 
     IMFMediaEventQueue_Release(queue);
     ret = get_refcount(&callback->IMFAsyncCallback_iface);
     ok(ret == 1 || broken(ret == 2) /* Vista */,
-       "Unexpected refcount %ld, expected 1.\n", ret);
+       "Unexpected refcount %d, expected 1.\n", ret);
     IMFAsyncCallback_Release(&callback->IMFAsyncCallback_iface);
 
     hr = MFShutdown();
-    ok(hr == S_OK, "Failed to shut down, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to shut down, hr %#x.\n", hr);
 }
 
 static void test_presentation_descriptor(void)
@@ -3380,58 +3346,58 @@ static void test_presentation_descriptor(void)
     HRESULT hr;
 
     hr = MFCreateMediaType(&media_type);
-    ok(hr == S_OK, "Failed to create media type, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to create media type, hr %#x.\n", hr);
 
     for (i = 0; i < ARRAY_SIZE(stream_desc); ++i)
     {
         hr = MFCreateStreamDescriptor(0, 1, &media_type, &stream_desc[i]);
-        ok(hr == S_OK, "Failed to create descriptor, hr %#lx.\n", hr);
+        ok(hr == S_OK, "Failed to create descriptor, hr %#x.\n", hr);
     }
 
     hr = MFCreatePresentationDescriptor(ARRAY_SIZE(stream_desc), stream_desc, &pd);
-    ok(hr == S_OK, "Failed to create presentation descriptor, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to create presentation descriptor, hr %#x.\n", hr);
 
     hr = IMFPresentationDescriptor_GetStreamDescriptorCount(pd, &count);
-    ok(count == ARRAY_SIZE(stream_desc), "Unexpected count %lu.\n", count);
+    ok(count == ARRAY_SIZE(stream_desc), "Unexpected count %u.\n", count);
 
     for (i = 0; i < count; ++i)
     {
         hr = IMFPresentationDescriptor_GetStreamDescriptorByIndex(pd, i, &selected, &stream_desc2);
-        ok(hr == S_OK, "Failed to get stream descriptor, hr %#lx.\n", hr);
+        ok(hr == S_OK, "Failed to get stream descriptor, hr %#x.\n", hr);
         ok(!selected, "Unexpected selected state.\n");
         ok(stream_desc[i] == stream_desc2, "Unexpected object.\n");
         IMFStreamDescriptor_Release(stream_desc2);
     }
 
     hr = IMFPresentationDescriptor_GetStreamDescriptorByIndex(pd, 10, &selected, &stream_desc2);
-    ok(hr == E_INVALIDARG, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
 
     hr = IMFPresentationDescriptor_SelectStream(pd, 10);
-    ok(hr == E_INVALIDARG, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
 
     hr = IMFPresentationDescriptor_SelectStream(pd, 0);
-    ok(hr == S_OK, "Failed to select a stream, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to select a stream, hr %#x.\n", hr);
 
     hr = IMFPresentationDescriptor_GetStreamDescriptorByIndex(pd, 0, &selected, &stream_desc2);
-    ok(hr == S_OK, "Failed to get stream descriptor, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get stream descriptor, hr %#x.\n", hr);
     ok(!!selected, "Unexpected selected state.\n");
     IMFStreamDescriptor_Release(stream_desc2);
 
     hr = IMFPresentationDescriptor_SetUINT64(pd, &MF_PD_TOTAL_FILE_SIZE, 1);
-    ok(hr == S_OK, "Failed to set attribute, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to set attribute, hr %#x.\n", hr);
 
     hr = IMFPresentationDescriptor_Clone(pd, &pd2);
-    ok(hr == S_OK, "Failed to clone, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to clone, hr %#x.\n", hr);
 
     hr = IMFPresentationDescriptor_GetStreamDescriptorByIndex(pd2, 0, &selected, &stream_desc2);
-    ok(hr == S_OK, "Failed to get stream descriptor, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get stream descriptor, hr %#x.\n", hr);
     ok(!!selected, "Unexpected selected state.\n");
     ok(stream_desc2 == stream_desc[0], "Unexpected stream descriptor.\n");
     IMFStreamDescriptor_Release(stream_desc2);
 
     value = 0;
     hr = IMFPresentationDescriptor_GetUINT64(pd2, &MF_PD_TOTAL_FILE_SIZE, &value);
-    ok(hr == S_OK, "Failed to get attribute, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get attribute, hr %#x.\n", hr);
     ok(value == 1, "Unexpected attribute value.\n");
 
     IMFPresentationDescriptor_Release(pd2);
@@ -3444,11 +3410,11 @@ static void test_presentation_descriptor(void)
 
     /* Partially initialized array. */
     hr = MFCreateStreamDescriptor(0, 1, &media_type, &stream_desc[1]);
-    ok(hr == S_OK, "Failed to create descriptor, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to create descriptor, hr %#x.\n", hr);
     stream_desc[0] = NULL;
 
     hr = MFCreatePresentationDescriptor(ARRAY_SIZE(stream_desc), stream_desc, &pd);
-    ok(hr == E_INVALIDARG, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
 
     IMFStreamDescriptor_Release(stream_desc[1]);
     IMFMediaType_Release(media_type);
@@ -3502,24 +3468,24 @@ static void test_system_time_source(void)
     HRESULT hr;
 
     hr = MFCreateSystemTimeSource(&time_source);
-    ok(hr == S_OK, "Failed to create time source, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to create time source, hr %#x.\n", hr);
 
     hr = IMFPresentationTimeSource_GetClockCharacteristics(time_source, &value);
-    ok(hr == S_OK, "Failed to get flags, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get flags, hr %#x.\n", hr);
     ok(value == (MFCLOCK_CHARACTERISTICS_FLAG_FREQUENCY_10MHZ | MFCLOCK_CHARACTERISTICS_FLAG_IS_SYSTEM_CLOCK),
-            "Unexpected flags %#lx.\n", value);
+            "Unexpected flags %#x.\n", value);
 
     value = 1;
     hr = IMFPresentationTimeSource_GetContinuityKey(time_source, &value);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
-    ok(value == 0, "Unexpected value %lu.\n", value);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(value == 0, "Unexpected value %u.\n", value);
 
     hr = IMFPresentationTimeSource_GetState(time_source, 0, &state);
-    ok(hr == S_OK, "Failed to get state, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get state, hr %#x.\n", hr);
     ok(state == MFCLOCK_STATE_INVALID, "Unexpected state %d.\n", state);
 
     hr = IMFPresentationTimeSource_QueryInterface(time_source, &IID_IMFClockStateSink, (void **)&statesink);
-    ok(hr == S_OK, "Failed to get state sink, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get state sink, hr %#x.\n", hr);
 
     /* State changes. */
     for (i = 0; i < ARRAY_SIZE(clock_state_change); ++i)
@@ -3541,9 +3507,9 @@ static void test_system_time_source(void)
             default:
                 ;
         }
-        ok(hr == (clock_state_change[i].is_invalid ? MF_E_INVALIDREQUEST : S_OK), "%u: unexpected hr %#lx.\n", i, hr);
+        ok(hr == (clock_state_change[i].is_invalid ? MF_E_INVALIDREQUEST : S_OK), "%u: unexpected hr %#x.\n", i, hr);
         hr = IMFPresentationTimeSource_GetState(time_source, 0, &state);
-        ok(hr == S_OK, "%u: failed to get state, hr %#lx.\n", i, hr);
+        ok(hr == S_OK, "%u: failed to get state, hr %#x.\n", i, hr);
         ok(state == clock_state_change[i].state, "%u: unexpected state %d.\n", i, state);
     }
 
@@ -3551,32 +3517,32 @@ static void test_system_time_source(void)
 
     /* Properties. */
     hr = IMFPresentationTimeSource_GetProperties(time_source, NULL);
-    ok(hr == E_POINTER, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Unexpected hr %#x.\n", hr);
 
     hr = IMFPresentationTimeSource_GetProperties(time_source, &props);
-    ok(hr == S_OK, "Failed to get clock properties, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get clock properties, hr %#x.\n", hr);
 
     ok(props.qwCorrelationRate == 0, "Unexpected correlation rate %s.\n",
             wine_dbgstr_longlong(props.qwCorrelationRate));
     ok(IsEqualGUID(&props.guidClockId, &GUID_NULL), "Unexpected clock id %s.\n", wine_dbgstr_guid(&props.guidClockId));
-    ok(props.dwClockFlags == 0, "Unexpected flags %#lx.\n", props.dwClockFlags);
+    ok(props.dwClockFlags == 0, "Unexpected flags %#x.\n", props.dwClockFlags);
     ok(props.qwClockFrequency == MFCLOCK_FREQUENCY_HNS, "Unexpected frequency %s.\n",
             wine_dbgstr_longlong(props.qwClockFrequency));
-    ok(props.dwClockTolerance == MFCLOCK_TOLERANCE_UNKNOWN, "Unexpected tolerance %lu.\n", props.dwClockTolerance);
-    ok(props.dwClockJitter == 1, "Unexpected jitter %lu.\n", props.dwClockJitter);
+    ok(props.dwClockTolerance == MFCLOCK_TOLERANCE_UNKNOWN, "Unexpected tolerance %u.\n", props.dwClockTolerance);
+    ok(props.dwClockJitter == 1, "Unexpected jitter %u.\n", props.dwClockJitter);
 
     /* Underlying clock. */
     hr = MFCreateSystemTimeSource(&time_source2);
-    ok(hr == S_OK, "Failed to create time source, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to create time source, hr %#x.\n", hr);
     EXPECT_REF(time_source2, 1);
     hr = IMFPresentationTimeSource_GetUnderlyingClock(time_source2, &clock2);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     EXPECT_REF(time_source2, 1);
     EXPECT_REF(clock2, 2);
 
     EXPECT_REF(time_source, 1);
     hr = IMFPresentationTimeSource_GetUnderlyingClock(time_source, &clock);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     EXPECT_REF(time_source, 1);
     EXPECT_REF(clock, 2);
 
@@ -3586,209 +3552,184 @@ static void test_system_time_source(void)
     IMFClock_Release(clock2);
 
     hr = IMFClock_GetClockCharacteristics(clock, &value);
-    ok(hr == S_OK, "Failed to get clock flags, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get clock flags, hr %#x.\n", hr);
     ok(value == (MFCLOCK_CHARACTERISTICS_FLAG_FREQUENCY_10MHZ | MFCLOCK_CHARACTERISTICS_FLAG_ALWAYS_RUNNING |
-            MFCLOCK_CHARACTERISTICS_FLAG_IS_SYSTEM_CLOCK), "Unexpected flags %#lx.\n", value);
+            MFCLOCK_CHARACTERISTICS_FLAG_IS_SYSTEM_CLOCK), "Unexpected flags %#x.\n", value);
 
     hr = IMFClock_GetContinuityKey(clock, &value);
-    ok(hr == S_OK, "Failed to get clock key, hr %#lx.\n", hr);
-    ok(value == 0, "Unexpected key value %lu.\n", value);
+    ok(hr == S_OK, "Failed to get clock key, hr %#x.\n", hr);
+    ok(value == 0, "Unexpected key value %u.\n", value);
 
     hr = IMFClock_GetState(clock, 0, &state);
-    ok(hr == S_OK, "Failed to get clock state, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get clock state, hr %#x.\n", hr);
     ok(state == MFCLOCK_STATE_RUNNING, "Unexpected state %d.\n", state);
 
     hr = IMFClock_GetProperties(clock, &props);
-    ok(hr == S_OK, "Failed to get clock properties, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get clock properties, hr %#x.\n", hr);
 
     ok(props.qwCorrelationRate == 0, "Unexpected correlation rate %s.\n",
             wine_dbgstr_longlong(props.qwCorrelationRate));
     ok(IsEqualGUID(&props.guidClockId, &GUID_NULL), "Unexpected clock id %s.\n", wine_dbgstr_guid(&props.guidClockId));
-    ok(props.dwClockFlags == 0, "Unexpected flags %#lx.\n", props.dwClockFlags);
+    ok(props.dwClockFlags == 0, "Unexpected flags %#x.\n", props.dwClockFlags);
     ok(props.qwClockFrequency == MFCLOCK_FREQUENCY_HNS, "Unexpected frequency %s.\n",
             wine_dbgstr_longlong(props.qwClockFrequency));
-    ok(props.dwClockTolerance == MFCLOCK_TOLERANCE_UNKNOWN, "Unexpected tolerance %lu.\n", props.dwClockTolerance);
-    ok(props.dwClockJitter == 1, "Unexpected jitter %lu.\n", props.dwClockJitter);
+    ok(props.dwClockTolerance == MFCLOCK_TOLERANCE_UNKNOWN, "Unexpected tolerance %u.\n", props.dwClockTolerance);
+    ok(props.dwClockJitter == 1, "Unexpected jitter %u.\n", props.dwClockJitter);
 
     hr = IMFClock_GetCorrelatedTime(clock, 0, &time, &systime);
-    ok(hr == S_OK, "Failed to get clock time, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get clock time, hr %#x.\n", hr);
     ok(time == systime, "Unexpected time %s, %s.\n", wine_dbgstr_longlong(time), wine_dbgstr_longlong(systime));
 
     IMFClock_Release(clock);
 
     /* Test returned time regarding specified rate and offset.  */
     hr = IMFPresentationTimeSource_QueryInterface(time_source, &IID_IMFClockStateSink, (void **)&statesink);
-    ok(hr == S_OK, "Failed to get sink interface, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get sink interface, hr %#x.\n", hr);
 
     hr = IMFPresentationTimeSource_GetState(time_source, 0, &state);
-    ok(hr == S_OK, "Failed to get state %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get state %#x.\n", hr);
     ok(state == MFCLOCK_STATE_STOPPED, "Unexpected state %d.\n", state);
 
     hr = IMFPresentationTimeSource_GetCorrelatedTime(time_source, 0, &time, &systime);
-    ok(hr == S_OK, "Failed to get time %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get time %#x.\n", hr);
     ok(time == 0, "Unexpected time stamp %s, %s.\n", wine_dbgstr_longlong(time), wine_dbgstr_longlong(systime));
 
     hr = IMFClockStateSink_OnClockStart(statesink, 0, 0);
-    ok(hr == S_OK, "Failed to start source, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to start source, hr %#x.\n", hr);
 
     hr = IMFPresentationTimeSource_GetCorrelatedTime(time_source, 0, &time, &systime);
-    ok(hr == S_OK, "Failed to get time %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get time %#x.\n", hr);
     ok(time == systime, "Unexpected time stamp %s, %s.\n", wine_dbgstr_longlong(time), wine_dbgstr_longlong(systime));
 
     hr = IMFClockStateSink_OnClockStart(statesink, 0, 1);
-    ok(hr == S_OK, "Failed to start source, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to start source, hr %#x.\n", hr);
 
     hr = IMFPresentationTimeSource_GetCorrelatedTime(time_source, 0, &time, &systime);
-    ok(hr == S_OK, "Failed to get time %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get time %#x.\n", hr);
     ok(time == systime + 1, "Unexpected time stamp %s, %s.\n", wine_dbgstr_longlong(time),
             wine_dbgstr_longlong(systime));
 
     hr = IMFClockStateSink_OnClockPause(statesink, 2);
-    ok(hr == S_OK, "Failed to pause source, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to pause source, hr %#x.\n", hr);
 
     hr = IMFPresentationTimeSource_GetCorrelatedTime(time_source, 0, &time, &systime);
-    ok(hr == S_OK, "Failed to get time %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get time %#x.\n", hr);
     ok(time == 3, "Unexpected time stamp %s, %s.\n", wine_dbgstr_longlong(time), wine_dbgstr_longlong(systime));
 
     hr = IMFClockStateSink_OnClockRestart(statesink, 5);
-    ok(hr == S_OK, "Failed to restart source, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to restart source, hr %#x.\n", hr);
 
     hr = IMFPresentationTimeSource_GetCorrelatedTime(time_source, 0, &time, &systime);
-    ok(hr == S_OK, "Failed to get time %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get time %#x.\n", hr);
     ok(time == systime - 2, "Unexpected time stamp %s, %s.\n", wine_dbgstr_longlong(time),
             wine_dbgstr_longlong(systime));
 
     hr = IMFClockStateSink_OnClockPause(statesink, 0);
-    ok(hr == S_OK, "Failed to pause source, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to pause source, hr %#x.\n", hr);
 
     hr = IMFPresentationTimeSource_GetCorrelatedTime(time_source, 0, &time, &systime);
-    ok(hr == S_OK, "Failed to get time %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get time %#x.\n", hr);
     ok(time == -2, "Unexpected time stamp %s, %s.\n", wine_dbgstr_longlong(time),
             wine_dbgstr_longlong(systime));
 
     hr = IMFClockStateSink_OnClockStop(statesink, 123);
-    ok(hr == S_OK, "Failed to stop source, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to stop source, hr %#x.\n", hr);
 
     hr = IMFPresentationTimeSource_GetCorrelatedTime(time_source, 0, &time, &systime);
-    ok(hr == S_OK, "Failed to get time %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get time %#x.\n", hr);
     ok(time == 0, "Unexpected time stamp %s, %s.\n", wine_dbgstr_longlong(time), wine_dbgstr_longlong(systime));
 
     /* Increased rate. */
     hr = IMFClockStateSink_OnClockSetRate(statesink, 0, 2.0f);
-    ok(hr == S_OK, "Failed to set rate, hr %#lx.\n", hr);
-
-    hr = IMFClockStateSink_OnClockStart(statesink, 0, 0);
-    ok(hr == S_OK, "Failed to start source, hr %#lx.\n", hr);
-
-    hr = IMFClockStateSink_OnClockSetRate(statesink, 5, 2.0f);
-    ok(hr == S_OK, "Failed to set rate, hr %#lx.\n", hr);
-
-    hr = IMFClockStateSink_OnClockPause(statesink, 6);
-    ok(hr == S_OK, "Failed to pause source, hr %#lx.\n", hr);
-
-    hr = IMFPresentationTimeSource_GetCorrelatedTime(time_source, 0, &time, &systime);
-    ok(hr == S_OK, "Failed to get time %#lx.\n", hr);
-    ok(time == 12 && !!systime, "Unexpected time stamp %s, %s.\n", wine_dbgstr_longlong(time),
-            wine_dbgstr_longlong(systime));
-
-    hr = IMFClockStateSink_OnClockRestart(statesink, 7);
-    ok(hr == S_OK, "Failed to restart source, hr %#lx.\n", hr);
-
-    hr = IMFClockStateSink_OnClockPause(statesink, 8);
-    ok(hr == S_OK, "Failed to pause source, hr %#lx.\n", hr);
-
-    hr = IMFPresentationTimeSource_GetCorrelatedTime(time_source, 0, &time, &systime);
-    ok(hr == S_OK, "Failed to get time %#lx.\n", hr);
-    ok(time == 14 && !!systime, "Unexpected time stamp %s, %s.\n", wine_dbgstr_longlong(time),
-            wine_dbgstr_longlong(systime));
+    ok(hr == S_OK, "Failed to set rate, hr %#x.\n", hr);
 
     hr = IMFClockStateSink_OnClockStart(statesink, 0, 0);
-    ok(hr == S_OK, "Failed to start source, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to start source, hr %#x.\n", hr);
 
     hr = IMFPresentationTimeSource_GetCorrelatedTime(time_source, 0, &time, &systime);
-    ok(hr == S_OK, "Failed to get time %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get time %#x.\n", hr);
     ok(time == 2 * systime, "Unexpected time stamp %s, %s.\n", wine_dbgstr_longlong(time),
             wine_dbgstr_longlong(2 * systime));
 
     hr = IMFClockStateSink_OnClockStart(statesink, 0, 10);
-    ok(hr == S_OK, "Failed to start source, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to start source, hr %#x.\n", hr);
 
     hr = IMFPresentationTimeSource_GetCorrelatedTime(time_source, 0, &time, &systime);
-    ok(hr == S_OK, "Failed to get time %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get time %#x.\n", hr);
     ok(time == 2 * systime + 10, "Unexpected time stamp %s, %s.\n", wine_dbgstr_longlong(time),
             wine_dbgstr_longlong(2 * systime));
 
     hr = IMFClockStateSink_OnClockPause(statesink, 2);
-    ok(hr == S_OK, "Failed to pause source, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to pause source, hr %#x.\n", hr);
 
     hr = IMFPresentationTimeSource_GetCorrelatedTime(time_source, 0, &time, &systime);
-    ok(hr == S_OK, "Failed to get time %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get time %#x.\n", hr);
     ok(time == 10 + 2 * 2, "Unexpected time stamp %s, %s.\n", wine_dbgstr_longlong(time),
             wine_dbgstr_longlong(systime));
 
     hr = IMFClockStateSink_OnClockRestart(statesink, 5);
-    ok(hr == S_OK, "Failed to restart source, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to restart source, hr %#x.\n", hr);
 
     hr = IMFPresentationTimeSource_GetCorrelatedTime(time_source, 0, &time, &systime);
-    ok(hr == S_OK, "Failed to get time %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get time %#x.\n", hr);
     ok(time == 2 * systime + 14 - 5 * 2, "Unexpected time stamp %s, %s.\n", wine_dbgstr_longlong(time),
             wine_dbgstr_longlong(systime));
 
     hr = IMFClockStateSink_OnClockPause(statesink, 0);
-    ok(hr == S_OK, "Failed to pause source, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to pause source, hr %#x.\n", hr);
 
     hr = IMFPresentationTimeSource_GetCorrelatedTime(time_source, 0, &time, &systime);
-    ok(hr == S_OK, "Failed to get time %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get time %#x.\n", hr);
     ok(time == 4, "Unexpected time stamp %s, %s.\n", wine_dbgstr_longlong(time),
             wine_dbgstr_longlong(systime));
 
     hr = IMFClockStateSink_OnClockStop(statesink, 123);
-    ok(hr == S_OK, "Failed to stop source, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to stop source, hr %#x.\n", hr);
 
     hr = IMFPresentationTimeSource_GetCorrelatedTime(time_source, 0, &time, &systime);
-    ok(hr == S_OK, "Failed to get time %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get time %#x.\n", hr);
     ok(time == 0, "Unexpected time stamp %s, %s.\n", wine_dbgstr_longlong(time), wine_dbgstr_longlong(systime));
 
     hr = IMFClockStateSink_OnClockStart(statesink, 10, 0);
-    ok(hr == S_OK, "Failed to start source, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to start source, hr %#x.\n", hr);
 
     hr = IMFPresentationTimeSource_GetCorrelatedTime(time_source, 0, &time, &systime);
-    ok(hr == S_OK, "Failed to get time %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get time %#x.\n", hr);
     ok(time == 2 * systime - 2 * 10, "Unexpected time stamp %s, %s.\n", wine_dbgstr_longlong(time),
             wine_dbgstr_longlong(2 * systime));
 
     hr = IMFClockStateSink_OnClockStop(statesink, 123);
-    ok(hr == S_OK, "Failed to stop source, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to stop source, hr %#x.\n", hr);
 
     hr = IMFClockStateSink_OnClockStart(statesink, 10, 20);
-    ok(hr == S_OK, "Failed to start source, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to start source, hr %#x.\n", hr);
 
     hr = IMFPresentationTimeSource_GetCorrelatedTime(time_source, 0, &time, &systime);
-    ok(hr == S_OK, "Failed to get time %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get time %#x.\n", hr);
     ok(time == 2 * systime, "Unexpected time stamp %s, %s.\n", wine_dbgstr_longlong(time),
             wine_dbgstr_longlong(2 * systime));
 
     hr = IMFClockStateSink_OnClockPause(statesink, 2);
-    ok(hr == S_OK, "Failed to pause source, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to pause source, hr %#x.\n", hr);
 
     hr = IMFPresentationTimeSource_GetCorrelatedTime(time_source, 0, &time, &systime);
-    ok(hr == S_OK, "Failed to get time %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get time %#x.\n", hr);
     ok(time == 2 * 2, "Unexpected time stamp %s, %s.\n", wine_dbgstr_longlong(time),
             wine_dbgstr_longlong(systime));
 
     hr = IMFClockStateSink_OnClockRestart(statesink, 5);
-    ok(hr == S_OK, "Failed to restart source, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to restart source, hr %#x.\n", hr);
 
     hr = IMFPresentationTimeSource_GetCorrelatedTime(time_source, 0, &time, &systime);
-    ok(hr == S_OK, "Failed to get time %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get time %#x.\n", hr);
     ok(time == 2 * systime + 4 - 5 * 2, "Unexpected time stamp %s, %s.\n", wine_dbgstr_longlong(time),
             wine_dbgstr_longlong(systime));
 
     hr = IMFClockStateSink_OnClockPause(statesink, 0);
-    ok(hr == S_OK, "Failed to pause source, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to pause source, hr %#x.\n", hr);
 
     hr = IMFPresentationTimeSource_GetCorrelatedTime(time_source, 0, &time, &systime);
-    ok(hr == S_OK, "Failed to get time %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get time %#x.\n", hr);
     ok(time == -6, "Unexpected time stamp %s, %s.\n", wine_dbgstr_longlong(time),
             wine_dbgstr_longlong(systime));
 
@@ -3797,105 +3738,105 @@ static void test_system_time_source(void)
 
     /* PRESENTATION_CURRENT_POSITION */
     hr = MFCreateSystemTimeSource(&time_source);
-    ok(hr == S_OK, "Failed to create time source, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to create time source, hr %#x.\n", hr);
 
     hr = IMFPresentationTimeSource_QueryInterface(time_source, &IID_IMFClockStateSink, (void **)&statesink);
-    ok(hr == S_OK, "Failed to get sink interface, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get sink interface, hr %#x.\n", hr);
 
     hr = IMFPresentationTimeSource_GetCorrelatedTime(time_source, 0, &time, &systime);
-    ok(hr == S_OK, "Failed to get time %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get time %#x.\n", hr);
     ok(!time && systime, "Unexpected time stamp %s, %s.\n", wine_dbgstr_longlong(time),
             wine_dbgstr_longlong(systime));
 
     /* INVALID -> RUNNING */
     hr = IMFClockStateSink_OnClockStart(statesink, 10, PRESENTATION_CURRENT_POSITION);
-    ok(hr == S_OK, "Failed to start source, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to start source, hr %#x.\n", hr);
 
     hr = IMFPresentationTimeSource_GetCorrelatedTime(time_source, 0, &time, &systime);
-    ok(hr == S_OK, "Failed to get time %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get time %#x.\n", hr);
     ok(time == systime - 10, "Unexpected time stamp %s, %s.\n", wine_dbgstr_longlong(time),
             wine_dbgstr_longlong(systime));
 
     /* RUNNING -> RUNNING */
     hr = IMFClockStateSink_OnClockStart(statesink, 20, PRESENTATION_CURRENT_POSITION);
-    ok(hr == S_OK, "Failed to start source, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to start source, hr %#x.\n", hr);
 
     hr = IMFPresentationTimeSource_GetCorrelatedTime(time_source, 0, &time, &systime);
-    ok(hr == S_OK, "Failed to get time %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get time %#x.\n", hr);
     ok(time == systime - 10, "Unexpected time stamp %s, %s.\n", wine_dbgstr_longlong(time),
             wine_dbgstr_longlong(systime));
 
     hr = IMFClockStateSink_OnClockStart(statesink, 0, PRESENTATION_CURRENT_POSITION);
-    ok(hr == S_OK, "Failed to start source, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to start source, hr %#x.\n", hr);
 
     hr = IMFPresentationTimeSource_GetCorrelatedTime(time_source, 0, &time, &systime);
-    ok(hr == S_OK, "Failed to get time %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get time %#x.\n", hr);
     ok(time == systime - 10, "Unexpected time stamp %s, %s.\n", wine_dbgstr_longlong(time),
             wine_dbgstr_longlong(systime));
 
     hr = IMFClockStateSink_OnClockStart(statesink, 0, 0);
-    ok(hr == S_OK, "Failed to start source, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to start source, hr %#x.\n", hr);
 
     hr = IMFPresentationTimeSource_GetCorrelatedTime(time_source, 0, &time, &systime);
-    ok(hr == S_OK, "Failed to get time %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get time %#x.\n", hr);
     ok(time == systime, "Unexpected time stamp %s, %s.\n", wine_dbgstr_longlong(time),
             wine_dbgstr_longlong(systime));
 
     hr = IMFClockStateSink_OnClockStart(statesink, 30, PRESENTATION_CURRENT_POSITION);
-    ok(hr == S_OK, "Failed to start source, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to start source, hr %#x.\n", hr);
 
     hr = IMFPresentationTimeSource_GetCorrelatedTime(time_source, 0, &time, &systime);
-    ok(hr == S_OK, "Failed to get time %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get time %#x.\n", hr);
     ok(time == systime, "Unexpected time stamp %s, %s.\n", wine_dbgstr_longlong(time),
             wine_dbgstr_longlong(systime));
 
     /* STOPPED -> RUNNING */
     hr = IMFClockStateSink_OnClockStop(statesink, 567);
-    ok(hr == S_OK, "Failed to stop source, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to stop source, hr %#x.\n", hr);
 
     hr = IMFPresentationTimeSource_GetCorrelatedTime(time_source, 0, &time, &systime);
-    ok(hr == S_OK, "Failed to get time %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get time %#x.\n", hr);
     ok(!time && systime != 0, "Unexpected time stamp %s, %s.\n", wine_dbgstr_longlong(time),
             wine_dbgstr_longlong(systime));
 
     hr = IMFClockStateSink_OnClockStart(statesink, 30, PRESENTATION_CURRENT_POSITION);
-    ok(hr == S_OK, "Failed to start source, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to start source, hr %#x.\n", hr);
 
     hr = IMFPresentationTimeSource_GetCorrelatedTime(time_source, 0, &time, &systime);
-    ok(hr == S_OK, "Failed to get time %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get time %#x.\n", hr);
     ok(time == systime - 30, "Unexpected time stamp %s, %s.\n", wine_dbgstr_longlong(time),
             wine_dbgstr_longlong(systime));
 
     /* PAUSED -> RUNNING */
     hr = IMFClockStateSink_OnClockPause(statesink, 8);
-    ok(hr == S_OK, "Failed to pause source, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to pause source, hr %#x.\n", hr);
 
     hr = IMFPresentationTimeSource_GetCorrelatedTime(time_source, 0, &time, &systime);
-    ok(hr == S_OK, "Failed to get time %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get time %#x.\n", hr);
     ok(time == (-30 + 8) && systime != 0, "Unexpected time stamp %s, %s.\n", wine_dbgstr_longlong(time),
             wine_dbgstr_longlong(systime));
 
     hr = IMFClockStateSink_OnClockStart(statesink, 40, PRESENTATION_CURRENT_POSITION);
-    ok(hr == S_OK, "Failed to start source, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to start source, hr %#x.\n", hr);
 
     hr = IMFPresentationTimeSource_GetCorrelatedTime(time_source, 0, &time, &systime);
-    ok(hr == S_OK, "Failed to get time %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get time %#x.\n", hr);
     ok(time == systime + (-30 + 8 - 40), "Unexpected time stamp %s, %s.\n", wine_dbgstr_longlong(time),
             wine_dbgstr_longlong(systime));
 
     hr = IMFClockStateSink_OnClockPause(statesink, 7);
-    ok(hr == S_OK, "Failed to pause source, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to pause source, hr %#x.\n", hr);
 
     hr = IMFPresentationTimeSource_GetCorrelatedTime(time_source, 0, &time, &systime);
-    ok(hr == S_OK, "Failed to get time %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get time %#x.\n", hr);
     ok(time == (-30 + 8 - 40 + 7) && systime != 0, "Unexpected time stamp %s, %s.\n", wine_dbgstr_longlong(time),
             wine_dbgstr_longlong(systime));
 
     hr = IMFClockStateSink_OnClockStart(statesink, 50, 7);
-    ok(hr == S_OK, "Failed to start source, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to start source, hr %#x.\n", hr);
 
     hr = IMFPresentationTimeSource_GetCorrelatedTime(time_source, 0, &time, &systime);
-    ok(hr == S_OK, "Failed to get time %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get time %#x.\n", hr);
     ok(time == systime + (-50 + 7), "Unexpected time stamp %s, %s.\n", wine_dbgstr_longlong(time),
             wine_dbgstr_longlong(systime));
 
@@ -3913,30 +3854,30 @@ static void test_MFInvokeCallback(void)
     DWORD ret;
 
     hr = MFStartup(MF_VERSION, MFSTARTUP_FULL);
-    ok(hr == S_OK, "Failed to start up, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to start up, hr %#x.\n", hr);
 
     callback = create_test_callback(NULL);
 
     hr = MFCreateAsyncResult(NULL, &callback->IMFAsyncCallback_iface, NULL, &result);
-    ok(hr == S_OK, "Failed to create object, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to create object, hr %#x.\n", hr);
 
     data = (MFASYNCRESULT *)result;
     data->hEvent = CreateEventA(NULL, FALSE, FALSE, NULL);
     ok(data->hEvent != NULL, "Failed to create event.\n");
 
     hr = MFInvokeCallback(result);
-    ok(hr == S_OK, "Failed to invoke, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to invoke, hr %#x.\n", hr);
 
     ret = WaitForSingleObject(data->hEvent, 100);
-    ok(ret == WAIT_TIMEOUT, "Expected timeout, ret %#lx.\n", ret);
+    ok(ret == WAIT_TIMEOUT, "Expected timeout, ret %#x.\n", ret);
 
     refcount = IMFAsyncResult_Release(result);
-    ok(!refcount, "Unexpected refcount %lu.\n", refcount);
+    ok(!refcount, "Unexpected refcount %u.\n", refcount);
 
     IMFAsyncCallback_Release(&callback->IMFAsyncCallback_iface);
 
     hr = MFShutdown();
-    ok(hr == S_OK, "Failed to shut down, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to shut down, hr %#x.\n", hr);
 }
 
 static void test_stream_descriptor(void)
@@ -3950,41 +3891,41 @@ static void test_stream_descriptor(void)
     HRESULT hr;
 
     hr = MFCreateStreamDescriptor(123, 0, NULL, &stream_desc);
-    ok(hr == E_INVALIDARG, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
 
     for (i = 0; i < ARRAY_SIZE(media_types); ++i)
     {
         hr = MFCreateMediaType(&media_types[i]);
-        ok(hr == S_OK, "Failed to create media type, hr %#lx.\n", hr);
+        ok(hr == S_OK, "Failed to create media type, hr %#x.\n", hr);
     }
 
     hr = MFCreateStreamDescriptor(123, 0, media_types, &stream_desc);
-    ok(hr == E_INVALIDARG, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
 
     hr = MFCreateStreamDescriptor(123, ARRAY_SIZE(media_types), media_types, &stream_desc);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IMFStreamDescriptor_GetStreamIdentifier(stream_desc, &id);
-    ok(hr == S_OK, "Failed to get descriptor id, hr %#lx.\n", hr);
-    ok(id == 123, "Unexpected id %#lx.\n", id);
+    ok(hr == S_OK, "Failed to get descriptor id, hr %#x.\n", hr);
+    ok(id == 123, "Unexpected id %#x.\n", id);
 
     hr = IMFStreamDescriptor_GetMediaTypeHandler(stream_desc, &type_handler);
-    ok(hr == S_OK, "Failed to get type handler, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get type handler, hr %#x.\n", hr);
 
     hr = IMFMediaTypeHandler_GetMediaTypeCount(type_handler, &count);
-    ok(hr == S_OK, "Failed to get type count, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get type count, hr %#x.\n", hr);
     ok(count == ARRAY_SIZE(media_types), "Unexpected type count.\n");
 
     hr = IMFMediaTypeHandler_GetCurrentMediaType(type_handler, &media_type);
-    ok(hr == MF_E_NOT_INITIALIZED, "Unexpected hr %#lx.\n", hr);
+    ok(hr == MF_E_NOT_INITIALIZED, "Unexpected hr %#x.\n", hr);
 
     hr = IMFMediaTypeHandler_GetMajorType(type_handler, &major_type);
-    ok(hr == MF_E_ATTRIBUTENOTFOUND, "Unexpected hr %#lx.\n", hr);
+    ok(hr == MF_E_ATTRIBUTENOTFOUND, "Unexpected hr %#x.\n", hr);
 
     for (i = 0; i < ARRAY_SIZE(media_types); ++i)
     {
         hr = IMFMediaTypeHandler_GetMediaTypeByIndex(type_handler, i, &media_type);
-        ok(hr == S_OK, "Failed to get media type, hr %#lx.\n", hr);
+        ok(hr == S_OK, "Failed to get media type, hr %#x.\n", hr);
         ok(media_type == media_types[i], "Unexpected object.\n");
 
         if (SUCCEEDED(hr))
@@ -3992,88 +3933,88 @@ static void test_stream_descriptor(void)
     }
 
     hr = IMFMediaTypeHandler_GetMediaTypeByIndex(type_handler, 2, &media_type);
-    ok(hr == MF_E_NO_MORE_TYPES, "Unexpected hr %#lx.\n", hr);
+    ok(hr == MF_E_NO_MORE_TYPES, "Unexpected hr %#x.\n", hr);
 
     /* IsMediaTypeSupported() */
 
     hr = IMFMediaTypeHandler_IsMediaTypeSupported(type_handler, NULL, NULL);
-    ok(hr == E_POINTER, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Unexpected hr %#x.\n", hr);
 
     hr = IMFMediaTypeHandler_IsMediaTypeSupported(type_handler, NULL, &media_type2);
-    ok(hr == E_POINTER, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Unexpected hr %#x.\n", hr);
 
     hr = MFCreateMediaType(&media_type);
-    ok(hr == S_OK, "Failed to create media type, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to create media type, hr %#x.\n", hr);
 
     hr = MFCreateMediaType(&media_type3);
-    ok(hr == S_OK, "Failed to create media type, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to create media type, hr %#x.\n", hr);
 
     media_type2 = (void *)0xdeadbeef;
     hr = IMFMediaTypeHandler_IsMediaTypeSupported(type_handler, media_type, &media_type2);
-    ok(hr == MF_E_INVALIDMEDIATYPE, "Unexpected hr %#lx.\n", hr);
+    ok(hr == MF_E_INVALIDMEDIATYPE, "Unexpected hr %#x.\n", hr);
     ok(!media_type2, "Unexpected pointer.\n");
 
     hr = IMFMediaTypeHandler_SetCurrentMediaType(type_handler, NULL);
-    ok(hr == E_POINTER, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Unexpected hr %#x.\n", hr);
 
     hr = IMFMediaTypeHandler_SetCurrentMediaType(type_handler, media_type);
-    ok(hr == S_OK, "Failed to set current type, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to set current type, hr %#x.\n", hr);
 
     media_type2 = (void *)0xdeadbeef;
     hr = IMFMediaTypeHandler_IsMediaTypeSupported(type_handler, media_type, &media_type2);
-    ok(hr == MF_E_INVALIDMEDIATYPE, "Unexpected hr %#lx.\n", hr);
+    ok(hr == MF_E_INVALIDMEDIATYPE, "Unexpected hr %#x.\n", hr);
     ok(!media_type2, "Unexpected pointer.\n");
 
     hr = IMFMediaTypeHandler_GetMajorType(type_handler, &major_type);
-    ok(hr == MF_E_ATTRIBUTENOTFOUND, "Unexpected hr %#lx.\n", hr);
+    ok(hr == MF_E_ATTRIBUTENOTFOUND, "Unexpected hr %#x.\n", hr);
 
     hr = IMFMediaType_SetGUID(media_type, &MF_MT_MAJOR_TYPE, &MFMediaType_Audio);
-    ok(hr == S_OK, "Failed to set major type, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to set major type, hr %#x.\n", hr);
 
     hr = IMFMediaTypeHandler_GetMajorType(type_handler, &major_type);
-    ok(hr == S_OK, "Failed to get major type, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get major type, hr %#x.\n", hr);
     ok(IsEqualGUID(&major_type, &MFMediaType_Audio), "Unexpected major type.\n");
 
     /* Mismatching major types. */
     hr = IMFMediaType_SetGUID(media_type3, &MF_MT_MAJOR_TYPE, &MFMediaType_Video);
-    ok(hr == S_OK, "Failed to set major type, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to set major type, hr %#x.\n", hr);
 
     media_type2 = (void *)0xdeadbeef;
     hr = IMFMediaTypeHandler_IsMediaTypeSupported(type_handler, media_type3, &media_type2);
-    ok(hr == MF_E_INVALIDMEDIATYPE, "Unexpected hr %#lx.\n", hr);
+    ok(hr == MF_E_INVALIDMEDIATYPE, "Unexpected hr %#x.\n", hr);
     ok(!media_type2, "Unexpected pointer.\n");
 
     /* Subtype missing. */
     hr = IMFMediaType_SetGUID(media_type3, &MF_MT_MAJOR_TYPE, &MFMediaType_Audio);
-    ok(hr == S_OK, "Failed to set attribute, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to set attribute, hr %#x.\n", hr);
 
     hr = IMFMediaType_SetGUID(media_type, &MF_MT_SUBTYPE, &MFAudioFormat_PCM);
-    ok(hr == S_OK, "Failed to set attribute, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to set attribute, hr %#x.\n", hr);
 
     media_type2 = (void *)0xdeadbeef;
     hr = IMFMediaTypeHandler_IsMediaTypeSupported(type_handler, media_type3, &media_type2);
-    ok(hr == MF_E_INVALIDMEDIATYPE, "Unexpected hr %#lx.\n", hr);
+    ok(hr == MF_E_INVALIDMEDIATYPE, "Unexpected hr %#x.\n", hr);
     ok(!media_type2, "Unexpected pointer.\n");
 
     hr = IMFMediaType_SetGUID(media_type3, &MF_MT_SUBTYPE, &MFAudioFormat_PCM);
-    ok(hr == S_OK, "Failed to set attribute, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to set attribute, hr %#x.\n", hr);
 
     media_type2 = (void *)0xdeadbeef;
     hr = IMFMediaTypeHandler_IsMediaTypeSupported(type_handler, media_type3, &media_type2);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(!media_type2, "Unexpected pointer.\n");
 
     /* Mismatching subtype. */
     hr = IMFMediaType_SetGUID(media_type3, &MF_MT_SUBTYPE, &MFAudioFormat_MP3);
-    ok(hr == S_OK, "Failed to set attribute, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to set attribute, hr %#x.\n", hr);
 
     media_type2 = (void *)0xdeadbeef;
     hr = IMFMediaTypeHandler_IsMediaTypeSupported(type_handler, media_type3, &media_type2);
-    ok(hr == MF_E_INVALIDMEDIATYPE, "Unexpected hr %#lx.\n", hr);
+    ok(hr == MF_E_INVALIDMEDIATYPE, "Unexpected hr %#x.\n", hr);
     ok(!media_type2, "Unexpected pointer.\n");
 
     hr = IMFMediaTypeHandler_GetMediaTypeCount(type_handler, &count);
-    ok(hr == S_OK, "Failed to get type count, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get type count, hr %#x.\n", hr);
     ok(count == ARRAY_SIZE(media_types), "Unexpected type count.\n");
 
     IMFMediaTypeHandler_Release(type_handler);
@@ -4081,60 +4022,60 @@ static void test_stream_descriptor(void)
 
     /* IsMediaTypeSupported() for unset current type. */
     hr = MFCreateStreamDescriptor(123, ARRAY_SIZE(media_types), media_types, &stream_desc);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IMFStreamDescriptor_GetMediaTypeHandler(stream_desc, &type_handler);
-    ok(hr == S_OK, "Failed to get type handler, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get type handler, hr %#x.\n", hr);
 
     hr = IMFMediaTypeHandler_IsMediaTypeSupported(type_handler, media_type3, NULL);
-    ok(hr == MF_E_INVALIDMEDIATYPE, "Unexpected hr %#lx.\n", hr);
+    ok(hr == MF_E_INVALIDMEDIATYPE, "Unexpected hr %#x.\n", hr);
 
     /* Initialize one from initial type set. */
     hr = IMFMediaType_CopyAllItems(media_type3, (IMFAttributes *)media_types[0]);
-    ok(hr == S_OK, "Failed to copy attributes, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to copy attributes, hr %#x.\n", hr);
 
     media_type2 = (void *)0xdeadbeef;
     hr = IMFMediaTypeHandler_IsMediaTypeSupported(type_handler, media_type3, &media_type2);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(!media_type2, "Unexpected pointer.\n");
 
     hr = IMFMediaType_SetGUID(media_type3, &MF_MT_SUBTYPE, &MFAudioFormat_PCM);
-    ok(hr == S_OK, "Failed to copy attributes, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to copy attributes, hr %#x.\n", hr);
 
     media_type2 = (void *)0xdeadbeef;
     hr = IMFMediaTypeHandler_IsMediaTypeSupported(type_handler, media_type3, &media_type2);
-    ok(hr == MF_E_INVALIDMEDIATYPE, "Unexpected hr %#lx.\n", hr);
+    ok(hr == MF_E_INVALIDMEDIATYPE, "Unexpected hr %#x.\n", hr);
     ok(!media_type2, "Unexpected pointer.\n");
 
     hr = IMFMediaType_SetGUID(media_type3, &MF_MT_SUBTYPE, &MFAudioFormat_MP3);
-    ok(hr == S_OK, "Failed to copy attributes, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to copy attributes, hr %#x.\n", hr);
 
     media_type2 = (void *)0xdeadbeef;
     hr = IMFMediaTypeHandler_IsMediaTypeSupported(type_handler, media_type3, &media_type2);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(!media_type2, "Unexpected pointer.\n");
 
     /* Now set current type that's not compatible. */
     hr = IMFMediaType_SetGUID(media_type3, &MF_MT_MAJOR_TYPE, &MFMediaType_Video);
-    ok(hr == S_OK, "Failed to copy attributes, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to copy attributes, hr %#x.\n", hr);
 
     hr = IMFMediaType_SetGUID(media_type3, &MF_MT_SUBTYPE, &MFVideoFormat_RGB8);
-    ok(hr == S_OK, "Failed to copy attributes, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to copy attributes, hr %#x.\n", hr);
 
     hr = IMFMediaTypeHandler_SetCurrentMediaType(type_handler, media_type3);
-    ok(hr == S_OK, "Failed to set current type, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to set current type, hr %#x.\n", hr);
 
     media_type2 = (void *)0xdeadbeef;
     hr = IMFMediaTypeHandler_IsMediaTypeSupported(type_handler, media_type3, &media_type2);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(!media_type2, "Unexpected pointer.\n");
 
     hr = IMFMediaType_CopyAllItems(media_types[0], (IMFAttributes *)media_type);
-    ok(hr == S_OK, "Failed to copy attributes, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to copy attributes, hr %#x.\n", hr);
 
     media_type2 = (void *)0xdeadbeef;
     hr = IMFMediaTypeHandler_IsMediaTypeSupported(type_handler, media_type, &media_type2);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(!media_type2, "Unexpected pointer.\n");
 
     IMFMediaType_Release(media_type);
@@ -4146,32 +4087,32 @@ static void test_stream_descriptor(void)
 
     /* Major type is returned for first entry. */
     hr = MFCreateMediaType(&media_types[0]);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     hr = MFCreateMediaType(&media_types[1]);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IMFMediaType_SetGUID(media_types[0], &MF_MT_MAJOR_TYPE, &MFMediaType_Audio);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     hr = IMFMediaType_SetGUID(media_types[1], &MF_MT_MAJOR_TYPE, &MFMediaType_Video);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = MFCreateStreamDescriptor(0, 2, media_types, &stream_desc);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IMFStreamDescriptor_GetMediaTypeHandler(stream_desc, &type_handler);
-    ok(hr == S_OK, "Failed to get type handler, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get type handler, hr %#x.\n", hr);
 
     hr = IMFMediaTypeHandler_GetMajorType(type_handler, &major_type);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(IsEqualGUID(&major_type, &MFMediaType_Audio), "Unexpected major type %s.\n", wine_dbgstr_guid(&major_type));
 
     hr = IMFMediaType_SetGUID(media_types[0], &MF_MT_MAJOR_TYPE, &MFMediaType_Video);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     hr = IMFMediaType_SetGUID(media_types[1], &MF_MT_MAJOR_TYPE, &MFMediaType_Audio);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IMFMediaTypeHandler_GetMajorType(type_handler, &major_type);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(IsEqualGUID(&major_type, &MFMediaType_Video), "Unexpected major type %s.\n", wine_dbgstr_guid(&major_type));
 
     IMFMediaType_Release(media_types[0]);
@@ -4181,106 +4122,107 @@ static void test_stream_descriptor(void)
     IMFStreamDescriptor_Release(stream_desc);
 }
 
-static const struct image_size_test
-{
-    const GUID *subtype;
-    UINT32 width;
-    UINT32 height;
-    UINT32 size;
-    UINT32 plane_size; /* Matches image size when 0. */
-}
-image_size_tests[] =
-{
-    { &MFVideoFormat_RGB8, 3, 5, 20 },
-    { &MFVideoFormat_RGB8, 1, 1, 4 },
-    { &MFVideoFormat_RGB555, 3, 5, 40 },
-    { &MFVideoFormat_RGB555, 1, 1, 4 },
-    { &MFVideoFormat_RGB565, 3, 5, 40 },
-    { &MFVideoFormat_RGB565, 1, 1, 4 },
-    { &MFVideoFormat_RGB24, 3, 5, 60 },
-    { &MFVideoFormat_RGB24, 1, 1, 4 },
-    { &MFVideoFormat_RGB32, 3, 5, 60 },
-    { &MFVideoFormat_RGB32, 1, 1, 4 },
-    { &MFVideoFormat_ARGB32, 3, 5, 60 },
-    { &MFVideoFormat_ARGB32, 1, 1, 4 },
-    { &MFVideoFormat_A2R10G10B10, 3, 5, 60 },
-    { &MFVideoFormat_A2R10G10B10, 1, 1, 4 },
-    { &MFVideoFormat_A16B16G16R16F, 3, 5, 120 },
-    { &MFVideoFormat_A16B16G16R16F, 1, 1, 8 },
-
-    /* YUV */
-    { &MFVideoFormat_NV12, 1, 3, 9, 4 },
-    { &MFVideoFormat_NV12, 1, 2, 6, 3 },
-    { &MFVideoFormat_NV12, 2, 2, 6, 6 },
-    { &MFVideoFormat_NV12, 3, 2, 12, 9 },
-    { &MFVideoFormat_NV12, 4, 2, 12 },
-    { &MFVideoFormat_NV12, 320, 240, 115200 },
-    { &MFVideoFormat_AYUV, 1, 1, 4 },
-    { &MFVideoFormat_AYUV, 2, 1, 8 },
-    { &MFVideoFormat_AYUV, 1, 2, 8 },
-    { &MFVideoFormat_AYUV, 4, 3, 48 },
-    { &MFVideoFormat_AYUV, 320, 240, 307200 },
-    { &MFVideoFormat_IMC1, 1, 1, 4 },
-    { &MFVideoFormat_IMC1, 2, 1, 4 },
-    { &MFVideoFormat_IMC1, 1, 2, 8 },
-    { &MFVideoFormat_IMC1, 4, 3, 24 },
-    { &MFVideoFormat_IMC1, 320, 240, 153600 },
-    { &MFVideoFormat_IMC3, 1, 1, 4 },
-    { &MFVideoFormat_IMC3, 2, 1, 4 },
-    { &MFVideoFormat_IMC3, 1, 2, 8 },
-    { &MFVideoFormat_IMC3, 4, 3, 24 },
-    { &MFVideoFormat_IMC3, 320, 240, 153600 },
-    { &MFVideoFormat_IMC2, 1, 3, 9, 4 },
-    { &MFVideoFormat_IMC2, 1, 2, 6, 3 },
-    { &MFVideoFormat_IMC2, 2, 2, 6, 6 },
-    { &MFVideoFormat_IMC2, 3, 2, 12, 9 },
-    { &MFVideoFormat_IMC2, 4, 2, 12 },
-    { &MFVideoFormat_IMC2, 320, 240, 115200 },
-    { &MFVideoFormat_IMC4, 1, 3, 9, 4 },
-    { &MFVideoFormat_IMC4, 1, 2, 6, 3 },
-    { &MFVideoFormat_IMC4, 2, 2, 6, 6 },
-    { &MFVideoFormat_IMC4, 3, 2, 12, 9 },
-    { &MFVideoFormat_IMC4, 4, 2, 12 },
-    { &MFVideoFormat_IMC4, 320, 240, 115200 },
-    { &MFVideoFormat_YV12, 1, 1, 3, 1 },
-    { &MFVideoFormat_YV12, 2, 1, 3 },
-    { &MFVideoFormat_YV12, 1, 2, 6, 3 },
-    { &MFVideoFormat_YV12, 4, 3, 18 },
-    { &MFVideoFormat_YV12, 320, 240, 115200 },
-
-    { &MFVideoFormat_I420, 1, 1, 3, 1 },
-    { &MFVideoFormat_I420, 2, 1, 3 },
-    { &MFVideoFormat_I420, 1, 2, 6, 3 },
-    { &MFVideoFormat_I420, 4, 3, 18 },
-    { &MFVideoFormat_I420, 320, 240, 115200 },
-
-    { &MFVideoFormat_IYUV, 1, 1, 3, 1 },
-    { &MFVideoFormat_IYUV, 2, 1, 3 },
-    { &MFVideoFormat_IYUV, 1, 2, 6, 3 },
-    { &MFVideoFormat_IYUV, 4, 3, 18 },
-    { &MFVideoFormat_IYUV, 320, 240, 115200 },
-
-    { &MFVideoFormat_YUY2, 2, 1, 4 },
-    { &MFVideoFormat_YUY2, 4, 3, 24 },
-    { &MFVideoFormat_YUY2, 128, 128, 32768 },
-    { &MFVideoFormat_YUY2, 320, 240, 153600 },
-
-    { &MFVideoFormat_UYVY, 2, 1, 4 },
-    { &MFVideoFormat_UYVY, 4, 3, 24 },
-    { &MFVideoFormat_UYVY, 128, 128, 32768 },
-    { &MFVideoFormat_UYVY, 320, 240, 153600 },
-};
-
 static void test_MFCalculateImageSize(void)
 {
-    DWORD plane_size;
+    static const struct image_size_test
+    {
+        const GUID *subtype;
+        UINT32 width;
+        UINT32 height;
+        UINT32 size;
+        UINT32 plane_size; /* Matches image size when 0. */
+    }
+    image_size_tests[] =
+    {
+        { &MFVideoFormat_RGB8, 3, 5, 20 },
+        { &MFVideoFormat_RGB8, 1, 1, 4 },
+        { &MFVideoFormat_RGB555, 3, 5, 40 },
+        { &MFVideoFormat_RGB555, 1, 1, 4 },
+        { &MFVideoFormat_RGB565, 3, 5, 40 },
+        { &MFVideoFormat_RGB565, 1, 1, 4 },
+        { &MFVideoFormat_RGB24, 3, 5, 60 },
+        { &MFVideoFormat_RGB24, 1, 1, 4 },
+        { &MFVideoFormat_RGB32, 3, 5, 60 },
+        { &MFVideoFormat_RGB32, 1, 1, 4 },
+        { &MFVideoFormat_ARGB32, 3, 5, 60 },
+        { &MFVideoFormat_ARGB32, 1, 1, 4 },
+        { &MFVideoFormat_A2R10G10B10, 3, 5, 60 },
+        { &MFVideoFormat_A2R10G10B10, 1, 1, 4 },
+        { &MFVideoFormat_A16B16G16R16F, 3, 5, 120 },
+        { &MFVideoFormat_A16B16G16R16F, 1, 1, 8 },
+
+        /* YUV */
+        { &MFVideoFormat_NV12, 1, 3, 9, 4 },
+        { &MFVideoFormat_NV12, 1, 2, 6, 3 },
+        { &MFVideoFormat_NV12, 2, 2, 6, 6 },
+        { &MFVideoFormat_NV12, 3, 2, 12, 9 },
+        { &MFVideoFormat_NV12, 4, 2, 12 },
+        { &MFVideoFormat_NV12, 320, 240, 115200 },
+        { &MFVideoFormat_AYUV, 1, 1, 4 },
+        { &MFVideoFormat_AYUV, 2, 1, 8 },
+        { &MFVideoFormat_AYUV, 1, 2, 8 },
+        { &MFVideoFormat_AYUV, 4, 3, 48 },
+        { &MFVideoFormat_AYUV, 320, 240, 307200 },
+        { &MFVideoFormat_IMC1, 1, 1, 4 },
+        { &MFVideoFormat_IMC1, 2, 1, 4 },
+        { &MFVideoFormat_IMC1, 1, 2, 8 },
+        { &MFVideoFormat_IMC1, 4, 3, 24 },
+        { &MFVideoFormat_IMC1, 320, 240, 153600 },
+        { &MFVideoFormat_IMC3, 1, 1, 4 },
+        { &MFVideoFormat_IMC3, 2, 1, 4 },
+        { &MFVideoFormat_IMC3, 1, 2, 8 },
+        { &MFVideoFormat_IMC3, 4, 3, 24 },
+        { &MFVideoFormat_IMC3, 320, 240, 153600 },
+        { &MFVideoFormat_IMC2, 1, 3, 9, 4 },
+        { &MFVideoFormat_IMC2, 1, 2, 6, 3 },
+        { &MFVideoFormat_IMC2, 2, 2, 6, 6 },
+        { &MFVideoFormat_IMC2, 3, 2, 12, 9 },
+        { &MFVideoFormat_IMC2, 4, 2, 12 },
+        { &MFVideoFormat_IMC2, 320, 240, 115200 },
+        { &MFVideoFormat_IMC4, 1, 3, 9, 4 },
+        { &MFVideoFormat_IMC4, 1, 2, 6, 3 },
+        { &MFVideoFormat_IMC4, 2, 2, 6, 6 },
+        { &MFVideoFormat_IMC4, 3, 2, 12, 9 },
+        { &MFVideoFormat_IMC4, 4, 2, 12 },
+        { &MFVideoFormat_IMC4, 320, 240, 115200 },
+        { &MFVideoFormat_YV12, 1, 1, 3, 1 },
+        { &MFVideoFormat_YV12, 2, 1, 3 },
+        { &MFVideoFormat_YV12, 1, 2, 6, 3 },
+        { &MFVideoFormat_YV12, 4, 3, 18 },
+        { &MFVideoFormat_YV12, 320, 240, 115200 },
+
+        { &MFVideoFormat_I420, 1, 1, 3, 1 },
+        { &MFVideoFormat_I420, 2, 1, 3 },
+        { &MFVideoFormat_I420, 1, 2, 6, 3 },
+        { &MFVideoFormat_I420, 4, 3, 18 },
+        { &MFVideoFormat_I420, 320, 240, 115200 },
+
+        { &MFVideoFormat_IYUV, 1, 1, 3, 1 },
+        { &MFVideoFormat_IYUV, 2, 1, 3 },
+        { &MFVideoFormat_IYUV, 1, 2, 6, 3 },
+        { &MFVideoFormat_IYUV, 4, 3, 18 },
+        { &MFVideoFormat_IYUV, 320, 240, 115200 },
+
+        { &MFVideoFormat_YUY2, 2, 1, 4 },
+        { &MFVideoFormat_YUY2, 4, 3, 24 },
+        { &MFVideoFormat_YUY2, 128, 128, 32768 },
+        { &MFVideoFormat_YUY2, 320, 240, 153600 },
+
+        { &MFVideoFormat_UYVY, 2, 1, 4 },
+        { &MFVideoFormat_UYVY, 4, 3, 24 },
+        { &MFVideoFormat_UYVY, 128, 128, 32768 },
+        { &MFVideoFormat_UYVY, 320, 240, 153600 },
+    };
     unsigned int i;
     UINT32 size;
     HRESULT hr;
 
+    if (!pMFGetPlaneSize)
+        win_skip("MFGetPlaneSize() is not available.\n");
+
     size = 1;
     hr = MFCalculateImageSize(&IID_IUnknown, 1, 1, &size);
-    ok(hr == E_INVALIDARG || broken(hr == S_OK) /* Vista */, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG || broken(hr == S_OK) /* Vista */, "Unexpected hr %#x.\n", hr);
     ok(size == 0, "Unexpected size %u.\n", size);
 
     for (i = 0; i < ARRAY_SIZE(image_size_tests); ++i)
@@ -4292,49 +4234,21 @@ static void test_MFCalculateImageSize(void)
                 IsEqualGUID(ptr->subtype, &MFVideoFormat_A2R10G10B10);
 
         hr = MFCalculateImageSize(ptr->subtype, ptr->width, ptr->height, &size);
-        ok(hr == S_OK || (is_broken && hr == E_INVALIDARG), "%u: failed to calculate image size, hr %#lx.\n", i, hr);
+        ok(hr == S_OK || (is_broken && hr == E_INVALIDARG), "%u: failed to calculate image size, hr %#x.\n", i, hr);
         ok(size == ptr->size, "%u: unexpected image size %u, expected %u. Size %u x %u, format %s.\n", i, size, ptr->size,
                 ptr->width, ptr->height, wine_dbgstr_an((char *)&ptr->subtype->Data1, 4));
 
         if (pMFGetPlaneSize)
         {
-            unsigned int expected = ptr->plane_size ? ptr->plane_size : ptr->size;
+            unsigned int plane_size = ptr->plane_size ? ptr->plane_size : ptr->size;
 
-            hr = pMFGetPlaneSize(ptr->subtype->Data1, ptr->width, ptr->height, &plane_size);
-            ok(hr == S_OK, "%u: failed to get plane size, hr %#lx.\n", i, hr);
-            ok(plane_size == expected, "%u: unexpected plane size %lu, expected %u.\n", i, plane_size, expected);
+            hr = pMFGetPlaneSize(ptr->subtype->Data1, ptr->width, ptr->height, &size);
+            ok(hr == S_OK, "%u: failed to get plane size, hr %#x.\n", i, hr);
+            ok(size == plane_size, "%u: unexpected plane size %u, expected %u.\n", i, size, plane_size);
         }
     }
 }
 
-static void test_MFGetPlaneSize(void)
-{
-    unsigned int i;
-    DWORD size;
-    HRESULT hr;
-
-    if (!pMFGetPlaneSize)
-    {
-        win_skip("MFGetPlaneSize() is not available.\n");
-        return;
-    }
-
-    size = 1;
-    hr = pMFGetPlaneSize(0xdeadbeef, 64, 64, &size);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
-    ok(size == 0, "Unexpected size %lu.\n", size);
-
-    for (i = 0; i < ARRAY_SIZE(image_size_tests); ++i)
-    {
-        const struct image_size_test *ptr = &image_size_tests[i];
-        unsigned int plane_size = ptr->plane_size ? ptr->plane_size : ptr->size;
-
-        hr = pMFGetPlaneSize(ptr->subtype->Data1, ptr->width, ptr->height, &size);
-        ok(hr == S_OK, "%u: failed to get plane size, hr %#lx.\n", i, hr);
-        ok(size == plane_size, "%u: unexpected plane size %lu, expected %u.\n", i, size, plane_size);
-    }
-}
-
 static void test_MFCompareFullToPartialMediaType(void)
 {
     IMFMediaType *full_type, *partial_type;
@@ -4342,31 +4256,31 @@ static void test_MFCompareFullToPartialMediaType(void)
     BOOL ret;
 
     hr = MFCreateMediaType(&full_type);
-    ok(hr == S_OK, "Failed to create media type, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to create media type, hr %#x.\n", hr);
 
     hr = MFCreateMediaType(&partial_type);
-    ok(hr == S_OK, "Failed to create media type, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to create media type, hr %#x.\n", hr);
 
     ret = MFCompareFullToPartialMediaType(full_type, partial_type);
     ok(!ret, "Unexpected result %d.\n", ret);
 
     hr = IMFMediaType_SetGUID(full_type, &MF_MT_MAJOR_TYPE, &MFMediaType_Audio);
-    ok(hr == S_OK, "Failed to set major type, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to set major type, hr %#x.\n", hr);
 
     hr = IMFMediaType_SetGUID(partial_type, &MF_MT_MAJOR_TYPE, &MFMediaType_Audio);
-    ok(hr == S_OK, "Failed to set major type, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to set major type, hr %#x.\n", hr);
 
     ret = MFCompareFullToPartialMediaType(full_type, partial_type);
     ok(ret, "Unexpected result %d.\n", ret);
 
     hr = IMFMediaType_SetGUID(full_type, &MF_MT_SUBTYPE, &MFMediaType_Audio);
-    ok(hr == S_OK, "Failed to set major type, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to set major type, hr %#x.\n", hr);
 
     ret = MFCompareFullToPartialMediaType(full_type, partial_type);
     ok(ret, "Unexpected result %d.\n", ret);
 
     hr = IMFMediaType_SetGUID(partial_type, &MF_MT_SUBTYPE, &MFMediaType_Video);
-    ok(hr == S_OK, "Failed to set major type, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to set major type, hr %#x.\n", hr);
 
     ret = MFCompareFullToPartialMediaType(full_type, partial_type);
     ok(!ret, "Unexpected result %d.\n", ret);
@@ -4389,35 +4303,35 @@ static void test_attributes_serialization(void)
     GUID guid;
 
     hr = MFCreateAttributes(&attributes, 0);
-    ok(hr == S_OK, "Failed to create object, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to create object, hr %#x.\n", hr);
 
     hr = MFCreateAttributes(&dest, 0);
-    ok(hr == S_OK, "Failed to create object, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to create object, hr %#x.\n", hr);
 
     hr = MFGetAttributesAsBlobSize(attributes, &size);
-    ok(hr == S_OK, "Failed to get blob size, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get blob size, hr %#x.\n", hr);
     ok(size == 8, "Got size %u.\n", size);
 
     buffer = malloc(size);
 
     hr = MFGetAttributesAsBlob(attributes, buffer, size);
-    ok(hr == S_OK, "Failed to serialize, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to serialize, hr %#x.\n", hr);
 
     hr = MFGetAttributesAsBlob(attributes, buffer, size - 1);
-    ok(hr == MF_E_BUFFERTOOSMALL, "Unexpected hr %#lx.\n", hr);
+    ok(hr == MF_E_BUFFERTOOSMALL, "Unexpected hr %#x.\n", hr);
 
     hr = MFInitAttributesFromBlob(dest, buffer, size - 1);
-    ok(hr == E_INVALIDARG, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
 
     hr = IMFAttributes_SetUINT32(dest, &MF_MT_MAJOR_TYPE, 1);
-    ok(hr == S_OK, "Failed to set attribute, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to set attribute, hr %#x.\n", hr);
 
     hr = MFInitAttributesFromBlob(dest, buffer, size);
-    ok(hr == S_OK, "Failed to deserialize, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to deserialize, hr %#x.\n", hr);
 
     /* Previous items are cleared. */
     hr = IMFAttributes_GetCount(dest, &count);
-    ok(hr == S_OK, "Failed to get attribute count, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get attribute count, hr %#x.\n", hr);
     ok(count == 0, "Unexpected count %u.\n", count);
 
     free(buffer);
@@ -4432,36 +4346,36 @@ static void test_attributes_serialization(void)
     IMFAttributes_SetBlob(attributes, &DUMMY_GUID1, blob, sizeof(blob));
 
     hr = MFGetAttributesAsBlobSize(attributes, &size);
-    ok(hr == S_OK, "Failed to get blob size, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get blob size, hr %#x.\n", hr);
     ok(size > 8, "Got unexpected size %u.\n", size);
 
     buffer = malloc(size);
     hr = MFGetAttributesAsBlob(attributes, buffer, size);
-    ok(hr == S_OK, "Failed to serialize, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to serialize, hr %#x.\n", hr);
     hr = MFInitAttributesFromBlob(dest, buffer, size);
-    ok(hr == S_OK, "Failed to deserialize, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to deserialize, hr %#x.\n", hr);
     free(buffer);
 
     hr = IMFAttributes_GetUINT32(dest, &MF_MT_MAJOR_TYPE, &value32);
-    ok(hr == S_OK, "Failed to get get uint32 value, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get get uint32 value, hr %#x.\n", hr);
     ok(value32 == 456, "Unexpected value %u.\n", value32);
     hr = IMFAttributes_GetUINT64(dest, &MF_MT_SUBTYPE, &value64);
-    ok(hr == S_OK, "Failed to get get uint64 value, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get get uint64 value, hr %#x.\n", hr);
     ok(value64 == 123, "Unexpected value.\n");
     hr = IMFAttributes_GetDouble(dest, &IID_IUnknown, &value_dbl);
-    ok(hr == S_OK, "Failed to get get double value, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get get double value, hr %#x.\n", hr);
     ok(value_dbl == 0.5, "Unexpected value.\n");
     hr = IMFAttributes_GetUnknown(dest, &IID_IMFAttributes, &IID_IUnknown, (void **)&obj);
-    ok(hr == MF_E_ATTRIBUTENOTFOUND, "Unexpected hr %#lx.\n", hr);
+    ok(hr == MF_E_ATTRIBUTENOTFOUND, "Unexpected hr %#x.\n", hr);
     hr = IMFAttributes_GetGUID(dest, &GUID_NULL, &guid);
-    ok(hr == S_OK, "Failed to get guid value, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get guid value, hr %#x.\n", hr);
     ok(IsEqualGUID(&guid, &IID_IUnknown), "Unexpected guid.\n");
     hr = IMFAttributes_GetAllocatedString(dest, &DUMMY_CLSID, &str, &size);
-    ok(hr == S_OK, "Failed to get string value, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get string value, hr %#x.\n", hr);
     ok(!lstrcmpW(str, L"Text"), "Unexpected string.\n");
     CoTaskMemFree(str);
     hr = IMFAttributes_GetAllocatedBlob(dest, &DUMMY_GUID1, &buffer, &size);
-    ok(hr == S_OK, "Failed to get blob value, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get blob value, hr %#x.\n", hr);
     ok(!memcmp(buffer, blob, sizeof(blob)), "Unexpected blob.\n");
     CoTaskMemFree(buffer);
 
@@ -4477,49 +4391,49 @@ static void test_wrapped_media_type(void)
     GUID guid;
 
     hr = MFCreateMediaType(&mediatype);
-    ok(hr == S_OK, "Failed to create media type, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to create media type, hr %#x.\n", hr);
 
     hr = MFUnwrapMediaType(mediatype, &mediatype2);
-    ok(hr == MF_E_ATTRIBUTENOTFOUND, "Unexpected hr %#lx.\n", hr);
+    ok(hr == MF_E_ATTRIBUTENOTFOUND, "Unexpected hr %#x.\n", hr);
 
     hr = IMFMediaType_SetUINT32(mediatype, &GUID_NULL, 1);
-    ok(hr == S_OK, "Failed to set attribute, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to set attribute, hr %#x.\n", hr);
     hr = IMFMediaType_SetUINT32(mediatype, &DUMMY_GUID1, 2);
-    ok(hr == S_OK, "Failed to set attribute, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to set attribute, hr %#x.\n", hr);
 
     hr = IMFMediaType_SetGUID(mediatype, &MF_MT_MAJOR_TYPE, &MFMediaType_Video);
-    ok(hr == S_OK, "Failed to set GUID value, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to set GUID value, hr %#x.\n", hr);
 
     hr = MFWrapMediaType(mediatype, &MFMediaType_Audio, &IID_IUnknown, &mediatype2);
-    ok(hr == S_OK, "Failed to create wrapped media type, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to create wrapped media type, hr %#x.\n", hr);
 
     hr = IMFMediaType_GetGUID(mediatype2, &MF_MT_MAJOR_TYPE, &guid);
-    ok(hr == S_OK, "Failed to get major type, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get major type, hr %#x.\n", hr);
     ok(IsEqualGUID(&guid, &MFMediaType_Audio), "Unexpected major type.\n");
 
     hr = IMFMediaType_GetGUID(mediatype2, &MF_MT_SUBTYPE, &guid);
-    ok(hr == S_OK, "Failed to get subtype, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get subtype, hr %#x.\n", hr);
     ok(IsEqualGUID(&guid, &IID_IUnknown), "Unexpected major type.\n");
 
     hr = IMFMediaType_GetCount(mediatype2, &count);
-    ok(hr == S_OK, "Failed to get item count, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get item count, hr %#x.\n", hr);
     ok(count == 3, "Unexpected count %u.\n", count);
 
     hr = IMFMediaType_GetItemType(mediatype2, &MF_MT_WRAPPED_TYPE, &type);
-    ok(hr == S_OK, "Failed to get item type, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get item type, hr %#x.\n", hr);
     ok(type == MF_ATTRIBUTE_BLOB, "Unexpected item type.\n");
 
     IMFMediaType_Release(mediatype);
 
     hr = MFUnwrapMediaType(mediatype2, &mediatype);
-    ok(hr == S_OK, "Failed to unwrap, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to unwrap, hr %#x.\n", hr);
 
     hr = IMFMediaType_GetGUID(mediatype, &MF_MT_MAJOR_TYPE, &guid);
-    ok(hr == S_OK, "Failed to get major type, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get major type, hr %#x.\n", hr);
     ok(IsEqualGUID(&guid, &MFMediaType_Video), "Unexpected major type.\n");
 
     hr = IMFMediaType_GetGUID(mediatype, &MF_MT_SUBTYPE, &guid);
-    ok(hr == MF_E_ATTRIBUTENOTFOUND, "Unexpected hr %#lx.\n", hr);
+    ok(hr == MF_E_ATTRIBUTENOTFOUND, "Unexpected hr %#x.\n", hr);
 
     IMFMediaType_Release(mediatype);
     IMFMediaType_Release(mediatype2);
@@ -4544,36 +4458,36 @@ static void test_MFCreateWaveFormatExFromMFMediaType(void)
     HRESULT hr;
 
     hr = MFCreateMediaType(&mediatype);
-    ok(hr == S_OK, "Failed to create media type, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to create media type, hr %#x.\n", hr);
 
     hr = MFCreateWaveFormatExFromMFMediaType(mediatype, &format, &size, MFWaveFormatExConvertFlag_Normal);
-    ok(hr == MF_E_ATTRIBUTENOTFOUND, "Unexpected hr %#lx.\n", hr);
+    ok(hr == MF_E_ATTRIBUTENOTFOUND, "Unexpected hr %#x.\n", hr);
 
     hr = IMFMediaType_SetGUID(mediatype, &MF_MT_MAJOR_TYPE, &MFMediaType_Video);
-    ok(hr == S_OK, "Failed to set attribute, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to set attribute, hr %#x.\n", hr);
 
     hr = MFCreateWaveFormatExFromMFMediaType(mediatype, &format, &size, MFWaveFormatExConvertFlag_Normal);
-    ok(hr == MF_E_ATTRIBUTENOTFOUND, "Unexpected hr %#lx.\n", hr);
+    ok(hr == MF_E_ATTRIBUTENOTFOUND, "Unexpected hr %#x.\n", hr);
 
     hr = IMFMediaType_SetGUID(mediatype, &MF_MT_SUBTYPE, &MFMediaType_Video);
-    ok(hr == S_OK, "Failed to set attribute, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to set attribute, hr %#x.\n", hr);
 
     hr = IMFMediaType_SetGUID(mediatype, &MF_MT_MAJOR_TYPE, &MFMediaType_Audio);
-    ok(hr == S_OK, "Failed to set attribute, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to set attribute, hr %#x.\n", hr);
 
     for (i = 0; i < ARRAY_SIZE(wave_fmt_tests); ++i)
     {
         hr = IMFMediaType_SetGUID(mediatype, &MF_MT_SUBTYPE, wave_fmt_tests[i].subtype);
-        ok(hr == S_OK, "Failed to set attribute, hr %#lx.\n", hr);
+        ok(hr == S_OK, "Failed to set attribute, hr %#x.\n", hr);
 
         hr = MFCreateWaveFormatExFromMFMediaType(mediatype, &format, &size, MFWaveFormatExConvertFlag_Normal);
-        ok(hr == S_OK, "Failed to create format, hr %#lx.\n", hr);
+        ok(hr == S_OK, "Failed to create format, hr %#x.\n", hr);
         ok(format != NULL, "Expected format structure.\n");
         ok(size == sizeof(*format), "Unexpected size %u.\n", size);
         ok(format->wFormatTag == wave_fmt_tests[i].format_tag, "Expected tag %u, got %u.\n", wave_fmt_tests[i].format_tag, format->wFormatTag);
         ok(format->nChannels == 0, "Unexpected number of channels, %u.\n", format->nChannels);
-        ok(format->nSamplesPerSec == 0, "Unexpected sample rate, %lu.\n", format->nSamplesPerSec);
-        ok(format->nAvgBytesPerSec == 0, "Unexpected average data rate rate, %lu.\n", format->nAvgBytesPerSec);
+        ok(format->nSamplesPerSec == 0, "Unexpected sample rate, %u.\n", format->nSamplesPerSec);
+        ok(format->nAvgBytesPerSec == 0, "Unexpected average data rate rate, %u.\n", format->nAvgBytesPerSec);
         ok(format->nBlockAlign == 0, "Unexpected alignment, %u.\n", format->nBlockAlign);
         ok(format->wBitsPerSample == 0, "Unexpected sample size, %u.\n", format->wBitsPerSample);
         ok(format->cbSize == 0, "Unexpected size field, %u.\n", format->cbSize);
@@ -4581,13 +4495,13 @@ static void test_MFCreateWaveFormatExFromMFMediaType(void)
 
         hr = MFCreateWaveFormatExFromMFMediaType(mediatype, (WAVEFORMATEX **)&format_ext, &size,
                 MFWaveFormatExConvertFlag_ForceExtensible);
-        ok(hr == S_OK, "Failed to create format, hr %#lx.\n", hr);
+        ok(hr == S_OK, "Failed to create format, hr %#x.\n", hr);
         ok(format_ext != NULL, "Expected format structure.\n");
         ok(size == sizeof(*format_ext), "Unexpected size %u.\n", size);
         ok(format_ext->Format.wFormatTag == WAVE_FORMAT_EXTENSIBLE, "Unexpected tag.\n");
         ok(format_ext->Format.nChannels == 0, "Unexpected number of channels, %u.\n", format_ext->Format.nChannels);
-        ok(format_ext->Format.nSamplesPerSec == 0, "Unexpected sample rate, %lu.\n", format_ext->Format.nSamplesPerSec);
-        ok(format_ext->Format.nAvgBytesPerSec == 0, "Unexpected average data rate rate, %lu.\n",
+        ok(format_ext->Format.nSamplesPerSec == 0, "Unexpected sample rate, %u.\n", format_ext->Format.nSamplesPerSec);
+        ok(format_ext->Format.nAvgBytesPerSec == 0, "Unexpected average data rate rate, %u.\n",
                 format_ext->Format.nAvgBytesPerSec);
         ok(format_ext->Format.nBlockAlign == 0, "Unexpected alignment, %u.\n", format_ext->Format.nBlockAlign);
         ok(format_ext->Format.wBitsPerSample == 0, "Unexpected sample size, %u.\n", format_ext->Format.wBitsPerSample);
@@ -4596,7 +4510,7 @@ static void test_MFCreateWaveFormatExFromMFMediaType(void)
         CoTaskMemFree(format_ext);
 
         hr = MFCreateWaveFormatExFromMFMediaType(mediatype, &format, &size, MFWaveFormatExConvertFlag_ForceExtensible + 1);
-        ok(hr == S_OK, "Failed to create format, hr %#lx.\n", hr);
+        ok(hr == S_OK, "Failed to create format, hr %#x.\n", hr);
         ok(size == sizeof(*format), "Unexpected size %u.\n", size);
         CoTaskMemFree(format);
     }
@@ -4616,10 +4530,10 @@ static HRESULT WINAPI test_create_file_callback_Invoke(IMFAsyncCallback *iface,
     ok((IUnknown *)iface == IMFAsyncResult_GetStateNoAddRef(result), "Unexpected result state.\n");
 
     hr = IMFAsyncResult_GetObject(result, &object);
-    ok(hr == E_POINTER, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Unexpected hr %#x.\n", hr);
 
     hr = MFEndCreateFile(result, &stream);
-    ok(hr == S_OK, "Failed to get file stream, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get file stream, hr %#x.\n", hr);
     IMFByteStream_Release(stream);
 
     SetEvent(callback->event);
@@ -4647,7 +4561,7 @@ static void test_async_create_file(void)
     callback = create_test_callback(&test_create_file_callback_vtbl);
 
     hr = MFStartup(MF_VERSION, MFSTARTUP_FULL);
-    ok(hr == S_OK, "Fail to start up, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Fail to start up, hr %#x.\n", hr);
 
     callback->event = CreateEventA(NULL, FALSE, FALSE, NULL);
 
@@ -4656,7 +4570,7 @@ static void test_async_create_file(void)
 
     hr = MFBeginCreateFile(MF_ACCESSMODE_READWRITE, MF_OPENMODE_DELETE_IF_EXIST, MF_FILEFLAGS_NONE, fileW,
             &callback->IMFAsyncCallback_iface, (IUnknown *)&callback->IMFAsyncCallback_iface, &cancel_cookie);
-    ok(hr == S_OK, "Async create request failed, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Async create request failed, hr %#x.\n", hr);
     ok(cancel_cookie != NULL, "Unexpected cancellation object.\n");
 
     WaitForSingleObject(callback->event, INFINITE);
@@ -4666,7 +4580,7 @@ static void test_async_create_file(void)
     CloseHandle(callback->event);
 
     hr = MFShutdown();
-    ok(hr == S_OK, "Failed to shut down, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to shut down, hr %#x.\n", hr);
 
     IMFAsyncCallback_Release(&callback->IMFAsyncCallback_iface);
 
@@ -4927,34 +4841,34 @@ static void test_local_handlers(void)
     }
 
     hr = pMFRegisterLocalSchemeHandler(NULL, NULL);
-    ok(hr == E_INVALIDARG, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
 
     hr = pMFRegisterLocalSchemeHandler(localW, NULL);
-    ok(hr == E_INVALIDARG, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
 
     hr = pMFRegisterLocalSchemeHandler(NULL, &local_activate);
-    ok(hr == E_INVALIDARG, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
 
     hr = pMFRegisterLocalSchemeHandler(localW, &local_activate);
-    ok(hr == S_OK, "Failed to register scheme handler, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to register scheme handler, hr %#x.\n", hr);
 
     hr = pMFRegisterLocalSchemeHandler(localW, &local_activate);
-    ok(hr == S_OK, "Failed to register scheme handler, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to register scheme handler, hr %#x.\n", hr);
 
     hr = pMFRegisterLocalByteStreamHandler(NULL, NULL, NULL);
-    ok(hr == E_INVALIDARG, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
 
     hr = pMFRegisterLocalByteStreamHandler(NULL, NULL, &local_activate);
-    ok(hr == E_INVALIDARG, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
 
     hr = pMFRegisterLocalByteStreamHandler(NULL, localW, &local_activate);
-    ok(hr == S_OK, "Failed to register stream handler, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to register stream handler, hr %#x.\n", hr);
 
     hr = pMFRegisterLocalByteStreamHandler(localW, NULL, &local_activate);
-    ok(hr == S_OK, "Failed to register stream handler, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to register stream handler, hr %#x.\n", hr);
 
     hr = pMFRegisterLocalByteStreamHandler(localW, localW, &local_activate);
-    ok(hr == S_OK, "Failed to register stream handler, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to register stream handler, hr %#x.\n", hr);
 }
 
 static void test_create_property_store(void)
@@ -4968,13 +4882,13 @@ static void test_create_property_store(void)
     HRESULT hr;
 
     hr = CreatePropertyStore(NULL);
-    ok(hr == E_INVALIDARG, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
 
     hr = CreatePropertyStore(&store);
-    ok(hr == S_OK, "Failed to create property store, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to create property store, hr %#x.\n", hr);
 
     hr = CreatePropertyStore(&store2);
-    ok(hr == S_OK, "Failed to create property store, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to create property store, hr %#x.\n", hr);
     ok(store2 != store, "Expected different store objects.\n");
     IPropertyStore_Release(store2);
 
@@ -4982,77 +4896,77 @@ static void test_create_property_store(void)
     check_interface(store, &IID_IPersistSerializedPropStorage, FALSE);
 
     hr = IPropertyStore_GetCount(store, NULL);
-    ok(hr == E_INVALIDARG, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
 
     count = 0xdeadbeef;
     hr = IPropertyStore_GetCount(store, &count);
-    ok(hr == S_OK, "Failed to get count, hr %#lx.\n", hr);
-    ok(!count, "Unexpected count %lu.\n", count);
+    ok(hr == S_OK, "Failed to get count, hr %#x.\n", hr);
+    ok(!count, "Unexpected count %u.\n", count);
 
     hr = IPropertyStore_Commit(store);
-    ok(hr == E_NOTIMPL, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_NOTIMPL, "Unexpected hr %#x.\n", hr);
 
     hr = IPropertyStore_GetAt(store, 0, &key);
-    ok(hr == E_INVALIDARG, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
 
     hr = IPropertyStore_GetValue(store, NULL, &value);
-    ok(hr == S_FALSE, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Unexpected hr %#x.\n", hr);
 
     hr = IPropertyStore_GetValue(store, &test_pkey, NULL);
-    ok(hr == E_INVALIDARG, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
 
     hr = IPropertyStore_GetValue(store, &test_pkey, &value);
-    ok(hr == S_FALSE, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Unexpected hr %#x.\n", hr);
 
     memset(&value, 0, sizeof(PROPVARIANT));
     value.vt = VT_I4;
     value.lVal = 0xdeadbeef;
     hr = IPropertyStore_SetValue(store, &test_pkey, &value);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
 if (0)
 {
     /* crashes on Windows */
     hr = IPropertyStore_SetValue(store, NULL, &value);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 }
 
     hr = IPropertyStore_GetCount(store, &count);
-    ok(hr == S_OK, "Failed to get count, hr %#lx.\n", hr);
-    ok(count == 1, "Unexpected count %lu.\n", count);
+    ok(hr == S_OK, "Failed to get count, hr %#x.\n", hr);
+    ok(count == 1, "Unexpected count %u.\n", count);
 
     hr = IPropertyStore_Commit(store);
-    ok(hr == E_NOTIMPL, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_NOTIMPL, "Unexpected hr %#x.\n", hr);
 
     hr = IPropertyStore_GetAt(store, 0, &key);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(!memcmp(&key, &test_pkey, sizeof(PROPERTYKEY)), "Keys didn't match.\n");
 
     hr = IPropertyStore_GetAt(store, 1, &key);
-    ok(hr == E_INVALIDARG, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
 
     memset(&value, 0xcc, sizeof(PROPVARIANT));
     hr = IPropertyStore_GetValue(store, &test_pkey, &value);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(value.vt == VT_I4, "Unexpected type %u.\n", value.vt);
-    ok(value.lVal == 0xdeadbeef, "Unexpected value %#lx.\n", value.lVal);
+    ok(value.lVal == 0xdeadbeef, "Unexpected value %#x.\n", value.lVal);
 
     memset(&value, 0, sizeof(PROPVARIANT));
     hr = IPropertyStore_SetValue(store, &test_pkey, &value);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IPropertyStore_GetCount(store, &count);
-    ok(hr == S_OK, "Failed to get count, hr %#lx.\n", hr);
-    ok(count == 1, "Unexpected count %lu.\n", count);
+    ok(hr == S_OK, "Failed to get count, hr %#x.\n", hr);
+    ok(count == 1, "Unexpected count %u.\n", count);
 
     memset(&value, 0xcc, sizeof(PROPVARIANT));
     hr = IPropertyStore_GetValue(store, &test_pkey, &value);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(value.vt == VT_EMPTY, "Unexpected type %u.\n", value.vt);
-    ok(!value.lVal, "Unexpected value %#lx.\n", value.lVal);
+    ok(!value.lVal, "Unexpected value %#x.\n", value.lVal);
 
     refcount = IPropertyStore_Release(store);
-    ok(!refcount, "Unexpected refcount %lu.\n", refcount);
+    ok(!refcount, "Unexpected refcount %u.\n", refcount);
 }
 
 struct test_thread_param
@@ -5098,184 +5012,184 @@ static void test_dxgi_device_manager(void)
     }
 
     hr = pMFCreateDXGIDeviceManager(NULL, &manager);
-    ok(hr == E_POINTER, "MFCreateDXGIDeviceManager should failed: %#lx.\n", hr);
+    ok(hr == E_POINTER, "MFCreateDXGIDeviceManager should failed: %#x.\n", hr);
 
     token = 0;
     hr = pMFCreateDXGIDeviceManager(&token, NULL);
-    ok(hr == E_POINTER, "MFCreateDXGIDeviceManager should failed: %#lx.\n", hr);
+    ok(hr == E_POINTER, "MFCreateDXGIDeviceManager should failed: %#x.\n", hr);
     ok(!token, "got wrong token: %u.\n", token);
 
     hr = pMFCreateDXGIDeviceManager(&token, &manager);
-    ok(hr == S_OK, "MFCreateDXGIDeviceManager failed: %#lx.\n", hr);
+    ok(hr == S_OK, "MFCreateDXGIDeviceManager failed: %#x.\n", hr);
     EXPECT_REF(manager, 1);
     ok(!!token, "got wrong token: %u.\n", token);
 
     Sleep(50);
     token2 = 0;
     hr = pMFCreateDXGIDeviceManager(&token2, &manager2);
-    ok(hr == S_OK, "MFCreateDXGIDeviceManager failed: %#lx.\n", hr);
+    ok(hr == S_OK, "MFCreateDXGIDeviceManager failed: %#x.\n", hr);
     EXPECT_REF(manager2, 1);
     ok(token2 && token2 != token, "got wrong token: %u, %u.\n", token2, token);
     ok(manager != manager2, "got wrong pointer: %p.\n", manager2);
     EXPECT_REF(manager, 1);
 
     hr = IMFDXGIDeviceManager_GetVideoService(manager, NULL, &IID_ID3D11Device, (void **)&unk);
-    ok(hr == MF_E_DXGI_DEVICE_NOT_INITIALIZED, "Unexpected hr %#lx.\n", hr);
+    ok(hr == MF_E_DXGI_DEVICE_NOT_INITIALIZED, "Unexpected hr %#x.\n", hr);
 
     hr = IMFDXGIDeviceManager_OpenDeviceHandle(manager, &handle);
-    ok(hr == MF_E_DXGI_DEVICE_NOT_INITIALIZED, "Unexpected hr %#lx.\n", hr);
+    ok(hr == MF_E_DXGI_DEVICE_NOT_INITIALIZED, "Unexpected hr %#x.\n", hr);
 
     hr = IMFDXGIDeviceManager_CloseDeviceHandle(manager, 0);
-    ok(hr == E_HANDLE, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_HANDLE, "Unexpected hr %#x.\n", hr);
 
     hr = pD3D11CreateDevice(NULL, D3D_DRIVER_TYPE_HARDWARE, NULL, D3D11_CREATE_DEVICE_VIDEO_SUPPORT,
                            NULL, 0, D3D11_SDK_VERSION, &d3d11_dev, NULL, NULL);
-    ok(hr == S_OK, "D3D11CreateDevice failed: %#lx.\n", hr);
+    ok(hr == S_OK, "D3D11CreateDevice failed: %#x.\n", hr);
     EXPECT_REF(d3d11_dev, 1);
 
     hr = IMFDXGIDeviceManager_ResetDevice(manager, (IUnknown *)d3d11_dev, token - 1);
-    ok(hr == E_INVALIDARG, "IMFDXGIDeviceManager_ResetDevice should failed: %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "IMFDXGIDeviceManager_ResetDevice should failed: %#x.\n", hr);
     EXPECT_REF(d3d11_dev, 1);
 
     hr = IMFDXGIDeviceManager_ResetDevice(manager, NULL, token);
-    ok(hr == E_INVALIDARG, "IMFDXGIDeviceManager_ResetDevice should failed: %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "IMFDXGIDeviceManager_ResetDevice should failed: %#x.\n", hr);
 
     hr = IMFDXGIDeviceManager_ResetDevice(manager, (IUnknown *)d3d11_dev, token);
-    ok(hr == S_OK, "IMFDXGIDeviceManager_ResetDevice failed: %#lx.\n", hr);
+    ok(hr == S_OK, "IMFDXGIDeviceManager_ResetDevice failed: %#x.\n", hr);
     EXPECT_REF(manager, 1);
     EXPECT_REF(d3d11_dev, 2);
 
     hr = IMFDXGIDeviceManager_ResetDevice(manager, (IUnknown *)manager2, token);
-    ok(hr == E_INVALIDARG, "IMFDXGIDeviceManager_ResetDevice should failed: %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "IMFDXGIDeviceManager_ResetDevice should failed: %#x.\n", hr);
     EXPECT_REF(manager2, 1);
     EXPECT_REF(d3d11_dev, 2);
 
     hr = IMFDXGIDeviceManager_ResetDevice(manager, (IUnknown *)d3d11_dev, token);
-    ok(hr == S_OK, "IMFDXGIDeviceManager_ResetDevice failed: %#lx.\n", hr);
+    ok(hr == S_OK, "IMFDXGIDeviceManager_ResetDevice failed: %#x.\n", hr);
     EXPECT_REF(manager, 1);
     EXPECT_REF(d3d11_dev, 2);
 
     /* GetVideoService() on device change. */
     handle = NULL;
     hr = IMFDXGIDeviceManager_OpenDeviceHandle(manager, &handle);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(!!handle, "Unexpected handle value %p.\n", handle);
 
     hr = pD3D11CreateDevice(NULL, D3D_DRIVER_TYPE_HARDWARE, NULL, 0,
                            NULL, 0, D3D11_SDK_VERSION, &d3d11_dev2, NULL, NULL);
-    ok(hr == S_OK, "D3D11CreateDevice failed: %#lx.\n", hr);
+    ok(hr == S_OK, "D3D11CreateDevice failed: %#x.\n", hr);
     EXPECT_REF(d3d11_dev2, 1);
     hr = IMFDXGIDeviceManager_ResetDevice(manager, (IUnknown *)d3d11_dev2, token);
-    ok(hr == S_OK, "IMFDXGIDeviceManager_ResetDevice failed: %#lx.\n", hr);
+    ok(hr == S_OK, "IMFDXGIDeviceManager_ResetDevice failed: %#x.\n", hr);
     EXPECT_REF(manager, 1);
     EXPECT_REF(d3d11_dev2, 2);
     EXPECT_REF(d3d11_dev, 1);
 
     hr = IMFDXGIDeviceManager_GetVideoService(manager, handle, &IID_ID3D11Device, (void **)&unk);
-    ok(hr == MF_E_DXGI_NEW_VIDEO_DEVICE, "Unexpected hr %#lx.\n", hr);
+    ok(hr == MF_E_DXGI_NEW_VIDEO_DEVICE, "Unexpected hr %#x.\n", hr);
 
     hr = IMFDXGIDeviceManager_CloseDeviceHandle(manager, handle);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     handle = NULL;
     hr = IMFDXGIDeviceManager_OpenDeviceHandle(manager, &handle);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(!!handle, "Unexpected handle value %p.\n", handle);
 
     hr = IMFDXGIDeviceManager_GetVideoService(manager, NULL, &IID_ID3D11Device, (void **)&unk);
-    ok(hr == E_HANDLE, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_HANDLE, "Unexpected hr %#x.\n", hr);
 
     hr = IMFDXGIDeviceManager_GetVideoService(manager, handle, &IID_ID3D11Device, (void **)&unk);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     IUnknown_Release(unk);
 
     hr = IMFDXGIDeviceManager_GetVideoService(manager, handle, &IID_IUnknown, (void **)&unk);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     IUnknown_Release(unk);
 
     hr = IMFDXGIDeviceManager_GetVideoService(manager, handle, &IID_IDXGIDevice, (void **)&unk);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     IUnknown_Release(unk);
 
     handle1 = NULL;
     hr = IMFDXGIDeviceManager_OpenDeviceHandle(manager, &handle1);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(handle != handle1, "Unexpected handle.\n");
 
     hr = IMFDXGIDeviceManager_CloseDeviceHandle(manager, handle);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     /* Already closed. */
     hr = IMFDXGIDeviceManager_CloseDeviceHandle(manager, handle);
-    ok(hr == E_HANDLE, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_HANDLE, "Unexpected hr %#x.\n", hr);
 
     handle = NULL;
     hr = IMFDXGIDeviceManager_OpenDeviceHandle(manager, &handle);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IMFDXGIDeviceManager_CloseDeviceHandle(manager, handle1);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IMFDXGIDeviceManager_TestDevice(manager, handle1);
-    ok(hr == E_HANDLE, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_HANDLE, "Unexpected hr %#x.\n", hr);
 
     hr = IMFDXGIDeviceManager_LockDevice(manager, handle, &IID_ID3D11Device, (void **)&device, FALSE);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(device == d3d11_dev2, "Unexpected device pointer.\n");
     ID3D11Device_Release(device);
 
     hr = IMFDXGIDeviceManager_UnlockDevice(manager, handle, FALSE);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IMFDXGIDeviceManager_UnlockDevice(manager, handle, FALSE);
-    ok(hr == E_INVALIDARG, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
 
     hr = IMFDXGIDeviceManager_UnlockDevice(manager, UlongToHandle(100), FALSE);
-    ok(hr == E_FAIL, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_FAIL, "Unexpected hr %#x.\n", hr);
 
     /* Locked with one handle, unlock with another. */
     hr = IMFDXGIDeviceManager_OpenDeviceHandle(manager, &handle1);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IMFDXGIDeviceManager_LockDevice(manager, handle, &IID_ID3D11Device, (void **)&device, FALSE);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IMFDXGIDeviceManager_UnlockDevice(manager, handle1, FALSE);
-    ok(hr == E_INVALIDARG, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
 
     ID3D11Device_Release(device);
 
     /* Closing unlocks the device. */
     hr = IMFDXGIDeviceManager_CloseDeviceHandle(manager, handle);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IMFDXGIDeviceManager_LockDevice(manager, handle1, &IID_ID3D11Device, (void **)&device, FALSE);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ID3D11Device_Release(device);
 
     hr = IMFDXGIDeviceManager_CloseDeviceHandle(manager, handle1);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     /* Open two handles. */
     hr = IMFDXGIDeviceManager_OpenDeviceHandle(manager, &handle);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IMFDXGIDeviceManager_OpenDeviceHandle(manager, &handle1);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IMFDXGIDeviceManager_LockDevice(manager, handle, &IID_ID3D11Device, (void **)&device, FALSE);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ID3D11Device_Release(device);
 
     hr = IMFDXGIDeviceManager_LockDevice(manager, handle1, &IID_ID3D11Device, (void **)&device, FALSE);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ID3D11Device_Release(device);
 
     hr = IMFDXGIDeviceManager_UnlockDevice(manager, handle, FALSE);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IMFDXGIDeviceManager_UnlockDevice(manager, handle, FALSE);
-    ok(hr == E_INVALIDARG, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
 
     param.manager = manager;
     param.handle = handle;
@@ -5283,18 +5197,18 @@ static void test_dxgi_device_manager(void)
     thread = CreateThread(NULL, 0, test_device_manager_thread, &param, 0, NULL);
     ok(!WaitForSingleObject(thread, 1000), "Wait for a test thread failed.\n");
     GetExitCodeThread(thread, (DWORD *)&hr);
-    ok(hr == MF_E_DXGI_VIDEO_DEVICE_LOCKED, "Unexpected hr %#lx.\n", hr);
+    ok(hr == MF_E_DXGI_VIDEO_DEVICE_LOCKED, "Unexpected hr %#x.\n", hr);
     CloseHandle(thread);
 
     hr = IMFDXGIDeviceManager_UnlockDevice(manager, handle1, FALSE);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IMFDXGIDeviceManager_UnlockDevice(manager, handle1, FALSE);
-    ok(hr == E_INVALIDARG, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
 
     /* Lock on main thread, unlock on another. */
     hr = IMFDXGIDeviceManager_LockDevice(manager, handle, &IID_ID3D11Device, (void **)&device, FALSE);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ID3D11Device_Release(device);
 
     param.manager = manager;
@@ -5303,14 +5217,14 @@ static void test_dxgi_device_manager(void)
     thread = CreateThread(NULL, 0, test_device_manager_thread, &param, 0, NULL);
     ok(!WaitForSingleObject(thread, 1000), "Wait for a test thread failed.\n");
     GetExitCodeThread(thread, (DWORD *)&hr);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     CloseHandle(thread);
 
     hr = IMFDXGIDeviceManager_CloseDeviceHandle(manager, handle1);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IMFDXGIDeviceManager_CloseDeviceHandle(manager, handle);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     IMFDXGIDeviceManager_Release(manager);
     EXPECT_REF(d3d11_dev2, 1);
@@ -5332,10 +5246,10 @@ static void test_MFCreateTransformActivate(void)
     }
 
     hr = pMFCreateTransformActivate(&activate);
-    ok(hr == S_OK, "Failed to create activator, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to create activator, hr %#x.\n", hr);
 
     hr = IMFActivate_GetCount(activate, &count);
-    ok(hr == S_OK, "Failed to get count, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get count, hr %#x.\n", hr);
     ok(!count, "Unexpected attribute count %u.\n", count);
 
     IMFActivate_Release(activate);
@@ -5404,49 +5318,49 @@ static void test_MFTRegisterLocal(void)
     input_types[0].guidMajorType = MFMediaType_Audio;
     input_types[0].guidSubtype = MFAudioFormat_PCM;
     hr = pMFTRegisterLocal(&test_factory, &MFT_CATEGORY_OTHER, L"Local MFT name", 0, 1, input_types, 0, NULL);
-    ok(hr == S_OK, "Failed to register MFT, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to register MFT, hr %#x.\n", hr);
 
     hr = pMFTRegisterLocal(&test_factory, &MFT_CATEGORY_OTHER, L"Local MFT name", 0, 1, input_types, 0, NULL);
-    ok(hr == S_OK, "Failed to register MFT, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to register MFT, hr %#x.\n", hr);
 
     hr = pMFTEnumEx(MFT_CATEGORY_OTHER, MFT_ENUM_FLAG_LOCALMFT, NULL, NULL, &activate, &count);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(count > 0, "Unexpected count %u.\n", count);
     CoTaskMemFree(activate);
 
     hr = pMFTUnregisterLocal(&test_factory);
-    ok(hr == S_OK, "Failed to unregister MFT, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to unregister MFT, hr %#x.\n", hr);
 
     hr = pMFTEnumEx(MFT_CATEGORY_OTHER, MFT_ENUM_FLAG_LOCALMFT, NULL, NULL, &activate, &count2);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(count2 < count, "Unexpected count %u.\n", count2);
     CoTaskMemFree(activate);
 
     hr = pMFTUnregisterLocal(&test_factory);
-    ok(hr == HRESULT_FROM_WIN32(ERROR_NOT_FOUND), "Unexpected hr %#lx.\n", hr);
+    ok(hr == HRESULT_FROM_WIN32(ERROR_NOT_FOUND), "Unexpected hr %#x.\n", hr);
 
     hr = pMFTUnregisterLocal(NULL);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = pMFTRegisterLocalByCLSID(&MFT_CATEGORY_OTHER, &MFT_CATEGORY_OTHER, L"Local MFT name 2", 0, 1, input_types,
             0, NULL);
-    ok(hr == S_OK, "Failed to register MFT, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to register MFT, hr %#x.\n", hr);
 
     hr = MFTGetInfo(MFT_CATEGORY_OTHER, &name, &in_types, &count, &out_types, &count2, &attributes);
-    ok(hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND), "Unexpected hr %#lx.\n", hr);
+    ok(hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND), "Unexpected hr %#x.\n", hr);
 
     hr = pMFTUnregisterLocal(NULL);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = pMFTUnregisterLocalByCLSID(MFT_CATEGORY_OTHER);
-    ok(hr == HRESULT_FROM_WIN32(ERROR_NOT_FOUND), "Unexpected hr %#lx.\n", hr);
+    ok(hr == HRESULT_FROM_WIN32(ERROR_NOT_FOUND), "Unexpected hr %#x.\n", hr);
 
     hr = pMFTRegisterLocalByCLSID(&MFT_CATEGORY_OTHER, &MFT_CATEGORY_OTHER, L"Local MFT name 2", 0, 1, input_types,
             0, NULL);
-    ok(hr == S_OK, "Failed to register MFT, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to register MFT, hr %#x.\n", hr);
 
     hr = pMFTUnregisterLocalByCLSID(MFT_CATEGORY_OTHER);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 }
 
 static void test_queue_com(void)
@@ -5515,16 +5429,16 @@ static HRESULT WINAPI test_queue_com_state_callback_Invoke(IMFAsyncCallback *ifa
     HRESULT hr;
 
     hr = pCoGetApartmentType(&com_type, &qualifier);
-    ok(SUCCEEDED(hr), "Failed to get apartment type, hr %#lx.\n", hr);
+    ok(SUCCEEDED(hr), "Failed to get apartment type, hr %#x.\n", hr);
     if (SUCCEEDED(hr))
     {
     todo_wine {
         if (callback->param == MFASYNC_CALLBACK_QUEUE_LONG_FUNCTION)
             ok(com_type == APTTYPE_MAINSTA && qualifier == APTTYPEQUALIFIER_NONE,
-                "%#lx: unexpected type %u, qualifier %u.\n", callback->param, com_type, qualifier);
+                "%#x: unexpected type %u, qualifier %u.\n", callback->param, com_type, qualifier);
         else
             ok(com_type == APTTYPE_MTA && qualifier == APTTYPEQUALIFIER_NONE,
-                "%#lx: unexpected type %u, qualifier %u.\n", callback->param, com_type, qualifier);
+                "%#x: unexpected type %u, qualifier %u.\n", callback->param, com_type, qualifier);
     }
     }
 
@@ -5551,13 +5465,13 @@ static void test_queue_com_state(const char *name)
     callback->event = CreateEventA(NULL, FALSE, FALSE, NULL);
 
     hr = MFStartup(MF_VERSION, MFSTARTUP_FULL);
-    ok(hr == S_OK, "Failed to start up, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to start up, hr %#x.\n", hr);
 
     if (name[0] == 's')
     {
         callback->param = name[1] - '0';
         hr = MFPutWorkItem(callback->param, &callback->IMFAsyncCallback_iface, NULL);
-        ok(SUCCEEDED(hr), "Failed to queue work item, hr %#lx.\n", hr);
+        ok(SUCCEEDED(hr), "Failed to queue work item, hr %#x.\n", hr);
         WaitForSingleObject(callback->event, INFINITE);
     }
     else if (name[0] == 'u')
@@ -5566,24 +5480,24 @@ static void test_queue_com_state(const char *name)
 
         hr = pMFAllocateWorkQueueEx(queue_type, &queue);
         ok(hr == S_OK || broken(queue_type == MF_MULTITHREADED_WORKQUEUE && hr == E_INVALIDARG) /* Win7 */,
-                "Failed to allocate a queue of type %lu, hr %#lx.\n", queue_type, hr);
+                "Failed to allocate a queue of type %u, hr %#x.\n", queue_type, hr);
 
         if (SUCCEEDED(hr))
         {
             callback->param = queue;
             hr = MFPutWorkItem(queue, &callback->IMFAsyncCallback_iface, NULL);
-            ok(SUCCEEDED(hr), "Failed to queue work item, hr %#lx.\n", hr);
+            ok(SUCCEEDED(hr), "Failed to queue work item, hr %#x.\n", hr);
             WaitForSingleObject(callback->event, INFINITE);
 
             hr = MFUnlockWorkQueue(queue);
-            ok(hr == S_OK, "Failed to unlock the queue, hr %#lx.\n", hr);
+            ok(hr == S_OK, "Failed to unlock the queue, hr %#x.\n", hr);
         }
     }
 
     CloseHandle(callback->event);
 
     hr = MFShutdown();
-    ok(hr == S_OK, "Failed to shut down, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to shut down, hr %#x.\n", hr);
 
     IMFAsyncCallback_Release(&callback->IMFAsyncCallback_iface);
 }
@@ -5658,13 +5572,13 @@ static void test_MFGetStrideForBitmapInfoHeader(void)
     }
 
     hr = pMFGetStrideForBitmapInfoHeader(MAKEFOURCC('H','2','6','4'), 1, &stride);
-    ok(hr == MF_E_INVALIDMEDIATYPE, "Unexpected hr %#lx.\n", hr);
+    ok(hr == MF_E_INVALIDMEDIATYPE, "Unexpected hr %#x.\n", hr);
 
     for (i = 0; i < ARRAY_SIZE(stride_tests); ++i)
     {
         hr = pMFGetStrideForBitmapInfoHeader(stride_tests[i].subtype->Data1, stride_tests[i].width, &stride);
-        ok(hr == S_OK, "%u: failed to get stride, hr %#lx.\n", i, hr);
-        ok(stride == stride_tests[i].stride, "%u: format %s, unexpected stride %ld, expected %ld.\n", i,
+        ok(hr == S_OK, "%u: failed to get stride, hr %#x.\n", i, hr);
+        ok(stride == stride_tests[i].stride, "%u: format %s, unexpected stride %d, expected %d.\n", i,
                 wine_dbgstr_an((char *)&stride_tests[i].subtype->Data1, 4), stride, stride_tests[i].stride);
     }
 }
@@ -5725,15 +5639,12 @@ static void test_MFCreate2DMediaBuffer(void)
         { 1, 4, D3DFMT_A8R8G8B8, 16, 64 },
         { 4, 1, D3DFMT_A8R8G8B8, 16, 64 },
     };
-    static const char two_aas[] = { 0xaa, 0xaa };
-    static const char eight_bbs[] = { 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb };
-    DWORD max_length, length, length2;
+    unsigned int max_length, length, length2;
     BYTE *buffer_start, *data, *data2;
-    LONG pitch, pitch2, stride;
+    int i, j, k, pitch, pitch2, stride;
     IMF2DBuffer2 *_2dbuffer2;
     IMF2DBuffer *_2dbuffer;
     IMFMediaBuffer *buffer;
-    int i, j, k;
     HRESULT hr;
     BOOL ret;
 
@@ -5744,174 +5655,160 @@ static void test_MFCreate2DMediaBuffer(void)
     }
 
     hr = pMFCreate2DMediaBuffer(2, 3, MAKEFOURCC('H','2','6','4'), FALSE, &buffer);
-    ok(hr == MF_E_INVALIDMEDIATYPE, "Unexpected hr %#lx.\n", hr);
+    ok(hr == MF_E_INVALIDMEDIATYPE, "Unexpected hr %#x.\n", hr);
 
     hr = pMFCreate2DMediaBuffer(2, 3, MAKEFOURCC('N','V','1','2'), FALSE, NULL);
-    ok(FAILED(hr), "Unexpected hr %#lx.\n", hr);
+    ok(FAILED(hr), "Unexpected hr %#x.\n", hr);
 
     /* YUV formats can't be bottom-up. */
     hr = pMFCreate2DMediaBuffer(2, 3, MAKEFOURCC('N','V','1','2'), TRUE, &buffer);
-    ok(hr == MF_E_INVALIDMEDIATYPE, "Unexpected hr %#lx.\n", hr);
+    ok(hr == MF_E_INVALIDMEDIATYPE, "Unexpected hr %#x.\n", hr);
 
     hr = pMFCreate2DMediaBuffer(2, 3, MAKEFOURCC('N','V','1','2'), FALSE, &buffer);
-    ok(hr == S_OK, "Failed to create a buffer, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to create a buffer, hr %#x.\n", hr);
 
     check_interface(buffer, &IID_IMFGetService, TRUE);
     check_interface(buffer, &IID_IMF2DBuffer, TRUE);
 
     /* Full backing buffer size, with 64 bytes per row alignment.  */
     hr = IMFMediaBuffer_GetMaxLength(buffer, &max_length);
-    ok(hr == S_OK, "Failed to get length, hr %#lx.\n", hr);
-    ok(max_length > 0, "Unexpected length %lu.\n", max_length);
+    ok(hr == S_OK, "Failed to get length, hr %#x.\n", hr);
+    ok(max_length > 0, "Unexpected length %u.\n", max_length);
 
     hr = IMFMediaBuffer_GetCurrentLength(buffer, &length);
-    ok(hr == S_OK, "Failed to get current length, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get current length, hr %#x.\n", hr);
     ok(!length, "Unexpected length.\n");
 
     hr = IMFMediaBuffer_SetCurrentLength(buffer, 10);
-    ok(hr == S_OK, "Failed to set current length, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to set current length, hr %#x.\n", hr);
 
     hr = IMFMediaBuffer_GetCurrentLength(buffer, &length);
-    ok(hr == S_OK, "Failed to get current length, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get current length, hr %#x.\n", hr);
     ok(length == 10, "Unexpected length.\n");
 
     /* Linear lock/unlock. */
 
     hr = IMFMediaBuffer_Lock(buffer, NULL, &max_length, &length);
-    ok(FAILED(hr), "Unexpected hr %#lx.\n", hr);
+    ok(FAILED(hr), "Unexpected hr %#x.\n", hr);
 
     /* Linear locking call returns plane size.*/
     hr = IMFMediaBuffer_Lock(buffer, &data, &max_length, &length);
-    ok(hr == S_OK, "Failed to lock buffer, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to lock buffer, hr %#x.\n", hr);
     ok(max_length == length, "Unexpected length.\n");
 
-    memset(data, 0xaa, length);
-
     length = 0;
     pMFGetPlaneSize(MAKEFOURCC('N','V','1','2'), 2, 3, &length);
-    ok(max_length == length && length == 9, "Unexpected length %lu.\n", length);
+    ok(max_length == length && length == 9, "Unexpected length %u.\n", length);
 
     /* Already locked */
     hr = IMFMediaBuffer_Lock(buffer, &data2, NULL, NULL);
-    ok(hr == S_OK, "Failed to lock buffer, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to lock buffer, hr %#x.\n", hr);
     ok(data2 == data, "Unexpected pointer.\n");
 
     hr = IMFMediaBuffer_Unlock(buffer);
-    ok(hr == S_OK, "Failed to unlock buffer, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to unlock buffer, hr %#x.\n", hr);
 
     hr = IMFMediaBuffer_QueryInterface(buffer, &IID_IMF2DBuffer, (void **)&_2dbuffer);
-    ok(hr == S_OK, "Failed to get interface, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get interface, hr %#x.\n", hr);
 
     hr = IMF2DBuffer_GetContiguousLength(_2dbuffer, NULL);
-    ok(hr == E_POINTER, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Unexpected hr %#x.\n", hr);
 
     hr = IMF2DBuffer_GetContiguousLength(_2dbuffer, &length);
-    ok(hr == S_OK, "Failed to get length, hr %#lx.\n", hr);
-    ok(length == 9, "Unexpected length %lu.\n", length);
+    ok(hr == S_OK, "Failed to get length, hr %#x.\n", hr);
+    ok(length == 9, "Unexpected length %u.\n", length);
 
     hr = IMF2DBuffer_IsContiguousFormat(_2dbuffer, NULL);
-    ok(hr == E_POINTER, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Unexpected hr %#x.\n", hr);
 
     /* 2D lock. */
     hr = IMF2DBuffer_Lock2D(_2dbuffer, &data, &pitch);
-    ok(hr == MF_E_UNEXPECTED, "Unexpected hr %#lx.\n", hr);
+    ok(hr == MF_E_UNEXPECTED, "Unexpected hr %#x.\n", hr);
 
     hr = IMF2DBuffer_GetScanline0AndPitch(_2dbuffer, &data, &pitch);
-    ok(hr == HRESULT_FROM_WIN32(ERROR_WAS_UNLOCKED), "Unexpected hr %#lx.\n", hr);
+    ok(hr == HRESULT_FROM_WIN32(ERROR_WAS_UNLOCKED), "Unexpected hr %#x.\n", hr);
 
     hr = IMFMediaBuffer_Unlock(buffer);
-    ok(hr == S_OK, "Failed to unlock buffer, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to unlock buffer, hr %#x.\n", hr);
 
     hr = IMF2DBuffer_GetScanline0AndPitch(_2dbuffer, &data, &pitch);
-    ok(hr == HRESULT_FROM_WIN32(ERROR_WAS_UNLOCKED), "Unexpected hr %#lx.\n", hr);
+    ok(hr == HRESULT_FROM_WIN32(ERROR_WAS_UNLOCKED), "Unexpected hr %#x.\n", hr);
 
     hr = IMF2DBuffer_Lock2D(_2dbuffer, NULL, NULL);
-    ok(hr == E_POINTER, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Unexpected hr %#x.\n", hr);
 
     hr = IMF2DBuffer_Lock2D(_2dbuffer, &data, NULL);
-    ok(hr == E_POINTER, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Unexpected hr %#x.\n", hr);
 
     hr = IMF2DBuffer_Lock2D(_2dbuffer, NULL, &pitch);
-    ok(hr == E_POINTER, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Unexpected hr %#x.\n", hr);
 
     hr = IMF2DBuffer_Lock2D(_2dbuffer, &data, &pitch);
-    ok(hr == S_OK, "Failed to lock buffer, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to lock buffer, hr %#x.\n", hr);
     ok(!!data, "Expected data pointer.\n");
-    ok(pitch == 64, "Unexpected pitch %ld.\n", pitch);
-
-    for (i = 0; i < 4; i++)
-        ok(memcmp(&data[64 * i], two_aas, sizeof(two_aas)) == 0, "Invalid data instead of 0xaa.\n");
-    memset(data, 0xbb, 194);
+    ok(pitch == 64, "Unexpected pitch %d.\n", pitch);
 
     hr = IMF2DBuffer_Lock2D(_2dbuffer, &data2, &pitch);
-    ok(hr == S_OK, "Failed to lock buffer, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to lock buffer, hr %#x.\n", hr);
     ok(data == data2, "Expected data pointer.\n");
 
     hr = IMF2DBuffer_GetScanline0AndPitch(_2dbuffer, NULL, &pitch);
-    ok(hr == E_POINTER, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Unexpected hr %#x.\n", hr);
 
     hr = IMF2DBuffer_GetScanline0AndPitch(_2dbuffer, &data, NULL);
-    ok(hr == E_POINTER, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Unexpected hr %#x.\n", hr);
 
     /* Active 2D lock */
     hr = IMFMediaBuffer_Lock(buffer, &data2, NULL, NULL);
-    ok(hr == MF_E_INVALIDREQUEST, "Unexpected hr %#lx.\n", hr);
+    ok(hr == MF_E_INVALIDREQUEST, "Unexpected hr %#x.\n", hr);
 
     hr = IMF2DBuffer_Unlock2D(_2dbuffer);
-    ok(hr == S_OK, "Failed to unlock buffer, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to unlock buffer, hr %#x.\n", hr);
 
     hr = IMFMediaBuffer_Lock(buffer, &data2, NULL, NULL);
-    ok(hr == MF_E_INVALIDREQUEST, "Unexpected hr %#lx.\n", hr);
+    ok(hr == MF_E_INVALIDREQUEST, "Unexpected hr %#x.\n", hr);
 
     hr = IMF2DBuffer_Unlock2D(_2dbuffer);
-    ok(hr == S_OK, "Failed to unlock buffer, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to unlock buffer, hr %#x.\n", hr);
 
     hr = IMF2DBuffer_Unlock2D(_2dbuffer);
-    ok(hr == HRESULT_FROM_WIN32(ERROR_WAS_UNLOCKED), "Unexpected hr %#lx.\n", hr);
-
-    hr = IMFMediaBuffer_Lock(buffer, &data, NULL, NULL);
-    ok(hr == S_OK, "Failed to lock buffer, hr %#lx.\n", hr);
-
-    ok(memcmp(data, eight_bbs, sizeof(eight_bbs)) == 0, "Invalid data instead of 0xbb.\n");
-
-    hr = IMFMediaBuffer_Unlock(buffer);
-    ok(hr == S_OK, "Failed to unlock buffer, hr %#lx.\n", hr);
+    ok(hr == HRESULT_FROM_WIN32(ERROR_WAS_UNLOCKED), "Unexpected hr %#x.\n", hr);
 
     hr = IMFMediaBuffer_QueryInterface(buffer, &IID_IMF2DBuffer2, (void **)&_2dbuffer2);
-    ok(hr == S_OK || broken(hr == E_NOINTERFACE), "Failed to get interface, hr %#lx.\n", hr);
+    ok(hr == S_OK || broken(hr == E_NOINTERFACE), "Failed to get interface, hr %#x.\n", hr);
 
     if (SUCCEEDED(hr))
     {
         hr = IMF2DBuffer_Lock2D(_2dbuffer, &data, &pitch);
-        ok(hr == S_OK, "Failed to lock buffer, hr %#lx.\n", hr);
+        ok(hr == S_OK, "Failed to lock buffer, hr %#x.\n", hr);
 
         hr = IMF2DBuffer2_Lock2DSize(_2dbuffer2, MF2DBuffer_LockFlags_Read, &data2, &pitch, &buffer_start, &length);
-        ok(hr == S_OK, "Failed to lock buffer, hr %#lx.\n", hr);
+        ok(hr == S_OK, "Failed to lock buffer, hr %#x.\n", hr);
 
         hr = IMF2DBuffer_Unlock2D(_2dbuffer);
-        ok(hr == S_OK, "Failed to unlock buffer, hr %#lx.\n", hr);
+        ok(hr == S_OK, "Failed to unlock buffer, hr %#x.\n", hr);
 
         hr = IMF2DBuffer_Unlock2D(_2dbuffer);
-        ok(hr == S_OK, "Failed to unlock buffer, hr %#lx.\n", hr);
+        ok(hr == S_OK, "Failed to unlock buffer, hr %#x.\n", hr);
 
         /* Flags are ignored. */
         hr = IMF2DBuffer2_Lock2DSize(_2dbuffer2, MF2DBuffer_LockFlags_Read, &data2, &pitch, &buffer_start, &length);
-        ok(hr == S_OK, "Failed to lock buffer, hr %#lx.\n", hr);
+        ok(hr == S_OK, "Failed to lock buffer, hr %#x.\n", hr);
 
         hr = IMF2DBuffer2_Lock2DSize(_2dbuffer2, MF2DBuffer_LockFlags_Write, &data2, &pitch, &buffer_start, &length);
-        ok(hr == S_OK, "Failed to lock buffer, hr %#lx.\n", hr);
+        ok(hr == S_OK, "Failed to lock buffer, hr %#x.\n", hr);
 
         hr = IMF2DBuffer_Unlock2D(_2dbuffer);
-        ok(hr == S_OK, "Failed to unlock buffer, hr %#lx.\n", hr);
+        ok(hr == S_OK, "Failed to unlock buffer, hr %#x.\n", hr);
 
         hr = IMF2DBuffer_Unlock2D(_2dbuffer);
-        ok(hr == S_OK, "Failed to unlock buffer, hr %#lx.\n", hr);
+        ok(hr == S_OK, "Failed to unlock buffer, hr %#x.\n", hr);
 
         hr = IMF2DBuffer2_Lock2DSize(_2dbuffer2, MF2DBuffer_LockFlags_Write, &data2, &pitch, NULL, &length);
-        ok(hr == E_POINTER, "Unexpected hr %#lx.\n", hr);
+        ok(hr == E_POINTER, "Unexpected hr %#x.\n", hr);
 
         hr = IMF2DBuffer2_Lock2DSize(_2dbuffer2, MF2DBuffer_LockFlags_Write, &data2, &pitch, &buffer_start, NULL);
-        ok(hr == E_POINTER, "Unexpected hr %#lx.\n", hr);
+        ok(hr == E_POINTER, "Unexpected hr %#x.\n", hr);
 
         IMF2DBuffer2_Release(_2dbuffer2);
     }
@@ -5927,44 +5824,44 @@ static void test_MFCreate2DMediaBuffer(void)
         const struct _2d_buffer_test *ptr = &_2d_buffer_tests[i];
 
         hr = pMFCreate2DMediaBuffer(ptr->width, ptr->height, ptr->fourcc, FALSE, &buffer);
-        ok(hr == S_OK, "Failed to create a buffer, hr %#lx.\n", hr);
+        ok(hr == S_OK, "Failed to create a buffer, hr %#x.\n", hr);
 
         hr = IMFMediaBuffer_GetMaxLength(buffer, &length);
-        ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+        ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
         if (ptr->max_length)
-            ok(length == ptr->max_length, "%u: unexpected maximum length %lu for %u x %u, format %s.\n",
+            ok(length == ptr->max_length, "%u: unexpected maximum length %u for %u x %u, format %s.\n",
                     i, length, ptr->width, ptr->height, wine_dbgstr_an((char *)&ptr->fourcc, 4));
 
         hr = IMFMediaBuffer_QueryInterface(buffer, &IID_IMF2DBuffer, (void **)&_2dbuffer);
-        ok(hr == S_OK, "Failed to get interface, hr %#lx.\n", hr);
+        ok(hr == S_OK, "Failed to get interface, hr %#x.\n", hr);
 
         hr = IMF2DBuffer_GetContiguousLength(_2dbuffer, &length);
-        ok(hr == S_OK, "Failed to get length, hr %#lx.\n", hr);
-        ok(length == ptr->contiguous_length, "%d: unexpected contiguous length %lu for %u x %u, format %s.\n",
+        ok(hr == S_OK, "Failed to get length, hr %#x.\n", hr);
+        ok(length == ptr->contiguous_length, "%d: unexpected contiguous length %u for %u x %u, format %s.\n",
                 i, length, ptr->width, ptr->height, wine_dbgstr_an((char *)&ptr->fourcc, 4));
 
         hr = IMFMediaBuffer_Lock(buffer, &data, &length2, NULL);
-        ok(hr == S_OK, "Failed to lock buffer, hr %#lx.\n", hr);
-        ok(length2 == ptr->contiguous_length, "%d: unexpected linear buffer length %lu for %u x %u, format %s.\n",
+        ok(hr == S_OK, "Failed to lock buffer, hr %#x.\n", hr);
+        ok(length2 == ptr->contiguous_length, "%d: unexpected linear buffer length %u for %u x %u, format %s.\n",
                 i, length2, ptr->width, ptr->height, wine_dbgstr_an((char *)&ptr->fourcc, 4));
 
         memset(data, 0xff, length2);
 
         hr = IMFMediaBuffer_Unlock(buffer);
-        ok(hr == S_OK, "Failed to unlock buffer, hr %#lx.\n", hr);
+        ok(hr == S_OK, "Failed to unlock buffer, hr %#x.\n", hr);
 
         hr = pMFGetPlaneSize(ptr->fourcc, ptr->width, ptr->height, &length2);
-        ok(hr == S_OK, "Failed to get plane size, hr %#lx.\n", hr);
+        ok(hr == S_OK, "Failed to get plane size, hr %#x.\n", hr);
         if (ptr->plane_multiplier)
             length2 *= ptr->plane_multiplier;
-        ok(length2 == length, "%d: contiguous length %lu does not match plane size %lu, %u x %u, format %s.\n", i, length,
+        ok(length2 == length, "%d: contiguous length %u does not match plane size %u, %u x %u, format %s.\n", i, length,
                 length2, ptr->width, ptr->height, wine_dbgstr_an((char *)&ptr->fourcc, 4));
 
         hr = IMF2DBuffer_Lock2D(_2dbuffer, &data, &pitch);
-        ok(hr == S_OK, "Failed to lock buffer, hr %#lx.\n", hr);
+        ok(hr == S_OK, "Failed to lock buffer, hr %#x.\n", hr);
 
         hr = IMF2DBuffer_GetScanline0AndPitch(_2dbuffer, &data2, &pitch2);
-        ok(hr == S_OK, "Failed to get scanline, hr %#lx.\n", hr);
+        ok(hr == S_OK, "Failed to get scanline, hr %#x.\n", hr);
         ok(data2 == data, "Unexpected data pointer.\n");
         ok(pitch == pitch2, "Unexpected pitch.\n");
 
@@ -5974,7 +5871,7 @@ static void test_MFCreate2DMediaBuffer(void)
                 ok(data[j * pitch + k] == 0xff, "Unexpected byte %02x at test %d row %d column %d.\n", data[j * pitch + k], i, j, k);
 
         hr = pMFGetStrideForBitmapInfoHeader(ptr->fourcc, ptr->width, &stride);
-        ok(hr == S_OK, "Failed to get stride, hr %#lx.\n", hr);
+        ok(hr == S_OK, "Failed to get stride, hr %#x.\n", hr);
 
         /* secondary planes */
         switch (ptr->fourcc)
@@ -6007,42 +5904,20 @@ static void test_MFCreate2DMediaBuffer(void)
         }
 
         hr = IMF2DBuffer_Unlock2D(_2dbuffer);
-        ok(hr == S_OK, "Failed to unlock buffer, hr %#lx.\n", hr);
+        ok(hr == S_OK, "Failed to unlock buffer, hr %#x.\n", hr);
 
-        ok(pitch == ptr->pitch, "%d: unexpected pitch %ld, expected %d, %u x %u, format %s.\n", i, pitch, ptr->pitch,
+        ok(pitch == ptr->pitch, "%d: unexpected pitch %d, expected %d, %u x %u, format %s.\n", i, pitch, ptr->pitch,
                 ptr->width, ptr->height, wine_dbgstr_an((char *)&ptr->fourcc, 4));
 
         ret = TRUE;
         hr = IMF2DBuffer_IsContiguousFormat(_2dbuffer, &ret);
-        ok(hr == S_OK, "Failed to get format flag, hr %#lx.\n", hr);
+        ok(hr == S_OK, "Failed to get format flag, hr %#x.\n", hr);
         ok(!ret, "%d: unexpected format flag %d.\n", i, ret);
 
         IMF2DBuffer_Release(_2dbuffer);
 
         IMFMediaBuffer_Release(buffer);
     }
-
-    /* Alignment tests */
-    for (i = 0; i < ARRAY_SIZE(_2d_buffer_tests); ++i)
-    {
-        const struct _2d_buffer_test *ptr = &_2d_buffer_tests[i];
-
-        hr = pMFCreate2DMediaBuffer(ptr->width, ptr->height, ptr->fourcc, FALSE, &buffer);
-        ok(hr == S_OK, "Failed to create a buffer, hr %#lx.\n", hr);
-
-        hr = IMFMediaBuffer_QueryInterface(buffer, &IID_IMF2DBuffer, (void **)&_2dbuffer);
-        ok(hr == S_OK, "Failed to get interface, hr %#lx.\n", hr);
-
-        hr = IMF2DBuffer_Lock2D(_2dbuffer, &data, &pitch);
-        ok(hr == S_OK, "Failed to lock buffer, hr %#lx.\n", hr);
-        ok(((uintptr_t)data & MF_64_BYTE_ALIGNMENT) == 0, "Misaligned data at %p.\n", data);
-
-        hr = IMF2DBuffer_Unlock2D(_2dbuffer);
-        ok(hr == S_OK, "Failed to unlock buffer, hr %#lx.\n", hr);
-
-        IMF2DBuffer_Release(_2dbuffer);
-        IMFMediaBuffer_Release(buffer);
-    }
 }
 
 static void test_MFCreateMediaBufferFromMediaType(void)
@@ -6057,21 +5932,18 @@ static void test_MFCreateMediaBufferFromMediaType(void)
         unsigned int buffer_length;
     } audio_tests[] =
     {
-        { 0,  0,   0,  4,  0, 20 },
-        { 0, 16,   0,  4,  0, 20 },
-        { 0,  0,  32,  4,  0, 36 },
-        { 0, 64,  32,  4,  0, 64 },
-        { 1,  0,   0,  4, 16, 36 },
-        { 2,  0,   0,  4, 16, 52 },
-        { 2,  0,  64,  4, 16, 68 },
-        { 2,  0, 128,  4, 16,132 },
+        { 0,  0,  0,  4,  0, 20 },
+        { 0, 16,  0,  4,  0, 20 },
+        { 0,  0, 32,  4,  0, 36 },
+        { 0, 64, 32,  4,  0, 64 },
+        { 1,  0,  0,  4, 16, 36 },
+        { 2,  0,  0,  4, 16, 52 },
     };
-    IMFMediaType *media_type, *media_type2;
-    unsigned int i, alignment;
     IMFMediaBuffer *buffer;
-    DWORD length, max;
-    BYTE *data;
+    UINT32 length;
     HRESULT hr;
+    IMFMediaType *media_type;
+    unsigned int i;
 
     if (!pMFCreateMediaBufferFromMediaType)
     {
@@ -6080,73 +5952,40 @@ static void test_MFCreateMediaBufferFromMediaType(void)
     }
 
     hr = pMFCreateMediaBufferFromMediaType(NULL, 0, 0, 0, &buffer);
-    ok(hr == E_INVALIDARG, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
 
     hr = MFCreateMediaType(&media_type);
-    ok(hr == S_OK, "Failed to create media type, hr %#lx.\n", hr);
-
-    hr = MFCreateMediaType(&media_type2);
-    ok(hr == S_OK, "Failed to create media type, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to create media type, hr %#x.\n", hr);
 
     hr = IMFMediaType_SetGUID(media_type, &MF_MT_MAJOR_TYPE, &MFMediaType_Audio);
-    ok(hr == S_OK, "Failed to set attribute, hr %#lx.\n", hr);
-
-    hr = IMFMediaType_CopyAllItems(media_type, (IMFAttributes *)media_type2);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to set attribute, hr %#x.\n", hr);
 
     for (i = 0; i < ARRAY_SIZE(audio_tests); ++i)
     {
         const struct audio_buffer_test *ptr = &audio_tests[i];
 
         hr = IMFMediaType_SetUINT32(media_type, &MF_MT_AUDIO_BLOCK_ALIGNMENT, ptr->block_alignment);
-        ok(hr == S_OK, "Failed to set attribute, hr %#lx.\n", hr);
+        ok(hr == S_OK, "Failed to set attribute, hr %#x.\n", hr);
 
         hr = IMFMediaType_SetUINT32(media_type, &MF_MT_AUDIO_AVG_BYTES_PER_SECOND, ptr->bytes_per_second);
-        ok(hr == S_OK, "Failed to set attribute, hr %#lx.\n", hr);
+        ok(hr == S_OK, "Failed to set attribute, hr %#x.\n", hr);
 
         hr = pMFCreateMediaBufferFromMediaType(media_type, ptr->duration * 10000000, ptr->min_length,
                 ptr->min_alignment, &buffer);
-        ok(hr == S_OK || broken(FAILED(hr)) /* Win8 */, "Unexpected hr %#lx.\n", hr);
+        ok(hr == S_OK || broken(FAILED(hr)) /* Win8 */, "Unexpected hr %#x.\n", hr);
         if (FAILED(hr))
             break;
 
         check_interface(buffer, &IID_IMFGetService, FALSE);
 
         hr = IMFMediaBuffer_GetMaxLength(buffer, &length);
-        ok(hr == S_OK, "Failed to get length, hr %#lx.\n", hr);
-        ok(ptr->buffer_length == length, "%d: unexpected buffer length %lu, expected %u.\n", i, length, ptr->buffer_length);
-
-        alignment = ptr->min_alignment ? ptr->min_alignment - 1 : MF_16_BYTE_ALIGNMENT;
-        hr = IMFMediaBuffer_Lock(buffer, &data, &max, &length);
-        ok(hr == S_OK, "Failed to lock, hr %#lx.\n", hr);
-        ok(ptr->buffer_length == max && !length, "Unexpected length.\n");
-        ok(!((uintptr_t)data & alignment), "%u: data at %p is misaligned.\n", i, data);
-        hr = IMFMediaBuffer_Unlock(buffer);
-        ok(hr == S_OK, "Failed to unlock, hr %#lx.\n", hr);
-
-        IMFMediaBuffer_Release(buffer);
-
-        /* Only major type is set. */
-        hr = pMFCreateMediaBufferFromMediaType(media_type2, ptr->duration * 10000000, ptr->min_length,
-                ptr->min_alignment, &buffer);
-        ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
-
-        hr = IMFMediaBuffer_GetMaxLength(buffer, &length);
-        ok(hr == S_OK, "Failed to get length, hr %#lx.\n", hr);
-        ok(ptr->min_length == length, "%u: unexpected buffer length %lu, expected %u.\n", i, length, ptr->min_length);
-
-        hr = IMFMediaBuffer_Lock(buffer, &data, &max, &length);
-        ok(hr == S_OK, "Failed to lock, hr %#lx.\n", hr);
-        ok(ptr->min_length == max && !length, "Unexpected length.\n");
-        ok(!((uintptr_t)data & alignment), "%u: data at %p is misaligned.\n", i, data);
-        hr = IMFMediaBuffer_Unlock(buffer);
-        ok(hr == S_OK, "Failed to unlock, hr %#lx.\n", hr);
+        ok(hr == S_OK, "Failed to get length, hr %#x.\n", hr);
+        ok(ptr->buffer_length == length, "%d: unexpected buffer length %u, expected %u.\n", i, length, ptr->buffer_length);
 
         IMFMediaBuffer_Release(buffer);
     }
 
     IMFMediaType_Release(media_type);
-    IMFMediaType_Release(media_type2);
 }
 
 static void validate_media_type(IMFMediaType *mediatype, const WAVEFORMATEX *format)
@@ -6156,11 +5995,11 @@ static void validate_media_type(IMFMediaType *mediatype, const WAVEFORMATEX *for
     HRESULT hr;
 
     hr = IMFMediaType_GetMajorType(mediatype, &guid);
-    ok(hr == S_OK, "Failed to get major type, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get major type, hr %#x.\n", hr);
     ok(IsEqualGUID(&guid, &MFMediaType_Audio), "Unexpected major type %s.\n", wine_dbgstr_guid(&guid));
 
     hr = IMFMediaType_GetGUID(mediatype, &MF_MT_SUBTYPE, &guid);
-    ok(hr == S_OK, "Failed to get subtype, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get subtype, hr %#x.\n", hr);
 
     if (format->wFormatTag == WAVE_FORMAT_EXTENSIBLE)
     {
@@ -6170,14 +6009,14 @@ static void validate_media_type(IMFMediaType *mediatype, const WAVEFORMATEX *for
         if (fex->dwChannelMask)
         {
             hr = IMFMediaType_GetUINT32(mediatype, &MF_MT_AUDIO_CHANNEL_MASK, &value);
-            ok(hr == S_OK, "Failed to get attribute, hr %#lx.\n", hr);
+            ok(hr == S_OK, "Failed to get attribute, hr %#x.\n", hr);
             ok(value == fex->dwChannelMask, "Unexpected CHANNEL_MASK %#x.\n", value);
         }
 
         if (format->wBitsPerSample && fex->Samples.wValidBitsPerSample)
         {
             hr = IMFMediaType_GetUINT32(mediatype, &MF_MT_AUDIO_VALID_BITS_PER_SAMPLE, &value);
-            ok(hr == S_OK, "Failed to get attribute, hr %#lx.\n", hr);
+            ok(hr == S_OK, "Failed to get attribute, hr %#x.\n", hr);
             ok(value == fex->Samples.wValidBitsPerSample, "Unexpected VALID_BITS_PER_SAMPLE %#x.\n", value);
         }
     }
@@ -6188,42 +6027,42 @@ static void validate_media_type(IMFMediaType *mediatype, const WAVEFORMATEX *for
         ok(IsEqualGUID(&guid, &subtype), "Unexpected subtype %s.\n", wine_dbgstr_guid(&guid));
 
         hr = IMFMediaType_GetUINT32(mediatype, &MF_MT_AUDIO_PREFER_WAVEFORMATEX, &value);
-        ok(hr == S_OK, "Failed to get attribute, hr %#lx.\n", hr);
+        ok(hr == S_OK, "Failed to get attribute, hr %#x.\n", hr);
         ok(value, "Unexpected value.\n");
     }
 
     if (format->nChannels)
     {
         hr = IMFMediaType_GetUINT32(mediatype, &MF_MT_AUDIO_NUM_CHANNELS, &value);
-        ok(hr == S_OK, "Failed to get attribute, hr %#lx.\n", hr);
+        ok(hr == S_OK, "Failed to get attribute, hr %#x.\n", hr);
         ok(value == format->nChannels, "Unexpected NUM_CHANNELS %u.\n", value);
     }
 
     if (format->nSamplesPerSec)
     {
         hr = IMFMediaType_GetUINT32(mediatype, &MF_MT_AUDIO_SAMPLES_PER_SECOND, &value);
-        ok(hr == S_OK, "Failed to get attribute, hr %#lx.\n", hr);
+        ok(hr == S_OK, "Failed to get attribute, hr %#x.\n", hr);
         ok(value == format->nSamplesPerSec, "Unexpected SAMPLES_PER_SECOND %u.\n", value);
     }
 
     if (format->nAvgBytesPerSec)
     {
         hr = IMFMediaType_GetUINT32(mediatype, &MF_MT_AUDIO_AVG_BYTES_PER_SECOND, &value);
-        ok(hr == S_OK, "Failed to get attribute, hr %#lx.\n", hr);
+        ok(hr == S_OK, "Failed to get attribute, hr %#x.\n", hr);
         ok(value == format->nAvgBytesPerSec, "Unexpected AVG_BYTES_PER_SECOND %u.\n", value);
     }
 
     if (format->nBlockAlign)
     {
         hr = IMFMediaType_GetUINT32(mediatype, &MF_MT_AUDIO_BLOCK_ALIGNMENT, &value);
-        ok(hr == S_OK, "Failed to get attribute, hr %#lx.\n", hr);
+        ok(hr == S_OK, "Failed to get attribute, hr %#x.\n", hr);
         ok(value == format->nBlockAlign, "Unexpected BLOCK_ALIGNMENT %u.\n", value);
     }
 
     if (format->wBitsPerSample)
     {
         hr = IMFMediaType_GetUINT32(mediatype, &MF_MT_AUDIO_BITS_PER_SAMPLE, &value);
-        ok(hr == S_OK, "Failed to get attribute, hr %#lx.\n", hr);
+        ok(hr == S_OK, "Failed to get attribute, hr %#x.\n", hr);
         ok(value == format->wBitsPerSample, "Unexpected BITS_PER_SAMPLE %u.\n", value);
     }
 
@@ -6232,7 +6071,7 @@ static void validate_media_type(IMFMediaType *mediatype, const WAVEFORMATEX *for
     if (IsEqualGUID(&guid, &MFAudioFormat_Float) ||
             IsEqualGUID(&guid, &MFAudioFormat_PCM))
     {
-        ok(hr == S_OK, "Failed to get attribute, hr %#lx.\n", hr);
+        ok(hr == S_OK, "Failed to get attribute, hr %#x.\n", hr);
         ok(value, "Unexpected ALL_SAMPLES_INDEPENDENT value.\n");
     }
     else
@@ -6278,12 +6117,12 @@ static void test_MFInitMediaTypeFromWaveFormatEx(void)
     HRESULT hr;
 
     hr = MFCreateMediaType(&mediatype);
-    ok(hr == S_OK, "Failed to create mediatype, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to create mediatype, hr %#x.\n", hr);
 
     for (i = 0; i < ARRAY_SIZE(waveformatex_tests); ++i)
     {
         hr = MFInitMediaTypeFromWaveFormatEx(mediatype, &waveformatex_tests[i], sizeof(waveformatex_tests[i]));
-        ok(hr == S_OK, "%d: format %#x, failed to initialize media type, hr %#lx.\n", i, waveformatex_tests[i].wFormatTag, hr);
+        ok(hr == S_OK, "%d: format %#x, failed to initialize media type, hr %#x.\n", i, waveformatex_tests[i].wFormatTag, hr);
 
         validate_media_type(mediatype, &waveformatex_tests[i]);
 
@@ -6296,10 +6135,10 @@ static void test_MFInitMediaTypeFromWaveFormatEx(void)
         waveformatext.SubFormat.Data1 = waveformatex_tests[i].wFormatTag;
 
         hr = MFInitMediaTypeFromWaveFormatEx(mediatype, &waveformatext.Format, sizeof(waveformatext));
-        ok(hr == S_OK, "Failed to initialize media type, hr %#lx.\n", hr);
+        ok(hr == S_OK, "Failed to initialize media type, hr %#x.\n", hr);
 
         hr = IMFMediaType_GetItem(mediatype, &MF_MT_USER_DATA, NULL);
-        ok(hr == MF_E_ATTRIBUTENOTFOUND, "Unexpected hr %#lx.\n", hr);
+        ok(hr == MF_E_ATTRIBUTENOTFOUND, "Unexpected hr %#x.\n", hr);
 
         validate_media_type(mediatype, &waveformatext.Format);
     }
@@ -6319,11 +6158,11 @@ static void test_MFInitMediaTypeFromWaveFormatEx(void)
     mp3format.nCodecDelay = 0;
 
     hr = MFInitMediaTypeFromWaveFormatEx(mediatype, (WAVEFORMATEX *)&mp3format, sizeof(mp3format));
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     validate_media_type(mediatype, &mp3format.wfx);
     hr = IMFMediaType_GetBlob(mediatype, &MF_MT_USER_DATA, buff, sizeof(buff), &size);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(size == mp3format.wfx.cbSize, "Unexpected size %u.\n", size);
     ok(!memcmp(buff, (WAVEFORMATEX *)&mp3format + 1, size), "Unexpected user data.\n");
 
@@ -6338,10 +6177,10 @@ static void test_MFCreateMFVideoFormatFromMFMediaType(void)
     HRESULT hr;
 
     hr = MFCreateMediaType(&media_type);
-    ok(hr == S_OK, "Failed to create media type, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to create media type, hr %#x.\n", hr);
 
     hr = MFCreateMFVideoFormatFromMFMediaType(media_type, &video_format, &size);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(!!video_format, "Unexpected format.\n");
     ok(video_format->dwSize == size && size == sizeof(*video_format), "Unexpected size %u.\n", size);
     CoTaskMemFree(video_format);
@@ -6382,19 +6221,19 @@ static void test_MFCreateDXSurfaceBuffer(void)
     }
 
     hr = IDirect3DDevice9_GetSwapChain(device, 0, &swapchain);
-    ok(SUCCEEDED(hr), "Failed to get the implicit swapchain (%08lx)\n", hr);
+    ok(SUCCEEDED(hr), "Failed to get the implicit swapchain (%08x)\n", hr);
 
     hr = IDirect3DSwapChain9_GetBackBuffer(swapchain, 0, D3DBACKBUFFER_TYPE_MONO, &backbuffer);
-    ok(SUCCEEDED(hr), "Failed to get the back buffer (%08lx)\n", hr);
+    ok(SUCCEEDED(hr), "Failed to get the back buffer (%08x)\n", hr);
     ok(backbuffer != NULL, "The back buffer is NULL\n");
 
     IDirect3DSwapChain9_Release(swapchain);
 
     hr = pMFCreateDXSurfaceBuffer(&IID_IUnknown, (IUnknown *)backbuffer, FALSE, &buffer);
-    ok(hr == E_INVALIDARG, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
 
     hr = pMFCreateDXSurfaceBuffer(&IID_IDirect3DSurface9, (IUnknown *)backbuffer, FALSE, &buffer);
-    ok(hr == S_OK, "Failed to create a buffer, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to create a buffer, hr %#x.\n", hr);
 
     check_interface(buffer, &IID_IMF2DBuffer, TRUE);
     check_interface(buffer, &IID_IMF2DBuffer2, TRUE);
@@ -6402,116 +6241,116 @@ static void test_MFCreateDXSurfaceBuffer(void)
 
     /* Surface is accessible. */
     hr = IMFMediaBuffer_QueryInterface(buffer, &IID_IMFGetService, (void **)&gs);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     hr = IMFGetService_GetService(gs, &MR_BUFFER_SERVICE, &IID_IDirect3DSurface9, (void **)&surface);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(surface == backbuffer, "Unexpected surface pointer.\n");
     IDirect3DSurface9_Release(surface);
     IMFGetService_Release(gs);
 
     max_length = 0;
     hr = IMFMediaBuffer_GetMaxLength(buffer, &max_length);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
-    ok(!!max_length, "Unexpected length %lu.\n", max_length);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(!!max_length, "Unexpected length %u.\n", max_length);
 
     hr = IMFMediaBuffer_GetCurrentLength(buffer, &length);
-    ok(hr == S_OK, "Failed to get length, hr %#lx.\n", hr);
-    ok(!length, "Unexpected length %lu.\n", length);
+    ok(hr == S_OK, "Failed to get length, hr %#x.\n", hr);
+    ok(!length, "Unexpected length %u.\n", length);
 
     hr = IMFMediaBuffer_SetCurrentLength(buffer, 2 * max_length);
-    ok(hr == S_OK, "Failed to get length, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get length, hr %#x.\n", hr);
 
     hr = IMFMediaBuffer_GetCurrentLength(buffer, &length);
-    ok(hr == S_OK, "Failed to get length, hr %#lx.\n", hr);
-    ok(length == 2 * max_length, "Unexpected length %lu.\n", length);
+    ok(hr == S_OK, "Failed to get length, hr %#x.\n", hr);
+    ok(length == 2 * max_length, "Unexpected length %u.\n", length);
 
     hr = IMFMediaBuffer_Lock(buffer, &data, NULL, &length);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(length == max_length, "Unexpected length.\n");
 
     /* Unlock twice. */
     hr = IMFMediaBuffer_Unlock(buffer);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IMFMediaBuffer_Unlock(buffer);
-    ok(hr == HRESULT_FROM_WIN32(ERROR_WAS_UNLOCKED), "Unexpected hr %#lx.\n", hr);
+    ok(hr == HRESULT_FROM_WIN32(ERROR_WAS_UNLOCKED), "Unexpected hr %#x.\n", hr);
 
     /* Lock twice. */
     hr = IMFMediaBuffer_Lock(buffer, &data, NULL, NULL);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IMFMediaBuffer_Lock(buffer, &data2, NULL, NULL);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(data == data2, "Unexpected pointer.\n");
 
     hr = IMFMediaBuffer_Unlock(buffer);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IMFMediaBuffer_Unlock(buffer);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IMFMediaBuffer_QueryInterface(buffer, &IID_IMF2DBuffer, (void **)&_2dbuffer);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     /* Unlocked. */
     hr = IMF2DBuffer_GetScanline0AndPitch(_2dbuffer, &data, &pitch);
-    ok(hr == HRESULT_FROM_WIN32(ERROR_WAS_UNLOCKED), "Unexpected hr %#lx.\n", hr);
+    ok(hr == HRESULT_FROM_WIN32(ERROR_WAS_UNLOCKED), "Unexpected hr %#x.\n", hr);
 
     hr = IMF2DBuffer_Lock2D(_2dbuffer, &data, &pitch);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IMF2DBuffer_GetScanline0AndPitch(_2dbuffer, &data, &pitch);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IMFMediaBuffer_Lock(buffer, &data2, NULL, NULL);
-    ok(hr == MF_E_INVALIDREQUEST, "Unexpected hr %#lx.\n", hr);
+    ok(hr == MF_E_INVALIDREQUEST, "Unexpected hr %#x.\n", hr);
 
     hr = IMF2DBuffer_Lock2D(_2dbuffer, &data, &pitch);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IMF2DBuffer_Unlock2D(_2dbuffer);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IMF2DBuffer_Unlock2D(_2dbuffer);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IMF2DBuffer_Unlock2D(_2dbuffer);
-    ok(hr == HRESULT_FROM_WIN32(ERROR_WAS_UNLOCKED), "Unexpected hr %#lx.\n", hr);
+    ok(hr == HRESULT_FROM_WIN32(ERROR_WAS_UNLOCKED), "Unexpected hr %#x.\n", hr);
 
     hr = IMF2DBuffer_IsContiguousFormat(_2dbuffer, &value);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(!value, "Unexpected return value %d.\n", value);
 
     hr = IMF2DBuffer_GetContiguousLength(_2dbuffer, NULL);
-    ok(hr == E_POINTER, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Unexpected hr %#x.\n", hr);
     hr = IMF2DBuffer_GetContiguousLength(_2dbuffer, &length);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
-    ok(length == max_length, "Unexpected length %lu.\n", length);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(length == max_length, "Unexpected length %u.\n", length);
 
     IMF2DBuffer_Release(_2dbuffer);
 
     hr = IMFMediaBuffer_QueryInterface(buffer, &IID_IMF2DBuffer2, (void **)&_2dbuffer2);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IMF2DBuffer2_Lock2DSize(_2dbuffer2, MF2DBuffer_LockFlags_Read, &data, &pitch, &data2, &length);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(data == data2, "Unexpected scanline pointer.\n");
     memset(data, 0xab, 4);
     IMF2DBuffer2_Unlock2D(_2dbuffer2);
 
     hr = IMF2DBuffer2_Lock2DSize(_2dbuffer2, MF2DBuffer_LockFlags_Write, &data, &pitch, &data2, &length);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(data[0] == 0xab, "Unexpected leading byte.\n");
     IMF2DBuffer2_Unlock2D(_2dbuffer2);
 
     hr = IMFMediaBuffer_Lock(buffer, &data, NULL, NULL);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(data[0] == 0xab, "Unexpected leading byte.\n");
     hr = IMFMediaBuffer_Unlock(buffer);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IMF2DBuffer2_Lock2DSize(_2dbuffer2, MF2DBuffer_LockFlags_ReadWrite, &data, &pitch, &data2, &length);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     IMF2DBuffer2_Unlock2D(_2dbuffer2);
 
     IMF2DBuffer2_Release(_2dbuffer2);
@@ -6539,14 +6378,14 @@ static void test_MFCreateTrackedSample(void)
     }
 
     hr = pMFCreateTrackedSample(&tracked_sample);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     /* It's actually a sample. */
     hr = IMFTrackedSample_QueryInterface(tracked_sample, &IID_IMFSample, (void **)&sample);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IMFTrackedSample_QueryInterface(tracked_sample, &IID_IUnknown, (void **)&unk);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(unk == (IUnknown *)sample, "Unexpected pointer.\n");
     IUnknown_Release(unk);
 
@@ -6584,12 +6423,12 @@ static void test_MFFrameRateToAverageTimePerFrame(void)
 
     avgtime = 1;
     hr = MFFrameRateToAverageTimePerFrame(0, 0, &avgtime);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(!avgtime, "Unexpected frame time.\n");
 
     avgtime = 1;
     hr = MFFrameRateToAverageTimePerFrame(0, 1001, &avgtime);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(!avgtime, "Unexpected frame time.\n");
 
     for (i = 0; i < ARRAY_SIZE(frame_rate_tests); ++i)
@@ -6597,59 +6436,12 @@ static void test_MFFrameRateToAverageTimePerFrame(void)
         avgtime = 0;
         hr = MFFrameRateToAverageTimePerFrame(frame_rate_tests[i].numerator,
                 frame_rate_tests[i].denominator, &avgtime);
-        ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+        ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
         ok(avgtime == frame_rate_tests[i].avgtime, "%u: unexpected frame time %s, expected %s.\n",
                 i, wine_dbgstr_longlong(avgtime), wine_dbgstr_longlong(frame_rate_tests[i].avgtime));
     }
 }
 
-static void test_MFAverageTimePerFrameToFrameRate(void)
-{
-    static const struct frame_rate_test
-    {
-        unsigned int numerator;
-        unsigned int denominator;
-        UINT64 avgtime;
-    } frame_rate_tests[] =
-    {
-        { 60000, 1001, 166833 },
-        { 30000, 1001, 333667 },
-        { 24000, 1001, 417188 },
-        { 60, 1, 166667 },
-        { 30, 1, 333333 },
-        { 50, 1, 200000 },
-        { 25, 1, 400000 },
-        { 24, 1, 416667 },
-
-        { 1000000, 25641, 256410 },
-        { 10000000, 83333, 83333 },
-        { 1, 10, 100000000 },
-        { 1, 10, 100000001 },
-        { 1, 10, 200000000 },
-        { 1,  1,  10000000 },
-        { 1,  2,  20000000 },
-        { 5,  1,   2000000 },
-        { 10, 1,   1000000 },
-    };
-    unsigned int i, numerator, denominator;
-    HRESULT hr;
-
-    numerator = denominator = 1;
-    hr = MFAverageTimePerFrameToFrameRate(0, &numerator, &denominator);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
-    ok(!numerator && !denominator, "Unexpected output %u/%u.\n", numerator, denominator);
-
-    for (i = 0; i < ARRAY_SIZE(frame_rate_tests); ++i)
-    {
-        numerator = denominator = 12345;
-        hr = MFAverageTimePerFrameToFrameRate(frame_rate_tests[i].avgtime, &numerator, &denominator);
-        ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
-        ok(numerator == frame_rate_tests[i].numerator && denominator == frame_rate_tests[i].denominator,
-                "%u: unexpected %u/%u, expected %u/%u.\n", i, numerator, denominator, frame_rate_tests[i].numerator,
-                frame_rate_tests[i].denominator);
-    }
-}
-
 static void test_MFMapDXGIFormatToDX9Format(void)
 {
     static const struct format_pair
@@ -6716,7 +6508,7 @@ static void test_MFMapDXGIFormatToDX9Format(void)
     for (i = 0; i < ARRAY_SIZE(formats_map); ++i)
     {
         format = pMFMapDXGIFormatToDX9Format(formats_map[i].dxgi_format);
-        ok(format == formats_map[i].d3d9_format, "Unexpected d3d9 format %#lx, dxgi format %#x.\n", format, formats_map[i].dxgi_format);
+        ok(format == formats_map[i].d3d9_format, "Unexpected d3d9 format %#x, dxgi format %#x.\n", format, formats_map[i].dxgi_format);
     }
 }
 
@@ -6780,7 +6572,7 @@ static void test_MFMapDX9FormatToDXGIFormat(void)
     for (i = 0; i < ARRAY_SIZE(formats_map); ++i)
     {
         format = pMFMapDX9FormatToDXGIFormat(formats_map[i].d3d9_format);
-        ok(format == formats_map[i].dxgi_format, "Unexpected DXGI format %#x, d3d9 format %#lx.\n",
+        ok(format == formats_map[i].dxgi_format, "Unexpected DXGI format %#x, d3d9 format %#x.\n",
                 format, formats_map[i].d3d9_format);
     }
 }
@@ -6829,13 +6621,13 @@ static IMFMediaType * create_video_type(const GUID *subtype)
     HRESULT hr;
 
     hr = MFCreateMediaType(&video_type);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IMFMediaType_SetGUID(video_type, &MF_MT_MAJOR_TYPE, &MFMediaType_Video);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IMFMediaType_SetGUID(video_type, &MF_MT_SUBTYPE, subtype);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     return video_type;
 }
@@ -6936,10 +6728,10 @@ static void test_d3d11_surface_buffer(void)
     desc.SampleDesc.Quality = 0;
 
     hr = ID3D11Device_CreateTexture2D(device, &desc, NULL, &texture);
-    ok(hr == S_OK, "Failed to create a texture, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to create a texture, hr %#x.\n", hr);
 
     hr = pMFCreateDXGISurfaceBuffer(&IID_ID3D11Texture2D, (IUnknown *)texture, 0, FALSE, &buffer);
-    ok(hr == S_OK, "Failed to create a buffer, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to create a buffer, hr %#x.\n", hr);
 
     check_interface(buffer, &IID_IMF2DBuffer, TRUE);
     check_interface(buffer, &IID_IMF2DBuffer2, TRUE);
@@ -6948,150 +6740,150 @@ static void test_d3d11_surface_buffer(void)
 
     max_length = 0;
     hr = IMFMediaBuffer_GetMaxLength(buffer, &max_length);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
-    ok(!!max_length, "Unexpected length %lu.\n", max_length);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(!!max_length, "Unexpected length %u.\n", max_length);
 
     hr = IMFMediaBuffer_GetCurrentLength(buffer, &cur_length);
-    ok(hr == S_OK, "Failed to get length, hr %#lx.\n", hr);
-    ok(!cur_length, "Unexpected length %lu.\n", cur_length);
+    ok(hr == S_OK, "Failed to get length, hr %#x.\n", hr);
+    ok(!cur_length, "Unexpected length %u.\n", cur_length);
 
     hr = IMFMediaBuffer_SetCurrentLength(buffer, 2 * max_length);
-    ok(hr == S_OK, "Failed to get length, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get length, hr %#x.\n", hr);
 
     hr = IMFMediaBuffer_GetCurrentLength(buffer, &cur_length);
-    ok(hr == S_OK, "Failed to get length, hr %#lx.\n", hr);
-    ok(cur_length == 2 * max_length, "Unexpected length %lu.\n", cur_length);
+    ok(hr == S_OK, "Failed to get length, hr %#x.\n", hr);
+    ok(cur_length == 2 * max_length, "Unexpected length %u.\n", cur_length);
 
     hr = IMFMediaBuffer_QueryInterface(buffer, &IID_IMF2DBuffer, (void **)&_2d_buffer);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IMF2DBuffer_GetContiguousLength(_2d_buffer, NULL);
-    ok(hr == E_POINTER, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Unexpected hr %#x.\n", hr);
     hr = IMF2DBuffer_GetContiguousLength(_2d_buffer, &length);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
-    ok(length == max_length, "Unexpected length %lu.\n", length);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(length == max_length, "Unexpected length %u.\n", length);
     IMF2DBuffer_Release(_2d_buffer);
 
     hr = IMFMediaBuffer_QueryInterface(buffer, &IID_IMFDXGIBuffer, (void **)&dxgi_buffer);
-    ok(hr == S_OK, "Failed to get interface, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get interface, hr %#x.\n", hr);
 
     EXPECT_REF(texture, 2);
     hr = IMFDXGIBuffer_GetResource(dxgi_buffer, &IID_ID3D11Texture2D, (void **)&obj);
-    ok(hr == S_OK, "Failed to get resource, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get resource, hr %#x.\n", hr);
     EXPECT_REF(texture, 3);
     ok(obj == (IUnknown *)texture, "Unexpected resource pointer.\n");
     IUnknown_Release(obj);
 
     hr = IMFDXGIBuffer_GetSubresourceIndex(dxgi_buffer, NULL);
-    ok(hr == E_POINTER, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Unexpected hr %#x.\n", hr);
 
     hr = IMFDXGIBuffer_GetSubresourceIndex(dxgi_buffer, &index);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(index == 0, "Unexpected subresource index.\n");
 
     hr = IMFDXGIBuffer_SetUnknown(dxgi_buffer, &IID_IMFDXGIBuffer, NULL);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IMFDXGIBuffer_SetUnknown(dxgi_buffer, &IID_IMFDXGIBuffer, (void *)device);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IMFDXGIBuffer_SetUnknown(dxgi_buffer, &IID_IMFDXGIBuffer, (void *)device);
-    ok(hr == HRESULT_FROM_WIN32(ERROR_OBJECT_ALREADY_EXISTS), "Unexpected hr %#lx.\n", hr);
+    ok(hr == HRESULT_FROM_WIN32(ERROR_OBJECT_ALREADY_EXISTS), "Unexpected hr %#x.\n", hr);
 
     hr = ID3D11Texture2D_GetPrivateData(texture, &IID_IMFDXGIBuffer, &size, &data);
-    ok(hr == DXGI_ERROR_NOT_FOUND, "Unexpected hr %#lx.\n", hr);
+    ok(hr == DXGI_ERROR_NOT_FOUND, "Unexpected hr %#x.\n", hr);
 
     hr = IMFDXGIBuffer_GetUnknown(dxgi_buffer, &IID_IMFDXGIBuffer, &IID_ID3D11Device, (void **)&obj);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(obj == (IUnknown *)device, "Unexpected pointer.\n");
     IUnknown_Release(obj);
 
     hr = IMFDXGIBuffer_SetUnknown(dxgi_buffer, &IID_IMFDXGIBuffer, NULL);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IMFDXGIBuffer_GetUnknown(dxgi_buffer, &IID_IMFDXGIBuffer, &IID_IUnknown, (void **)&obj);
-    ok(hr == MF_E_NOT_FOUND, "Unexpected hr %#lx.\n", hr);
+    ok(hr == MF_E_NOT_FOUND, "Unexpected hr %#x.\n", hr);
 
     IMFDXGIBuffer_Release(dxgi_buffer);
 
     /* Texture updates. */
     color = get_d3d11_texture_color(texture, 0, 0);
-    ok(!color, "Unexpected texture color %#lx.\n", color);
+    ok(!color, "Unexpected texture color %#x.\n", color);
 
     max_length = cur_length = 0;
     data = NULL;
     hr = IMFMediaBuffer_Lock(buffer, &data, &max_length, &cur_length);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
-    ok(max_length && max_length == cur_length, "Unexpected length %lu.\n", max_length);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(max_length && max_length == cur_length, "Unexpected length %u.\n", max_length);
     if (data) *(DWORD *)data = ~0u;
 
     color = get_d3d11_texture_color(texture, 0, 0);
-    ok(!color, "Unexpected texture color %#lx.\n", color);
+    ok(!color, "Unexpected texture color %#x.\n", color);
 
     hr = IMFMediaBuffer_Unlock(buffer);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     color = get_d3d11_texture_color(texture, 0, 0);
-    ok(color == ~0u, "Unexpected texture color %#lx.\n", color);
+    ok(color == ~0u, "Unexpected texture color %#x.\n", color);
 
     hr = IMFMediaBuffer_Lock(buffer, &data, &max_length, &cur_length);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
-    ok(*(DWORD *)data == ~0u, "Unexpected buffer %#lx.\n", *(DWORD *)data);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(*(DWORD *)data == ~0u, "Unexpected buffer %#x.\n", *(DWORD *)data);
 
     hr = IMFMediaBuffer_Unlock(buffer);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     /* Lock2D()/Unlock2D() */
     hr = IMFMediaBuffer_QueryInterface(buffer, &IID_IMF2DBuffer, (void **)&_2d_buffer);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IMF2DBuffer_GetScanline0AndPitch(_2d_buffer, &data2, &pitch2);
-    ok(hr == HRESULT_FROM_WIN32(ERROR_WAS_UNLOCKED), "Unexpected hr %#lx.\n", hr);
+    ok(hr == HRESULT_FROM_WIN32(ERROR_WAS_UNLOCKED), "Unexpected hr %#x.\n", hr);
 
     hr = IMF2DBuffer_Lock2D(_2d_buffer, &data, &pitch);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
-    ok(!!data && pitch == desc.Width * 4, "Unexpected pitch %ld.\n", pitch);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(!!data && pitch == desc.Width * 4, "Unexpected pitch %d.\n", pitch);
 
     hr = IMF2DBuffer_Lock2D(_2d_buffer, &data, &pitch);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
-    ok(!!data && pitch == desc.Width * 4, "Unexpected pitch %ld.\n", pitch);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(!!data && pitch == desc.Width * 4, "Unexpected pitch %d.\n", pitch);
 
     hr = IMF2DBuffer_GetScanline0AndPitch(_2d_buffer, &data2, &pitch2);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(data2 == data && pitch2 == pitch, "Unexpected data/pitch.\n");
 
     hr = IMFMediaBuffer_Lock(buffer, &data, &max_length, &cur_length);
-    ok(hr == MF_E_INVALIDREQUEST, "Unexpected hr %#lx.\n", hr);
+    ok(hr == MF_E_INVALIDREQUEST, "Unexpected hr %#x.\n", hr);
 
     hr = IMF2DBuffer_Unlock2D(_2d_buffer);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IMF2DBuffer_Unlock2D(_2d_buffer);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IMF2DBuffer_Unlock2D(_2d_buffer);
-    ok(hr == HRESULT_FROM_WIN32(ERROR_WAS_UNLOCKED), "Unexpected hr %#lx.\n", hr);
+    ok(hr == HRESULT_FROM_WIN32(ERROR_WAS_UNLOCKED), "Unexpected hr %#x.\n", hr);
 
     IMF2DBuffer_Release(_2d_buffer);
     IMFMediaBuffer_Release(buffer);
 
     /* Bottom up. */
     hr = pMFCreateDXGISurfaceBuffer(&IID_ID3D11Texture2D, (IUnknown *)texture, 0, TRUE, &buffer);
-    ok(hr == S_OK, "Failed to create a buffer, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to create a buffer, hr %#x.\n", hr);
 
     hr = IMFMediaBuffer_QueryInterface(buffer, &IID_IMF2DBuffer, (void **)&_2d_buffer);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IMF2DBuffer_Lock2D(_2d_buffer, &data, &pitch);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
-    ok(!!data && pitch == desc.Width * 4, "Unexpected pitch %ld.\n", pitch);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(!!data && pitch == desc.Width * 4, "Unexpected pitch %d.\n", pitch);
 
     hr = IMF2DBuffer_GetScanline0AndPitch(_2d_buffer, &data2, &pitch2);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(data2 == data && pitch2 == pitch, "Unexpected data/pitch.\n");
 
     hr = IMF2DBuffer_Unlock2D(_2d_buffer);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     IMF2DBuffer_Release(_2d_buffer);
     IMFMediaBuffer_Release(buffer);
@@ -7100,13 +6892,13 @@ static void test_d3d11_surface_buffer(void)
 
     /* Subresource index 1. */
     hr = ID3D11Device_CreateTexture2D(device, &desc, NULL, &texture);
-    ok(hr == S_OK, "Failed to create a texture, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to create a texture, hr %#x.\n", hr);
 
     hr = pMFCreateDXGISurfaceBuffer(&IID_ID3D11Texture2D, (IUnknown *)texture, 1, FALSE, &buffer);
-    ok(hr == S_OK, "Failed to create a buffer, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to create a buffer, hr %#x.\n", hr);
 
     hr = IMFMediaBuffer_QueryInterface(buffer, &IID_IMF2DBuffer, (void **)&_2d_buffer);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     /* Pitch reflects top level. */
     memset(buff, 0, sizeof(buff));
@@ -7114,12 +6906,12 @@ static void test_d3d11_surface_buffer(void)
     update_d3d11_texture(texture, 1, buff, 64 * 4);
 
     hr = IMF2DBuffer_Lock2D(_2d_buffer, &data, &pitch);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
-    ok(pitch == desc.Width * 4, "Unexpected pitch %ld.\n", pitch);
-    ok(*(DWORD *)data == 0xff00ff00, "Unexpected color %#lx.\n", *(DWORD *)data);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(pitch == desc.Width * 4, "Unexpected pitch %d.\n", pitch);
+    ok(*(DWORD *)data == 0xff00ff00, "Unexpected color %#x.\n", *(DWORD *)data);
 
     hr = IMF2DBuffer_Unlock2D(_2d_buffer);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     IMF2DBuffer_Release(_2d_buffer);
     IMFMediaBuffer_Release(buffer);
@@ -7166,16 +6958,16 @@ static void test_d3d12_surface_buffer(void)
 
     hr = ID3D12Device_CreateCommittedResource(device, &heap_props, D3D12_HEAP_FLAG_NONE,
             &desc, D3D12_RESOURCE_STATE_RENDER_TARGET, NULL, &IID_ID3D12Resource, (void **)&resource);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = pMFCreateDXGISurfaceBuffer(&IID_ID3D12Resource, (IUnknown *)resource, 0, FALSE, &buffer);
     if (hr == E_INVALIDARG)
     {
-        todo_wine
+todo_wine
         win_skip("D3D12 resource buffers are not supported.\n");
         goto notsupported;
     }
-    ok(hr == S_OK, "Failed to create a buffer, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to create a buffer, hr %#x.\n", hr);
 
 if (SUCCEEDED(hr))
 {
@@ -7185,10 +6977,10 @@ if (SUCCEEDED(hr))
     check_interface(buffer, &IID_IMFGetService, FALSE);
 
     hr = IMFMediaBuffer_QueryInterface(buffer, &IID_IMFDXGIBuffer, (void **)&dxgi_buffer);
-    ok(hr == S_OK, "Failed to get interface, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get interface, hr %#x.\n", hr);
 
     hr = IMFDXGIBuffer_GetResource(dxgi_buffer, &IID_ID3D12Resource, (void **)&obj);
-    ok(hr == S_OK, "Failed to get resource, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get resource, hr %#x.\n", hr);
     ok(obj == (IUnknown *)resource, "Unexpected resource pointer.\n");
     IUnknown_Release(obj);
 
@@ -7209,11 +7001,11 @@ static void test_sample_allocator_sysmem(void)
     IMFVideoSampleAllocatorCallback *allocator_cb;
     IMFVideoSampleAllocatorEx *allocatorex;
     IMFVideoSampleAllocator *allocator;
+    unsigned int buffer_count;
     IMFSample *sample, *sample2;
     IMFAttributes *attributes;
     IMFMediaBuffer *buffer;
     LONG refcount, count;
-    DWORD buffer_count;
     IUnknown *unk;
     HRESULT hr;
 
@@ -7221,7 +7013,7 @@ static void test_sample_allocator_sysmem(void)
         return;
 
     hr = pMFCreateVideoSampleAllocatorEx(&IID_IUnknown, (void **)&unk);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     check_interface(unk, &IID_IMFVideoSampleAllocator, TRUE);
     check_interface(unk, &IID_IMFVideoSampleAllocatorEx, TRUE);
@@ -7230,123 +7022,123 @@ static void test_sample_allocator_sysmem(void)
     IUnknown_Release(unk);
 
     hr = pMFCreateVideoSampleAllocatorEx(&IID_IMFVideoSampleAllocator, (void **)&allocator);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IMFVideoSampleAllocator_QueryInterface(allocator, &IID_IMFVideoSampleAllocatorCallback, (void **)&allocator_cb);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IMFVideoSampleAllocatorCallback_SetCallback(allocator_cb, NULL);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IMFVideoSampleAllocatorCallback_SetCallback(allocator_cb, &test_notify);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IMFVideoSampleAllocatorCallback_SetCallback(allocator_cb, NULL);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IMFVideoSampleAllocatorCallback_GetFreeSampleCount(allocator_cb, NULL);
-    ok(hr == E_POINTER, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Unexpected hr %#x.\n", hr);
 
     count = 10;
     hr = IMFVideoSampleAllocatorCallback_GetFreeSampleCount(allocator_cb, &count);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
-    ok(!count, "Unexpected count %ld.\n", count);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(!count, "Unexpected count %d.\n", count);
 
     hr = IMFVideoSampleAllocator_UninitializeSampleAllocator(allocator);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IMFVideoSampleAllocator_AllocateSample(allocator, &sample);
-    ok(hr == MF_E_NOT_INITIALIZED, "Unexpected hr %#lx.\n", hr);
+    ok(hr == MF_E_NOT_INITIALIZED, "Unexpected hr %#x.\n", hr);
 
     hr = IMFVideoSampleAllocator_SetDirectXManager(allocator, NULL);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = MFCreateMediaType(&media_type);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IMFVideoSampleAllocator_InitializeSampleAllocator(allocator, 2, media_type);
-    ok(hr == MF_E_ATTRIBUTENOTFOUND, "Unexpected hr %#lx.\n", hr);
+    ok(hr == MF_E_ATTRIBUTENOTFOUND, "Unexpected hr %#x.\n", hr);
 
     video_type = create_video_type(&MFVideoFormat_RGB32);
     video_type2 = create_video_type(&MFVideoFormat_RGB32);
 
     hr = IMFVideoSampleAllocator_InitializeSampleAllocator(allocator, 2, video_type);
-    ok(hr == MF_E_ATTRIBUTENOTFOUND, "Unexpected hr %#lx.\n", hr);
+    ok(hr == MF_E_ATTRIBUTENOTFOUND, "Unexpected hr %#x.\n", hr);
 
     /* Frame size is required. */
     hr = IMFMediaType_SetUINT64(video_type, &MF_MT_FRAME_SIZE, (UINT64) 320 << 32 | 240);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IMFMediaType_SetUINT64(video_type2, &MF_MT_FRAME_SIZE, (UINT64) 320 << 32 | 240);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IMFVideoSampleAllocator_InitializeSampleAllocator(allocator, 0, video_type);
-    ok(hr == E_INVALIDARG, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
 
     EXPECT_REF(video_type, 1);
     hr = IMFVideoSampleAllocator_InitializeSampleAllocator(allocator, 1, video_type);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     EXPECT_REF(video_type, 2);
 
     hr = IMFMediaType_SetUINT64(video_type2, &IID_IUnknown, (UINT64) 320 << 32 | 240);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     /* Setting identical type does not replace it. */
     hr = IMFVideoSampleAllocator_InitializeSampleAllocator(allocator, 1, video_type2);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     EXPECT_REF(video_type, 2);
     EXPECT_REF(video_type2, 1);
 
     hr = IMFMediaType_SetUINT64(video_type2, &MF_MT_FRAME_SIZE, (UINT64) 64 << 32 | 64);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IMFVideoSampleAllocator_InitializeSampleAllocator(allocator, 1, video_type2);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     EXPECT_REF(video_type2, 2);
     EXPECT_REF(video_type, 1);
 
     /* Modify referenced type. */
     hr = IMFMediaType_SetUINT64(video_type2, &MF_MT_FRAME_SIZE, (UINT64) 320 << 32 | 64);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IMFVideoSampleAllocator_InitializeSampleAllocator(allocator, 1, video_type);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     EXPECT_REF(video_type, 2);
     EXPECT_REF(video_type2, 1);
 
     count = 0;
     hr = IMFVideoSampleAllocatorCallback_GetFreeSampleCount(allocator_cb, &count);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
-    ok(count == 1, "Unexpected count %ld.\n", count);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(count == 1, "Unexpected count %d.\n", count);
 
     sample = NULL;
     hr = IMFVideoSampleAllocator_AllocateSample(allocator, &sample);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     refcount = get_refcount(sample);
 
     hr = IMFVideoSampleAllocatorCallback_GetFreeSampleCount(allocator_cb, &count);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
-    ok(!count, "Unexpected count %ld.\n", count);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(!count, "Unexpected count %d.\n", count);
 
     hr = IMFVideoSampleAllocator_AllocateSample(allocator, &sample2);
-    ok(hr == MF_E_SAMPLEALLOCATOR_EMPTY, "Unexpected hr %#lx.\n", hr);
+    ok(hr == MF_E_SAMPLEALLOCATOR_EMPTY, "Unexpected hr %#x.\n", hr);
 
     /* Reinitialize with active sample. */
     hr = IMFVideoSampleAllocator_InitializeSampleAllocator(allocator, 2, video_type);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
-    ok(refcount == get_refcount(sample), "Unexpected refcount %lu.\n", get_refcount(sample));
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(refcount == get_refcount(sample), "Unexpected refcount %u.\n", get_refcount(sample));
     EXPECT_REF(video_type, 2);
 
     hr = IMFVideoSampleAllocatorCallback_GetFreeSampleCount(allocator_cb, &count);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
-    todo_wine
-    ok(!count, "Unexpected count %ld.\n", count);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+todo_wine
+    ok(!count, "Unexpected count %d.\n", count);
 
     check_interface(sample, &IID_IMFTrackedSample, TRUE);
     check_interface(sample, &IID_IMFDesiredSample, FALSE);
 
     hr = IMFSample_GetBufferByIndex(sample, 0, &buffer);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     check_interface(buffer, &IID_IMF2DBuffer, TRUE);
     check_interface(buffer, &IID_IMF2DBuffer2, TRUE);
@@ -7356,72 +7148,72 @@ static void test_sample_allocator_sysmem(void)
     IMFMediaBuffer_Release(buffer);
 
     hr = IMFSample_GetBufferCount(sample, &buffer_count);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
-    ok(buffer_count == 1, "Unexpected buffer count %lu.\n", buffer_count);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(buffer_count == 1, "Unexpected buffer count %u.\n", buffer_count);
 
     IMFSample_Release(sample);
 
     hr = IMFVideoSampleAllocator_UninitializeSampleAllocator(allocator);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
-    todo_wine
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+todo_wine
     EXPECT_REF(video_type, 2);
 
     hr = IMFVideoSampleAllocatorCallback_GetFreeSampleCount(allocator_cb, &count);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
-    ok(!count, "Unexpected count %ld.\n", count);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(!count, "Unexpected count %d.\n", count);
 
     hr = IMFVideoSampleAllocator_AllocateSample(allocator, &sample);
-    ok(hr == MF_E_NOT_INITIALIZED, "Unexpected hr %#lx.\n", hr);
+    ok(hr == MF_E_NOT_INITIALIZED, "Unexpected hr %#x.\n", hr);
 
     IMFVideoSampleAllocatorCallback_Release(allocator_cb);
     IMFVideoSampleAllocator_Release(allocator);
 
     /* IMFVideoSampleAllocatorEx */
     hr = MFCreateAttributes(&attributes, 0);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = pMFCreateVideoSampleAllocatorEx(&IID_IMFVideoSampleAllocatorEx, (void **)&allocatorex);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IMFVideoSampleAllocatorEx_QueryInterface(allocatorex, &IID_IMFVideoSampleAllocatorCallback, (void **)&allocator_cb);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IMFVideoSampleAllocatorEx_InitializeSampleAllocatorEx(allocatorex, 1, 0, NULL, video_type);
-    ok(hr == E_INVALIDARG, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
 
     hr = IMFAttributes_SetUINT32(attributes, &MF_SA_BUFFERS_PER_SAMPLE, 2);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IMFVideoSampleAllocatorEx_AllocateSample(allocatorex, &sample);
-    ok(hr == MF_E_NOT_INITIALIZED, "Unexpected hr %#lx.\n", hr);
+    ok(hr == MF_E_NOT_INITIALIZED, "Unexpected hr %#x.\n", hr);
 
     EXPECT_REF(attributes, 1);
     hr = IMFVideoSampleAllocatorEx_InitializeSampleAllocatorEx(allocatorex, 0, 0, attributes, video_type);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     EXPECT_REF(attributes, 2);
 
     count = 0;
     hr = IMFVideoSampleAllocatorCallback_GetFreeSampleCount(allocator_cb, &count);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
-    ok(count == 1, "Unexpected count %ld.\n", count);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(count == 1, "Unexpected count %d.\n", count);
 
     hr = IMFVideoSampleAllocatorEx_AllocateSample(allocatorex, &sample);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IMFSample_GetBufferCount(sample, &buffer_count);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
-    ok(buffer_count == 2, "Unexpected buffer count %lu.\n", buffer_count);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(buffer_count == 2, "Unexpected buffer count %u.\n", buffer_count);
 
     hr = IMFVideoSampleAllocatorEx_AllocateSample(allocatorex, &sample2);
-    ok(hr == MF_E_SAMPLEALLOCATOR_EMPTY, "Unexpected hr %#lx.\n", hr);
+    ok(hr == MF_E_SAMPLEALLOCATOR_EMPTY, "Unexpected hr %#x.\n", hr);
 
     /* Reinitialize with already allocated samples. */
     hr = IMFVideoSampleAllocatorEx_InitializeSampleAllocatorEx(allocatorex, 0, 0, NULL, video_type);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     EXPECT_REF(attributes, 1);
 
     hr = IMFVideoSampleAllocatorEx_AllocateSample(allocatorex, &sample2);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     IMFSample_Release(sample2);
 
     IMFSample_Release(sample);
@@ -7457,34 +7249,34 @@ static void test_sample_allocator_d3d9(void)
     }
 
     hr = DXVA2CreateDirect3DDeviceManager9(&token, &d3d9_manager);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IDirect3DDeviceManager9_ResetDevice(d3d9_manager, d3d9_device, token);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = pMFCreateVideoSampleAllocatorEx(&IID_IMFVideoSampleAllocator, (void **)&allocator);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IMFVideoSampleAllocator_SetDirectXManager(allocator, (IUnknown *)d3d9_manager);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     video_type = create_video_type(&MFVideoFormat_RGB32);
 
     /* Frame size is required. */
     hr = IMFMediaType_SetUINT64(video_type, &MF_MT_FRAME_SIZE, (UINT64) 64 << 32 | 64);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IMFVideoSampleAllocator_InitializeSampleAllocator(allocator, 1, video_type);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IMFVideoSampleAllocator_AllocateSample(allocator, &sample);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     check_interface(sample, &IID_IMFTrackedSample, TRUE);
     check_interface(sample, &IID_IMFDesiredSample, FALSE);
 
     hr = IMFSample_GetBufferByIndex(sample, 0, &buffer);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     check_interface(buffer, &IID_IMF2DBuffer, TRUE);
     check_interface(buffer, &IID_IMF2DBuffer2, TRUE);
@@ -7543,31 +7335,31 @@ static void test_sample_allocator_d3d11(void)
     }
 
     hr = pMFCreateDXGIDeviceManager(&token, &manager);
-    ok(hr == S_OK, "Failed to create device manager, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to create device manager, hr %#x.\n", hr);
 
     hr = IMFDXGIDeviceManager_ResetDevice(manager, (IUnknown *)device, token);
-    ok(hr == S_OK, "Failed to set a device, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to set a device, hr %#x.\n", hr);
 
     hr = pMFCreateVideoSampleAllocatorEx(&IID_IMFVideoSampleAllocator, (void **)&allocator);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     EXPECT_REF(manager, 1);
     hr = IMFVideoSampleAllocator_SetDirectXManager(allocator, (IUnknown *)manager);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     EXPECT_REF(manager, 2);
 
     video_type = create_video_type(&MFVideoFormat_RGB32);
     hr = IMFMediaType_SetUINT64(video_type, &MF_MT_FRAME_SIZE, (UINT64) 64 << 32 | 64);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IMFVideoSampleAllocator_InitializeSampleAllocator(allocator, 1, video_type);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IMFVideoSampleAllocator_AllocateSample(allocator, &sample);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IMFSample_GetBufferByIndex(sample, 0, &buffer);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     check_interface(buffer, &IID_IMF2DBuffer, TRUE);
     check_interface(buffer, &IID_IMF2DBuffer2, TRUE);
@@ -7575,10 +7367,10 @@ static void test_sample_allocator_d3d11(void)
     check_interface(buffer, &IID_IMFGetService, FALSE);
 
     hr = IMFMediaBuffer_QueryInterface(buffer, &IID_IMFDXGIBuffer, (void **)&dxgi_buffer);
-    ok(hr == S_OK, "Failed to get interface, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get interface, hr %#x.\n", hr);
 
     hr = IMFDXGIBuffer_GetResource(dxgi_buffer, &IID_ID3D11Texture2D, (void **)&texture);
-    ok(hr == S_OK, "Failed to get resource, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get resource, hr %#x.\n", hr);
 
     ID3D11Texture2D_GetDesc(texture, &desc);
     ok(desc.Width == 64, "Unexpected width %u.\n", desc.Width);
@@ -7598,10 +7390,10 @@ static void test_sample_allocator_d3d11(void)
     IMFDXGIBuffer_Release(dxgi_buffer);
 
     hr = IMFMediaBuffer_Lock(buffer, &data, NULL, NULL);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IMFMediaBuffer_Unlock(buffer);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     IMFSample_Release(sample);
 
@@ -7609,42 +7401,42 @@ static void test_sample_allocator_d3d11(void)
 
     /* MF_SA_D3D11_USAGE */
     hr = MFCreateAttributes(&attributes, 1);
-    ok(hr == S_OK, "Failed to create attributes, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to create attributes, hr %#x.\n", hr);
 
     for (i = 0; i < ARRAY_SIZE(usage); ++i)
     {
         hr = pMFCreateVideoSampleAllocatorEx(&IID_IMFVideoSampleAllocatorEx, (void **)&allocatorex);
-        ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+        ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
         hr = IMFVideoSampleAllocatorEx_SetDirectXManager(allocatorex, (IUnknown *)manager);
-        ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+        ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
         hr = IMFAttributes_SetUINT32(attributes, &MF_SA_D3D11_USAGE, usage[i]);
-        ok(hr == S_OK, "Failed to set attribute, hr %#lx.\n", hr);
+        ok(hr == S_OK, "Failed to set attribute, hr %#x.\n", hr);
 
         hr = IMFVideoSampleAllocatorEx_InitializeSampleAllocatorEx(allocatorex, 0, 0, attributes, video_type);
         if (usage[i] == D3D11_USAGE_IMMUTABLE || usage[i] > D3D11_USAGE_STAGING)
         {
-            ok(hr == E_INVALIDARG, "Unexpected hr %#lx.\n", hr);
+            ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
             IMFVideoSampleAllocatorEx_Release(allocatorex);
             continue;
         }
-        ok(hr == S_OK, "%u: Unexpected hr %#lx.\n", usage[i], hr);
+        ok(hr == S_OK, "%u: Unexpected hr %#x.\n", usage[i], hr);
 
         hr = IMFAttributes_SetUINT32(attributes, &MF_SA_D3D11_USAGE, D3D11_USAGE_DEFAULT);
-        ok(hr == S_OK, "Failed to set attribute, hr %#lx.\n", hr);
+        ok(hr == S_OK, "Failed to set attribute, hr %#x.\n", hr);
 
         hr = IMFVideoSampleAllocatorEx_AllocateSample(allocatorex, &sample);
-        ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+        ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
         hr = IMFSample_GetBufferByIndex(sample, 0, &buffer);
-        ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+        ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
         hr = IMFMediaBuffer_QueryInterface(buffer, &IID_IMFDXGIBuffer, (void **)&dxgi_buffer);
-        ok(hr == S_OK, "Failed to get interface, hr %#lx.\n", hr);
+        ok(hr == S_OK, "Failed to get interface, hr %#x.\n", hr);
 
         hr = IMFDXGIBuffer_GetResource(dxgi_buffer, &IID_ID3D11Texture2D, (void **)&texture);
-        ok(hr == S_OK, "Failed to get resource, hr %#lx.\n", hr);
+        ok(hr == S_OK, "Failed to get resource, hr %#x.\n", hr);
 
         ID3D11Texture2D_GetDesc(texture, &desc);
         ok(desc.Usage == usage[i], "Unexpected usage %u.\n", desc.Usage);
@@ -7680,50 +7472,50 @@ static void test_sample_allocator_d3d11(void)
     for (i = 0; i < ARRAY_SIZE(sharing); ++i)
     {
         hr = pMFCreateVideoSampleAllocatorEx(&IID_IMFVideoSampleAllocatorEx, (void **)&allocatorex);
-        ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+        ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
         hr = IMFVideoSampleAllocatorEx_SetDirectXManager(allocatorex, (IUnknown *)manager);
-        ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+        ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
         hr = IMFAttributes_DeleteAllItems(attributes);
-        ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+        ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
         hr = IMFAttributes_SetUINT32(attributes, &MF_SA_D3D11_USAGE, D3D11_USAGE_DEFAULT);
-        ok(hr == S_OK, "Failed to set attribute, hr %#lx.\n", hr);
+        ok(hr == S_OK, "Failed to set attribute, hr %#x.\n", hr);
 
         if (sharing[i] & D3D11_RESOURCE_MISC_SHARED_KEYEDMUTEX)
         {
             hr = IMFAttributes_SetUINT32(attributes, &MF_SA_D3D11_SHARED, TRUE);
-            ok(hr == S_OK, "Failed to set attribute, hr %#lx.\n", hr);
+            ok(hr == S_OK, "Failed to set attribute, hr %#x.\n", hr);
         }
 
         if (sharing[i] & D3D11_RESOURCE_MISC_SHARED)
         {
             hr = IMFAttributes_SetUINT32(attributes, &MF_SA_D3D11_SHARED_WITHOUT_MUTEX, TRUE);
-            ok(hr == S_OK, "Failed to set attribute, hr %#lx.\n", hr);
+            ok(hr == S_OK, "Failed to set attribute, hr %#x.\n", hr);
         }
 
         hr = IMFVideoSampleAllocatorEx_InitializeSampleAllocatorEx(allocatorex, 0, 0, attributes, video_type);
         if (sharing[i] == (D3D11_RESOURCE_MISC_SHARED_KEYEDMUTEX | D3D11_RESOURCE_MISC_SHARED))
         {
-            todo_wine
-            ok(hr == E_INVALIDARG, "%u: Unexpected hr %#lx.\n", i, hr);
+        todo_wine
+            ok(hr == E_INVALIDARG, "%u: Unexpected hr %#x.\n", i, hr);
             IMFVideoSampleAllocatorEx_Release(allocatorex);
             continue;
         }
-        ok(hr == S_OK, "%u: Unexpected hr %#lx.\n", i, hr);
+        ok(hr == S_OK, "%u: Unexpected hr %#x.\n", i, hr);
 
         hr = IMFVideoSampleAllocatorEx_AllocateSample(allocatorex, &sample);
-        ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+        ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
         hr = IMFSample_GetBufferByIndex(sample, 0, &buffer);
-        ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+        ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
         hr = IMFMediaBuffer_QueryInterface(buffer, &IID_IMFDXGIBuffer, (void **)&dxgi_buffer);
-        ok(hr == S_OK, "Failed to get interface, hr %#lx.\n", hr);
+        ok(hr == S_OK, "Failed to get interface, hr %#x.\n", hr);
 
         hr = IMFDXGIBuffer_GetResource(dxgi_buffer, &IID_ID3D11Texture2D, (void **)&texture);
-        ok(hr == S_OK, "Failed to get resource, hr %#lx.\n", hr);
+        ok(hr == S_OK, "Failed to get resource, hr %#x.\n", hr);
 
         ID3D11Texture2D_GetDesc(texture, &desc);
         ok(desc.MiscFlags == sharing[i], "%u: unexpected misc flags %#x.\n", i, desc.MiscFlags);
@@ -7766,7 +7558,7 @@ static void test_sample_allocator_d3d12(void)
     }
 
     hr = pMFCreateDXGIDeviceManager(&token, &manager);
-    ok(hr == S_OK, "Failed to create device manager, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to create device manager, hr %#x.\n", hr);
 
     hr = IMFDXGIDeviceManager_ResetDevice(manager, (IUnknown *)device, token);
     if (FAILED(hr))
@@ -7774,32 +7566,32 @@ static void test_sample_allocator_d3d12(void)
         win_skip("Device manager does not support D3D12 devices.\n");
         goto done;
     }
-    ok(hr == S_OK, "Failed to set a device, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to set a device, hr %#x.\n", hr);
 
     hr = pMFCreateVideoSampleAllocatorEx(&IID_IMFVideoSampleAllocator, (void **)&allocator);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     EXPECT_REF(manager, 1);
     hr = IMFVideoSampleAllocator_SetDirectXManager(allocator, (IUnknown *)manager);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     EXPECT_REF(manager, 2);
 
     video_type = create_video_type(&MFVideoFormat_RGB32);
     hr = IMFMediaType_SetUINT64(video_type, &MF_MT_FRAME_SIZE, (UINT64) 64 << 32 | 64);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     hr = IMFMediaType_SetUINT32(video_type, &MF_MT_D3D_RESOURCE_VERSION, MF_D3D12_RESOURCE);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IMFVideoSampleAllocator_InitializeSampleAllocator(allocator, 1, video_type);
-    todo_wine
-    ok(hr == S_OK || broken(hr == MF_E_UNEXPECTED) /* Some Win10 versions fail. */, "Unexpected hr %#lx.\n", hr);
+todo_wine
+    ok(hr == S_OK || broken(hr == MF_E_UNEXPECTED) /* Some Win10 versions fail. */, "Unexpected hr %#x.\n", hr);
     if (FAILED(hr)) goto done;
 
     hr = IMFVideoSampleAllocator_AllocateSample(allocator, &sample);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = IMFSample_GetBufferByIndex(sample, 0, &buffer);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     check_interface(buffer, &IID_IMF2DBuffer, TRUE);
     check_interface(buffer, &IID_IMF2DBuffer2, TRUE);
@@ -7807,10 +7599,10 @@ static void test_sample_allocator_d3d12(void)
     check_interface(buffer, &IID_IMFGetService, FALSE);
 
     hr = IMFMediaBuffer_QueryInterface(buffer, &IID_IMFDXGIBuffer, (void **)&dxgi_buffer);
-    ok(hr == S_OK, "Failed to get interface, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get interface, hr %#x.\n", hr);
 
     hr = IMFDXGIBuffer_GetResource(dxgi_buffer, &IID_ID3D12Resource, (void **)&resource);
-    ok(hr == S_OK, "Failed to get resource, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to get resource, hr %#x.\n", hr);
 
     resource->lpVtbl->GetDesc(resource, &desc);
     ok(desc.Width == 64, "Unexpected width.\n");
@@ -7824,7 +7616,7 @@ static void test_sample_allocator_d3d12(void)
     ok(!desc.Flags, "Unexpected flags %#x.\n", desc.Flags);
 
     hr = ID3D12Resource_GetHeapProperties(resource, &heap_props, &heap_flags);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(heap_props.Type == D3D12_HEAP_TYPE_DEFAULT, "Unexpected heap type %u.\n", heap_props.Type);
     ok(heap_props.CPUPageProperty == D3D12_CPU_PAGE_PROPERTY_UNKNOWN, "Unexpected page property %u.\n",
             heap_props.CPUPageProperty);
@@ -7854,17 +7646,17 @@ static void test_MFLockSharedWorkQueue(void)
     }
 
     hr = MFStartup(MF_VERSION, MFSTARTUP_FULL);
-    ok(hr == S_OK, "Failed to start up, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to start up, hr %#x.\n", hr);
 
     hr = pMFLockSharedWorkQueue(NULL, 0, &taskid, &queue);
-    ok(hr == E_POINTER, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Unexpected hr %#x.\n", hr);
 
     hr = pMFLockSharedWorkQueue(NULL, 0, NULL, &queue);
-    ok(hr == E_POINTER, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Unexpected hr %#x.\n", hr);
 
     taskid = 0;
     hr = pMFLockSharedWorkQueue(L"", 0, &taskid, &queue);
-    ok(hr == E_INVALIDARG, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
 
     queue = 0;
     hr = pMFLockSharedWorkQueue(L"", 0, NULL, &queue);
@@ -7872,17 +7664,17 @@ static void test_MFLockSharedWorkQueue(void)
 
     queue2 = 0;
     hr = pMFLockSharedWorkQueue(L"", 0, NULL, &queue2);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
-    ok(queue == queue2, "Unexpected queue %#lx.\n", queue2);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
+    ok(queue == queue2, "Unexpected queue %#x.\n", queue2);
 
     hr = MFUnlockWorkQueue(queue2);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = MFUnlockWorkQueue(queue);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     hr = MFShutdown();
-    ok(hr == S_OK, "Failed to shut down, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to shut down, hr %#x.\n", hr);
 }
 
 static void test_MFllMulDiv(void)
@@ -7935,25 +7727,25 @@ static void test_shared_dxgi_device_manager(void)
     }
 
     hr = pMFUnlockDXGIDeviceManager();
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     manager = NULL;
     hr = pMFLockDXGIDeviceManager(NULL, &manager);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
     ok(!!manager, "Unexpected instance.\n");
 
     hr = pMFLockDXGIDeviceManager(&token, &manager);
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     EXPECT_REF(manager, 3);
 
     hr = pMFUnlockDXGIDeviceManager();
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 
     EXPECT_REF(manager, 2);
 
     hr = pMFUnlockDXGIDeviceManager();
-    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
 }
 
 static void check_video_format(const MFVIDEOFORMAT *format, unsigned int width, unsigned int height,
@@ -7983,8 +7775,8 @@ static void check_video_format(const MFVIDEOFORMAT *format, unsigned int width,
     guid.Data1 = d3dformat;
 
     ok(format->dwSize == sizeof(*format), "Unexpected format size.\n");
-    ok(format->videoInfo.dwWidth == width, "Unexpected width %lu.\n", format->videoInfo.dwWidth);
-    ok(format->videoInfo.dwHeight == height, "Unexpected height %lu.\n", format->videoInfo.dwHeight);
+    ok(format->videoInfo.dwWidth == width, "Unexpected width %u.\n", format->videoInfo.dwWidth);
+    ok(format->videoInfo.dwHeight == height, "Unexpected height %u.\n", format->videoInfo.dwHeight);
     ok(format->videoInfo.PixelAspectRatio.Numerator == 1 &&
             format->videoInfo.PixelAspectRatio.Denominator == 1, "Unexpected PAR.\n");
     ok(format->videoInfo.SourceChromaSubsampling == MFVideoChromaSubsampling_Unknown, "Unexpected chroma subsampling.\n");
@@ -7998,7 +7790,7 @@ static void check_video_format(const MFVIDEOFORMAT *format, unsigned int width,
     ok(format->videoInfo.SourceLighting == MFVideoLighting_office, "Unexpected source lighting %u.\n",
             format->videoInfo.SourceLighting);
     ok(format->videoInfo.FramesPerSecond.Numerator == 60 &&
-            format->videoInfo.FramesPerSecond.Denominator == 1, "Unexpected frame rate %lu/%lu.\n",
+            format->videoInfo.FramesPerSecond.Denominator == 1, "Unexpected frame rate %u/%u.\n",
             format->videoInfo.FramesPerSecond.Numerator, format->videoInfo.FramesPerSecond.Denominator);
     ok(format->videoInfo.NominalRange == MFNominalRange_Normal, "Unexpected nominal range %u.\n",
             format->videoInfo.NominalRange);
@@ -8013,8 +7805,8 @@ static void check_video_format(const MFVIDEOFORMAT *format, unsigned int width,
     ok(format->compressedInfo.AvgBitrate == 0, "Unexpected bitrate.\n");
     ok(format->compressedInfo.AvgBitErrorRate == 0, "Unexpected error bitrate.\n");
     ok(format->compressedInfo.MaxKeyFrameSpacing == 0, "Unexpected MaxKeyFrameSpacing.\n");
-    ok(format->surfaceInfo.Format == d3dformat, "Unexpected format %lu.\n", format->surfaceInfo.Format);
-    ok(format->surfaceInfo.PaletteEntries == 0, "Unexpected palette size %lu.\n", format->surfaceInfo.PaletteEntries);
+    ok(format->surfaceInfo.Format == d3dformat, "Unexpected format %u.\n", format->surfaceInfo.Format);
+    ok(format->surfaceInfo.PaletteEntries == 0, "Unexpected palette size %u.\n", format->surfaceInfo.PaletteEntries);
 }
 
 static void test_MFInitVideoFormat_RGB(void)
@@ -8047,13 +7839,13 @@ static void test_MFInitVideoFormat_RGB(void)
     }
 
     hr = pMFInitVideoFormat_RGB(NULL, 64, 32, 0);
-    ok(hr == E_INVALIDARG, "Unexpected hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Unexpected hr %#x.\n", hr);
 
     for (i = 0; i < ARRAY_SIZE(formats); ++i)
     {
         memset(&format, 0, sizeof(format));
         hr = pMFInitVideoFormat_RGB(&format, 64, 32, formats[i]);
-        ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+        ok(hr == S_OK, "Unexpected hr %#x.\n", hr);
         if (SUCCEEDED(hr))
             check_video_format(&format, 64, 32, formats[i]);
     }
@@ -8090,7 +7882,6 @@ START_TEST(mfplat)
     test_file_stream();
     test_MFCreateMFByteStreamOnStream();
     test_system_memory_buffer();
-    test_system_memory_aligned_buffer();
     test_source_resolver();
     test_MFCreateAsyncResult();
     test_allocate_queue();
@@ -8107,7 +7898,6 @@ START_TEST(mfplat)
     test_MFInvokeCallback();
     test_stream_descriptor();
     test_MFCalculateImageSize();
-    test_MFGetPlaneSize();
     test_MFCompareFullToPartialMediaType();
     test_attributes_serialization();
     test_wrapped_media_type();
@@ -8127,7 +7917,6 @@ START_TEST(mfplat)
     test_MFCreateDXSurfaceBuffer();
     test_MFCreateTrackedSample();
     test_MFFrameRateToAverageTimePerFrame();
-    test_MFAverageTimePerFrameToFrameRate();
     test_MFMapDXGIFormatToDX9Format();
     test_d3d11_surface_buffer();
     test_d3d12_surface_buffer();
diff --git a/dlls/mfplat/unix_private.h b/dlls/mfplat/unix_private.h
new file mode 100644
index 00000000000..88566ab1db5
--- /dev/null
+++ wine/dlls/mfplat/unix_private.h
@@ -0,0 +1,37 @@
+/*
+ * winegstreamer Unix library interface
+ *
+ * Copyright 2020-2021 Zebediah Figura for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifndef __WINE_WINEGSTREAMER_UNIX_PRIVATE_H
+#define __WINE_WINEGSTREAMER_UNIX_PRIVATE_H
+
+#include "unixlib.h"
+
+extern bool init_gstreamer(void) DECLSPEC_HIDDEN;
+extern GstElement *create_element(const char *name, const char *plugin_set) DECLSPEC_HIDDEN;
+extern GstCaps *wg_format_to_caps(const struct wg_format *format) DECLSPEC_HIDDEN;
+extern void wg_format_from_caps(struct wg_format *format, const GstCaps *caps) DECLSPEC_HIDDEN;
+extern bool wg_format_compare(const struct wg_format *a, const struct wg_format *b) DECLSPEC_HIDDEN;
+
+extern NTSTATUS wg_transform_create(void *args) DECLSPEC_HIDDEN;
+extern NTSTATUS wg_transform_destroy(void *args) DECLSPEC_HIDDEN;
+extern NTSTATUS wg_transform_push_data(void *args) DECLSPEC_HIDDEN;
+extern NTSTATUS wg_transform_read_data(void *args) DECLSPEC_HIDDEN;
+
+#endif /* __WINE_WINEGSTREAMER_UNIX_PRIVATE_H */
diff --git a/dlls/mfplat/unixlib.h b/dlls/mfplat/unixlib.h
new file mode 100644
index 00000000000..e39cf54fd08
--- /dev/null
+++ wine/dlls/mfplat/unixlib.h
@@ -0,0 +1,354 @@
+/*
+ * winegstreamer Unix library interface
+ *
+ * Copyright 2020-2021 Zebediah Figura for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifndef __WINE_WINEGSTREAMER_UNIXLIB_H
+#define __WINE_WINEGSTREAMER_UNIXLIB_H
+
+#include <stdbool.h>
+#include <stdint.h>
+#include "windef.h"
+#include "winternl.h"
+#include "wtypes.h"
+#include "mmreg.h"
+
+#include "wine/unixlib.h"
+
+struct wg_format
+{
+    enum wg_major_type
+    {
+        WG_MAJOR_TYPE_UNKNOWN,
+        WG_MAJOR_TYPE_VIDEO,
+        WG_MAJOR_TYPE_AUDIO,
+    } major_type;
+
+    union
+    {
+        struct
+        {
+            enum wg_video_format
+            {
+                WG_VIDEO_FORMAT_UNKNOWN,
+
+                WG_VIDEO_FORMAT_BGRA,
+                WG_VIDEO_FORMAT_BGRx,
+                WG_VIDEO_FORMAT_BGR,
+                WG_VIDEO_FORMAT_RGB15,
+                WG_VIDEO_FORMAT_RGB16,
+
+                WG_VIDEO_FORMAT_AYUV,
+                WG_VIDEO_FORMAT_I420,
+                WG_VIDEO_FORMAT_NV12,
+                WG_VIDEO_FORMAT_UYVY,
+                WG_VIDEO_FORMAT_YUY2,
+                WG_VIDEO_FORMAT_YV12,
+                WG_VIDEO_FORMAT_YVYU,
+
+                WG_VIDEO_FORMAT_CINEPAK,
+            } format;
+            int32_t width, height;
+            uint32_t fps_n, fps_d;
+        } video;
+        struct
+        {
+            enum wg_audio_format
+            {
+                WG_AUDIO_FORMAT_UNKNOWN,
+
+                WG_AUDIO_FORMAT_U8,
+                WG_AUDIO_FORMAT_S16LE,
+                WG_AUDIO_FORMAT_S24LE,
+                WG_AUDIO_FORMAT_S32LE,
+                WG_AUDIO_FORMAT_F32LE,
+                WG_AUDIO_FORMAT_F64LE,
+
+                WG_AUDIO_FORMAT_MPEG1_LAYER1,
+                WG_AUDIO_FORMAT_MPEG1_LAYER2,
+                WG_AUDIO_FORMAT_MPEG1_LAYER3,
+            } format;
+
+            uint32_t channels;
+            uint32_t channel_mask; /* In WinMM format. */
+            uint32_t rate;
+        } audio;
+    } u;
+};
+
+struct wg_encoded_format
+{
+    enum wg_encoded_type
+    {
+        WG_ENCODED_TYPE_UNKNOWN,
+        WG_ENCODED_TYPE_WMA,
+        WG_ENCODED_TYPE_XMA,
+        WG_ENCODED_TYPE_AAC,
+        WG_ENCODED_TYPE_H264,
+    } encoded_type;
+
+    union
+    {
+        struct
+        {
+            uint32_t version;
+            uint32_t bitrate;
+            uint32_t rate;
+            uint32_t depth;
+            uint32_t channels;
+            uint32_t block_align;
+            uint32_t codec_data_len;
+            unsigned char codec_data[64];
+        } xwma;
+        struct
+        {
+            uint32_t payload_type;
+            uint32_t profile_level_indication;
+            uint32_t codec_data_len;
+            unsigned char codec_data[64];
+        } aac;
+        struct
+        {
+            int32_t width, height;
+            uint32_t fps_n, fps_d;
+            uint32_t profile;
+            uint32_t level;
+        } h264;
+    } u;
+};
+
+struct wg_rect
+{
+    uint32_t left;
+    uint32_t right;
+    uint32_t top;
+    uint32_t bottom;
+};
+
+struct wg_parser_buffer
+{
+    /* pts and duration are in 100-nanosecond units. */
+    UINT64 pts, duration;
+    UINT32 size;
+    bool discontinuity, preroll, delta, has_pts, has_duration;
+};
+C_ASSERT(sizeof(struct wg_parser_buffer) == 32);
+
+enum wg_read_result
+{
+    WG_READ_SUCCESS,
+    WG_READ_FAILURE,
+    WG_READ_FLUSHING,
+    WG_READ_EOS,
+};
+
+enum wg_parser_type
+{
+    WG_PARSER_DECODEBIN,
+    WG_PARSER_AVIDEMUX,
+    WG_PARSER_MPEGAUDIOPARSE,
+    WG_PARSER_WAVPARSE,
+    WG_PARSER_AUDIOCONV,
+    WG_PARSER_VIDEOCONV,
+};
+
+struct wg_parser_create_params
+{
+    struct wg_parser *parser;
+    enum wg_parser_type type;
+    bool unlimited_buffering;
+};
+
+struct wg_parser_connect_params
+{
+    struct wg_parser *parser;
+    UINT64 file_size;
+};
+
+struct wg_parser_connect_unseekable_params
+{
+    struct wg_parser *parser;
+    const struct wg_format *in_format;
+    UINT32 stream_count;
+    const struct wg_format *out_formats;
+    const struct wg_rect *apertures;
+};
+
+struct wg_parser_get_next_read_offset_params
+{
+    struct wg_parser *parser;
+    UINT32 size;
+    UINT64 offset;
+};
+
+struct wg_parser_push_data_params
+{
+    struct wg_parser *parser;
+    enum wg_read_result result;
+    const void *data;
+    UINT32 size;
+};
+
+struct wg_parser_get_stream_count_params
+{
+    struct wg_parser *parser;
+    UINT32 count;
+};
+
+struct wg_parser_get_stream_params
+{
+    struct wg_parser *parser;
+    UINT32 index;
+    struct wg_parser_stream *stream;
+};
+
+struct wg_parser_stream_get_preferred_format_params
+{
+    struct wg_parser_stream *stream;
+    struct wg_format *format;
+};
+
+#define STREAM_ENABLE_FLAG_FLIP_RGB 0x1
+
+struct wg_parser_stream_enable_params
+{
+    struct wg_parser_stream *stream;
+    const struct wg_format *format;
+    const struct wg_rect *aperture;
+    uint32_t flags;
+};
+
+struct wg_parser_stream_get_buffer_params
+{
+    struct wg_parser_stream *stream;
+    struct wg_parser_buffer *buffer;
+};
+
+struct wg_parser_stream_copy_buffer_params
+{
+    struct wg_parser_stream *stream;
+    void *data;
+    UINT32 offset;
+    UINT32 size;
+};
+
+struct wg_parser_stream_notify_qos_params
+{
+    struct wg_parser_stream *stream;
+    bool underflow;
+    DOUBLE proportion;
+    INT64 diff;
+    UINT64 timestamp;
+};
+
+struct wg_parser_stream_get_duration_params
+{
+    struct wg_parser_stream *stream;
+    UINT64 duration;
+};
+
+struct wg_parser_stream_get_language_params
+{
+    struct wg_parser_stream *stream;
+    char *buffer;
+    UINT32 size;
+};
+
+struct wg_parser_stream_seek_params
+{
+    struct wg_parser_stream *stream;
+    DOUBLE rate;
+    UINT64 start_pos, stop_pos;
+    DWORD start_flags, stop_flags;
+};
+
+struct wg_transform_create_params
+{
+    struct wg_transform *transform;
+    const struct wg_encoded_format *input_format;
+    const struct wg_format *output_format;
+};
+
+struct wg_transform_push_data_params
+{
+    struct wg_transform *transform;
+    const void *data;
+    UINT32 size;
+};
+
+enum wg_sample_flags
+{
+    WG_SAMPLE_FLAG_INCOMPLETE = 1,
+    WG_SAMPLE_FLAG_HAS_PTS = 2,
+    WG_SAMPLE_FLAG_HAS_DURATION = 4,
+};
+
+struct wg_sample
+{
+    UINT32 flags;
+    BYTE *data;
+    UINT32 size;
+    /* pts and duration are in 100-nanosecond units. */
+    ULONGLONG pts, duration;
+    struct wg_format *format;
+};
+
+struct wg_transform_read_data_params
+{
+    struct wg_transform *transform;
+    struct wg_sample *sample;
+};
+
+enum unix_funcs
+{
+    unix_wg_parser_create,
+    unix_wg_parser_destroy,
+
+    unix_wg_parser_connect,
+    unix_wg_parser_connect_unseekable,
+    unix_wg_parser_disconnect,
+
+    unix_wg_parser_get_next_read_offset,
+    unix_wg_parser_push_data,
+
+    unix_wg_parser_get_stream_count,
+    unix_wg_parser_get_stream,
+
+    unix_wg_parser_stream_get_preferred_format,
+    unix_wg_parser_stream_enable,
+    unix_wg_parser_stream_disable,
+
+    unix_wg_parser_stream_get_buffer,
+    unix_wg_parser_stream_copy_buffer,
+    unix_wg_parser_stream_release_buffer,
+    unix_wg_parser_stream_notify_qos,
+
+    unix_wg_parser_stream_get_duration,
+    unix_wg_parser_stream_get_language,
+    unix_wg_parser_stream_seek,
+
+    unix_wg_parser_stream_drain,
+
+    unix_wg_transform_create,
+    unix_wg_transform_destroy,
+
+    unix_wg_transform_push_data,
+    unix_wg_transform_read_data,
+};
+
+#endif /* __WINE_WINEGSTREAMER_UNIXLIB_H */
diff --git a/dlls/mfplat/wg_parser.c b/dlls/mfplat/wg_parser.c
new file mode 100644
index 00000000000..cbd037e42c8
--- /dev/null
+++ wine/dlls/mfplat/wg_parser.c
@@ -0,0 +1,2584 @@
+/*
+ * GStreamer parser backend
+ *
+ * Copyright 2010 Maarten Lankhorst for CodeWeavers
+ * Copyright 2010 Aric Stewart for CodeWeavers
+ * Copyright 2019-2020 Zebediah Figura
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include <assert.h>
+#include <stdarg.h>
+#include <stdio.h>
+
+#define GLIB_VERSION_MIN_REQUIRED GLIB_VERSION_2_30
+#include <gst/gst.h>
+#include <gst/video/video.h>
+#include <gst/audio/audio.h>
+
+#include "winternl.h"
+#include "dshow.h"
+
+#include "unix_private.h"
+
+typedef enum
+{
+    GST_AUTOPLUG_SELECT_TRY,
+    GST_AUTOPLUG_SELECT_EXPOSE,
+    GST_AUTOPLUG_SELECT_SKIP,
+} GstAutoplugSelectResult;
+
+/* GStreamer callbacks may be called on threads not created by Wine, and
+ * therefore cannot access the Wine TEB. This means that we must use GStreamer
+ * debug logging instead of Wine debug logging. In order to be safe we forbid
+ * any use of Wine debug logging in this entire file. */
+
+GST_DEBUG_CATEGORY(wine);
+#define GST_CAT_DEFAULT wine
+
+typedef BOOL (*init_gst_cb)(struct wg_parser *parser);
+
+struct wg_parser
+{
+    init_gst_cb init_gst;
+
+    struct wg_parser_stream **streams;
+    unsigned int stream_count, expected_stream_count;
+
+    GstElement *container, *decodebin;
+    GstBus *bus;
+    GstPad *my_src, *their_sink;
+
+    guint64 file_size, start_offset, next_offset, stop_offset;
+    guint64 next_pull_offset;
+
+    pthread_t push_thread;
+
+    pthread_mutex_t mutex;
+
+    pthread_cond_t init_cond;
+    bool no_more_pads, has_duration, error, pull_mode, seekable;
+
+    pthread_cond_t read_cond, read_done_cond;
+    struct
+    {
+        GstBuffer *buffer;
+        uint64_t offset;
+        uint32_t size;
+        bool done;
+        GstFlowReturn ret;
+    } read_request;
+
+    bool sink_connected, draining;
+
+    bool unlimited_buffering;
+    struct wg_format input_format;
+
+    bool use_mediaconv;
+};
+
+struct wg_parser_stream
+{
+    struct wg_parser *parser;
+
+    GstPad *their_src, *post_sink, *post_src, *my_sink;
+    GstElement *flip, *box;
+    GstSegment segment;
+    struct wg_format preferred_format, current_format;
+    struct wg_rect aperture;
+
+    pthread_cond_t event_cond, event_empty_cond;
+    GstBuffer *buffer;
+    GstMapInfo map_info;
+
+    bool flushing, eos, enabled, has_caps;
+
+    uint64_t duration;
+    gchar *language_code;
+};
+
+static enum wg_audio_format wg_audio_format_from_gst(GstAudioFormat format)
+{
+    switch (format)
+    {
+        case GST_AUDIO_FORMAT_U8:
+            return WG_AUDIO_FORMAT_U8;
+        case GST_AUDIO_FORMAT_S16LE:
+            return WG_AUDIO_FORMAT_S16LE;
+        case GST_AUDIO_FORMAT_S24LE:
+            return WG_AUDIO_FORMAT_S24LE;
+        case GST_AUDIO_FORMAT_S32LE:
+            return WG_AUDIO_FORMAT_S32LE;
+        case GST_AUDIO_FORMAT_F32LE:
+            return WG_AUDIO_FORMAT_F32LE;
+        case GST_AUDIO_FORMAT_F64LE:
+            return WG_AUDIO_FORMAT_F64LE;
+        default:
+            return WG_AUDIO_FORMAT_UNKNOWN;
+    }
+}
+
+static uint32_t wg_channel_position_from_gst(GstAudioChannelPosition position)
+{
+    static const uint32_t position_map[] =
+    {
+        SPEAKER_FRONT_LEFT,
+        SPEAKER_FRONT_RIGHT,
+        SPEAKER_FRONT_CENTER,
+        SPEAKER_LOW_FREQUENCY,
+        SPEAKER_BACK_LEFT,
+        SPEAKER_BACK_RIGHT,
+        SPEAKER_FRONT_LEFT_OF_CENTER,
+        SPEAKER_FRONT_RIGHT_OF_CENTER,
+        SPEAKER_BACK_CENTER,
+        0,
+        SPEAKER_SIDE_LEFT,
+        SPEAKER_SIDE_RIGHT,
+        SPEAKER_TOP_FRONT_LEFT,
+        SPEAKER_TOP_FRONT_RIGHT,
+        SPEAKER_TOP_FRONT_CENTER,
+        SPEAKER_TOP_CENTER,
+        SPEAKER_TOP_BACK_LEFT,
+        SPEAKER_TOP_BACK_RIGHT,
+        0,
+        0,
+        SPEAKER_TOP_BACK_CENTER,
+    };
+
+    if (position == GST_AUDIO_CHANNEL_POSITION_MONO)
+        return SPEAKER_FRONT_CENTER;
+
+    if (position >= 0 && position < ARRAY_SIZE(position_map))
+        return position_map[position];
+    return 0;
+}
+
+static uint32_t wg_channel_mask_from_gst(const GstAudioInfo *info)
+{
+    uint32_t mask = 0, position;
+    unsigned int i;
+
+    for (i = 0; i < GST_AUDIO_INFO_CHANNELS(info); ++i)
+    {
+        if (!(position = wg_channel_position_from_gst(GST_AUDIO_INFO_POSITION(info, i))))
+        {
+            GST_WARNING("Unsupported channel %#x.", GST_AUDIO_INFO_POSITION(info, i));
+            return 0;
+        }
+        /* Make sure it's also in WinMM order. WinMM mandates that channels be
+         * ordered, as it were, from least to most significant SPEAKER_* bit.
+         * Hence we fail if the current channel was already specified, or if any
+         * higher bit was already specified. */
+        if (mask & ~(position - 1))
+        {
+            GST_WARNING("Unsupported channel order.");
+            return 0;
+        }
+        mask |= position;
+    }
+    return mask;
+}
+
+static void wg_format_from_audio_info(struct wg_format *format, const GstAudioInfo *info)
+{
+    format->major_type = WG_MAJOR_TYPE_AUDIO;
+    format->u.audio.format = wg_audio_format_from_gst(GST_AUDIO_INFO_FORMAT(info));
+    format->u.audio.channels = GST_AUDIO_INFO_CHANNELS(info);
+    format->u.audio.channel_mask = wg_channel_mask_from_gst(info);
+    format->u.audio.rate = GST_AUDIO_INFO_RATE(info);
+}
+
+static enum wg_video_format wg_video_format_from_gst(GstVideoFormat format)
+{
+    switch (format)
+    {
+        case GST_VIDEO_FORMAT_BGRA:
+            return WG_VIDEO_FORMAT_BGRA;
+        case GST_VIDEO_FORMAT_BGRx:
+            return WG_VIDEO_FORMAT_BGRx;
+        case GST_VIDEO_FORMAT_BGR:
+            return WG_VIDEO_FORMAT_BGR;
+        case GST_VIDEO_FORMAT_RGB15:
+            return WG_VIDEO_FORMAT_RGB15;
+        case GST_VIDEO_FORMAT_RGB16:
+            return WG_VIDEO_FORMAT_RGB16;
+        case GST_VIDEO_FORMAT_AYUV:
+            return WG_VIDEO_FORMAT_AYUV;
+        case GST_VIDEO_FORMAT_I420:
+            return WG_VIDEO_FORMAT_I420;
+        case GST_VIDEO_FORMAT_NV12:
+            return WG_VIDEO_FORMAT_NV12;
+        case GST_VIDEO_FORMAT_UYVY:
+            return WG_VIDEO_FORMAT_UYVY;
+        case GST_VIDEO_FORMAT_YUY2:
+            return WG_VIDEO_FORMAT_YUY2;
+        case GST_VIDEO_FORMAT_YV12:
+            return WG_VIDEO_FORMAT_YV12;
+        case GST_VIDEO_FORMAT_YVYU:
+            return WG_VIDEO_FORMAT_YVYU;
+        default:
+            return WG_VIDEO_FORMAT_UNKNOWN;
+    }
+}
+
+static void wg_format_from_video_info(struct wg_format *format, const GstVideoInfo *info)
+{
+    format->major_type = WG_MAJOR_TYPE_VIDEO;
+    format->u.video.format = wg_video_format_from_gst(GST_VIDEO_INFO_FORMAT(info));
+    format->u.video.width = GST_VIDEO_INFO_WIDTH(info);
+    format->u.video.height = GST_VIDEO_INFO_HEIGHT(info);
+    format->u.video.fps_n = GST_VIDEO_INFO_FPS_N(info);
+    format->u.video.fps_d = GST_VIDEO_INFO_FPS_D(info);
+}
+
+static void wg_format_from_caps_audio_mpeg(struct wg_format *format, const GstCaps *caps)
+{
+    const GstStructure *structure = gst_caps_get_structure(caps, 0);
+    gint layer, channels, rate;
+
+    if (!gst_structure_get_int(structure, "layer", &layer))
+    {
+        GST_WARNING("Missing \"layer\" value.");
+        return;
+    }
+    if (!gst_structure_get_int(structure, "channels", &channels))
+    {
+        GST_WARNING("Missing \"channels\" value.");
+        return;
+    }
+    if (!gst_structure_get_int(structure, "rate", &rate))
+    {
+        GST_WARNING("Missing \"rate\" value.");
+        return;
+    }
+
+    format->major_type = WG_MAJOR_TYPE_AUDIO;
+
+    if (layer == 1)
+        format->u.audio.format = WG_AUDIO_FORMAT_MPEG1_LAYER1;
+    else if (layer == 2)
+        format->u.audio.format = WG_AUDIO_FORMAT_MPEG1_LAYER2;
+    else if (layer == 3)
+        format->u.audio.format = WG_AUDIO_FORMAT_MPEG1_LAYER3;
+
+    format->u.audio.channels = channels;
+    format->u.audio.rate = rate;
+}
+
+static void wg_format_from_caps_video_cinepak(struct wg_format *format, const GstCaps *caps)
+{
+    const GstStructure *structure = gst_caps_get_structure(caps, 0);
+    gint width, height, fps_n, fps_d;
+
+    if (!gst_structure_get_int(structure, "width", &width))
+    {
+        GST_WARNING("Missing \"width\" value.");
+        return;
+    }
+    if (!gst_structure_get_int(structure, "height", &height))
+    {
+        GST_WARNING("Missing \"height\" value.");
+        return;
+    }
+    if (!gst_structure_get_fraction(structure, "framerate", &fps_n, &fps_d))
+    {
+        fps_n = 0;
+        fps_d = 1;
+    }
+
+    format->major_type = WG_MAJOR_TYPE_VIDEO;
+    format->u.video.format = WG_VIDEO_FORMAT_CINEPAK;
+    format->u.video.width = width;
+    format->u.video.height = height;
+    format->u.video.fps_n = fps_n;
+    format->u.video.fps_d = fps_d;
+}
+
+void wg_format_from_caps(struct wg_format *format, const GstCaps *caps)
+{
+    const GstStructure *structure = gst_caps_get_structure(caps, 0);
+    const char *name = gst_structure_get_name(structure);
+
+    memset(format, 0, sizeof(*format));
+
+    if (!strcmp(name, "audio/x-raw"))
+    {
+        GstAudioInfo info;
+
+        if (gst_audio_info_from_caps(&info, caps))
+            wg_format_from_audio_info(format, &info);
+    }
+    else if (!strcmp(name, "video/x-raw"))
+    {
+        GstVideoInfo info;
+
+        if (gst_video_info_from_caps(&info, caps))
+            wg_format_from_video_info(format, &info);
+    }
+    else if (!strcmp(name, "audio/mpeg"))
+    {
+        wg_format_from_caps_audio_mpeg(format, caps);
+    }
+    else if (!strcmp(name, "video/x-cinepak"))
+    {
+        wg_format_from_caps_video_cinepak(format, caps);
+    }
+    else
+    {
+        gchar *str = gst_caps_to_string(caps);
+
+        GST_FIXME("Unhandled caps %s.", str);
+        g_free(str);
+    }
+}
+
+static GstAudioFormat wg_audio_format_to_gst(enum wg_audio_format format)
+{
+    switch (format)
+    {
+        case WG_AUDIO_FORMAT_U8:    return GST_AUDIO_FORMAT_U8;
+        case WG_AUDIO_FORMAT_S16LE: return GST_AUDIO_FORMAT_S16LE;
+        case WG_AUDIO_FORMAT_S24LE: return GST_AUDIO_FORMAT_S24LE;
+        case WG_AUDIO_FORMAT_S32LE: return GST_AUDIO_FORMAT_S32LE;
+        case WG_AUDIO_FORMAT_F32LE: return GST_AUDIO_FORMAT_F32LE;
+        case WG_AUDIO_FORMAT_F64LE: return GST_AUDIO_FORMAT_F64LE;
+        default: return GST_AUDIO_FORMAT_UNKNOWN;
+    }
+}
+
+static void wg_channel_mask_to_gst(GstAudioChannelPosition *positions, uint32_t mask, uint32_t channel_count)
+{
+    const uint32_t orig_mask = mask;
+    unsigned int i;
+    DWORD bit;
+
+    static const GstAudioChannelPosition position_map[] =
+    {
+        GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,
+        GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,
+        GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER,
+        GST_AUDIO_CHANNEL_POSITION_LFE1,
+        GST_AUDIO_CHANNEL_POSITION_REAR_LEFT,
+        GST_AUDIO_CHANNEL_POSITION_REAR_RIGHT,
+        GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT_OF_CENTER,
+        GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT_OF_CENTER,
+        GST_AUDIO_CHANNEL_POSITION_REAR_CENTER,
+        GST_AUDIO_CHANNEL_POSITION_SIDE_LEFT,
+        GST_AUDIO_CHANNEL_POSITION_SIDE_RIGHT,
+        GST_AUDIO_CHANNEL_POSITION_TOP_CENTER,
+        GST_AUDIO_CHANNEL_POSITION_TOP_FRONT_LEFT,
+        GST_AUDIO_CHANNEL_POSITION_TOP_FRONT_CENTER,
+        GST_AUDIO_CHANNEL_POSITION_TOP_FRONT_RIGHT,
+        GST_AUDIO_CHANNEL_POSITION_TOP_REAR_LEFT,
+        GST_AUDIO_CHANNEL_POSITION_TOP_REAR_CENTER,
+        GST_AUDIO_CHANNEL_POSITION_TOP_REAR_RIGHT,
+    };
+
+    for (i = 0; i < channel_count; ++i)
+    {
+        positions[i] = GST_AUDIO_CHANNEL_POSITION_NONE;
+        if (BitScanForward(&bit, mask))
+        {
+            if (bit < ARRAY_SIZE(position_map))
+                positions[i] = position_map[bit];
+            else
+                GST_WARNING("Invalid channel mask %#x.\n", orig_mask);
+            mask &= ~(1 << bit);
+        }
+        else
+        {
+            GST_WARNING("Incomplete channel mask %#x.\n", orig_mask);
+        }
+    }
+}
+
+static GstCaps *wg_format_to_caps_audio(const struct wg_format *format)
+{
+    GstAudioChannelPosition positions[32];
+    GstAudioFormat audio_format;
+    GstAudioInfo info;
+
+    if ((audio_format = wg_audio_format_to_gst(format->u.audio.format)) == GST_AUDIO_FORMAT_UNKNOWN)
+        return NULL;
+
+    wg_channel_mask_to_gst(positions, format->u.audio.channel_mask, format->u.audio.channels);
+    gst_audio_info_set_format(&info, audio_format, format->u.audio.rate, format->u.audio.channels, positions);
+    return gst_audio_info_to_caps(&info);
+}
+
+static GstVideoFormat wg_video_format_to_gst(enum wg_video_format format)
+{
+    switch (format)
+    {
+        case WG_VIDEO_FORMAT_BGRA:  return GST_VIDEO_FORMAT_BGRA;
+        case WG_VIDEO_FORMAT_BGRx:  return GST_VIDEO_FORMAT_BGRx;
+        case WG_VIDEO_FORMAT_BGR:   return GST_VIDEO_FORMAT_BGR;
+        case WG_VIDEO_FORMAT_RGB15: return GST_VIDEO_FORMAT_RGB15;
+        case WG_VIDEO_FORMAT_RGB16: return GST_VIDEO_FORMAT_RGB16;
+        case WG_VIDEO_FORMAT_AYUV:  return GST_VIDEO_FORMAT_AYUV;
+        case WG_VIDEO_FORMAT_I420:  return GST_VIDEO_FORMAT_I420;
+        case WG_VIDEO_FORMAT_NV12:  return GST_VIDEO_FORMAT_NV12;
+        case WG_VIDEO_FORMAT_UYVY:  return GST_VIDEO_FORMAT_UYVY;
+        case WG_VIDEO_FORMAT_YUY2:  return GST_VIDEO_FORMAT_YUY2;
+        case WG_VIDEO_FORMAT_YV12:  return GST_VIDEO_FORMAT_YV12;
+        case WG_VIDEO_FORMAT_YVYU:  return GST_VIDEO_FORMAT_YVYU;
+        default: return GST_VIDEO_FORMAT_UNKNOWN;
+    }
+}
+
+static GstCaps *wg_format_to_caps_video(const struct wg_format *format)
+{
+    GstVideoFormat video_format;
+    GstVideoInfo info;
+    unsigned int i;
+    GstCaps *caps;
+
+    if ((video_format = wg_video_format_to_gst(format->u.video.format)) == GST_VIDEO_FORMAT_UNKNOWN)
+        return NULL;
+
+    gst_video_info_set_format(&info, video_format, format->u.video.width, abs(format->u.video.height));
+    if ((caps = gst_video_info_to_caps(&info)))
+    {
+        /* Clear some fields that shouldn't prevent us from connecting. */
+        for (i = 0; i < gst_caps_get_size(caps); ++i)
+        {
+            gst_structure_remove_fields(gst_caps_get_structure(caps, i),
+                    "framerate", "pixel-aspect-ratio", "colorimetry", "chroma-site", NULL);
+        }
+    }
+    return caps;
+}
+
+GstCaps *wg_format_to_caps(const struct wg_format *format)
+{
+    switch (format->major_type)
+    {
+        case WG_MAJOR_TYPE_UNKNOWN:
+            return NULL;
+        case WG_MAJOR_TYPE_AUDIO:
+            return wg_format_to_caps_audio(format);
+        case WG_MAJOR_TYPE_VIDEO:
+            return wg_format_to_caps_video(format);
+    }
+    assert(0);
+    return NULL;
+}
+
+bool wg_format_compare(const struct wg_format *a, const struct wg_format *b)
+{
+    if (a->major_type != b->major_type)
+        return false;
+
+    switch (a->major_type)
+    {
+        case WG_MAJOR_TYPE_UNKNOWN:
+            return false;
+
+        case WG_MAJOR_TYPE_AUDIO:
+            return a->u.audio.format == b->u.audio.format
+                    && a->u.audio.channels == b->u.audio.channels
+                    && a->u.audio.rate == b->u.audio.rate;
+
+        case WG_MAJOR_TYPE_VIDEO:
+            /* Do not compare FPS. */
+            return a->u.video.format == b->u.video.format
+                    && a->u.video.width == b->u.video.width
+                    && abs(a->u.video.height) == abs(b->u.video.height);
+    }
+
+    assert(0);
+    return false;
+}
+
+static NTSTATUS wg_parser_get_stream_count(void *args)
+{
+    struct wg_parser_get_stream_count_params *params = args;
+
+    params->count = params->parser->stream_count;
+    return S_OK;
+}
+
+static NTSTATUS wg_parser_get_stream(void *args)
+{
+    struct wg_parser_get_stream_params *params = args;
+
+    params->stream = params->parser->streams[params->index];
+    return S_OK;
+}
+
+static NTSTATUS wg_parser_get_next_read_offset(void *args)
+{
+    struct wg_parser_get_next_read_offset_params *params = args;
+    struct wg_parser *parser = params->parser;
+
+    pthread_mutex_lock(&parser->mutex);
+
+    while (parser->sink_connected && (!parser->read_request.size || parser->read_request.done))
+        pthread_cond_wait(&parser->read_cond, &parser->mutex);
+
+    if (!parser->sink_connected)
+    {
+        pthread_mutex_unlock(&parser->mutex);
+        return VFW_E_WRONG_STATE;
+    }
+
+    params->offset = parser->read_request.offset;
+    params->size = parser->read_request.size;
+
+    pthread_mutex_unlock(&parser->mutex);
+    return S_OK;
+}
+
+static GstFlowReturn wg_read_result_to_gst(enum wg_read_result result)
+{
+    switch (result)
+    {
+    case WG_READ_SUCCESS: return GST_FLOW_OK;
+    case WG_READ_FAILURE: return GST_FLOW_ERROR;
+    case WG_READ_FLUSHING: return GST_FLOW_FLUSHING;
+    case WG_READ_EOS: return GST_FLOW_EOS;
+    }
+    return GST_FLOW_ERROR;
+}
+
+static NTSTATUS wg_parser_push_data(void *args)
+{
+    const struct wg_parser_push_data_params *params = args;
+    struct wg_parser *parser = params->parser;
+    enum wg_read_result result = params->result;
+    const void *data = params->data;
+    uint32_t size = params->size;
+
+    pthread_mutex_lock(&parser->mutex);
+
+    if (result != WG_READ_SUCCESS)
+    {
+            parser->read_request.ret = wg_read_result_to_gst(result);
+    }
+    else if (data)
+    {
+        if (size)
+        {
+            GstMapInfo map_info;
+
+            /* Note that we don't allocate the buffer until we have a size.
+             * midiparse passes a NULL buffer and a size of UINT_MAX, in an
+             * apparent attempt to read the whole input stream at once. */
+            if (!parser->read_request.buffer)
+                parser->read_request.buffer = gst_buffer_new_and_alloc(size);
+            gst_buffer_map(parser->read_request.buffer, &map_info, GST_MAP_WRITE);
+            memcpy(map_info.data, data, size);
+            gst_buffer_unmap(parser->read_request.buffer, &map_info);
+            parser->read_request.ret = GST_FLOW_OK;
+        }
+        else
+        {
+            parser->read_request.ret = GST_FLOW_EOS;
+        }
+    }
+    else
+    {
+        parser->read_request.ret = GST_FLOW_ERROR;
+    }
+    parser->read_request.done = true;
+    parser->read_request.size = 0;
+
+    pthread_mutex_unlock(&parser->mutex);
+    pthread_cond_signal(&parser->read_done_cond);
+
+    return S_OK;
+}
+
+static NTSTATUS wg_parser_stream_get_preferred_format(void *args)
+{
+    const struct wg_parser_stream_get_preferred_format_params *params = args;
+
+    if (params->stream->has_caps)
+        *params->format = params->stream->preferred_format;
+
+    return S_OK;
+}
+
+static NTSTATUS wg_parser_stream_enable(void *args)
+{
+    const struct wg_parser_stream_enable_params *params = args;
+    struct wg_parser_stream *stream = params->stream;
+    const struct wg_format *format = params->format;
+    const struct wg_rect *aperture = params->aperture;
+
+    if (!stream->parser->seekable)
+        return S_OK;
+
+    stream->current_format = *format;
+    stream->enabled = true;
+
+    if (format->major_type == WG_MAJOR_TYPE_VIDEO)
+    {
+        if (params->flags & STREAM_ENABLE_FLAG_FLIP_RGB)
+        {
+            bool flip = (format->u.video.height < 0);
+
+            switch (format->u.video.format)
+            {
+                case WG_VIDEO_FORMAT_BGRA:
+                case WG_VIDEO_FORMAT_BGRx:
+                case WG_VIDEO_FORMAT_BGR:
+                case WG_VIDEO_FORMAT_RGB15:
+                case WG_VIDEO_FORMAT_RGB16:
+                    flip = !flip;
+                    break;
+
+                case WG_VIDEO_FORMAT_AYUV:
+                case WG_VIDEO_FORMAT_I420:
+                case WG_VIDEO_FORMAT_NV12:
+                case WG_VIDEO_FORMAT_UYVY:
+                case WG_VIDEO_FORMAT_YUY2:
+                case WG_VIDEO_FORMAT_YV12:
+                case WG_VIDEO_FORMAT_YVYU:
+                case WG_VIDEO_FORMAT_UNKNOWN:
+                case WG_VIDEO_FORMAT_CINEPAK:
+                    break;
+            }
+
+            gst_util_set_object_arg(G_OBJECT(stream->flip), "method", flip ? "vertical-flip" : "none");
+        }
+
+        if (aperture)
+        {
+            if (!stream->box && (stream->aperture.left || stream->aperture.top ||
+                (stream->aperture.right && stream->aperture.right != stream->current_format.u.video.width) ||
+                (stream->aperture.bottom && stream->aperture.bottom != stream->current_format.u.video.height)))
+            {
+                fprintf(stderr, "winegstreamer: failed to create videobox, are %u-bit GStreamer \"good\" plugins installed?\n",
+                    8 * (int)sizeof(void *));
+                return E_FAIL;
+            }
+
+            if (aperture->left)
+                g_object_set(G_OBJECT(stream->box), "left", -aperture->left, NULL);
+            if (aperture->top)
+                g_object_set(G_OBJECT(stream->box), "top", -aperture->top, NULL);
+            if (aperture->right)
+                g_object_set(G_OBJECT(stream->box), "right", aperture->right - format->u.video.width, NULL);
+            if (aperture->bottom)
+                g_object_set(G_OBJECT(stream->box), "bottom", aperture->bottom - format->u.video.height, NULL);
+        }
+    }
+
+    gst_pad_push_event(stream->my_sink, gst_event_new_reconfigure());
+    return S_OK;
+}
+
+static NTSTATUS wg_parser_stream_disable(void *args)
+{
+    struct wg_parser_stream *stream = args;
+
+    stream->enabled = false;
+    return S_OK;
+}
+
+static NTSTATUS wg_parser_stream_get_buffer(void *args)
+{
+    const struct wg_parser_stream_get_buffer_params *params = args;
+    struct wg_parser_buffer *wg_buffer = params->buffer;
+    struct wg_parser_stream *stream = params->stream;
+    struct wg_parser *parser = stream->parser;
+    GstBuffer *buffer;
+
+    pthread_mutex_lock(&parser->mutex);
+
+    while (!stream->eos && !stream->buffer)
+        pthread_cond_wait(&stream->event_cond, &parser->mutex);
+
+    /* Note that we can both have a buffer and stream->eos, in which case we
+     * must return the buffer. */
+    if ((buffer = stream->buffer))
+    {
+        /* FIXME: Should we use gst_segment_to_stream_time_full()? Under what
+         * circumstances is the stream time not equal to the buffer PTS? Note
+         * that this will need modification to wg_parser_stream_notify_qos() as
+         * well. */
+
+        if ((wg_buffer->has_pts = GST_BUFFER_PTS_IS_VALID(buffer)))
+            wg_buffer->pts = GST_BUFFER_PTS(buffer) / 100;
+        if ((wg_buffer->has_duration = GST_BUFFER_DURATION_IS_VALID(buffer)))
+            wg_buffer->duration = GST_BUFFER_DURATION(buffer) / 100;
+        wg_buffer->discontinuity = GST_BUFFER_FLAG_IS_SET(buffer, GST_BUFFER_FLAG_DISCONT);
+        wg_buffer->preroll = GST_BUFFER_FLAG_IS_SET(buffer, GST_BUFFER_FLAG_LIVE);
+        wg_buffer->delta = GST_BUFFER_FLAG_IS_SET(buffer, GST_BUFFER_FLAG_DELTA_UNIT);
+        wg_buffer->size = gst_buffer_get_size(buffer);
+
+        pthread_mutex_unlock(&parser->mutex);
+        return S_OK;
+    }
+
+    pthread_mutex_unlock(&parser->mutex);
+    return S_FALSE;
+}
+
+static NTSTATUS wg_parser_stream_copy_buffer(void *args)
+{
+    const struct wg_parser_stream_copy_buffer_params *params = args;
+    struct wg_parser_stream *stream = params->stream;
+    struct wg_parser *parser = stream->parser;
+    uint32_t offset = params->offset;
+    uint32_t size = params->size;
+
+    pthread_mutex_lock(&parser->mutex);
+
+    if (!stream->buffer)
+    {
+        pthread_mutex_unlock(&parser->mutex);
+        return VFW_E_WRONG_STATE;
+    }
+
+    assert(offset < stream->map_info.size);
+    assert(offset + size <= stream->map_info.size);
+    memcpy(params->data, stream->map_info.data + offset, size);
+
+    pthread_mutex_unlock(&parser->mutex);
+    return S_OK;
+}
+
+static NTSTATUS wg_parser_stream_release_buffer(void *args)
+{
+    struct wg_parser_stream *stream = args;
+    struct wg_parser *parser = stream->parser;
+
+    pthread_mutex_lock(&parser->mutex);
+
+    assert(stream->buffer);
+
+    gst_buffer_unmap(stream->buffer, &stream->map_info);
+    gst_buffer_unref(stream->buffer);
+    stream->buffer = NULL;
+
+    pthread_mutex_unlock(&parser->mutex);
+    pthread_cond_signal(&stream->event_empty_cond);
+
+    return S_OK;
+}
+
+static NTSTATUS wg_parser_stream_get_duration(void *args)
+{
+    struct wg_parser_stream_get_duration_params *params = args;
+
+    params->duration = params->stream->duration;
+    return S_OK;
+}
+
+static NTSTATUS wg_parser_stream_get_language(void *args)
+{
+    struct wg_parser_stream_get_language_params *params = args;
+    if (params->stream->language_code)
+        lstrcpynA(params->buffer, params->stream->language_code, params->size);
+    return params->stream->language_code ? S_OK : E_FAIL;
+}
+
+static NTSTATUS wg_parser_stream_seek(void *args)
+{
+    GstSeekType start_type = GST_SEEK_TYPE_SET, stop_type = GST_SEEK_TYPE_SET;
+    const struct wg_parser_stream_seek_params *params = args;
+    DWORD start_flags = params->start_flags;
+    DWORD stop_flags = params->stop_flags;
+    GstSeekFlags flags = 0;
+
+    if (!params->stream->parser->seekable)
+        return E_FAIL;
+
+    if (start_flags & AM_SEEKING_SeekToKeyFrame)
+        flags |= GST_SEEK_FLAG_KEY_UNIT;
+    if (start_flags & AM_SEEKING_Segment)
+        flags |= GST_SEEK_FLAG_SEGMENT;
+    if (!(start_flags & AM_SEEKING_NoFlush))
+        flags |= GST_SEEK_FLAG_FLUSH;
+
+    if ((start_flags & AM_SEEKING_PositioningBitsMask) == AM_SEEKING_NoPositioning)
+        start_type = GST_SEEK_TYPE_NONE;
+    if ((stop_flags & AM_SEEKING_PositioningBitsMask) == AM_SEEKING_NoPositioning)
+        stop_type = GST_SEEK_TYPE_NONE;
+
+    if (!gst_pad_push_event(params->stream->my_sink, gst_event_new_seek(params->rate, GST_FORMAT_TIME,
+            flags, start_type, params->start_pos * 100, stop_type, params->stop_pos * 100)))
+        GST_ERROR("Failed to seek.\n");
+
+    return S_OK;
+}
+
+static NTSTATUS wg_parser_stream_drain(void *args)
+{
+    struct wg_parser_stream *stream = args;
+    struct wg_parser *parser = stream->parser;
+    bool ret;
+
+    pthread_mutex_lock(&parser->mutex);
+
+    /* Sanity check making sure caller didn't try to drain an already-EOS or unselected stream.
+       There's no reason for a caller to do this, but it could be an accident in which case we
+       should indicate that the stream is drained instead of locking-up. */
+    if (!stream->enabled || stream->eos)
+    {
+        pthread_mutex_unlock(&parser->mutex);
+        return true;
+    }
+
+    parser->draining = true;
+    pthread_cond_signal(&parser->read_done_cond);
+
+    /* We must wait for either an event to occur or the drain to complete.
+       Since drains are blocking, we assign this responsibility to the thread
+       pulling data, as the pipeline will not need to pull more data until
+       the drain completes.  If one input buffer yields more than one output
+       buffer, the chain callback blocks on the wg_parser_stream_buffer_release
+       for the first buffer, which would never be called if the drain function
+       hadn't completed. */
+    while (parser->draining && !stream->buffer)
+        pthread_cond_wait(&stream->event_cond, &parser->mutex);
+
+    ret = !stream->buffer;
+    parser->draining = false;
+
+    pthread_mutex_unlock(&stream->parser->mutex);
+
+    return ret;
+}
+
+static NTSTATUS wg_parser_stream_notify_qos(void *args)
+{
+    const struct wg_parser_stream_notify_qos_params *params = args;
+    struct wg_parser_stream *stream = params->stream;
+    GstClockTime stream_time;
+    GstEvent *event;
+
+    /* We return timestamps in stream time, i.e. relative to the start of the
+     * file (or other medium), but gst_event_new_qos() expects the timestamp in
+     * running time. */
+    stream_time = gst_segment_to_running_time(&stream->segment, GST_FORMAT_TIME, params->timestamp * 100);
+    if (stream_time == -1)
+    {
+        /* This can happen legitimately if the sample falls outside of the
+         * segment bounds. GStreamer elements shouldn't present the sample in
+         * that case, but DirectShow doesn't care. */
+        GST_LOG("Ignoring QoS event.\n");
+        return S_OK;
+    }
+
+    if (!(event = gst_event_new_qos(params->underflow ? GST_QOS_TYPE_UNDERFLOW : GST_QOS_TYPE_OVERFLOW,
+            params->proportion, params->diff * 100, stream_time)))
+        GST_ERROR("Failed to create QOS event.\n");
+    gst_pad_push_event(stream->my_sink, event);
+
+    return S_OK;
+}
+
+static GstAutoplugSelectResult autoplug_select_cb(GstElement *bin, GstPad *pad,
+        GstCaps *caps, GstElementFactory *fact, gpointer user)
+{
+    const char *name = gst_element_factory_get_longname(fact);
+
+    GST_INFO("Using \"%s\".", name);
+
+    if (strstr(name, "Player protection"))
+    {
+        GST_WARNING("Blacklisted a/52 decoder because it only works in Totem.");
+        return GST_AUTOPLUG_SELECT_SKIP;
+    }
+    if (!strcmp(name, "Fluendo Hardware Accelerated Video Decoder"))
+    {
+        GST_WARNING("Disabled video acceleration since it breaks in wine.");
+        return GST_AUTOPLUG_SELECT_SKIP;
+    }
+    return GST_AUTOPLUG_SELECT_TRY;
+}
+
+static gint find_videoconv_cb(gconstpointer a, gconstpointer b)
+{
+    const GValue *val_a = a, *val_b = b;
+    GstElementFactory *factory_a = g_value_get_object(val_a), *factory_b = g_value_get_object(val_b);
+    const char *name_a = gst_element_factory_get_longname(factory_a), *name_b = gst_element_factory_get_longname(factory_b);
+
+    if (!strcmp(name_a, "Proton video converter"))
+        return -1;
+    if (!strcmp(name_b, "Proton video converter"))
+        return 1;
+    return 0;
+}
+
+static GValueArray *autoplug_sort_cb(GstElement *bin, GstPad *pad,
+        GstCaps *caps, GValueArray *factories, gpointer user)
+{
+    struct wg_parser *parser = user;
+    GValueArray *ret = g_value_array_copy(factories);
+
+    if (!parser->use_mediaconv)
+        return NULL;
+
+    GST_DEBUG("parser %p.", parser);
+
+    g_value_array_sort(ret, find_videoconv_cb);
+    return ret;
+}
+
+static void no_more_pads_cb(GstElement *element, gpointer user)
+{
+    struct wg_parser *parser = user;
+
+    GST_DEBUG("parser %p.", parser);
+
+    pthread_mutex_lock(&parser->mutex);
+    parser->no_more_pads = true;
+    pthread_mutex_unlock(&parser->mutex);
+    pthread_cond_signal(&parser->init_cond);
+}
+
+static gboolean sink_event_cb(GstPad *pad, GstObject *parent, GstEvent *event)
+{
+    struct wg_parser_stream *stream = gst_pad_get_element_private(pad);
+    struct wg_parser *parser = stream->parser;
+
+    GST_LOG("stream %p, type \"%s\".", stream, GST_EVENT_TYPE_NAME(event));
+
+    switch (event->type)
+    {
+        case GST_EVENT_SEGMENT:
+            if (stream->enabled)
+            {
+                const GstSegment *segment;
+
+                gst_event_parse_segment(event, &segment);
+
+                if (segment->format != GST_FORMAT_TIME)
+                {
+                    GST_FIXME("Unhandled format \"%s\".", gst_format_get_name(segment->format));
+                    break;
+                }
+
+                gst_segment_copy_into(segment, &stream->segment);
+            }
+            break;
+
+        case GST_EVENT_EOS:
+            pthread_mutex_lock(&parser->mutex);
+            stream->eos = true;
+            pthread_mutex_unlock(&parser->mutex);
+            if (stream->enabled)
+                pthread_cond_signal(&stream->event_cond);
+            else
+                pthread_cond_signal(&parser->init_cond);
+            break;
+
+        case GST_EVENT_FLUSH_START:
+            if (stream->enabled)
+            {
+                pthread_mutex_lock(&parser->mutex);
+
+                stream->flushing = true;
+                pthread_cond_signal(&stream->event_empty_cond);
+
+                if (stream->buffer)
+                {
+                    gst_buffer_unmap(stream->buffer, &stream->map_info);
+                    gst_buffer_unref(stream->buffer);
+                    stream->buffer = NULL;
+                }
+
+                pthread_mutex_unlock(&parser->mutex);
+            }
+            break;
+
+        case GST_EVENT_FLUSH_STOP:
+        {
+            gboolean reset_time;
+
+            gst_event_parse_flush_stop(event, &reset_time);
+
+            if (reset_time)
+                gst_segment_init(&stream->segment, GST_FORMAT_UNDEFINED);
+
+            pthread_mutex_lock(&parser->mutex);
+
+            stream->eos = false;
+            if (stream->enabled)
+                stream->flushing = false;
+
+            pthread_mutex_unlock(&parser->mutex);
+            break;
+        }
+
+        case GST_EVENT_CAPS:
+        {
+            GstCaps *caps;
+
+            gst_event_parse_caps(event, &caps);
+            pthread_mutex_lock(&parser->mutex);
+            wg_format_from_caps(&stream->preferred_format, caps);
+            stream->has_caps = true;
+            pthread_mutex_unlock(&parser->mutex);
+            pthread_cond_signal(&parser->init_cond);
+            break;
+        }
+
+        default:
+            GST_WARNING("Ignoring \"%s\" event.", GST_EVENT_TYPE_NAME(event));
+    }
+    gst_event_unref(event);
+    return TRUE;
+}
+
+static GstFlowReturn sink_chain_cb(GstPad *pad, GstObject *parent, GstBuffer *buffer)
+{
+    struct wg_parser_stream *stream = gst_pad_get_element_private(pad);
+    struct wg_parser *parser = stream->parser;
+
+    GST_LOG("stream %p, buffer %p.", stream, buffer);
+
+    if (!stream->enabled)
+    {
+        gst_buffer_unref(buffer);
+        return GST_FLOW_OK;
+    }
+
+    /* Allow this buffer to be flushed by GStreamer. We are effectively
+     * implementing a queue object here. */
+
+    pthread_mutex_lock(&parser->mutex);
+
+    while (!stream->flushing && stream->buffer)
+        pthread_cond_wait(&stream->event_empty_cond, &parser->mutex);
+    if (stream->flushing)
+    {
+        pthread_mutex_unlock(&parser->mutex);
+        GST_DEBUG("Stream is flushing; discarding buffer.");
+        gst_buffer_unref(buffer);
+        return GST_FLOW_FLUSHING;
+    }
+
+    if (!gst_buffer_map(buffer, &stream->map_info, GST_MAP_READ))
+    {
+        pthread_mutex_unlock(&parser->mutex);
+        GST_ERROR("Failed to map buffer.\n");
+        gst_buffer_unref(buffer);
+        return GST_FLOW_ERROR;
+    }
+
+    stream->buffer = buffer;
+
+    pthread_mutex_unlock(&parser->mutex);
+    pthread_cond_signal(&stream->event_cond);
+
+    /* The chain callback is given a reference to the buffer. Transfer that
+     * reference to the stream object, which will release it in
+     * wg_parser_stream_release_buffer(). */
+
+    GST_LOG("Buffer queued.");
+    return GST_FLOW_OK;
+}
+
+static gboolean sink_query_cb(GstPad *pad, GstObject *parent, GstQuery *query)
+{
+    struct wg_parser_stream *stream = gst_pad_get_element_private(pad);
+
+    GST_LOG("stream %p, type \"%s\".", stream, gst_query_type_get_name(query->type));
+
+    switch (query->type)
+    {
+        case GST_QUERY_CAPS:
+        {
+            GstCaps *caps, *filter, *temp;
+            gchar *str;
+
+            gst_query_parse_caps(query, &filter);
+
+            if (stream->enabled)
+                caps = wg_format_to_caps(&stream->current_format);
+            else
+                caps = gst_caps_new_any();
+            if (!caps)
+                return FALSE;
+
+            str = gst_caps_to_string(caps);
+            GST_LOG("Stream caps are \"%s\".", str);
+            g_free(str);
+
+            if (filter)
+            {
+                temp = gst_caps_intersect(caps, filter);
+                gst_caps_unref(caps);
+                caps = temp;
+            }
+
+            gst_query_set_caps_result(query, caps);
+            gst_caps_unref(caps);
+            return TRUE;
+        }
+
+        case GST_QUERY_ACCEPT_CAPS:
+        {
+            struct wg_format format;
+            gboolean ret = TRUE;
+            GstCaps *caps;
+
+            if (!stream->enabled)
+            {
+                gst_query_set_accept_caps_result(query, TRUE);
+                return TRUE;
+            }
+
+            gst_query_parse_accept_caps(query, &caps);
+            wg_format_from_caps(&format, caps);
+            ret = wg_format_compare(&format, &stream->current_format);
+            if (!ret && gst_debug_category_get_threshold(GST_CAT_DEFAULT) >= GST_LEVEL_WARNING)
+            {
+                gchar *str = gst_caps_to_string(caps);
+                GST_WARNING("Rejecting caps \"%s\".", str);
+                g_free(str);
+            }
+            gst_query_set_accept_caps_result(query, ret);
+            return TRUE;
+        }
+
+        default:
+            return gst_pad_query_default (pad, parent, query);
+    }
+}
+
+GstElement *create_element(const char *name, const char *plugin_set)
+{
+    GstElement *element;
+
+    if (!(element = gst_element_factory_make(name, NULL)))
+        fprintf(stderr, "winegstreamer: failed to create %s, are %u-bit GStreamer \"%s\" plugins installed?\n",
+                name, 8 * (unsigned int)sizeof(void *), plugin_set);
+    return element;
+}
+
+static struct wg_parser_stream *create_stream(struct wg_parser *parser)
+{
+    struct wg_parser_stream *stream, **new_array;
+    unsigned int i;
+    char pad_name[19];
+
+    for (i = 0; i < parser->expected_stream_count; i++)
+    {
+        if (!parser->streams[i]->parser)
+        {
+            stream = parser->streams[i];
+            break;
+        }
+    }
+
+    if (i == parser->expected_stream_count)
+    {
+        if (!(new_array = realloc(parser->streams, (parser->stream_count + 1) * sizeof(*parser->streams))))
+            return NULL;
+        parser->streams = new_array;
+
+        if (!(stream = calloc(1, sizeof(*stream))))
+            return NULL;
+    }
+
+    gst_segment_init(&stream->segment, GST_FORMAT_UNDEFINED);
+
+    stream->parser = parser;
+    pthread_cond_init(&stream->event_cond, NULL);
+    pthread_cond_init(&stream->event_empty_cond, NULL);
+
+    sprintf(pad_name, "wine_sink_%u", parser->stream_count);
+    stream->my_sink = gst_pad_new(pad_name, GST_PAD_SINK);
+    gst_pad_set_element_private(stream->my_sink, stream);
+    gst_pad_set_chain_function(stream->my_sink, sink_chain_cb);
+    gst_pad_set_event_function(stream->my_sink, sink_event_cb);
+    gst_pad_set_query_function(stream->my_sink, sink_query_cb);
+
+    parser->streams[parser->stream_count++] = stream;
+    return stream;
+}
+
+static void free_stream(struct wg_parser_stream *stream)
+{
+    if (stream->their_src)
+    {
+        if (stream->post_sink)
+        {
+            gst_pad_unlink(stream->their_src, stream->post_sink);
+            gst_pad_unlink(stream->post_src, stream->my_sink);
+            gst_object_unref(stream->post_src);
+            gst_object_unref(stream->post_sink);
+            stream->post_src = stream->post_sink = NULL;
+        }
+        else
+            gst_pad_unlink(stream->their_src, stream->my_sink);
+        gst_object_unref(stream->their_src);
+    }
+    gst_object_unref(stream->my_sink);
+
+    pthread_cond_destroy(&stream->event_cond);
+    pthread_cond_destroy(&stream->event_empty_cond);
+
+    if (stream->language_code)
+        g_free(stream->language_code);
+
+    free(stream);
+}
+
+static void pad_added_cb(GstElement *element, GstPad *pad, gpointer user)
+{
+    struct wg_parser *parser = user;
+    struct wg_parser_stream *stream;
+    const char *name;
+    GstCaps *caps;
+    int ret;
+
+    GST_LOG("parser %p, element %p, pad %p.", parser, element, pad);
+
+    if (gst_pad_is_linked(pad))
+        return;
+
+    caps = gst_pad_query_caps(pad, NULL);
+    name = gst_structure_get_name(gst_caps_get_structure(caps, 0));
+
+    if (!(stream = create_stream(parser)))
+        goto out;
+
+    if (!strcmp(name, "video/x-raw"))
+    {
+        GstElement *capssetter, *deinterlace, *vconv, *flip, *box, *vconv2;
+
+        /* Hack?: Flatten down the colorimetry to default values, without
+         * actually modifying the video at all.
+         *
+         * We want to do color matrix conversions when converting from YUV to
+         * RGB or vice versa. We do *not* want to do color matrix conversions
+         * when converting YUV <-> YUV or RGB <-> RGB, because these are slow
+         * (it essentially means always using the slow path, never going through
+         * liborc). However, we have two videoconvert elements, and it's
+         * basically impossible to know what conversions each is going to do
+         * until caps are negotiated (without depending on some implementation
+         * details, and even then it'snot exactly trivial). And setting
+         * matrix-mode after caps are negotiated has no effect.
+         *
+         * Nor can we just retain colorimetry information the way we retain
+         * other caps values, because videoconvert automatically clears it if
+         * not doing passthrough. I think that this would only happen if we have
+         * to do a double conversion, but that is possible. Not likely, but I
+         * don't want to have to be the one to find out that there's still a
+         * game broken.
+         *
+         * [Note that we'd actually kind of like to retain colorimetry
+         * information, just in case it does ever become relevant to pass that
+         * on to the next DirectShow filter. Hence I think the correct solution
+         * for upstream is to get videoconvert to Not Do That.]
+         *
+         * So as a fallback solution, we force an identity transformation of
+         * the caps to those with a "default" color matrix—i.e. transform the
+         * caps, but not the data. We do this by *pre*pending a capssetter to
+         * the front of the chain, and we remove the matrix-mode setting for the
+         * videoconvert elements.
+         */
+        if (!(capssetter = gst_element_factory_make("capssetter", NULL)))
+        {
+            GST_ERROR("Failed to create capssetter, are %u-bit GStreamer \"good\" plugins installed?\n",
+                    8 * (int)sizeof(void *));
+            goto out;
+        }
+        gst_util_set_object_arg(G_OBJECT(capssetter), "join", "true");
+        /* Actually, this is invalid, but it causes videoconvert to use default
+         * colorimetry as a result. Yes, this is depending on undocumented
+         * implementation details. It's a hack.
+         *
+         * Sadly there doesn't seem to be a way to get capssetter to clear
+         * certain fields while leaving others untouched. */
+        gst_util_set_object_arg(G_OBJECT(capssetter), "caps", "video/x-raw,colorimetry=0:0:0:0");
+
+        /* DirectShow can express interlaced video, but downstream filters can't
+         * necessarily consume it. In particular, the video renderer can't. */
+        if (!(deinterlace = create_element("deinterlace", "good")))
+            goto out;
+
+        /* decodebin considers many YUV formats to be "raw", but some quartz
+         * filters can't handle those. Also, videoflip can't handle all "raw"
+         * formats either. Add a videoconvert to swap color spaces. */
+        if (!(vconv = create_element("videoconvert", "base")))
+            goto out;
+
+        /* Let GStreamer choose a default number of threads. */
+        gst_util_set_object_arg(G_OBJECT(vconv), "n-threads", "0");
+
+        /* GStreamer outputs RGB video top-down, but DirectShow expects bottom-up. */
+        if (!(flip = create_element("videoflip", "good")))
+            goto out;
+
+        box = gst_element_factory_make("videobox", NULL);
+
+        /* videoflip does not support 15 and 16-bit RGB so add a second videoconvert
+         * to do the final conversion. */
+        if (!(vconv2 = create_element("videoconvert", "base")))
+            goto out;
+
+        /* Let GStreamer choose a default number of threads. */
+        gst_util_set_object_arg(G_OBJECT(vconv2), "n-threads", "0");
+
+        if (!parser->seekable)
+        {
+            if (!box && (stream->aperture.left || stream->aperture.top ||
+                (stream->aperture.right && stream->aperture.right != stream->current_format.u.video.width) ||
+                (stream->aperture.bottom && stream->aperture.bottom != stream->current_format.u.video.height)))
+            {
+                fprintf(stderr, "winegstreamer: failed to create videobox, are %u-bit GStreamer \"good\" plugins installed?\n",
+                    8 * (int)sizeof(void *));
+                goto out;
+            }
+            if (stream->aperture.left)
+                g_object_set(G_OBJECT(box), "left", -stream->aperture.left, NULL);
+            if (stream->aperture.bottom)
+                g_object_set(G_OBJECT(box), "top", -stream->aperture.top, NULL);
+            if (stream->aperture.right)
+                g_object_set(G_OBJECT(box), "right", stream->aperture.right - stream->current_format.u.video.width, NULL);
+            if (stream->aperture.bottom)
+                g_object_set(G_OBJECT(box), "bottom", stream->aperture.bottom - stream->current_format.u.video.height, NULL);
+        }
+
+        /* The bin takes ownership of these elements. */
+        gst_bin_add(GST_BIN(parser->container), capssetter);
+        gst_element_sync_state_with_parent(capssetter);
+        gst_bin_add(GST_BIN(parser->container), deinterlace);
+        gst_element_sync_state_with_parent(deinterlace);
+        gst_bin_add(GST_BIN(parser->container), vconv);
+        gst_element_sync_state_with_parent(vconv);
+        gst_bin_add(GST_BIN(parser->container), flip);
+        gst_element_sync_state_with_parent(flip);
+        if (box)
+        {
+            gst_bin_add(GST_BIN(parser->container), box);
+            gst_element_sync_state_with_parent(box);
+        }
+        gst_bin_add(GST_BIN(parser->container), vconv2);
+        gst_element_sync_state_with_parent(vconv2);
+
+        gst_element_link(capssetter, deinterlace);
+        gst_element_link(deinterlace, vconv);
+        gst_element_link(vconv, flip);
+        if (box)
+        {
+            gst_element_link(flip, box);
+            gst_element_link(box, vconv2);
+        }
+        else
+        {
+            gst_element_link(flip, vconv2);
+        }
+
+        stream->post_sink = gst_element_get_static_pad(capssetter, "sink");
+        stream->post_src = gst_element_get_static_pad(vconv2, "src");
+        stream->flip = flip;
+        stream->box = box;
+    }
+    else if (!strcmp(name, "audio/x-raw"))
+    {
+        GstElement *convert;
+
+        /* Currently our dsound can't handle 64-bit formats or all
+         * surround-sound configurations. Native dsound can't always handle
+         * 64-bit formats either. Add an audioconvert to allow changing bit
+         * depth and channel count. */
+        if (!(convert = create_element("audioconvert", "base")))
+            goto out;
+
+        gst_bin_add(GST_BIN(parser->container), convert);
+        gst_element_sync_state_with_parent(convert);
+
+        stream->post_sink = gst_element_get_static_pad(convert, "sink");
+        stream->post_src = gst_element_get_static_pad(convert, "src");
+    }
+
+    if (stream->post_sink)
+    {
+        if ((ret = gst_pad_link(pad, stream->post_sink)) < 0)
+        {
+            GST_ERROR("Failed to link decodebin source pad to post-processing elements, error %s.",
+                    gst_pad_link_get_name(ret));
+            gst_object_unref(stream->post_sink);
+            stream->post_sink = NULL;
+            goto out;
+        }
+
+        if ((ret = gst_pad_link(stream->post_src, stream->my_sink)) < 0)
+        {
+            GST_ERROR("Failed to link post-processing elements to our sink pad, error %s.",
+                    gst_pad_link_get_name(ret));
+            gst_object_unref(stream->post_src);
+            stream->post_src = NULL;
+            gst_object_unref(stream->post_sink);
+            stream->post_sink = NULL;
+            goto out;
+        }
+    }
+    else if ((ret = gst_pad_link(pad, stream->my_sink)) < 0)
+    {
+        GST_ERROR("Failed to link decodebin source pad to our sink pad, error %s.",
+                gst_pad_link_get_name(ret));
+        goto out;
+    }
+
+    gst_pad_set_active(stream->my_sink, 1);
+    gst_object_ref(stream->their_src = pad);
+out:
+    gst_caps_unref(caps);
+}
+
+static void pad_removed_cb(GstElement *element, GstPad *pad, gpointer user)
+{
+    struct wg_parser *parser = user;
+    unsigned int i;
+    char *name;
+
+    GST_LOG("parser %p, element %p, pad %p.", parser, element, pad);
+
+    for (i = 0; i < parser->stream_count; ++i)
+    {
+        struct wg_parser_stream *stream = parser->streams[i];
+
+        if (stream->their_src == pad)
+        {
+            if (stream->post_sink)
+                gst_pad_unlink(stream->their_src, stream->post_sink);
+            else
+                gst_pad_unlink(stream->their_src, stream->my_sink);
+            gst_object_unref(stream->their_src);
+            stream->their_src = NULL;
+            return;
+        }
+    }
+
+    name = gst_pad_get_name(pad);
+    GST_WARNING("No pin matching pad \"%s\" found.", name);
+    g_free(name);
+}
+
+static GstFlowReturn src_getrange_cb(GstPad *pad, GstObject *parent,
+        guint64 offset, guint size, GstBuffer **buffer)
+{
+    struct wg_parser *parser = gst_pad_get_element_private(pad);
+    GstFlowReturn ret;
+    unsigned int i;
+
+    GST_LOG("pad %p, offset %" G_GINT64_MODIFIER "u, size %u, buffer %p.", pad, offset, size, *buffer);
+
+    if (offset == GST_BUFFER_OFFSET_NONE)
+        offset = parser->next_pull_offset;
+    parser->next_pull_offset = offset + size;
+
+    if (!size)
+    {
+        /* asfreader occasionally asks for zero bytes. gst_buffer_map() will
+         * return NULL in this case. Avoid confusing the read thread by asking
+         * it for zero bytes. */
+        if (!*buffer)
+            *buffer = gst_buffer_new_and_alloc(0);
+        gst_buffer_set_size(*buffer, 0);
+        GST_LOG("Returning empty buffer.");
+        return GST_FLOW_OK;
+    }
+
+    pthread_mutex_lock(&parser->mutex);
+
+    if (parser->draining)
+    {
+        gst_pad_peer_query(parser->my_src, gst_query_new_drain());
+        parser->draining = false;
+        for (i = 0; i < parser->stream_count; i++)
+            pthread_cond_signal(&parser->streams[i]->event_cond);
+    }
+
+    assert(!parser->read_request.size);
+    parser->read_request.buffer = *buffer;
+    parser->read_request.offset = offset;
+    parser->read_request.size = size;
+    parser->read_request.done = false;
+    pthread_cond_signal(&parser->read_cond);
+
+    /* Note that we don't unblock this wait on GST_EVENT_FLUSH_START. We expect
+     * the upstream pin to flush if necessary. We should never be blocked on
+     * read_thread() not running. */
+
+    while (!parser->read_request.done)
+    {
+        pthread_cond_wait(&parser->read_done_cond, &parser->mutex);
+        if (parser->draining)
+        {
+            gst_pad_peer_query(parser->my_src, gst_query_new_drain());
+            parser->draining = false;
+            for (i = 0; i < parser->stream_count; i++)
+                pthread_cond_signal(&parser->streams[i]->event_cond);
+        }
+    }
+
+    *buffer = parser->read_request.buffer;
+    ret = parser->read_request.ret;
+
+    pthread_mutex_unlock(&parser->mutex);
+
+    GST_LOG("Request returned %s.", gst_flow_get_name(ret));
+
+    return ret;
+}
+
+static gboolean src_query_cb(GstPad *pad, GstObject *parent, GstQuery *query)
+{
+    struct wg_parser *parser = gst_pad_get_element_private(pad);
+    GstFormat format;
+
+    GST_LOG("parser %p, type %s.", parser, GST_QUERY_TYPE_NAME(query));
+
+    switch (GST_QUERY_TYPE(query))
+    {
+        case GST_QUERY_DURATION:
+            gst_query_parse_duration(query, &format, NULL);
+            if (format == GST_FORMAT_PERCENT)
+            {
+                gst_query_set_duration(query, GST_FORMAT_PERCENT, GST_FORMAT_PERCENT_MAX);
+                return TRUE;
+            }
+            else if (format == GST_FORMAT_BYTES && parser->seekable)
+            {
+                gst_query_set_duration(query, GST_FORMAT_BYTES, parser->file_size);
+                return TRUE;
+            }
+            return FALSE;
+
+        case GST_QUERY_SEEKING:
+            gst_query_parse_seeking (query, &format, NULL, NULL, NULL);
+            if (format != GST_FORMAT_BYTES)
+            {
+                GST_WARNING("Cannot seek using format \"%s\".", gst_format_get_name(format));
+                return FALSE;
+            }
+            if (!parser->seekable)
+                return FALSE;
+            gst_query_set_seeking(query, GST_FORMAT_BYTES, 1, 0, parser->file_size);
+            return TRUE;
+
+        case GST_QUERY_SCHEDULING:
+            gst_query_set_scheduling(query, parser->seekable ? GST_SCHEDULING_FLAG_SEEKABLE : GST_SCHEDULING_FLAG_SEQUENTIAL, 1, -1, 0);
+            gst_query_add_scheduling_mode(query, GST_PAD_MODE_PUSH);
+            gst_query_add_scheduling_mode(query, GST_PAD_MODE_PULL);
+            return TRUE;
+
+        case GST_QUERY_CAPS:
+        {
+            GstCaps *caps, *filter, *temp;
+
+            gst_query_parse_caps(query, &filter);
+
+            if (parser->input_format.major_type)
+                caps = wg_format_to_caps(&parser->input_format);
+            else
+                caps = gst_caps_new_any();
+            if (!caps)
+                return FALSE;
+
+            if (filter)
+            {
+                temp = gst_caps_intersect(caps, filter);
+                gst_caps_unref(caps);
+                caps = temp;
+            }
+
+            gst_query_set_caps_result(query, caps);
+            gst_caps_unref(caps);
+            return TRUE;
+        }
+
+        default:
+            GST_WARNING("Unhandled query type %s.", GST_QUERY_TYPE_NAME(query));
+            return FALSE;
+    }
+}
+
+static void *push_data(void *arg)
+{
+    struct wg_parser *parser = arg;
+    ULONG alloc_size = 16384;
+    GstCaps *caps = NULL;
+    GstSegment *segment;
+    GstBuffer *buffer;
+    unsigned int i;
+    guint max_size;
+
+    GST_DEBUG("Starting push thread.");
+
+    if (parser->input_format.major_type)
+        caps = wg_format_to_caps(&parser->input_format);
+
+    if (parser->input_format.major_type == WG_MAJOR_TYPE_VIDEO)
+    {
+        GstVideoInfo info;
+        gst_video_info_from_caps(&info, caps);
+        alloc_size = info.size;
+    }
+
+    max_size = parser->stop_offset ? parser->stop_offset : parser->file_size;
+
+    gst_pad_push_event(parser->my_src, gst_event_new_stream_start("wg_stream"));
+
+    if (caps) gst_pad_push_event(parser->my_src, gst_event_new_caps(caps));
+
+    segment = gst_segment_new();
+    gst_segment_init(segment, GST_FORMAT_BYTES);
+    gst_pad_push_event(parser->my_src, gst_event_new_segment(segment));
+
+    for (;;)
+    {
+        ULONG size;
+        int ret;
+
+        if (parser->seekable && parser->next_offset >= max_size)
+            break;
+        size = parser->seekable ? min(alloc_size, max_size - parser->next_offset) : alloc_size;
+
+        buffer = NULL;
+        if ((ret = src_getrange_cb(parser->my_src, NULL, parser->next_offset, size, &buffer) < 0))
+        {
+            /* When we are in unseekable push mode, the pushing pad is responsible for handling flushing.  */
+            if (!parser->seekable && ret == GST_FLOW_FLUSHING)
+            {
+                gst_pad_push_event(parser->my_src, gst_event_new_seek(1.0f,
+                    GST_FORMAT_BYTES, GST_SEEK_FLAG_FLUSH, GST_SEEK_TYPE_NONE, 0, GST_SEEK_TYPE_NONE, 0));
+                continue;
+            }
+
+            if (!parser->seekable && ret == GST_FLOW_EOS)
+            {
+                gst_pad_push_event(parser->my_src, gst_event_new_eos());
+                pthread_mutex_lock(&parser->mutex);
+                for (i = 0; i < parser->stream_count; i++)
+                {
+                    if (!parser->streams[i]->enabled)
+                        continue;
+                    while (!parser->streams[i]->flushing && !parser->streams[i]->eos)
+                        pthread_cond_wait(&parser->streams[i]->event_empty_cond, &parser->mutex);
+                    parser->streams[i]->eos = false;
+                }
+
+                pthread_mutex_unlock(&parser->mutex);
+
+                segment = gst_segment_new();
+                gst_segment_init(segment, GST_FORMAT_BYTES);
+                gst_pad_push_event(parser->my_src, gst_event_new_segment(segment));
+                continue;
+            }
+
+            GST_ERROR("Failed to read data, ret %s.", gst_flow_get_name(ret));
+            break;
+        }
+
+        parser->next_offset += gst_buffer_get_size(buffer);
+
+        buffer->duration = buffer->pts = -1;
+        if ((ret = gst_pad_push(parser->my_src, buffer)) < 0)
+        {
+            GST_ERROR("Failed to push data, ret %s.", gst_flow_get_name(ret));
+            break;
+        }
+    }
+
+    gst_pad_push_event(parser->my_src, gst_event_new_eos());
+
+    GST_DEBUG("Stopping push thread.");
+
+    return NULL;
+}
+
+static gboolean activate_push(GstPad *pad, gboolean activate)
+{
+    struct wg_parser *parser = gst_pad_get_element_private(pad);
+
+    if (!activate)
+    {
+        if (parser->push_thread)
+        {
+            pthread_join(parser->push_thread, NULL);
+            parser->push_thread = 0;
+        }
+    }
+    else if (!parser->push_thread)
+    {
+        int ret;
+
+        if ((ret = pthread_create(&parser->push_thread, NULL, push_data, parser)))
+        {
+            GST_ERROR("Failed to create push thread: %s", strerror(errno));
+            parser->push_thread = 0;
+            return FALSE;
+        }
+    }
+    return TRUE;
+}
+
+static gboolean src_activate_mode_cb(GstPad *pad, GstObject *parent, GstPadMode mode, gboolean activate)
+{
+    struct wg_parser *parser = gst_pad_get_element_private(pad);
+
+    GST_DEBUG("%s source pad for parser %p in %s mode.",
+            activate ? "Activating" : "Deactivating", parser, gst_pad_mode_get_name(mode));
+
+    parser->pull_mode = false;
+
+    switch (mode)
+    {
+        case GST_PAD_MODE_PULL:
+            parser->pull_mode = activate;
+            return TRUE;
+        case GST_PAD_MODE_PUSH:
+            return activate_push(pad, activate);
+        case GST_PAD_MODE_NONE:
+            break;
+    }
+    return FALSE;
+}
+
+static BOOL decodebin_parser_init_gst(struct wg_parser *parser);
+
+static GstBusSyncReply bus_handler_cb(GstBus *bus, GstMessage *msg, gpointer user)
+{
+    struct wg_parser *parser = user;
+    const GstStructure *structure;
+    gchar *dbg_info = NULL;
+    GError *err = NULL;
+
+    GST_DEBUG("parser %p, message type %s.", parser, GST_MESSAGE_TYPE_NAME(msg));
+
+    switch (msg->type)
+    {
+    case GST_MESSAGE_ERROR:
+        gst_message_parse_error(msg, &err, &dbg_info);
+        fprintf(stderr, "winegstreamer error: %s: %s\n", GST_OBJECT_NAME(msg->src), err->message);
+        fprintf(stderr, "winegstreamer error: %s: %s\n", GST_OBJECT_NAME(msg->src), dbg_info);
+        g_error_free(err);
+        g_free(dbg_info);
+        pthread_mutex_lock(&parser->mutex);
+        parser->error = true;
+        pthread_mutex_unlock(&parser->mutex);
+        pthread_cond_signal(&parser->init_cond);
+        break;
+
+    case GST_MESSAGE_WARNING:
+        gst_message_parse_warning(msg, &err, &dbg_info);
+        fprintf(stderr, "winegstreamer warning: %s: %s\n", GST_OBJECT_NAME(msg->src), err->message);
+        fprintf(stderr, "winegstreamer warning: %s: %s\n", GST_OBJECT_NAME(msg->src), dbg_info);
+        g_error_free(err);
+        g_free(dbg_info);
+        break;
+
+    case GST_MESSAGE_DURATION_CHANGED:
+        pthread_mutex_lock(&parser->mutex);
+        parser->has_duration = true;
+        pthread_mutex_unlock(&parser->mutex);
+        pthread_cond_signal(&parser->init_cond);
+        break;
+
+    case GST_MESSAGE_ELEMENT:
+        structure = gst_message_get_structure(msg);
+        if (gst_structure_has_name(structure, "missing-plugin"))
+        {
+            pthread_mutex_lock(&parser->mutex);
+            if (!parser->use_mediaconv && parser->init_gst == decodebin_parser_init_gst)
+            {
+                GST_WARNING("Autoplugged element failed to initialise, trying again with protonvideoconvert.");
+                parser->error = true;
+                pthread_cond_signal(&parser->init_cond);
+            }
+            pthread_mutex_unlock(&parser->mutex);
+        }
+        break;
+
+    default:
+        break;
+    }
+    gst_message_unref(msg);
+    return GST_BUS_DROP;
+}
+
+static gboolean src_perform_seek(struct wg_parser *parser, GstEvent *event)
+{
+    BOOL thread = !!parser->push_thread;
+    GstSeekType cur_type, stop_type;
+    GstFormat seek_format;
+    GstEvent *flush_event;
+    GstSeekFlags flags;
+    gint64 cur, stop;
+    GstSegment *seg;
+    guint32 seqnum;
+    gdouble rate;
+
+    gst_event_parse_seek(event, &rate, &seek_format, &flags,
+                         &cur_type, &cur, &stop_type, &stop);
+
+    if (seek_format != GST_FORMAT_BYTES)
+    {
+        GST_FIXME("Unhandled format \"%s\".", gst_format_get_name(seek_format));
+        return FALSE;
+    }
+
+    seqnum = gst_event_get_seqnum(event);
+
+    /* send flush start */
+    if (flags & GST_SEEK_FLAG_FLUSH)
+    {
+        flush_event = gst_event_new_flush_start();
+        gst_event_set_seqnum(flush_event, seqnum);
+        gst_pad_push_event(parser->my_src, flush_event);
+        if (thread)
+            gst_pad_set_active(parser->my_src, 1);
+    }
+
+    parser->next_offset = parser->start_offset = cur;
+
+    /* and prepare to continue streaming */
+    if (flags & GST_SEEK_FLAG_FLUSH)
+    {
+        flush_event = gst_event_new_flush_stop(TRUE);
+        gst_event_set_seqnum(flush_event, seqnum);
+        gst_pad_push_event(parser->my_src, flush_event);
+        if (thread)
+        {
+            gst_pad_set_active(parser->my_src, 1);
+            seg = gst_segment_new();
+            gst_segment_init(seg, GST_FORMAT_BYTES);
+            gst_pad_push_event(parser->my_src, gst_event_new_segment(seg));
+        }
+    }
+
+    return TRUE;
+}
+
+static gboolean src_event_cb(GstPad *pad, GstObject *parent, GstEvent *event)
+{
+    struct wg_parser *parser = gst_pad_get_element_private(pad);
+    gboolean ret = TRUE;
+
+    GST_LOG("parser %p, type \"%s\".", parser, GST_EVENT_TYPE_NAME(event));
+
+    switch (event->type)
+    {
+        case GST_EVENT_SEEK:
+            ret = src_perform_seek(parser, event);
+            break;
+
+        case GST_EVENT_FLUSH_START:
+        case GST_EVENT_FLUSH_STOP:
+        case GST_EVENT_QOS:
+        case GST_EVENT_RECONFIGURE:
+            break;
+
+        default:
+            GST_WARNING("Ignoring \"%s\" event.", GST_EVENT_TYPE_NAME(event));
+            ret = FALSE;
+            break;
+    }
+    gst_event_unref(event);
+    return ret;
+}
+
+static gchar *query_language(GstPad *pad)
+{
+    GstTagList *tag_list;
+    GstEvent *tag_event;
+    gchar *ret = NULL;
+
+    if ((tag_event = gst_pad_get_sticky_event(pad, GST_EVENT_TAG, 0)))
+    {
+        gst_event_parse_tag(tag_event, &tag_list);
+        gst_tag_list_get_string(tag_list, "language-code", &ret);
+        gst_event_unref(tag_event);
+    }
+
+    return ret;
+}
+
+static HRESULT wg_parser_connect_inner(struct wg_parser *parser)
+{
+    GstStaticPadTemplate src_template = GST_STATIC_PAD_TEMPLATE("wine_src",
+            GST_PAD_SRC, GST_PAD_ALWAYS, GST_STATIC_CAPS_ANY);
+
+    parser->sink_connected = true;
+
+    if (!parser->bus)
+    {
+        parser->bus = gst_bus_new();
+        gst_bus_set_sync_handler(parser->bus, bus_handler_cb, parser, NULL);
+    }
+
+    parser->container = gst_bin_new(NULL);
+    gst_element_set_bus(parser->container, parser->bus);
+
+    parser->my_src = gst_pad_new_from_static_template(&src_template, "wine-src");
+    gst_pad_set_getrange_function(parser->my_src, src_getrange_cb);
+    gst_pad_set_query_function(parser->my_src, src_query_cb);
+    gst_pad_set_activatemode_function(parser->my_src, src_activate_mode_cb);
+    gst_pad_set_event_function(parser->my_src, src_event_cb);
+    gst_pad_set_element_private(parser->my_src, parser);
+
+    parser->start_offset = parser->next_offset = parser->stop_offset = 0;
+    parser->next_pull_offset = 0;
+    parser->error = false;
+
+    return S_OK;
+}
+
+static NTSTATUS wg_parser_connect(void *args)
+{
+    const struct wg_parser_connect_params *params = args;
+    struct wg_parser *parser = params->parser;
+    bool use_mediaconv = false;
+    unsigned int i;
+    HRESULT hr;
+    int ret;
+
+    parser->seekable = true;
+    parser->file_size = params->file_size;
+
+    if ((hr = wg_parser_connect_inner(parser)))
+        return hr;
+
+    if (!parser->init_gst(parser))
+        goto out;
+
+    gst_element_set_state(parser->container, GST_STATE_PAUSED);
+    if (!parser->pull_mode)
+        gst_pad_set_active(parser->my_src, 1);
+    ret = gst_element_get_state(parser->container, NULL, NULL, -1);
+
+    if (ret == GST_STATE_CHANGE_FAILURE)
+    {
+        if (!parser->use_mediaconv && parser->init_gst == decodebin_parser_init_gst && parser->pull_mode)
+        {
+            GST_WARNING("Failed to play media, trying again with protonvideoconvert.");
+            use_mediaconv = true;
+        }
+        else
+            GST_ERROR("Failed to play stream.\n");
+        goto out;
+    }
+
+    pthread_mutex_lock(&parser->mutex);
+
+    while (!parser->no_more_pads && !parser->error)
+        pthread_cond_wait(&parser->init_cond, &parser->mutex);
+    if (parser->error)
+    {
+        if (!parser->use_mediaconv && parser->init_gst == decodebin_parser_init_gst)
+            use_mediaconv = true;
+        pthread_mutex_unlock(&parser->mutex);
+        goto out;
+    }
+
+    for (i = 0; i < parser->stream_count; ++i)
+    {
+        struct wg_parser_stream *stream = parser->streams[i];
+        gint64 duration;
+
+        while (!stream->has_caps && !parser->error)
+            pthread_cond_wait(&parser->init_cond, &parser->mutex);
+
+        /* GStreamer doesn't actually provide any guarantees about when duration
+         * is available, even for seekable streams. It's basically built for
+         * applications that don't care, e.g. movie players that can display
+         * a duration once it's available, and update it visually if a better
+         * estimate is found. This doesn't really match well with DirectShow or
+         * Media Foundation, which both expect duration to be available
+         * immediately on connecting, so we have to use some complex heuristics
+         * to try to actually get a usable duration.
+         *
+         * Some elements (avidemux, wavparse, qtdemux) record duration almost
+         * immediately, before fixing caps. Such elements don't send
+         * duration-changed messages. Therefore always try querying duration
+         * after caps have been found.
+         *
+         * Some elements (mpegaudioparse) send duration-changed. In the case of
+         * a mp3 stream without seek tables it will not be sent immediately, but
+         * only after enough frames have been parsed to form an estimate. They
+         * may send it multiple times with increasingly accurate estimates, but
+         * unfortunately we have no way of knowing whether another estimate will
+         * be sent, so we always take the first one. We assume that if the
+         * duration is not immediately available then the element will always
+         * send duration-changed.
+         */
+
+        for (;;)
+        {
+            if (parser->error)
+            {
+                pthread_mutex_unlock(&parser->mutex);
+                goto out;
+            }
+            if (gst_pad_query_duration(stream->their_src, GST_FORMAT_TIME, &duration))
+            {
+                stream->duration = duration / 100;
+                break;
+            }
+
+            if (stream->eos)
+            {
+                stream->duration = 0;
+                GST_WARNING("Failed to query duration.\n");
+                break;
+            }
+
+            /* Elements based on GstBaseParse send duration-changed before
+             * actually updating the duration in GStreamer versions prior
+             * to 1.17.1. See <gstreamer.git:d28e0b4147fe7073b2>. So after
+             * receiving duration-changed we have to continue polling until
+             * the query succeeds. */
+            if (parser->has_duration)
+            {
+                pthread_mutex_unlock(&parser->mutex);
+                g_usleep(10000);
+                pthread_mutex_lock(&parser->mutex);
+            }
+            else
+            {
+                pthread_cond_wait(&parser->init_cond, &parser->mutex);
+            }
+        }
+        stream->language_code = query_language(stream->their_src);
+    }
+
+    pthread_mutex_unlock(&parser->mutex);
+
+    parser->next_offset = 0;
+    return S_OK;
+
+out:
+    if (parser->container)
+        gst_element_set_state(parser->container, GST_STATE_NULL);
+    if (parser->their_sink)
+    {
+        gst_pad_unlink(parser->my_src, parser->their_sink);
+        gst_object_unref(parser->their_sink);
+        parser->my_src = parser->their_sink = NULL;
+    }
+
+    for (i = 0; i < parser->stream_count; ++i)
+        free_stream(parser->streams[i]);
+    parser->stream_count = 0;
+    free(parser->streams);
+    parser->streams = NULL;
+
+    if (parser->container)
+    {
+        gst_element_set_bus(parser->container, NULL);
+        gst_object_unref(parser->container);
+        parser->container = NULL;
+    }
+
+    pthread_mutex_lock(&parser->mutex);
+    parser->sink_connected = false;
+    pthread_mutex_unlock(&parser->mutex);
+    pthread_cond_signal(&parser->read_cond);
+
+    if (use_mediaconv)
+    {
+        parser->use_mediaconv = true;
+        hr = wg_parser_connect(args);
+        parser->use_mediaconv = false;
+        return hr;
+    }
+
+    return E_FAIL;
+}
+
+static NTSTATUS wg_parser_connect_unseekable(void *args)
+{
+    const struct wg_parser_connect_unseekable_params *params = args;
+    const struct wg_format *out_formats = params->out_formats;
+    const struct wg_format *in_format = params->in_format;
+    const struct wg_rect *apertures = params->apertures;
+    uint32_t stream_count = params->stream_count;
+    struct wg_parser *parser = params->parser;
+    unsigned int i;
+    HRESULT hr;
+
+    parser->seekable = false;
+    /* since typefind is not available here, we must have an input_format */
+    parser->input_format = *in_format;
+
+    if ((hr = wg_parser_connect_inner(parser)))
+        return hr;
+
+    parser->stop_offset = -1;
+
+    parser->expected_stream_count = stream_count;
+    parser->streams = calloc(stream_count, sizeof(*parser->streams));
+
+    for (i = 0; i < stream_count; i++)
+    {
+        parser->streams[i] = calloc(1, sizeof(*parser->streams[i]));
+        parser->streams[i]->current_format = out_formats[i];
+        if (apertures)
+            parser->streams[i]->aperture = apertures[i];
+        parser->streams[i]->enabled = true;
+    }
+
+    if (!parser->init_gst(parser))
+        return E_FAIL;
+
+    if (parser->stream_count < parser->expected_stream_count)
+        return E_FAIL;
+
+    return S_OK;
+}
+
+static NTSTATUS wg_parser_disconnect(void *args)
+{
+    struct wg_parser *parser = args;
+    unsigned int i;
+
+    /* Unblock all of our streams. */
+    pthread_mutex_lock(&parser->mutex);
+    parser->no_more_pads = true;
+    pthread_cond_signal(&parser->init_cond);
+    for (i = 0; i < parser->stream_count; ++i)
+    {
+        parser->streams[i]->flushing = true;
+        pthread_cond_signal(&parser->streams[i]->event_cond);
+        pthread_cond_signal(&parser->streams[i]->event_empty_cond);
+    }
+    pthread_mutex_unlock(&parser->mutex);
+
+    gst_element_set_state(parser->container, GST_STATE_NULL);
+    if (!parser->pull_mode)
+        gst_pad_set_active(parser->my_src, 0);
+    gst_pad_unlink(parser->my_src, parser->their_sink);
+    gst_object_unref(parser->my_src);
+    gst_object_unref(parser->their_sink);
+    parser->my_src = parser->their_sink = NULL;
+
+    pthread_mutex_lock(&parser->mutex);
+    parser->sink_connected = false;
+    pthread_mutex_unlock(&parser->mutex);
+    pthread_cond_signal(&parser->read_cond);
+
+    for (i = 0; i < parser->stream_count; ++i)
+        free_stream(parser->streams[i]);
+
+    parser->stream_count = 0;
+    free(parser->streams);
+    parser->streams = NULL;
+
+    gst_element_set_bus(parser->container, NULL);
+    gst_object_unref(parser->container);
+    parser->container = NULL;
+
+    return S_OK;
+}
+
+static BOOL decodebin_parser_init_gst(struct wg_parser *parser)
+{
+    GstElement *element;
+    int ret;
+
+    if (!(element = create_element("decodebin", "base")))
+        return FALSE;
+
+    if (parser->input_format.major_type)
+        g_object_set(G_OBJECT(element), "sink-caps", wg_format_to_caps(&parser->input_format), NULL);
+
+    gst_bin_add(GST_BIN(parser->container), element);
+    parser->decodebin = element;
+
+    if (parser->unlimited_buffering)
+    {
+        g_object_set(parser->decodebin, "max-size-buffers", G_MAXUINT, NULL);
+        g_object_set(parser->decodebin, "max-size-time", G_MAXUINT64, NULL);
+        g_object_set(parser->decodebin, "max-size-bytes", G_MAXUINT, NULL);
+    }
+
+    g_signal_connect(element, "pad-added", G_CALLBACK(pad_added_cb), parser);
+    g_signal_connect(element, "pad-removed", G_CALLBACK(pad_removed_cb), parser);
+    g_signal_connect(element, "autoplug-select", G_CALLBACK(autoplug_select_cb), parser);
+    g_signal_connect(element, "autoplug-sort", G_CALLBACK(autoplug_sort_cb), parser);
+    g_signal_connect(element, "no-more-pads", G_CALLBACK(no_more_pads_cb), parser);
+
+    parser->their_sink = gst_element_get_static_pad(element, "sink");
+
+    pthread_mutex_lock(&parser->mutex);
+    parser->no_more_pads = false;
+    pthread_mutex_unlock(&parser->mutex);
+
+    if ((ret = gst_pad_link(parser->my_src, parser->their_sink)) < 0)
+    {
+        GST_ERROR("Failed to link pads, error %d.\n", ret);
+        return FALSE;
+    }
+
+    return TRUE;
+}
+
+static BOOL avi_parser_init_gst(struct wg_parser *parser)
+{
+    GstElement *element;
+    int ret;
+
+    if (!(element = create_element("avidemux", "good")))
+        return FALSE;
+
+    gst_bin_add(GST_BIN(parser->container), element);
+
+    g_signal_connect(element, "pad-added", G_CALLBACK(pad_added_cb), parser);
+    g_signal_connect(element, "pad-removed", G_CALLBACK(pad_removed_cb), parser);
+    g_signal_connect(element, "no-more-pads", G_CALLBACK(no_more_pads_cb), parser);
+
+    parser->their_sink = gst_element_get_static_pad(element, "sink");
+
+    pthread_mutex_lock(&parser->mutex);
+    parser->no_more_pads = false;
+    pthread_mutex_unlock(&parser->mutex);
+
+    if ((ret = gst_pad_link(parser->my_src, parser->their_sink)) < 0)
+    {
+        GST_ERROR("Failed to link pads, error %d.\n", ret);
+        return FALSE;
+    }
+
+    return TRUE;
+}
+
+static BOOL mpeg_audio_parser_init_gst(struct wg_parser *parser)
+{
+    struct wg_parser_stream *stream;
+    GstElement *element;
+    int ret;
+
+    if (!(element = create_element("mpegaudioparse", "good")))
+        return FALSE;
+
+    gst_bin_add(GST_BIN(parser->container), element);
+
+    parser->their_sink = gst_element_get_static_pad(element, "sink");
+    if ((ret = gst_pad_link(parser->my_src, parser->their_sink)) < 0)
+    {
+        GST_ERROR("Failed to link sink pads, error %d.\n", ret);
+        return FALSE;
+    }
+
+    if (!(stream = create_stream(parser)))
+        return FALSE;
+
+    gst_object_ref(stream->their_src = gst_element_get_static_pad(element, "src"));
+    if ((ret = gst_pad_link(stream->their_src, stream->my_sink)) < 0)
+    {
+        GST_ERROR("Failed to link source pads, error %d.\n", ret);
+        return FALSE;
+    }
+    gst_pad_set_active(stream->my_sink, 1);
+
+    parser->no_more_pads = true;
+
+    return TRUE;
+}
+
+static BOOL wave_parser_init_gst(struct wg_parser *parser)
+{
+    struct wg_parser_stream *stream;
+    GstElement *element;
+    int ret;
+
+    if (!(element = create_element("wavparse", "good")))
+        return FALSE;
+
+    gst_bin_add(GST_BIN(parser->container), element);
+
+    parser->their_sink = gst_element_get_static_pad(element, "sink");
+    if ((ret = gst_pad_link(parser->my_src, parser->their_sink)) < 0)
+    {
+        GST_ERROR("Failed to link sink pads, error %d.\n", ret);
+        return FALSE;
+    }
+
+    if (!(stream = create_stream(parser)))
+        return FALSE;
+
+    stream->their_src = gst_element_get_static_pad(element, "src");
+    gst_object_ref(stream->their_src);
+    if ((ret = gst_pad_link(stream->their_src, stream->my_sink)) < 0)
+    {
+        GST_ERROR("Failed to link source pads, error %d.\n", ret);
+        return FALSE;
+    }
+    gst_pad_set_active(stream->my_sink, 1);
+
+    parser->no_more_pads = true;
+
+    return TRUE;
+}
+
+static BOOL audio_convert_init_gst(struct wg_parser *parser)
+{
+    struct wg_parser_stream *stream;
+    GstElement *convert, *resampler;
+    int ret;
+
+    if (parser->seekable)
+        return FALSE;
+
+    if (parser->expected_stream_count != 1)
+        return FALSE;
+
+    if (parser->input_format.major_type != WG_MAJOR_TYPE_AUDIO)
+        return FALSE;
+
+    if (!(convert = create_element("audioconvert", "base")))
+        return FALSE;
+
+    gst_bin_add(GST_BIN(parser->container), convert);
+
+    if (!(resampler = create_element("audioresample", "base")))
+        return FALSE;
+
+    gst_bin_add(GST_BIN(parser->container), resampler);
+
+    gst_element_link(convert, resampler);
+
+    parser->their_sink = gst_element_get_static_pad(convert, "sink");
+    if ((ret = gst_pad_link(parser->my_src, parser->their_sink)) < 0)
+    {
+        GST_ERROR("Failed to link sink pads, error %d.\n", ret);
+        return FALSE;
+    }
+
+    if (!(stream = create_stream(parser)))
+        return FALSE;
+
+    stream->their_src = gst_element_get_static_pad(resampler, "src");
+    gst_object_ref(stream->their_src);
+    if ((ret = gst_pad_link(stream->their_src, stream->my_sink)) < 0)
+    {
+        GST_ERROR("Failed to link source pads, error %d.\n", ret);
+        return FALSE;
+    }
+    gst_pad_set_active(stream->my_sink, 1);
+
+    parser->no_more_pads = true;
+
+    gst_element_set_state(parser->container, GST_STATE_PAUSED);
+    gst_pad_set_active(parser->my_src, 1);
+    ret = gst_element_get_state(parser->container, NULL, NULL, -1);
+    if (ret == GST_STATE_CHANGE_FAILURE)
+    {
+        GST_ERROR("Failed to play stream.\n");
+        return FALSE;
+    }
+
+    return TRUE;
+}
+
+static BOOL video_convert_init_gst(struct wg_parser *parser)
+{
+    struct wg_parser_stream *stream;
+    GstElement *convert;
+    int ret;
+
+    if (parser->seekable)
+        return FALSE;
+
+    if (parser->expected_stream_count != 1)
+        return FALSE;
+
+    if (parser->input_format.major_type != WG_MAJOR_TYPE_VIDEO)
+        return FALSE;
+
+    if (!(convert = create_element("videoconvert", "base")))
+        return FALSE;
+
+    gst_bin_add(GST_BIN(parser->container), convert);
+
+    parser->their_sink = gst_element_get_static_pad(convert, "sink");
+    if ((ret = gst_pad_link(parser->my_src, parser->their_sink)) < 0)
+    {
+        GST_ERROR("Failed to link sink pads, error %d.\n", ret);
+        return FALSE;
+    }
+
+    if (!(stream = create_stream(parser)))
+        return FALSE;
+
+    stream->their_src = gst_element_get_static_pad(convert, "src");
+    gst_object_ref(stream->their_src);
+    if ((ret = gst_pad_link(stream->their_src, stream->my_sink)) < 0)
+    {
+        GST_ERROR("Failed to link source pads, error %d.\n", ret);
+        return FALSE;
+    }
+    gst_pad_set_active(stream->my_sink, 1);
+
+    parser->no_more_pads = true;
+
+    gst_element_set_state(parser->container, GST_STATE_PAUSED);
+    gst_pad_set_active(parser->my_src, 1);
+    ret = gst_element_get_state(parser->container, NULL, NULL, -1);
+    if (ret == GST_STATE_CHANGE_FAILURE)
+    {
+        GST_ERROR("Failed to play stream.\n");
+        return FALSE;
+    }
+
+    return TRUE;
+}
+
+static void init_gstreamer_once(void)
+{
+    char arg0[] = "wine";
+    char arg1[] = "--gst-disable-registry-fork";
+    char *args[] = {arg0, arg1, NULL};
+    int argc = ARRAY_SIZE(args) - 1;
+    char **argv = args;
+    GError *err;
+    const char *e;
+
+    if ((e = getenv("WINE_GST_REGISTRY_DIR")))
+    {
+        char gst_reg[PATH_MAX];
+#if defined(__x86_64__)
+        const char *arch = "/registry.x86_64.bin";
+#elif defined(__i386__)
+        const char *arch = "/registry.i386.bin";
+#else
+#error Bad arch
+#endif
+        strcpy(gst_reg, e);
+        strcat(gst_reg, arch);
+        setenv("GST_REGISTRY_1_0", gst_reg, 1);
+    }
+
+    if (!gst_init_check(&argc, &argv, &err))
+    {
+        fprintf(stderr, "winegstreamer: failed to initialize GStreamer: %s\n", err->message);
+        g_error_free(err);
+        return;
+    }
+
+    GST_DEBUG_CATEGORY_INIT(wine, "WINE", GST_DEBUG_FG_RED, "Wine GStreamer support");
+
+    GST_INFO("GStreamer library version %s; wine built with %d.%d.%d.\n",
+            gst_version_string(), GST_VERSION_MAJOR, GST_VERSION_MINOR, GST_VERSION_MICRO);
+}
+
+bool init_gstreamer(void)
+{
+    static pthread_once_t init_once = PTHREAD_ONCE_INIT;
+
+    if (pthread_once(&init_once, init_gstreamer_once))
+        return false;
+
+    return true;
+}
+
+static NTSTATUS wg_parser_create(void *args)
+{
+    static const init_gst_cb init_funcs[] =
+    {
+        [WG_PARSER_DECODEBIN] = decodebin_parser_init_gst,
+        [WG_PARSER_AVIDEMUX] = avi_parser_init_gst,
+        [WG_PARSER_MPEGAUDIOPARSE] = mpeg_audio_parser_init_gst,
+        [WG_PARSER_WAVPARSE] = wave_parser_init_gst,
+        [WG_PARSER_AUDIOCONV] = audio_convert_init_gst,
+        [WG_PARSER_VIDEOCONV] = video_convert_init_gst,
+    };
+
+    struct wg_parser_create_params *params = args;
+    struct wg_parser *parser;
+
+    if (!init_gstreamer())
+        return E_FAIL;
+
+    if (!(parser = calloc(1, sizeof(*parser))))
+        return E_OUTOFMEMORY;
+
+    pthread_mutex_init(&parser->mutex, NULL);
+    pthread_cond_init(&parser->init_cond, NULL);
+    pthread_cond_init(&parser->read_cond, NULL);
+    pthread_cond_init(&parser->read_done_cond, NULL);
+    parser->init_gst = init_funcs[params->type];
+    parser->unlimited_buffering = params->unlimited_buffering;
+
+    GST_DEBUG("Created winegstreamer parser %p.\n", parser);
+    params->parser = parser;
+    return S_OK;
+}
+
+static NTSTATUS wg_parser_destroy(void *args)
+{
+    struct wg_parser *parser = args;
+
+    if (parser->bus)
+    {
+        gst_bus_set_sync_handler(parser->bus, NULL, NULL, NULL);
+        gst_object_unref(parser->bus);
+    }
+
+    pthread_mutex_destroy(&parser->mutex);
+    pthread_cond_destroy(&parser->init_cond);
+    pthread_cond_destroy(&parser->read_cond);
+    pthread_cond_destroy(&parser->read_done_cond);
+
+    free(parser);
+    return S_OK;
+}
+
+const unixlib_entry_t __wine_unix_call_funcs[] =
+{
+#define X(name) [unix_ ## name] = name
+    X(wg_parser_create),
+    X(wg_parser_destroy),
+
+    X(wg_parser_connect),
+    X(wg_parser_connect_unseekable),
+    X(wg_parser_disconnect),
+
+    X(wg_parser_get_next_read_offset),
+    X(wg_parser_push_data),
+
+    X(wg_parser_get_stream_count),
+    X(wg_parser_get_stream),
+
+    X(wg_parser_stream_get_preferred_format),
+    X(wg_parser_stream_enable),
+    X(wg_parser_stream_disable),
+
+    X(wg_parser_stream_get_buffer),
+    X(wg_parser_stream_copy_buffer),
+    X(wg_parser_stream_release_buffer),
+    X(wg_parser_stream_notify_qos),
+
+    X(wg_parser_stream_get_duration),
+    X(wg_parser_stream_get_language),
+    X(wg_parser_stream_seek),
+
+    X(wg_parser_stream_drain),
+
+    X(wg_transform_create),
+    X(wg_transform_destroy),
+
+    X(wg_transform_push_data),
+    X(wg_transform_read_data),
+};
diff --git a/dlls/mfplat/wg_transform.c b/dlls/mfplat/wg_transform.c
new file mode 100644
index 00000000000..b080894dbe4
--- /dev/null
+++ wine/dlls/mfplat/wg_transform.c
@@ -0,0 +1,630 @@
+/*
+ * GStreamer transform backend
+ *
+ * Copyright 2022 Rémi Bernon for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include <assert.h>
+#include <stdarg.h>
+#include <stdio.h>
+
+#include <gst/gst.h>
+#include <gst/video/video.h>
+#include <gst/audio/audio.h>
+
+#include "winternl.h"
+#include "dshow.h"
+#include "mferror.h"
+
+#include "unix_private.h"
+
+#include "wine/list.h"
+
+GST_DEBUG_CATEGORY_EXTERN(wine);
+#define GST_CAT_DEFAULT wine
+
+struct wg_transform_sample
+{
+    struct list entry;
+    GstSample *sample;
+};
+
+struct wg_transform
+{
+    GstElement *container;
+    GstPad *my_src, *my_sink;
+    GstPad *their_sink, *their_src;
+    pthread_mutex_t mutex;
+    struct list samples;
+    GstCaps *sink_caps;
+};
+
+static GstCaps *wg_format_to_caps_xwma(const struct wg_encoded_format *format)
+{
+    GstBuffer *buffer;
+    GstCaps *caps;
+
+    if (format->encoded_type == WG_ENCODED_TYPE_WMA)
+    {
+        caps = gst_caps_new_empty_simple("audio/x-wma");
+        if (format->u.xwma.version)
+            gst_caps_set_simple(caps, "wmaversion", G_TYPE_INT, format->u.xwma.version, NULL);
+    }
+    else
+    {
+        caps = gst_caps_new_empty_simple("audio/x-xma");
+        if (format->u.xwma.version)
+            gst_caps_set_simple(caps, "xmaversion", G_TYPE_INT, format->u.xwma.version, NULL);
+    }
+
+    if (format->u.xwma.bitrate)
+        gst_caps_set_simple(caps, "bitrate", G_TYPE_INT, format->u.xwma.bitrate, NULL);
+    if (format->u.xwma.rate)
+        gst_caps_set_simple(caps, "rate", G_TYPE_INT, format->u.xwma.rate, NULL);
+    if (format->u.xwma.depth)
+        gst_caps_set_simple(caps, "depth", G_TYPE_INT, format->u.xwma.depth, NULL);
+    if (format->u.xwma.channels)
+        gst_caps_set_simple(caps, "channels", G_TYPE_INT, format->u.xwma.channels, NULL);
+    if (format->u.xwma.block_align)
+        gst_caps_set_simple(caps, "block_align", G_TYPE_INT, format->u.xwma.block_align, NULL);
+
+    if (format->u.xwma.codec_data_len)
+    {
+        buffer = gst_buffer_new_and_alloc(format->u.xwma.codec_data_len);
+        gst_buffer_fill(buffer, 0, format->u.xwma.codec_data, format->u.xwma.codec_data_len);
+        gst_caps_set_simple(caps, "codec_data", GST_TYPE_BUFFER, buffer, NULL);
+        gst_buffer_unref(buffer);
+    }
+
+    return caps;
+}
+
+static GstCaps *wg_format_to_caps_aac(const struct wg_encoded_format *format)
+{
+    const char *profile, *level, *stream_format;
+    GstBuffer *buffer;
+    GstCaps *caps;
+
+    caps = gst_caps_new_empty_simple("audio/mpeg");
+    gst_caps_set_simple(caps, "mpegversion", G_TYPE_INT, 4, NULL);
+
+    switch (format->u.aac.payload_type)
+    {
+        case 0: stream_format = "raw"; break;
+        case 1: stream_format = "adts"; break;
+        case 2: stream_format = "adif"; break;
+        case 3: stream_format = "loas"; break;
+        default: stream_format = "raw"; break;
+    }
+    if (stream_format)
+        gst_caps_set_simple(caps, "stream-format", G_TYPE_STRING, stream_format, NULL);
+
+    switch (format->u.aac.profile_level_indication)
+    {
+        case 0x29: profile = "lc"; level = "2";  break;
+        case 0x2A: profile = "lc"; level = "4"; break;
+        case 0x2B: profile = "lc"; level = "5"; break;
+        default:
+            GST_FIXME("Unrecognized profile-level-indication %u\n", format->u.aac.profile_level_indication);
+            /* fallthrough */
+        case 0x00: case 0xFE: profile = level = NULL; break; /* unspecified */
+    }
+    if (profile)
+        gst_caps_set_simple(caps, "profile", G_TYPE_STRING, profile, NULL);
+    if (level)
+        gst_caps_set_simple(caps, "level", G_TYPE_STRING, level, NULL);
+
+    if (format->u.aac.codec_data_len)
+    {
+        buffer = gst_buffer_new_and_alloc(format->u.aac.codec_data_len);
+        gst_buffer_fill(buffer, 0, format->u.aac.codec_data, format->u.aac.codec_data_len);
+        gst_caps_set_simple(caps, "codec_data", GST_TYPE_BUFFER, buffer, NULL);
+        gst_buffer_unref(buffer);
+    }
+
+    return caps;
+}
+
+static GstCaps *wg_format_to_caps_h264(const struct wg_encoded_format *format)
+{
+    const char *profile, *level;
+    GstCaps *caps;
+
+    caps = gst_caps_new_empty_simple("video/x-h264");
+    gst_caps_set_simple(caps, "stream-format", G_TYPE_STRING, "byte-stream", NULL);
+    gst_caps_set_simple(caps, "alignment", G_TYPE_STRING, "au", NULL);
+
+    if (format->u.h264.width)
+        gst_caps_set_simple(caps, "width", G_TYPE_INT, format->u.h264.width, NULL);
+    if (format->u.h264.height)
+        gst_caps_set_simple(caps, "height", G_TYPE_INT, format->u.h264.height, NULL);
+    if (format->u.h264.fps_n || format->u.h264.fps_d)
+        gst_caps_set_simple(caps, "framerate", GST_TYPE_FRACTION, format->u.h264.fps_n, format->u.h264.fps_d, NULL);
+
+    switch (format->u.h264.profile)
+    {
+        case /* eAVEncH264VProfile_Main */ 77:  profile = "main"; break;
+        case /* eAVEncH264VProfile_High */ 100: profile = "high"; break;
+        case /* eAVEncH264VProfile_444 */  244: profile = "high-4:4:4"; break;
+        default:
+            GST_ERROR("Unrecognized H.264 profile attribute %u.", format->u.h264.profile);
+            /* fallthrough */
+        case 0: profile = NULL;
+    }
+    if (profile)
+        gst_caps_set_simple(caps, "profile", G_TYPE_STRING, profile, NULL);
+
+    switch (format->u.h264.level)
+    {
+        case /* eAVEncH264VLevel1 */   10: level = "1";   break;
+        case /* eAVEncH264VLevel1_1 */ 11: level = "1.1"; break;
+        case /* eAVEncH264VLevel1_2 */ 12: level = "1.2"; break;
+        case /* eAVEncH264VLevel1_3 */ 13: level = "1.3"; break;
+        case /* eAVEncH264VLevel2 */   20: level = "2";   break;
+        case /* eAVEncH264VLevel2_1 */ 21: level = "2.1"; break;
+        case /* eAVEncH264VLevel2_2 */ 22: level = "2.2"; break;
+        case /* eAVEncH264VLevel3 */   30: level = "3";   break;
+        case /* eAVEncH264VLevel3_1 */ 31: level = "3.1"; break;
+        case /* eAVEncH264VLevel3_2 */ 32: level = "3.2"; break;
+        case /* eAVEncH264VLevel4 */   40: level = "4";   break;
+        case /* eAVEncH264VLevel4_1 */ 41: level = "4.1"; break;
+        case /* eAVEncH264VLevel4_2 */ 42: level = "4.2"; break;
+        case /* eAVEncH264VLevel5 */   50: level = "5";   break;
+        case /* eAVEncH264VLevel5_1 */ 51: level = "5.1"; break;
+        case /* eAVEncH264VLevel5_2 */ 52: level = "5.2"; break;
+        default:
+            GST_ERROR("Unrecognized H.264 level attribute %u.", format->u.h264.level);
+            /* fallthrough */
+        case 0: level = NULL;
+    }
+    if (level)
+        gst_caps_set_simple(caps, "level", G_TYPE_STRING, level, NULL);
+
+    return caps;
+}
+
+static GstCaps *wg_encoded_format_to_caps(const struct wg_encoded_format *format)
+{
+    switch (format->encoded_type)
+    {
+        case WG_ENCODED_TYPE_UNKNOWN:
+            return NULL;
+        case WG_ENCODED_TYPE_WMA:
+        case WG_ENCODED_TYPE_XMA:
+            return wg_format_to_caps_xwma(format);
+        case WG_ENCODED_TYPE_AAC:
+            return wg_format_to_caps_aac(format);
+        case WG_ENCODED_TYPE_H264:
+            return wg_format_to_caps_h264(format);
+    }
+    assert(0);
+    return NULL;
+}
+
+static GstFlowReturn transform_sink_chain_cb(GstPad *pad, GstObject *parent, GstBuffer *buffer)
+{
+    struct wg_transform *transform = gst_pad_get_element_private(pad);
+    struct wg_transform_sample *sample;
+
+    GST_INFO("transform %p, buffer %p.", transform, buffer);
+
+    if (!(sample = malloc(sizeof(*sample))))
+        GST_ERROR("Failed to allocate transform sample entry");
+    else
+    {
+        pthread_mutex_lock(&transform->mutex);
+        if (!(sample->sample = gst_sample_new(buffer, transform->sink_caps, NULL, NULL)))
+            GST_ERROR("Failed to allocate transform sample");
+        list_add_tail(&transform->samples, &sample->entry);
+        pthread_mutex_unlock(&transform->mutex);
+    }
+
+    gst_buffer_unref(buffer);
+    return GST_FLOW_OK;
+}
+
+static gboolean transform_sink_event_cb(GstPad *pad, GstObject *parent, GstEvent *event)
+{
+    struct wg_transform *transform = gst_pad_get_element_private(pad);
+
+    GST_INFO("transform %p, type \"%s\".", transform, GST_EVENT_TYPE_NAME(event));
+
+    switch (event->type)
+    {
+    case GST_EVENT_CAPS:
+    {
+        GstCaps *caps;
+        gchar *str;
+
+        gst_event_parse_caps(event, &caps);
+        str = gst_caps_to_string(caps);
+        GST_WARNING("Got caps \"%s\".", str);
+        g_free(str);
+
+        pthread_mutex_lock(&transform->mutex);
+        gst_caps_unref(transform->sink_caps);
+        transform->sink_caps = gst_caps_ref(caps);
+        pthread_mutex_unlock(&transform->mutex);
+        break;
+    }
+    default:
+        GST_WARNING("Ignoring \"%s\" event.", GST_EVENT_TYPE_NAME(event));
+    }
+
+    gst_event_unref(event);
+    return TRUE;
+}
+
+NTSTATUS wg_transform_destroy(void *args)
+{
+    struct wg_transform *transform = args;
+    struct wg_transform_sample *sample, *next;
+
+    if (transform->container)
+        gst_element_set_state(transform->container, GST_STATE_NULL);
+
+    if (transform->their_src && transform->my_sink)
+        gst_pad_unlink(transform->their_src, transform->my_sink);
+    if (transform->their_sink && transform->my_src)
+        gst_pad_unlink(transform->my_src, transform->their_sink);
+
+    if (transform->their_sink)
+        g_object_unref(transform->their_sink);
+    if (transform->their_src)
+        g_object_unref(transform->their_src);
+
+    if (transform->container)
+        g_object_unref(transform->container);
+
+    if (transform->my_sink)
+        g_object_unref(transform->my_sink);
+    if (transform->my_src)
+        g_object_unref(transform->my_src);
+
+    LIST_FOR_EACH_ENTRY_SAFE(sample, next, &transform->samples, struct wg_transform_sample, entry)
+    {
+        gst_sample_unref(sample->sample);
+        list_remove(&sample->entry);
+        free(sample);
+    }
+
+    free(transform);
+    return S_OK;
+}
+
+static GstElement *try_create_transform(GstCaps *src_caps, GstCaps *sink_caps)
+{
+    GstElement *element = NULL;
+    GList *tmp, *transforms;
+    gchar *type;
+
+    transforms = gst_element_factory_list_get_elements(GST_ELEMENT_FACTORY_TYPE_ANY,
+            GST_RANK_MARGINAL);
+
+    tmp = gst_element_factory_list_filter(transforms, src_caps, GST_PAD_SINK, FALSE);
+    gst_plugin_feature_list_free(transforms);
+    transforms = tmp;
+
+    tmp = gst_element_factory_list_filter(transforms, sink_caps, GST_PAD_SRC, FALSE);
+    gst_plugin_feature_list_free(transforms);
+    transforms = tmp;
+
+    transforms = g_list_sort(transforms, gst_plugin_feature_rank_compare_func);
+    for (tmp = transforms; tmp != NULL && element == NULL; tmp = tmp->next)
+    {
+        type = gst_plugin_feature_get_name(GST_PLUGIN_FEATURE(tmp->data));
+        element = gst_element_factory_create(GST_ELEMENT_FACTORY(tmp->data), NULL);
+        if (!element)
+            GST_WARNING("Failed to create %s element.", type);
+    }
+    gst_plugin_feature_list_free(transforms);
+
+    if (element)
+        GST_INFO("Created %s element %p.", type, element);
+    else
+    {
+        gchar *src_str = gst_caps_to_string(src_caps), *sink_str = gst_caps_to_string(sink_caps);
+        GST_WARNING("Failed to create transform matching caps %s / %s.", src_str, sink_str);
+        g_free(sink_str);
+        g_free(src_str);
+    }
+
+    return element;
+}
+
+static bool transform_append_element(struct wg_transform *transform, GstElement *element,
+        GstElement **first, GstElement **last)
+{
+    gchar *name = gst_element_get_name(element);
+
+    if (!gst_bin_add(GST_BIN(transform->container), element))
+    {
+        GST_ERROR("Failed to add %s element to bin.", name);
+        g_free(name);
+        return false;
+    }
+
+    if (*last && !gst_element_link(*last, element))
+    {
+        GST_ERROR("Failed to link %s element.", name);
+        g_free(name);
+        return false;
+    }
+
+    GST_INFO("Created %s element %p.", name, element);
+    g_free(name);
+
+    if (!*first)
+        *first = element;
+
+    *last = element;
+    return true;
+}
+
+NTSTATUS wg_transform_create(void *args)
+{
+    struct wg_transform_create_params *params = args;
+    struct wg_encoded_format input_format = *params->input_format;
+    struct wg_format output_format = *params->output_format;
+    GstElement *first = NULL, *last = NULL, *element;
+    GstCaps *raw_caps, *src_caps, *sink_caps;
+    struct wg_transform *transform;
+    GstPadTemplate *template;
+    const gchar *media_type;
+    GstSegment *segment;
+    int i, ret;
+
+    if (!init_gstreamer())
+        return E_FAIL;
+
+    if (!(transform = calloc(1, sizeof(*transform))))
+        return E_OUTOFMEMORY;
+
+    list_init(&transform->samples);
+
+    src_caps = wg_encoded_format_to_caps(&input_format);
+    assert(src_caps);
+    sink_caps = wg_format_to_caps(&output_format);
+    assert(sink_caps);
+    media_type = gst_structure_get_name(gst_caps_get_structure(sink_caps, 0));
+    raw_caps = gst_caps_new_empty_simple(media_type);
+    assert(raw_caps);
+
+    transform->sink_caps = gst_caps_copy(sink_caps);
+    transform->container = gst_bin_new("wg_transform");
+    assert(transform->container);
+
+    if (!(element = try_create_transform(src_caps, raw_caps)) ||
+            !transform_append_element(transform, element, &first, &last))
+        goto failed;
+
+    switch (output_format.major_type)
+    {
+    case WG_MAJOR_TYPE_AUDIO:
+        if (!(element = create_element("audioconvert", "base")) ||
+                !transform_append_element(transform, element, &first, &last))
+            goto failed;
+        if (!(element = create_element("audioresample", "base")) ||
+                !transform_append_element(transform, element, &first, &last))
+            goto failed;
+        break;
+    case WG_MAJOR_TYPE_VIDEO:
+        if (!(element = create_element("videoconvert", "base")) ||
+                !transform_append_element(transform, element, &first, &last))
+            goto failed;
+        for (i = 0; i < gst_caps_get_size(sink_caps); ++i)
+            gst_structure_remove_fields(gst_caps_get_structure(sink_caps, i),
+                    "width", "height", NULL);
+        break;
+    default:
+        assert(0);
+        break;
+    }
+
+    if (!(transform->their_sink = gst_element_get_static_pad(first, "sink")))
+    {
+        GST_ERROR("Failed to find target sink pad.");
+        goto failed;
+    }
+    if (!(transform->their_src = gst_element_get_static_pad(last, "src")))
+    {
+        GST_ERROR("Failed to find target src pad.");
+        goto failed;
+    }
+
+    template = gst_pad_template_new("src", GST_PAD_SRC, GST_PAD_ALWAYS, src_caps);
+    assert(template);
+    transform->my_src = gst_pad_new_from_template(template, "src");
+    g_object_unref(template);
+    assert(transform->my_src);
+
+    template = gst_pad_template_new("sink", GST_PAD_SINK, GST_PAD_ALWAYS, sink_caps);
+    assert(template);
+    transform->my_sink = gst_pad_new_from_template(template, "sink");
+    g_object_unref(template);
+    assert(transform->my_sink);
+
+    gst_pad_set_element_private(transform->my_sink, transform);
+    gst_pad_set_event_function(transform->my_sink, transform_sink_event_cb);
+    gst_pad_set_chain_function(transform->my_sink, transform_sink_chain_cb);
+
+    if ((ret = gst_pad_link(transform->my_src, transform->their_sink)) < 0)
+    {
+        GST_ERROR("Failed to link sink pads, error %d.", ret);
+        goto failed;
+    }
+    if ((ret = gst_pad_link(transform->their_src, transform->my_sink)) < 0)
+    {
+        GST_ERROR("Failed to link source pads, error %d.", ret);
+        goto failed;
+    }
+
+    if (!(ret = gst_pad_set_active(transform->my_sink, 1)))
+        GST_WARNING("Failed to activate my_sink.");
+    if (!(ret = gst_pad_set_active(transform->my_src, 1)))
+        GST_WARNING("Failed to activate my_src.");
+
+    gst_element_set_state(transform->container, GST_STATE_PAUSED);
+    ret = gst_element_get_state(transform->container, NULL, NULL, -1);
+    if (ret == GST_STATE_CHANGE_FAILURE)
+    {
+        GST_ERROR("Failed to play stream.\n");
+        goto failed;
+    }
+
+    if (!gst_pad_push_event(transform->my_src, gst_event_new_stream_start("stream")))
+    {
+        GST_ERROR("Failed to send stream-start.");
+        goto failed;
+    }
+
+    if (!gst_pad_push_event(transform->my_src, gst_event_new_caps(src_caps)) ||
+        !gst_pad_has_current_caps(transform->their_sink))
+    {
+        GST_ERROR("Failed to set stream caps.");
+        goto failed;
+    }
+
+    segment = gst_segment_new();
+    gst_segment_init(segment, GST_FORMAT_TIME);
+    segment->start = 0;
+    segment->stop = -1;
+    ret = gst_pad_push_event(transform->my_src, gst_event_new_segment(segment));
+    gst_segment_free(segment);
+    if (!ret)
+    {
+        GST_ERROR("Failed to start new segment.");
+        goto failed;
+    }
+
+    GST_INFO("Created winegstreamer transform %p.", transform);
+    params->transform = transform;
+
+failed:
+    gst_caps_unref(raw_caps);
+    gst_caps_unref(src_caps);
+    gst_caps_unref(sink_caps);
+
+    if (params->transform)
+        return S_OK;
+
+    wg_transform_destroy(transform);
+    return E_FAIL;
+}
+
+NTSTATUS wg_transform_push_data(void *args)
+{
+    struct wg_transform_push_data_params *params = args;
+    struct wg_transform *transform = params->transform;
+    GstBuffer *buffer;
+    GstFlowReturn ret;
+
+    buffer = gst_buffer_new_and_alloc(params->size);
+    gst_buffer_fill(buffer, 0, params->data, params->size);
+
+    ret = gst_pad_push(transform->my_src, buffer);
+    if (ret)
+    {
+        GST_ERROR("Failed to push buffer %d", ret);
+        return MF_E_NOTACCEPTING;
+    }
+
+    GST_INFO("Pushed %u bytes", params->size);
+    return S_OK;
+}
+
+NTSTATUS wg_transform_read_data(void *args)
+{
+    struct wg_transform_read_data_params *params = args;
+    struct wg_transform *transform = params->transform;
+    struct wg_sample *read_sample = params->sample;
+    struct wg_transform_sample *transform_sample;
+    struct wg_format buffer_format;
+    bool broken_timestamp = false;
+    GstBuffer *buffer;
+    struct list *head;
+    GstMapInfo info;
+    GstCaps *caps;
+
+    pthread_mutex_lock(&transform->mutex);
+    if (!(head = list_head(&transform->samples)))
+    {
+        pthread_mutex_unlock(&transform->mutex);
+        return MF_E_TRANSFORM_NEED_MORE_INPUT;
+    }
+
+    transform_sample = LIST_ENTRY(head, struct wg_transform_sample, entry);
+    buffer = gst_sample_get_buffer(transform_sample->sample);
+
+    if (read_sample->format)
+    {
+        if (!(caps = gst_sample_get_caps(transform_sample->sample)))
+            caps = transform->sink_caps;
+        wg_format_from_caps(&buffer_format, caps);
+        if (!wg_format_compare(read_sample->format, &buffer_format))
+        {
+            *read_sample->format = buffer_format;
+            read_sample->size = gst_buffer_get_size(buffer);
+            pthread_mutex_unlock(&transform->mutex);
+            return MF_E_TRANSFORM_STREAM_CHANGE;
+        }
+
+        if (buffer_format.major_type == WG_MAJOR_TYPE_VIDEO
+                && buffer_format.u.video.fps_n <= 1
+                && buffer_format.u.video.fps_d <= 1)
+            broken_timestamp = true;
+    }
+
+    gst_buffer_map(buffer, &info, GST_MAP_READ);
+    if (read_sample->size > info.size)
+        read_sample->size = info.size;
+    memcpy(read_sample->data, info.data, read_sample->size);
+    gst_buffer_unmap(buffer, &info);
+
+    if (buffer->pts != GST_CLOCK_TIME_NONE && !broken_timestamp)
+    {
+        read_sample->flags |= WG_SAMPLE_FLAG_HAS_PTS;
+        read_sample->pts = buffer->pts / 100;
+    }
+    if (buffer->duration != GST_CLOCK_TIME_NONE && !broken_timestamp)
+    {
+        read_sample->flags |= WG_SAMPLE_FLAG_HAS_DURATION;
+        read_sample->duration = buffer->duration / 100;
+    }
+
+    if (info.size > read_sample->size)
+    {
+        read_sample->flags |= WG_SAMPLE_FLAG_INCOMPLETE;
+        gst_buffer_resize(buffer, read_sample->size, -1);
+    }
+    else
+    {
+        gst_sample_unref(transform_sample->sample);
+        list_remove(&transform_sample->entry);
+        free(transform_sample);
+    }
+    pthread_mutex_unlock(&transform->mutex);
+
+    GST_INFO("Read %u bytes, flags %#x", read_sample->size, read_sample->flags);
+    return S_OK;
+}
diff --git a/dlls/mfplat/winegstreamer.rgs b/dlls/mfplat/winegstreamer.rgs
new file mode 100644
index 00000000000..923ba673f8c
--- /dev/null
+++ wine/dlls/mfplat/winegstreamer.rgs
@@ -0,0 +1,14 @@
+HKCR
+{
+    NoRemove 'Media Type'
+    {
+        '{e436eb83-524f-11ce-9f53-0020af0ba770}'
+        {
+            ForceRemove '{ffffffff-128f-4dd1-ad22-becfa66ce7aa}'
+            {
+                val '0' = s '0,1,00,0'
+                val 'Source Filter' = s '{e436ebb5-524f-11ce-9f53-0020af0ba770}'
+            }
+        }
+    }
+}
diff --git a/dlls/mfplat/winegstreamer.spec b/dlls/mfplat/winegstreamer.spec
new file mode 100644
index 00000000000..bc6a390f8b1
--- /dev/null
+++ wine/dlls/mfplat/winegstreamer.spec
@@ -0,0 +1,6 @@
+@ stdcall -private DllCanUnloadNow()
+@ stdcall -private DllGetClassObject(ptr ptr ptr)
+@ stdcall -private DllRegisterServer()
+@ stdcall -private DllUnregisterServer()
+@ stdcall winegstreamer_create_wm_async_reader(ptr)
+@ stdcall winegstreamer_create_wm_sync_reader(ptr)
diff --git a/dlls/mfplat/winegstreamer_classes.idl b/dlls/mfplat/winegstreamer_classes.idl
new file mode 100644
index 00000000000..5762430a5cd
--- /dev/null
+++ wine/dlls/mfplat/winegstreamer_classes.idl
@@ -0,0 +1,93 @@
+/*
+ * COM classes for winegstreamer
+ *
+ * Copyright 2019 Nikolay Sivov
+ * Copyright 2019 Zebediah Figura
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#pragma makedep register
+
+[
+    helpstring("AVI Splitter"),
+    threading(both),
+    uuid(1b544c20-fd0b-11ce-8c63-00aa0044b51e)
+]
+coclass AviSplitter {}
+
+[
+    helpstring("MPEG-I Stream Splitter"),
+    threading(both),
+    uuid(336475d0-942a-11ce-a870-00aa002feab5)
+]
+coclass MPEG1Splitter {}
+
+[
+    helpstring("Wave Parser"),
+    threading(both),
+    uuid(d51bd5a1-7548-11cf-a520-0080c77ef58a)
+]
+coclass WAVEParser {}
+
+[
+    helpstring("GStreamer parser using decodebin"),
+    threading(both),
+    uuid(f9d8d64e-a144-47dc-8ee0-f53498372c29)
+]
+coclass decodebin_parser {}
+
+[
+    threading(both),
+    uuid(88753b26-5b24-49bd-b2e7-0c445c78c982)
+]
+coclass VideoProcessorMFT {}
+
+[
+    helpstring("Generic Decodebin Byte Stream Handler"),
+    threading(both),
+    uuid(317df618-5e5a-468a-9f15-d827a9a08162)
+]
+coclass GStreamerByteStreamHandler {}
+
+[
+    threading(both),
+    uuid(6a170414-aad9-4693-b806-3a0c47c570d6)
+]
+coclass WINEAudioConverter { }
+
+[
+    threading(both),
+    uuid(2eeb4adf-4578-4d10-bca7-bb955f56320a)
+]
+coclass CWMADecMediaObject {};
+
+[
+    threading(both),
+    uuid(62ce7e72-4c71-4d20-b15d-452831a87d9d)
+]
+coclass CMSH264DecoderMFT { }
+
+[
+    threading(both),
+    uuid(32d186a7-218f-4c75-8876-dd77273a8999)
+]
+coclass CMSAACDecMFT { }
+
+[
+    threading(both),
+    uuid(98230571-0087-4204-b020-3282538e57d3)
+]
+coclass CColorConvertDMO { }
diff --git a/dlls/mfplat/wm_asyncreader.c b/dlls/mfplat/wm_asyncreader.c
new file mode 100644
index 00000000000..a7ad6a6c45c
--- /dev/null
+++ wine/dlls/mfplat/wm_asyncreader.c
@@ -0,0 +1,1590 @@
+/*
+ * Copyright 2012 Austin English
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "gst_private.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(wmvcore);
+
+struct async_reader
+{
+    struct wm_reader reader;
+
+    IWMReader IWMReader_iface;
+    IWMReaderAdvanced6 IWMReaderAdvanced6_iface;
+    IWMReaderAccelerator IWMReaderAccelerator_iface;
+    IWMReaderNetworkConfig2 IWMReaderNetworkConfig2_iface;
+    IWMReaderStreamClock IWMReaderStreamClock_iface;
+    IWMReaderTypeNegotiation IWMReaderTypeNegotiation_iface;
+    IReferenceClock IReferenceClock_iface;
+
+    IWMReaderCallback *callback;
+    void *context;
+
+    LARGE_INTEGER clock_frequency;
+    HANDLE stream_thread;
+    CRITICAL_SECTION stream_cs;
+    CONDITION_VARIABLE stream_cv;
+
+    bool running;
+
+    bool user_clock;
+    QWORD user_time;
+};
+
+static REFERENCE_TIME get_current_time(const struct async_reader *reader)
+{
+    LARGE_INTEGER time;
+
+    QueryPerformanceCounter(&time);
+    return (time.QuadPart * 1000) / reader->clock_frequency.QuadPart * 10000;
+}
+
+static void open_stream(struct async_reader *reader, IWMReaderCallback *callback, void *context)
+{
+    static const DWORD zero;
+    HRESULT hr;
+
+    IWMReaderCallback_AddRef(reader->callback = callback);
+    reader->context = context;
+    IWMReaderCallback_OnStatus(callback, WMT_OPENED, S_OK, WMT_TYPE_DWORD, (BYTE *)&zero, context);
+
+    if (FAILED(hr = IWMReaderCallback_QueryInterface(callback,
+            &IID_IWMReaderCallbackAdvanced, (void **)&reader->reader.callback_advanced)))
+        reader->reader.callback_advanced = NULL;
+    TRACE("Querying for IWMReaderCallbackAdvanced returned %#x.\n", hr);
+}
+
+static DWORD WINAPI stream_thread(void *arg)
+{
+    struct async_reader *reader = arg;
+    IWMReaderCallback *callback = reader->callback;
+    REFERENCE_TIME start_time;
+    static const DWORD zero;
+    QWORD pts, duration;
+    WORD stream_number;
+    INSSBuffer *sample;
+    DWORD flags;
+    HRESULT hr;
+
+    start_time = get_current_time(reader);
+
+    EnterCriticalSection(&reader->stream_cs);
+
+    while (reader->running)
+    {
+        hr = wm_reader_get_stream_sample(&reader->reader, 0, &sample, &pts, &duration, &flags, &stream_number);
+
+        if (hr == S_OK)
+        {
+            struct wm_stream *stream = wm_reader_get_stream_by_stream_number(&reader->reader, stream_number);
+
+            if (reader->user_clock)
+            {
+                QWORD user_time = reader->user_time;
+
+                if (pts > user_time && reader->reader.callback_advanced)
+                    IWMReaderCallbackAdvanced_OnTime(reader->reader.callback_advanced, user_time, reader->context);
+                while (pts > reader->user_time && reader->running)
+                    SleepConditionVariableCS(&reader->stream_cv, &reader->stream_cs, INFINITE);
+                if (!reader->running)
+                {
+                    INSSBuffer_Release(sample);
+                    goto out;
+                }
+            }
+            else
+            {
+                for (;;)
+                {
+                    REFERENCE_TIME current_time = get_current_time(reader);
+
+                    if (pts <= current_time - start_time)
+                        break;
+
+                    SleepConditionVariableCS(&reader->stream_cv, &reader->stream_cs,
+                            (pts - (current_time - start_time)) / 10000);
+
+                    if (!reader->running)
+                    {
+                        INSSBuffer_Release(sample);
+                        goto out;
+                    }
+                }
+            }
+
+            if (stream->read_compressed)
+                hr = IWMReaderCallbackAdvanced_OnStreamSample(reader->reader.callback_advanced,
+                        stream_number, pts, duration, flags, sample, reader->context);
+            else
+                hr = IWMReaderCallback_OnSample(callback, stream_number - 1, pts, duration,
+                        flags, sample, reader->context);
+            TRACE("Callback returned %#x.\n", hr);
+            INSSBuffer_Release(sample);
+        }
+        else if (hr == NS_E_NO_MORE_SAMPLES)
+        {
+            IWMReaderCallback_OnStatus(callback, WMT_END_OF_STREAMING, S_OK,
+                    WMT_TYPE_DWORD, (BYTE *)&zero, reader->context);
+            IWMReaderCallback_OnStatus(callback, WMT_EOF, S_OK,
+                    WMT_TYPE_DWORD, (BYTE *)&zero, reader->context);
+
+            if (reader->user_clock && reader->reader.callback_advanced)
+            {
+                /* We can only get here if user_time is greater than the PTS
+                 * of all samples, in which case we cannot have sent this
+                 * notification already. */
+                IWMReaderCallbackAdvanced_OnTime(reader->reader.callback_advanced,
+                        reader->user_time, reader->context);
+            }
+
+            TRACE("Reached end of stream; exiting.\n");
+            LeaveCriticalSection(&reader->stream_cs);
+            return 0;
+        }
+        else
+        {
+            ERR("Failed to get sample, hr %#x.\n", hr);
+            LeaveCriticalSection(&reader->stream_cs);
+            return 0;
+        }
+    }
+
+out:
+    LeaveCriticalSection(&reader->stream_cs);
+
+    TRACE("Reader is stopping; exiting.\n");
+    return 0;
+}
+
+static void stop_streaming(struct async_reader *reader)
+{
+    if (reader->stream_thread)
+    {
+        EnterCriticalSection(&reader->stream_cs);
+        reader->running = false;
+        LeaveCriticalSection(&reader->stream_cs);
+        WakeConditionVariable(&reader->stream_cv);
+        WaitForSingleObject(reader->stream_thread, INFINITE);
+        CloseHandle(reader->stream_thread);
+        reader->stream_thread = NULL;
+    }
+}
+
+static struct async_reader *impl_from_IWMReader(IWMReader *iface)
+{
+    return CONTAINING_RECORD(iface, struct async_reader, IWMReader_iface);
+}
+
+static HRESULT WINAPI WMReader_QueryInterface(IWMReader *iface, REFIID iid, void **out)
+{
+    struct async_reader *reader = impl_from_IWMReader(iface);
+
+    return IWMProfile3_QueryInterface(&reader->reader.IWMProfile3_iface, iid, out);
+}
+
+static ULONG WINAPI WMReader_AddRef(IWMReader *iface)
+{
+    struct async_reader *reader = impl_from_IWMReader(iface);
+
+    return IWMProfile3_AddRef(&reader->reader.IWMProfile3_iface);
+}
+
+static ULONG WINAPI WMReader_Release(IWMReader *iface)
+{
+    struct async_reader *reader = impl_from_IWMReader(iface);
+
+    return IWMProfile3_Release(&reader->reader.IWMProfile3_iface);
+}
+
+static HRESULT WINAPI WMReader_Open(IWMReader *iface, const WCHAR *url,
+        IWMReaderCallback *callback, void *context)
+{
+    struct async_reader *reader = impl_from_IWMReader(iface);
+    HRESULT hr;
+
+    TRACE("reader %p, url %s, callback %p, context %p.\n",
+            reader, debugstr_w(url), callback, context);
+
+    EnterCriticalSection(&reader->reader.cs);
+
+    if (SUCCEEDED(hr = wm_reader_open_file(&reader->reader, url)))
+        open_stream(reader, callback, context);
+
+    LeaveCriticalSection(&reader->reader.cs);
+    return hr;
+}
+
+static HRESULT WINAPI WMReader_Close(IWMReader *iface)
+{
+    struct async_reader *reader = impl_from_IWMReader(iface);
+    static const DWORD zero;
+    HRESULT hr;
+
+    TRACE("reader %p.\n", reader);
+
+    EnterCriticalSection(&reader->reader.cs);
+
+    stop_streaming(reader);
+
+    hr = wm_reader_close(&reader->reader);
+    if (reader->callback)
+    {
+        IWMReaderCallback_OnStatus(reader->callback, WMT_CLOSED, S_OK,
+                WMT_TYPE_DWORD, (BYTE *)&zero, reader->context);
+        IWMReaderCallback_Release(reader->callback);
+    }
+    reader->callback = NULL;
+
+    LeaveCriticalSection(&reader->reader.cs);
+
+    return hr;
+}
+
+static HRESULT WINAPI WMReader_GetOutputCount(IWMReader *iface, DWORD *count)
+{
+    struct async_reader *reader = impl_from_IWMReader(iface);
+
+    TRACE("reader %p, count %p.\n", reader, count);
+
+    EnterCriticalSection(&reader->reader.cs);
+    *count = reader->reader.stream_count;
+    LeaveCriticalSection(&reader->reader.cs);
+    return S_OK;
+}
+
+static HRESULT WINAPI WMReader_GetOutputProps(IWMReader *iface, DWORD output, IWMOutputMediaProps **props)
+{
+    struct async_reader *reader = impl_from_IWMReader(iface);
+
+    TRACE("reader %p, output %u, props %p.\n", reader, output, props);
+
+    return wm_reader_get_output_props(&reader->reader, output, props);
+}
+
+static HRESULT WINAPI WMReader_SetOutputProps(IWMReader *iface, DWORD output, IWMOutputMediaProps *props)
+{
+    struct async_reader *reader = impl_from_IWMReader(iface);
+
+    TRACE("reader %p, output %u, props %p.\n", reader, output, props);
+
+    return wm_reader_set_output_props(&reader->reader, output, props);
+}
+
+static HRESULT WINAPI WMReader_GetOutputFormatCount(IWMReader *iface, DWORD output, DWORD *count)
+{
+    struct async_reader *reader = impl_from_IWMReader(iface);
+
+    TRACE("reader %p, output %u, count %p.\n", reader, output, count);
+
+    return wm_reader_get_output_format_count(&reader->reader, output, count);
+}
+
+static HRESULT WINAPI WMReader_GetOutputFormat(IWMReader *iface, DWORD output,
+        DWORD index, IWMOutputMediaProps **props)
+{
+    struct async_reader *reader = impl_from_IWMReader(iface);
+
+    TRACE("reader %p, output %u, index %u, props %p.\n", reader, output, index, props);
+
+    return wm_reader_get_output_format(&reader->reader, output, index, props);
+}
+
+static HRESULT WINAPI WMReader_Start(IWMReader *iface,
+        QWORD start, QWORD duration, float rate, void *context)
+{
+    struct async_reader *reader = impl_from_IWMReader(iface);
+    static const DWORD zero;
+
+    TRACE("reader %p, start %s, duration %s, rate %.8e, context %p.\n",
+            reader, debugstr_time(start), debugstr_time(duration), rate, context);
+
+    if (rate != 1.0f)
+        FIXME("Ignoring rate %.8e.\n", rate);
+
+    EnterCriticalSection(&reader->reader.cs);
+
+    stop_streaming(reader);
+
+    IWMReaderCallback_OnStatus(reader->callback, WMT_STARTED, S_OK, WMT_TYPE_DWORD, (BYTE *)&zero, context);
+    reader->context = context;
+
+    wm_reader_seek(&reader->reader, start, duration);
+
+    reader->running = true;
+    reader->user_time = 0;
+
+    if (!(reader->stream_thread = CreateThread(NULL, 0, stream_thread, reader, 0, NULL)))
+    {
+        LeaveCriticalSection(&reader->reader.cs);
+        return E_OUTOFMEMORY;
+    }
+
+    LeaveCriticalSection(&reader->reader.cs);
+    WakeConditionVariable(&reader->stream_cv);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI WMReader_Stop(IWMReader *iface)
+{
+    struct async_reader *reader = impl_from_IWMReader(iface);
+    static const DWORD zero;
+
+    TRACE("reader %p.\n", reader);
+
+    EnterCriticalSection(&reader->reader.cs);
+
+    if (!reader->reader.wg_parser)
+    {
+        LeaveCriticalSection(&reader->reader.cs);
+        WARN("No stream is open; returning E_UNEXPECTED.\n");
+        return E_UNEXPECTED;
+    }
+
+    stop_streaming(reader);
+    IWMReaderCallback_OnStatus(reader->callback, WMT_STOPPED, S_OK,
+            WMT_TYPE_DWORD, (BYTE *)&zero, reader->context);
+    LeaveCriticalSection(&reader->reader.cs);
+    return S_OK;
+}
+
+static HRESULT WINAPI WMReader_Pause(IWMReader *iface)
+{
+    struct async_reader *This = impl_from_IWMReader(iface);
+    FIXME("(%p)\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI WMReader_Resume(IWMReader *iface)
+{
+    struct async_reader *This = impl_from_IWMReader(iface);
+    FIXME("(%p)\n", This);
+    return E_NOTIMPL;
+}
+
+static const IWMReaderVtbl WMReaderVtbl = {
+    WMReader_QueryInterface,
+    WMReader_AddRef,
+    WMReader_Release,
+    WMReader_Open,
+    WMReader_Close,
+    WMReader_GetOutputCount,
+    WMReader_GetOutputProps,
+    WMReader_SetOutputProps,
+    WMReader_GetOutputFormatCount,
+    WMReader_GetOutputFormat,
+    WMReader_Start,
+    WMReader_Stop,
+    WMReader_Pause,
+    WMReader_Resume
+};
+
+static struct async_reader *impl_from_IWMReaderAdvanced6(IWMReaderAdvanced6 *iface)
+{
+    return CONTAINING_RECORD(iface, struct async_reader, IWMReaderAdvanced6_iface);
+}
+
+static HRESULT WINAPI WMReaderAdvanced_QueryInterface(IWMReaderAdvanced6 *iface, REFIID riid, void **ppv)
+{
+    struct async_reader *This = impl_from_IWMReaderAdvanced6(iface);
+    return IWMReader_QueryInterface(&This->IWMReader_iface, riid, ppv);
+}
+
+static ULONG WINAPI WMReaderAdvanced_AddRef(IWMReaderAdvanced6 *iface)
+{
+    struct async_reader *This = impl_from_IWMReaderAdvanced6(iface);
+    return IWMReader_AddRef(&This->IWMReader_iface);
+}
+
+static ULONG WINAPI WMReaderAdvanced_Release(IWMReaderAdvanced6 *iface)
+{
+    struct async_reader *This = impl_from_IWMReaderAdvanced6(iface);
+    return IWMReader_Release(&This->IWMReader_iface);
+}
+
+static HRESULT WINAPI WMReaderAdvanced_SetUserProvidedClock(IWMReaderAdvanced6 *iface, BOOL user_clock)
+{
+    struct async_reader *reader = impl_from_IWMReaderAdvanced6(iface);
+
+    TRACE("reader %p, user_clock %d.\n", reader, user_clock);
+
+    EnterCriticalSection(&reader->stream_cs);
+    reader->user_clock = !!user_clock;
+    LeaveCriticalSection(&reader->stream_cs);
+    return S_OK;
+}
+
+static HRESULT WINAPI WMReaderAdvanced_GetUserProvidedClock(IWMReaderAdvanced6 *iface, BOOL *user_clock)
+{
+    struct async_reader *This = impl_from_IWMReaderAdvanced6(iface);
+    FIXME("(%p)->(%p)\n", This, user_clock);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI WMReaderAdvanced_DeliverTime(IWMReaderAdvanced6 *iface, QWORD time)
+{
+    struct async_reader *reader = impl_from_IWMReaderAdvanced6(iface);
+
+    TRACE("reader %p, time %s.\n", reader, debugstr_time(time));
+
+    EnterCriticalSection(&reader->stream_cs);
+
+    if (!reader->user_clock)
+    {
+        LeaveCriticalSection(&reader->stream_cs);
+        WARN("Not using a user-provided clock; returning E_UNEXPECTED.\n");
+        return E_UNEXPECTED;
+    }
+
+    reader->user_time = time;
+
+    LeaveCriticalSection(&reader->stream_cs);
+    WakeConditionVariable(&reader->stream_cv);
+    return S_OK;
+}
+
+static HRESULT WINAPI WMReaderAdvanced_SetManualStreamSelection(IWMReaderAdvanced6 *iface, BOOL selection)
+{
+    struct async_reader *This = impl_from_IWMReaderAdvanced6(iface);
+    FIXME("(%p)->(%x)\n", This, selection);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI WMReaderAdvanced_GetManualStreamSelection(IWMReaderAdvanced6 *iface, BOOL *selection)
+{
+    struct async_reader *This = impl_from_IWMReaderAdvanced6(iface);
+    FIXME("(%p)->(%p)\n", This, selection);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI WMReaderAdvanced_SetStreamsSelected(IWMReaderAdvanced6 *iface,
+        WORD count, WORD *stream_numbers, WMT_STREAM_SELECTION *selections)
+{
+    struct async_reader *reader = impl_from_IWMReaderAdvanced6(iface);
+
+    TRACE("reader %p, count %u, stream_numbers %p, selections %p.\n",
+            reader, count, stream_numbers, selections);
+
+    return wm_reader_set_streams_selected(&reader->reader, count, stream_numbers, selections);
+}
+
+static HRESULT WINAPI WMReaderAdvanced_GetStreamSelected(IWMReaderAdvanced6 *iface,
+        WORD stream_number, WMT_STREAM_SELECTION *selection)
+{
+    struct async_reader *reader = impl_from_IWMReaderAdvanced6(iface);
+
+    TRACE("reader %p, stream_number %u, selection %p.\n", reader, stream_number, selection);
+
+    return wm_reader_get_stream_selection(&reader->reader, stream_number, selection);
+}
+
+static HRESULT WINAPI WMReaderAdvanced_SetReceiveSelectionCallbacks(IWMReaderAdvanced6 *iface, BOOL get_callbacks)
+{
+    struct async_reader *This = impl_from_IWMReaderAdvanced6(iface);
+    FIXME("(%p)->(%x)\n", This, get_callbacks);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI WMReaderAdvanced_GetReceiveSelectionCallbacks(IWMReaderAdvanced6 *iface, BOOL *get_callbacks)
+{
+    struct async_reader *This = impl_from_IWMReaderAdvanced6(iface);
+    FIXME("(%p)->(%p)\n", This, get_callbacks);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI WMReaderAdvanced_SetReceiveStreamSamples(IWMReaderAdvanced6 *iface,
+        WORD stream_number, BOOL compressed)
+{
+    struct async_reader *reader = impl_from_IWMReaderAdvanced6(iface);
+
+    TRACE("reader %p, stream_number %u, compressed %d.\n", reader, stream_number, compressed);
+
+    return wm_reader_set_read_compressed(&reader->reader, stream_number, compressed);
+}
+
+static HRESULT WINAPI WMReaderAdvanced_GetReceiveStreamSamples(IWMReaderAdvanced6 *iface, WORD stream_num,
+        BOOL *receive_stream_samples)
+{
+    struct async_reader *This = impl_from_IWMReaderAdvanced6(iface);
+    FIXME("(%p)->(%d %p)\n", This, stream_num, receive_stream_samples);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI WMReaderAdvanced_SetAllocateForOutput(IWMReaderAdvanced6 *iface,
+        DWORD output, BOOL allocate)
+{
+    struct async_reader *reader = impl_from_IWMReaderAdvanced6(iface);
+
+    TRACE("reader %p, output %u, allocate %d.\n", reader, output, allocate);
+
+    return wm_reader_set_allocate_for_output(&reader->reader, output, allocate);
+}
+
+static HRESULT WINAPI WMReaderAdvanced_GetAllocateForOutput(IWMReaderAdvanced6 *iface, DWORD output_num, BOOL *allocate)
+{
+    struct async_reader *This = impl_from_IWMReaderAdvanced6(iface);
+    FIXME("(%p)->(%d %p)\n", This, output_num, allocate);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI WMReaderAdvanced_SetAllocateForStream(IWMReaderAdvanced6 *iface,
+        WORD stream_number, BOOL allocate)
+{
+    struct async_reader *reader = impl_from_IWMReaderAdvanced6(iface);
+
+    TRACE("reader %p, stream_number %u, allocate %d.\n", reader, stream_number, allocate);
+
+    return wm_reader_set_allocate_for_stream(&reader->reader, stream_number, allocate);
+}
+
+static HRESULT WINAPI WMReaderAdvanced_GetAllocateForStream(IWMReaderAdvanced6 *iface, WORD output_num, BOOL *allocate)
+{
+    struct async_reader *This = impl_from_IWMReaderAdvanced6(iface);
+    FIXME("(%p)->(%d %p)\n", This, output_num, allocate);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI WMReaderAdvanced_GetStatistics(IWMReaderAdvanced6 *iface, WM_READER_STATISTICS *statistics)
+{
+    struct async_reader *This = impl_from_IWMReaderAdvanced6(iface);
+    FIXME("(%p)->(%p)\n", This, statistics);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI WMReaderAdvanced_SetClientInfo(IWMReaderAdvanced6 *iface, WM_READER_CLIENTINFO *client_info)
+{
+    struct async_reader *This = impl_from_IWMReaderAdvanced6(iface);
+    FIXME("(%p)->(%p)\n", This, client_info);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI WMReaderAdvanced_GetMaxOutputSampleSize(IWMReaderAdvanced6 *iface, DWORD output, DWORD *max)
+{
+    struct async_reader *This = impl_from_IWMReaderAdvanced6(iface);
+    FIXME("(%p)->(%d %p)\n", This, output, max);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI WMReaderAdvanced_GetMaxStreamSampleSize(IWMReaderAdvanced6 *iface,
+        WORD stream_number, DWORD *size)
+{
+    struct async_reader *reader = impl_from_IWMReaderAdvanced6(iface);
+
+    TRACE("reader %p, stream_number %u, size %p.\n", reader, stream_number, size);
+
+    return wm_reader_get_max_stream_size(&reader->reader, stream_number, size);
+}
+
+static HRESULT WINAPI WMReaderAdvanced_NotifyLateDelivery(IWMReaderAdvanced6 *iface, QWORD lateness)
+{
+    struct async_reader *This = impl_from_IWMReaderAdvanced6(iface);
+    FIXME("(%p)->(%s)\n", This, wine_dbgstr_longlong(lateness));
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI WMReaderAdvanced2_SetPlayMode(IWMReaderAdvanced6 *iface, WMT_PLAY_MODE mode)
+{
+    struct async_reader *This = impl_from_IWMReaderAdvanced6(iface);
+    FIXME("(%p)->(%d)\n", This, mode);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI WMReaderAdvanced2_GetPlayMode(IWMReaderAdvanced6 *iface, WMT_PLAY_MODE *mode)
+{
+    struct async_reader *This = impl_from_IWMReaderAdvanced6(iface);
+    FIXME("(%p)->(%p)\n", This, mode);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI WMReaderAdvanced2_GetBufferProgress(IWMReaderAdvanced6 *iface, DWORD *percent, QWORD *buffering)
+{
+    struct async_reader *This = impl_from_IWMReaderAdvanced6(iface);
+    FIXME("(%p)->(%p %p)\n", This, percent, buffering);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI WMReaderAdvanced2_GetDownloadProgress(IWMReaderAdvanced6 *iface, DWORD *percent,
+        QWORD *bytes_downloaded, QWORD *download)
+{
+    struct async_reader *This = impl_from_IWMReaderAdvanced6(iface);
+    FIXME("(%p)->(%p %p %p)\n", This, percent, bytes_downloaded, download);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI WMReaderAdvanced2_GetSaveAsProgress(IWMReaderAdvanced6 *iface, DWORD *percent)
+{
+    struct async_reader *This = impl_from_IWMReaderAdvanced6(iface);
+    FIXME("(%p)->(%p)\n", This, percent);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI WMReaderAdvanced2_SaveFileAs(IWMReaderAdvanced6 *iface, const WCHAR *filename)
+{
+    struct async_reader *This = impl_from_IWMReaderAdvanced6(iface);
+    FIXME("(%p)->(%s)\n", This, debugstr_w(filename));
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI WMReaderAdvanced2_GetProtocolName(IWMReaderAdvanced6 *iface, WCHAR *protocol, DWORD *protocol_len)
+{
+    struct async_reader *This = impl_from_IWMReaderAdvanced6(iface);
+    FIXME("(%p)->(%p %p)\n", This, protocol, protocol_len);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI WMReaderAdvanced2_StartAtMarker(IWMReaderAdvanced6 *iface, WORD marker_index,
+        QWORD duration, float rate, void *context)
+{
+    struct async_reader *This = impl_from_IWMReaderAdvanced6(iface);
+    FIXME("(%p)->(%d %s %f %p)\n", This, marker_index, wine_dbgstr_longlong(duration), rate, context);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI WMReaderAdvanced2_GetOutputSetting(IWMReaderAdvanced6 *iface, DWORD output_num,
+        const WCHAR *name, WMT_ATTR_DATATYPE *type, BYTE *value, WORD *length)
+{
+    struct async_reader *This = impl_from_IWMReaderAdvanced6(iface);
+    FIXME("(%p)->(%d %s %p %p %p)\n", This, output_num, debugstr_w(name), type, value, length);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI WMReaderAdvanced2_SetOutputSetting(IWMReaderAdvanced6 *iface, DWORD output_num,
+        const WCHAR *name, WMT_ATTR_DATATYPE type, const BYTE *value, WORD length)
+{
+    struct async_reader *This = impl_from_IWMReaderAdvanced6(iface);
+    FIXME("(%p)->(%d %s %d %p %d)\n", This, output_num, debugstr_w(name), type, value, length);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI WMReaderAdvanced2_Preroll(IWMReaderAdvanced6 *iface, QWORD start, QWORD duration, float rate)
+{
+    struct async_reader *This = impl_from_IWMReaderAdvanced6(iface);
+    FIXME("(%p)->(%s %s %f)\n", This, wine_dbgstr_longlong(start), wine_dbgstr_longlong(duration), rate);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI WMReaderAdvanced2_SetLogClientID(IWMReaderAdvanced6 *iface, BOOL log_client_id)
+{
+    struct async_reader *This = impl_from_IWMReaderAdvanced6(iface);
+    FIXME("(%p)->(%x)\n", This, log_client_id);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI WMReaderAdvanced2_GetLogClientID(IWMReaderAdvanced6 *iface, BOOL *log_client_id)
+{
+    struct async_reader *This = impl_from_IWMReaderAdvanced6(iface);
+    FIXME("(%p)->(%p)\n", This, log_client_id);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI WMReaderAdvanced2_StopBuffering(IWMReaderAdvanced6 *iface)
+{
+    struct async_reader *This = impl_from_IWMReaderAdvanced6(iface);
+    FIXME("(%p)\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI WMReaderAdvanced2_OpenStream(IWMReaderAdvanced6 *iface,
+        IStream *stream, IWMReaderCallback *callback, void *context)
+{
+    struct async_reader *reader = impl_from_IWMReaderAdvanced6(iface);
+    HRESULT hr;
+
+    TRACE("reader %p, stream %p, callback %p, context %p.\n", reader, stream, callback, context);
+
+    EnterCriticalSection(&reader->reader.cs);
+
+    if (SUCCEEDED(hr = wm_reader_open_stream(&reader->reader, stream)))
+        open_stream(reader, callback, context);
+
+    LeaveCriticalSection(&reader->reader.cs);
+    return hr;
+}
+
+static HRESULT WINAPI WMReaderAdvanced3_StopNetStreaming(IWMReaderAdvanced6 *iface)
+{
+    struct async_reader *This = impl_from_IWMReaderAdvanced6(iface);
+    FIXME("(%p)\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI WMReaderAdvanced3_StartAtPosition(IWMReaderAdvanced6 *iface, WORD stream_num,
+        void *offset_start, void *duration, WMT_OFFSET_FORMAT format, float rate, void *context)
+{
+    struct async_reader *This = impl_from_IWMReaderAdvanced6(iface);
+    FIXME("(%p)->(%d %p %p %d %f %p)\n", This, stream_num, offset_start, duration, format, rate, context);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI WMReaderAdvanced4_GetLanguageCount(IWMReaderAdvanced6 *iface, DWORD output_num, WORD *language_count)
+{
+    struct async_reader *This = impl_from_IWMReaderAdvanced6(iface);
+    FIXME("(%p)->(%d %p)\n", This, output_num, language_count);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI WMReaderAdvanced4_GetLanguage(IWMReaderAdvanced6 *iface, DWORD output_num,
+       WORD language, WCHAR *language_string, WORD *language_string_len)
+{
+    struct async_reader *This = impl_from_IWMReaderAdvanced6(iface);
+    FIXME("(%p)->(%d %x %p %p)\n", This, output_num, language, language_string, language_string_len);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI WMReaderAdvanced4_GetMaxSpeedFactor(IWMReaderAdvanced6 *iface, double *factor)
+{
+    struct async_reader *This = impl_from_IWMReaderAdvanced6(iface);
+    FIXME("(%p)->(%p)\n", This, factor);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI WMReaderAdvanced4_IsUsingFastCache(IWMReaderAdvanced6 *iface, BOOL *using_fast_cache)
+{
+    struct async_reader *This = impl_from_IWMReaderAdvanced6(iface);
+    FIXME("(%p)->(%p)\n", This, using_fast_cache);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI WMReaderAdvanced4_AddLogParam(IWMReaderAdvanced6 *iface, const WCHAR *namespace,
+        const WCHAR *name, const WCHAR *value)
+{
+    struct async_reader *This = impl_from_IWMReaderAdvanced6(iface);
+    FIXME("(%p)->(%s %s %s)\n", This, debugstr_w(namespace), debugstr_w(name), debugstr_w(value));
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI WMReaderAdvanced4_SendLogParams(IWMReaderAdvanced6 *iface)
+{
+    struct async_reader *This = impl_from_IWMReaderAdvanced6(iface);
+    FIXME("(%p)\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI WMReaderAdvanced4_CanSaveFileAs(IWMReaderAdvanced6 *iface, BOOL *can_save)
+{
+    struct async_reader *This = impl_from_IWMReaderAdvanced6(iface);
+    FIXME("(%p)->(%p)\n", This, can_save);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI WMReaderAdvanced4_CancelSaveFileAs(IWMReaderAdvanced6 *iface)
+{
+    struct async_reader *This = impl_from_IWMReaderAdvanced6(iface);
+    FIXME("(%p)\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI WMReaderAdvanced4_GetURL(IWMReaderAdvanced6 *iface, WCHAR *url, DWORD *url_len)
+{
+    struct async_reader *This = impl_from_IWMReaderAdvanced6(iface);
+    FIXME("(%p)->(%p %p)\n", This, url, url_len);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI WMReaderAdvanced5_SetPlayerHook(IWMReaderAdvanced6 *iface, DWORD output_num, IWMPlayerHook *hook)
+{
+    struct async_reader *This = impl_from_IWMReaderAdvanced6(iface);
+    FIXME("(%p)->(%d %p)\n", This, output_num, hook);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI WMReaderAdvanced6_SetProtectStreamSamples(IWMReaderAdvanced6 *iface, BYTE *cert,
+        DWORD cert_size, DWORD cert_type, DWORD flags, BYTE *initialization_vector, DWORD *initialization_vector_size)
+{
+    struct async_reader *This = impl_from_IWMReaderAdvanced6(iface);
+    FIXME("(%p)->(%p %d %d %x %p %p)\n", This, cert, cert_size, cert_type, flags, initialization_vector,
+          initialization_vector_size);
+    return E_NOTIMPL;
+}
+
+static const IWMReaderAdvanced6Vtbl WMReaderAdvanced6Vtbl = {
+    WMReaderAdvanced_QueryInterface,
+    WMReaderAdvanced_AddRef,
+    WMReaderAdvanced_Release,
+    WMReaderAdvanced_SetUserProvidedClock,
+    WMReaderAdvanced_GetUserProvidedClock,
+    WMReaderAdvanced_DeliverTime,
+    WMReaderAdvanced_SetManualStreamSelection,
+    WMReaderAdvanced_GetManualStreamSelection,
+    WMReaderAdvanced_SetStreamsSelected,
+    WMReaderAdvanced_GetStreamSelected,
+    WMReaderAdvanced_SetReceiveSelectionCallbacks,
+    WMReaderAdvanced_GetReceiveSelectionCallbacks,
+    WMReaderAdvanced_SetReceiveStreamSamples,
+    WMReaderAdvanced_GetReceiveStreamSamples,
+    WMReaderAdvanced_SetAllocateForOutput,
+    WMReaderAdvanced_GetAllocateForOutput,
+    WMReaderAdvanced_SetAllocateForStream,
+    WMReaderAdvanced_GetAllocateForStream,
+    WMReaderAdvanced_GetStatistics,
+    WMReaderAdvanced_SetClientInfo,
+    WMReaderAdvanced_GetMaxOutputSampleSize,
+    WMReaderAdvanced_GetMaxStreamSampleSize,
+    WMReaderAdvanced_NotifyLateDelivery,
+    WMReaderAdvanced2_SetPlayMode,
+    WMReaderAdvanced2_GetPlayMode,
+    WMReaderAdvanced2_GetBufferProgress,
+    WMReaderAdvanced2_GetDownloadProgress,
+    WMReaderAdvanced2_GetSaveAsProgress,
+    WMReaderAdvanced2_SaveFileAs,
+    WMReaderAdvanced2_GetProtocolName,
+    WMReaderAdvanced2_StartAtMarker,
+    WMReaderAdvanced2_GetOutputSetting,
+    WMReaderAdvanced2_SetOutputSetting,
+    WMReaderAdvanced2_Preroll,
+    WMReaderAdvanced2_SetLogClientID,
+    WMReaderAdvanced2_GetLogClientID,
+    WMReaderAdvanced2_StopBuffering,
+    WMReaderAdvanced2_OpenStream,
+    WMReaderAdvanced3_StopNetStreaming,
+    WMReaderAdvanced3_StartAtPosition,
+    WMReaderAdvanced4_GetLanguageCount,
+    WMReaderAdvanced4_GetLanguage,
+    WMReaderAdvanced4_GetMaxSpeedFactor,
+    WMReaderAdvanced4_IsUsingFastCache,
+    WMReaderAdvanced4_AddLogParam,
+    WMReaderAdvanced4_SendLogParams,
+    WMReaderAdvanced4_CanSaveFileAs,
+    WMReaderAdvanced4_CancelSaveFileAs,
+    WMReaderAdvanced4_GetURL,
+    WMReaderAdvanced5_SetPlayerHook,
+    WMReaderAdvanced6_SetProtectStreamSamples
+};
+
+static struct async_reader *impl_from_IWMReaderAccelerator(IWMReaderAccelerator *iface)
+{
+    return CONTAINING_RECORD(iface, struct async_reader, IWMReaderAccelerator_iface);
+}
+
+static HRESULT WINAPI reader_accl_QueryInterface(IWMReaderAccelerator *iface, REFIID riid, void **object)
+{
+    struct async_reader *This = impl_from_IWMReaderAccelerator(iface);
+    return IWMReader_QueryInterface(&This->IWMReader_iface, riid, object);
+}
+
+static ULONG WINAPI reader_accl_AddRef(IWMReaderAccelerator *iface)
+{
+    struct async_reader *This = impl_from_IWMReaderAccelerator(iface);
+    return IWMReader_AddRef(&This->IWMReader_iface);
+}
+
+static ULONG WINAPI reader_accl_Release(IWMReaderAccelerator *iface)
+{
+    struct async_reader *This = impl_from_IWMReaderAccelerator(iface);
+    return IWMReader_Release(&This->IWMReader_iface);
+}
+
+static HRESULT WINAPI reader_accl_GetCodecInterface(IWMReaderAccelerator *iface, DWORD output, REFIID riid, void **codec)
+{
+    struct async_reader *This = impl_from_IWMReaderAccelerator(iface);
+
+    FIXME("%p, %d, %s, %p\n", This, output, debugstr_guid(riid), codec);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI reader_accl_Notify(IWMReaderAccelerator *iface, DWORD output, WM_MEDIA_TYPE *subtype)
+{
+    struct async_reader *This = impl_from_IWMReaderAccelerator(iface);
+
+    FIXME("%p, %d, %p\n", This, output, subtype);
+
+    return E_NOTIMPL;
+}
+
+static const IWMReaderAcceleratorVtbl WMReaderAcceleratorVtbl = {
+    reader_accl_QueryInterface,
+    reader_accl_AddRef,
+    reader_accl_Release,
+    reader_accl_GetCodecInterface,
+    reader_accl_Notify
+};
+
+static struct async_reader *impl_from_IWMReaderNetworkConfig2(IWMReaderNetworkConfig2 *iface)
+{
+    return CONTAINING_RECORD(iface, struct async_reader, IWMReaderNetworkConfig2_iface);
+}
+
+static HRESULT WINAPI networkconfig_QueryInterface(IWMReaderNetworkConfig2 *iface, REFIID riid, void **ppv)
+{
+    struct async_reader *This = impl_from_IWMReaderNetworkConfig2(iface);
+    return IWMReader_QueryInterface(&This->IWMReader_iface, riid, ppv);
+}
+
+static ULONG WINAPI networkconfig_AddRef(IWMReaderNetworkConfig2 *iface)
+{
+    struct async_reader *This = impl_from_IWMReaderNetworkConfig2(iface);
+    return IWMReader_AddRef(&This->IWMReader_iface);
+}
+
+static ULONG WINAPI networkconfig_Release(IWMReaderNetworkConfig2 *iface)
+{
+    struct async_reader *This = impl_from_IWMReaderNetworkConfig2(iface);
+    return IWMReader_Release(&This->IWMReader_iface);
+}
+
+static HRESULT WINAPI networkconfig_GetBufferingTime(IWMReaderNetworkConfig2 *iface, QWORD *buffering_time)
+{
+    struct async_reader *This = impl_from_IWMReaderNetworkConfig2(iface);
+    FIXME("%p, %p\n", This, buffering_time);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI networkconfig_SetBufferingTime(IWMReaderNetworkConfig2 *iface, QWORD buffering_time)
+{
+    struct async_reader *This = impl_from_IWMReaderNetworkConfig2(iface);
+    FIXME("%p, %s\n", This, wine_dbgstr_longlong(buffering_time));
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI networkconfig_GetUDPPortRanges(IWMReaderNetworkConfig2 *iface, WM_PORT_NUMBER_RANGE *array,
+        DWORD *ranges)
+{
+    struct async_reader *This = impl_from_IWMReaderNetworkConfig2(iface);
+    FIXME("%p, %p, %p\n", This, array, ranges);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI networkconfig_SetUDPPortRanges(IWMReaderNetworkConfig2 *iface, WM_PORT_NUMBER_RANGE *array,
+        DWORD ranges)
+{
+    struct async_reader *This = impl_from_IWMReaderNetworkConfig2(iface);
+    FIXME("%p, %p, %u\n", This, array, ranges);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI networkconfig_GetProxySettings(IWMReaderNetworkConfig2 *iface, const WCHAR *protocol,
+        WMT_PROXY_SETTINGS *proxy)
+{
+    struct async_reader *This = impl_from_IWMReaderNetworkConfig2(iface);
+    FIXME("%p, %s, %p\n", This, debugstr_w(protocol), proxy);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI networkconfig_SetProxySettings(IWMReaderNetworkConfig2 *iface, LPCWSTR protocol,
+        WMT_PROXY_SETTINGS proxy)
+{
+    struct async_reader *This = impl_from_IWMReaderNetworkConfig2(iface);
+    FIXME("%p, %s, %d\n", This, debugstr_w(protocol), proxy);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI networkconfig_GetProxyHostName(IWMReaderNetworkConfig2 *iface, const WCHAR *protocol,
+        WCHAR *hostname, DWORD *size)
+{
+    struct async_reader *This = impl_from_IWMReaderNetworkConfig2(iface);
+    FIXME("%p, %s, %p, %p\n", This, debugstr_w(protocol), hostname, size);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI networkconfig_SetProxyHostName(IWMReaderNetworkConfig2 *iface, const WCHAR *protocol,
+        const WCHAR *hostname)
+{
+    struct async_reader *This = impl_from_IWMReaderNetworkConfig2(iface);
+    FIXME("%p, %s, %s\n", This, debugstr_w(protocol), debugstr_w(hostname));
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI networkconfig_GetProxyPort(IWMReaderNetworkConfig2 *iface, const WCHAR *protocol,
+        DWORD *port)
+{
+    struct async_reader *This = impl_from_IWMReaderNetworkConfig2(iface);
+    FIXME("%p, %s, %p\n", This, debugstr_w(protocol), port);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI networkconfig_SetProxyPort(IWMReaderNetworkConfig2 *iface, const WCHAR *protocol,
+        DWORD port)
+{
+    struct async_reader *This = impl_from_IWMReaderNetworkConfig2(iface);
+    FIXME("%p, %s, %u\n", This, debugstr_w(protocol), port);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI networkconfig_GetProxyExceptionList(IWMReaderNetworkConfig2 *iface, const WCHAR *protocol,
+        WCHAR *exceptions, DWORD *count)
+{
+    struct async_reader *This = impl_from_IWMReaderNetworkConfig2(iface);
+    FIXME("%p, %s, %p, %p\n", This, debugstr_w(protocol), exceptions, count);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI networkconfig_SetProxyExceptionList(IWMReaderNetworkConfig2 *iface, const WCHAR *protocol,
+        const WCHAR *exceptions)
+{
+    struct async_reader *This = impl_from_IWMReaderNetworkConfig2(iface);
+    FIXME("%p, %s, %s\n", This, debugstr_w(protocol), debugstr_w(exceptions));
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI networkconfig_GetProxyBypassForLocal(IWMReaderNetworkConfig2 *iface, const WCHAR *protocol,
+        BOOL *bypass)
+{
+    struct async_reader *This = impl_from_IWMReaderNetworkConfig2(iface);
+    FIXME("%p, %s, %p\n", This, debugstr_w(protocol), bypass);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI networkconfig_SetProxyBypassForLocal(IWMReaderNetworkConfig2 *iface, const WCHAR *protocol,
+        BOOL bypass)
+{
+    struct async_reader *This = impl_from_IWMReaderNetworkConfig2(iface);
+    FIXME("%p, %s, %d\n", This, debugstr_w(protocol), bypass);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI networkconfig_GetForceRerunAutoProxyDetection(IWMReaderNetworkConfig2 *iface,
+        BOOL *detection)
+{
+    struct async_reader *This = impl_from_IWMReaderNetworkConfig2(iface);
+    FIXME("%p, %p\n", This, detection);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI networkconfig_SetForceRerunAutoProxyDetection(IWMReaderNetworkConfig2 *iface,
+        BOOL detection)
+{
+    struct async_reader *This = impl_from_IWMReaderNetworkConfig2(iface);
+    FIXME("%p, %d\n", This, detection);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI networkconfig_GetEnableMulticast(IWMReaderNetworkConfig2 *iface, BOOL *multicast)
+{
+    struct async_reader *This = impl_from_IWMReaderNetworkConfig2(iface);
+    FIXME("%p, %p\n", This, multicast);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI networkconfig_SetEnableMulticast(IWMReaderNetworkConfig2 *iface, BOOL multicast)
+{
+    struct async_reader *This = impl_from_IWMReaderNetworkConfig2(iface);
+    FIXME("%p, %d\n", This, multicast);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI networkconfig_GetEnableHTTP(IWMReaderNetworkConfig2 *iface, BOOL *enable)
+{
+    struct async_reader *This = impl_from_IWMReaderNetworkConfig2(iface);
+    FIXME("%p, %p\n", This, enable);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI networkconfig_SetEnableHTTP(IWMReaderNetworkConfig2 *iface, BOOL enable)
+{
+    struct async_reader *This = impl_from_IWMReaderNetworkConfig2(iface);
+    FIXME("%p, %d\n", This, enable);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI networkconfig_GetEnableUDP(IWMReaderNetworkConfig2 *iface, BOOL *enable)
+{
+    struct async_reader *This = impl_from_IWMReaderNetworkConfig2(iface);
+    FIXME("%p, %p\n", This, enable);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI networkconfig_SetEnableUDP(IWMReaderNetworkConfig2 *iface, BOOL enable)
+{
+    struct async_reader *This = impl_from_IWMReaderNetworkConfig2(iface);
+    FIXME("%p, %d\n", This, enable);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI networkconfig_GetEnableTCP(IWMReaderNetworkConfig2 *iface, BOOL *enable)
+{
+    struct async_reader *This = impl_from_IWMReaderNetworkConfig2(iface);
+    FIXME("%p, %p\n", This, enable);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI networkconfig_SetEnableTCP(IWMReaderNetworkConfig2 *iface, BOOL enable)
+{
+    struct async_reader *This = impl_from_IWMReaderNetworkConfig2(iface);
+    FIXME("%p, %d\n", This, enable);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI networkconfig_ResetProtocolRollover(IWMReaderNetworkConfig2 *iface)
+{
+    struct async_reader *This = impl_from_IWMReaderNetworkConfig2(iface);
+    FIXME("%p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI networkconfig_GetConnectionBandwidth(IWMReaderNetworkConfig2 *iface, DWORD *bandwidth)
+{
+    struct async_reader *This = impl_from_IWMReaderNetworkConfig2(iface);
+    FIXME("%p, %p\n", This, bandwidth);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI networkconfig_SetConnectionBandwidth(IWMReaderNetworkConfig2 *iface, DWORD bandwidth)
+{
+    struct async_reader *This = impl_from_IWMReaderNetworkConfig2(iface);
+    FIXME("%p, %u\n", This, bandwidth);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI networkconfig_GetNumProtocolsSupported(IWMReaderNetworkConfig2 *iface, DWORD *protocols)
+{
+    struct async_reader *This = impl_from_IWMReaderNetworkConfig2(iface);
+    FIXME("%p, %p\n", This, protocols);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI networkconfig_GetSupportedProtocolName(IWMReaderNetworkConfig2 *iface, DWORD protocol_num,
+        WCHAR *protocol, DWORD *size)
+{
+    struct async_reader *This = impl_from_IWMReaderNetworkConfig2(iface);
+    FIXME("%p, %u, %p %p\n", This, protocol_num, protocol, size);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI networkconfig_AddLoggingUrl(IWMReaderNetworkConfig2 *iface, const WCHAR *url)
+{
+    struct async_reader *This = impl_from_IWMReaderNetworkConfig2(iface);
+    FIXME("%p, %s\n", This, debugstr_w(url));
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI networkconfig_GetLoggingUrl(IWMReaderNetworkConfig2 *iface, DWORD index, WCHAR *url,
+        DWORD *size)
+{
+    struct async_reader *This = impl_from_IWMReaderNetworkConfig2(iface);
+    FIXME("%p, %u, %p, %p\n", This, index, url, size);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI networkconfig_GetLoggingUrlCount(IWMReaderNetworkConfig2 *iface, DWORD *count)
+{
+    struct async_reader *This = impl_from_IWMReaderNetworkConfig2(iface);
+    FIXME("%p, %p\n", This, count);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI networkconfig_ResetLoggingUrlList(IWMReaderNetworkConfig2 *iface)
+{
+    struct async_reader *This = impl_from_IWMReaderNetworkConfig2(iface);
+    FIXME("%p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI networkconfig_GetEnableContentCaching(IWMReaderNetworkConfig2 *iface, BOOL *enable)
+{
+    struct async_reader *This = impl_from_IWMReaderNetworkConfig2(iface);
+    FIXME("%p, %p\n", This, enable);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI networkconfig_SetEnableContentCaching(IWMReaderNetworkConfig2 *iface, BOOL enable)
+{
+    struct async_reader *This = impl_from_IWMReaderNetworkConfig2(iface);
+    FIXME("%p, %d\n", This, enable);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI networkconfig_GetEnableFastCache(IWMReaderNetworkConfig2 *iface, BOOL *enable)
+{
+    struct async_reader *This = impl_from_IWMReaderNetworkConfig2(iface);
+    FIXME("%p, %p\n", This, enable);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI networkconfig_SetEnableFastCache(IWMReaderNetworkConfig2 *iface, BOOL enable)
+{
+    struct async_reader *This = impl_from_IWMReaderNetworkConfig2(iface);
+    FIXME("%p, %d\n", This, enable);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI networkconfig_GetAcceleratedStreamingDuration(IWMReaderNetworkConfig2 *iface,
+        QWORD *duration)
+{
+    struct async_reader *This = impl_from_IWMReaderNetworkConfig2(iface);
+    FIXME("%p, %p\n", This, duration);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI networkconfig_SetAcceleratedStreamingDuration(IWMReaderNetworkConfig2 *iface,
+        QWORD duration)
+{
+    struct async_reader *This = impl_from_IWMReaderNetworkConfig2(iface);
+    FIXME("%p, %s\n", This, wine_dbgstr_longlong(duration));
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI networkconfig_GetAutoReconnectLimit(IWMReaderNetworkConfig2 *iface, DWORD *limit)
+{
+    struct async_reader *This = impl_from_IWMReaderNetworkConfig2(iface);
+    FIXME("%p, %p\n", This, limit);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI networkconfig_SetAutoReconnectLimit(IWMReaderNetworkConfig2 *iface, DWORD limit)
+{
+    struct async_reader *This = impl_from_IWMReaderNetworkConfig2(iface);
+    FIXME("%p, %u\n", This, limit);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI networkconfig_GetEnableResends(IWMReaderNetworkConfig2 *iface, BOOL *enable)
+{
+    struct async_reader *This = impl_from_IWMReaderNetworkConfig2(iface);
+    FIXME("%p, %p\n", This, enable);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI networkconfig_SetEnableResends(IWMReaderNetworkConfig2 *iface, BOOL enable)
+{
+    struct async_reader *This = impl_from_IWMReaderNetworkConfig2(iface);
+    FIXME("%p, %u\n", This, enable);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI networkconfig_GetEnableThinning(IWMReaderNetworkConfig2 *iface, BOOL *enable)
+{
+    struct async_reader *This = impl_from_IWMReaderNetworkConfig2(iface);
+    FIXME("%p, %p\n", This, enable);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI networkconfig_SetEnableThinning(IWMReaderNetworkConfig2 *iface, BOOL enable)
+{
+    struct async_reader *This = impl_from_IWMReaderNetworkConfig2(iface);
+    FIXME("%p, %u\n", This, enable);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI networkconfig_GetMaxNetPacketSize(IWMReaderNetworkConfig2 *iface, DWORD *packet_size)
+{
+    struct async_reader *This = impl_from_IWMReaderNetworkConfig2(iface);
+    FIXME("%p, %p\n", This, packet_size);
+    return E_NOTIMPL;
+}
+
+static const IWMReaderNetworkConfig2Vtbl WMReaderNetworkConfig2Vtbl =
+{
+    networkconfig_QueryInterface,
+    networkconfig_AddRef,
+    networkconfig_Release,
+    networkconfig_GetBufferingTime,
+    networkconfig_SetBufferingTime,
+    networkconfig_GetUDPPortRanges,
+    networkconfig_SetUDPPortRanges,
+    networkconfig_GetProxySettings,
+    networkconfig_SetProxySettings,
+    networkconfig_GetProxyHostName,
+    networkconfig_SetProxyHostName,
+    networkconfig_GetProxyPort,
+    networkconfig_SetProxyPort,
+    networkconfig_GetProxyExceptionList,
+    networkconfig_SetProxyExceptionList,
+    networkconfig_GetProxyBypassForLocal,
+    networkconfig_SetProxyBypassForLocal,
+    networkconfig_GetForceRerunAutoProxyDetection,
+    networkconfig_SetForceRerunAutoProxyDetection,
+    networkconfig_GetEnableMulticast,
+    networkconfig_SetEnableMulticast,
+    networkconfig_GetEnableHTTP,
+    networkconfig_SetEnableHTTP,
+    networkconfig_GetEnableUDP,
+    networkconfig_SetEnableUDP,
+    networkconfig_GetEnableTCP,
+    networkconfig_SetEnableTCP,
+    networkconfig_ResetProtocolRollover,
+    networkconfig_GetConnectionBandwidth,
+    networkconfig_SetConnectionBandwidth,
+    networkconfig_GetNumProtocolsSupported,
+    networkconfig_GetSupportedProtocolName,
+    networkconfig_AddLoggingUrl,
+    networkconfig_GetLoggingUrl,
+    networkconfig_GetLoggingUrlCount,
+    networkconfig_ResetLoggingUrlList,
+    networkconfig_GetEnableContentCaching,
+    networkconfig_SetEnableContentCaching,
+    networkconfig_GetEnableFastCache,
+    networkconfig_SetEnableFastCache,
+    networkconfig_GetAcceleratedStreamingDuration,
+    networkconfig_SetAcceleratedStreamingDuration,
+    networkconfig_GetAutoReconnectLimit,
+    networkconfig_SetAutoReconnectLimit,
+    networkconfig_GetEnableResends,
+    networkconfig_SetEnableResends,
+    networkconfig_GetEnableThinning,
+    networkconfig_SetEnableThinning,
+    networkconfig_GetMaxNetPacketSize
+};
+
+static struct async_reader *impl_from_IWMReaderStreamClock(IWMReaderStreamClock *iface)
+{
+    return CONTAINING_RECORD(iface, struct async_reader, IWMReaderStreamClock_iface);
+}
+
+static HRESULT WINAPI readclock_QueryInterface(IWMReaderStreamClock *iface, REFIID riid, void **ppv)
+{
+    struct async_reader *This = impl_from_IWMReaderStreamClock(iface);
+    return IWMReader_QueryInterface(&This->IWMReader_iface, riid, ppv);
+}
+
+static ULONG WINAPI readclock_AddRef(IWMReaderStreamClock *iface)
+{
+    struct async_reader *This = impl_from_IWMReaderStreamClock(iface);
+    return IWMReader_AddRef(&This->IWMReader_iface);
+}
+
+static ULONG WINAPI readclock_Release(IWMReaderStreamClock *iface)
+{
+    struct async_reader *This = impl_from_IWMReaderStreamClock(iface);
+    return IWMReader_Release(&This->IWMReader_iface);
+}
+
+static HRESULT WINAPI readclock_GetTime(IWMReaderStreamClock *iface, QWORD *now)
+{
+    struct async_reader *This = impl_from_IWMReaderStreamClock(iface);
+    FIXME("%p, %p\n", This, now);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI readclock_SetTimer(IWMReaderStreamClock *iface, QWORD when, void *param, DWORD *id)
+{
+    struct async_reader *This = impl_from_IWMReaderStreamClock(iface);
+    FIXME("%p, %s, %p, %p\n", This, wine_dbgstr_longlong(when), param, id);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI readclock_KillTimer(IWMReaderStreamClock *iface, DWORD id)
+{
+    struct async_reader *This = impl_from_IWMReaderStreamClock(iface);
+    FIXME("%p, %d\n", This, id);
+    return E_NOTIMPL;
+}
+
+static const IWMReaderStreamClockVtbl WMReaderStreamClockVtbl =
+{
+    readclock_QueryInterface,
+    readclock_AddRef,
+    readclock_Release,
+    readclock_GetTime,
+    readclock_SetTimer,
+    readclock_KillTimer
+};
+
+static struct async_reader *impl_from_IWMReaderTypeNegotiation(IWMReaderTypeNegotiation *iface)
+{
+    return CONTAINING_RECORD(iface, struct async_reader, IWMReaderTypeNegotiation_iface);
+}
+
+static HRESULT WINAPI negotiation_QueryInterface(IWMReaderTypeNegotiation *iface, REFIID riid, void **ppv)
+{
+    struct async_reader *This = impl_from_IWMReaderTypeNegotiation(iface);
+    return IWMReader_QueryInterface(&This->IWMReader_iface, riid, ppv);
+}
+
+static ULONG WINAPI negotiation_AddRef(IWMReaderTypeNegotiation *iface)
+{
+    struct async_reader *This = impl_from_IWMReaderTypeNegotiation(iface);
+    return IWMReader_AddRef(&This->IWMReader_iface);
+}
+
+static ULONG WINAPI negotiation_Release(IWMReaderTypeNegotiation *iface)
+{
+    struct async_reader *This = impl_from_IWMReaderTypeNegotiation(iface);
+    return IWMReader_Release(&This->IWMReader_iface);
+}
+
+static HRESULT WINAPI negotiation_TryOutputProps(IWMReaderTypeNegotiation *iface, DWORD output, IWMOutputMediaProps *props)
+{
+    struct async_reader *This = impl_from_IWMReaderTypeNegotiation(iface);
+    FIXME("%p, %d, %p\n", This, output, props);
+    return E_NOTIMPL;
+}
+
+static const IWMReaderTypeNegotiationVtbl WMReaderTypeNegotiationVtbl =
+{
+    negotiation_QueryInterface,
+    negotiation_AddRef,
+    negotiation_Release,
+    negotiation_TryOutputProps
+};
+
+static struct async_reader *impl_from_IReferenceClock(IReferenceClock *iface)
+{
+    return CONTAINING_RECORD(iface, struct async_reader, IReferenceClock_iface);
+}
+
+static HRESULT WINAPI refclock_QueryInterface(IReferenceClock *iface, REFIID riid, void **ppv)
+{
+    struct async_reader *This = impl_from_IReferenceClock(iface);
+    return IWMReader_QueryInterface(&This->IWMReader_iface, riid, ppv);
+}
+
+static ULONG WINAPI refclock_AddRef(IReferenceClock *iface)
+{
+    struct async_reader *This = impl_from_IReferenceClock(iface);
+    return IWMReader_AddRef(&This->IWMReader_iface);
+}
+
+static ULONG WINAPI refclock_Release(IReferenceClock *iface)
+{
+    struct async_reader *This = impl_from_IReferenceClock(iface);
+    return IWMReader_Release(&This->IWMReader_iface);
+}
+
+static HRESULT WINAPI refclock_GetTime(IReferenceClock *iface, REFERENCE_TIME *time)
+{
+    struct async_reader *This = impl_from_IReferenceClock(iface);
+    FIXME("%p, %p\n", This, time);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI refclock_AdviseTime(IReferenceClock *iface, REFERENCE_TIME basetime,
+        REFERENCE_TIME streamtime, HEVENT event, DWORD_PTR *cookie)
+{
+    struct async_reader *This = impl_from_IReferenceClock(iface);
+    FIXME("%p, %s, %s, %lu, %p\n", This, wine_dbgstr_longlong(basetime),
+            wine_dbgstr_longlong(streamtime), event, cookie);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI refclock_AdvisePeriodic(IReferenceClock *iface, REFERENCE_TIME starttime,
+        REFERENCE_TIME period, HSEMAPHORE semaphore, DWORD_PTR *cookie)
+{
+    struct async_reader *This = impl_from_IReferenceClock(iface);
+    FIXME("%p, %s, %s, %lu, %p\n", This, wine_dbgstr_longlong(starttime),
+            wine_dbgstr_longlong(period), semaphore, cookie);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI refclock_Unadvise(IReferenceClock *iface, DWORD_PTR cookie)
+{
+    struct async_reader *This = impl_from_IReferenceClock(iface);
+    FIXME("%p, %lu\n", This, cookie);
+    return E_NOTIMPL;
+}
+
+static const IReferenceClockVtbl ReferenceClockVtbl =
+{
+    refclock_QueryInterface,
+    refclock_AddRef,
+    refclock_Release,
+    refclock_GetTime,
+    refclock_AdviseTime,
+    refclock_AdvisePeriodic,
+    refclock_Unadvise
+};
+
+static struct async_reader *impl_from_wm_reader(struct wm_reader *iface)
+{
+    return CONTAINING_RECORD(iface, struct async_reader, reader);
+}
+
+static void *async_reader_query_interface(struct wm_reader *iface, REFIID iid)
+{
+    struct async_reader *reader = impl_from_wm_reader(iface);
+
+    TRACE("reader %p, iid %s.\n", reader, debugstr_guid(iid));
+
+    if (IsEqualIID(iid, &IID_IReferenceClock))
+        return &reader->IReferenceClock_iface;
+
+    if (IsEqualIID(iid, &IID_IWMReader))
+        return &reader->IWMReader_iface;
+
+    if (IsEqualIID(iid, &IID_IWMReaderAccelerator))
+        return &reader->IWMReaderAccelerator_iface;
+
+    if (IsEqualIID(iid, &IID_IWMReaderAdvanced)
+            || IsEqualIID(iid, &IID_IWMReaderAdvanced2)
+            || IsEqualIID(iid, &IID_IWMReaderAdvanced3)
+            || IsEqualIID(iid, &IID_IWMReaderAdvanced4)
+            || IsEqualIID(iid, &IID_IWMReaderAdvanced5)
+            || IsEqualIID(iid, &IID_IWMReaderAdvanced6))
+        return &reader->IWMReaderAdvanced6_iface;
+
+    if (IsEqualIID(iid, &IID_IWMReaderNetworkConfig)
+            || IsEqualIID(iid, &IID_IWMReaderNetworkConfig2))
+        return &reader->IWMReaderNetworkConfig2_iface;
+
+    if (IsEqualIID(iid, &IID_IWMReaderStreamClock))
+        return &reader->IWMReaderStreamClock_iface;
+
+    if (IsEqualIID(iid, &IID_IWMReaderTypeNegotiation))
+        return &reader->IWMReaderTypeNegotiation_iface;
+
+    return NULL;
+}
+
+static void async_reader_destroy(struct wm_reader *iface)
+{
+    struct async_reader *reader = impl_from_wm_reader(iface);
+
+    TRACE("reader %p.\n", reader);
+
+    if (reader->stream_thread)
+    {
+        WaitForSingleObject(reader->stream_thread, INFINITE);
+        CloseHandle(reader->stream_thread);
+    }
+
+    reader->stream_cs.DebugInfo->Spare[0] = 0;
+    DeleteCriticalSection(&reader->stream_cs);
+
+    wm_reader_close(&reader->reader);
+
+    if (reader->callback)
+        IWMReaderCallback_Release(reader->callback);
+
+    wm_reader_cleanup(&reader->reader);
+    free(reader);
+}
+
+static const struct wm_reader_ops async_reader_ops =
+{
+    .query_interface = async_reader_query_interface,
+    .destroy = async_reader_destroy,
+};
+
+HRESULT WINAPI winegstreamer_create_wm_async_reader(IWMReader **reader)
+{
+    struct async_reader *object;
+
+    TRACE("reader %p.\n", reader);
+
+    if (!(object = calloc(1, sizeof(*object))))
+        return E_OUTOFMEMORY;
+
+    wm_reader_init(&object->reader, &async_reader_ops);
+
+    object->IReferenceClock_iface.lpVtbl = &ReferenceClockVtbl;
+    object->IWMReader_iface.lpVtbl = &WMReaderVtbl;
+    object->IWMReaderAdvanced6_iface.lpVtbl = &WMReaderAdvanced6Vtbl;
+    object->IWMReaderAccelerator_iface.lpVtbl = &WMReaderAcceleratorVtbl;
+    object->IWMReaderNetworkConfig2_iface.lpVtbl = &WMReaderNetworkConfig2Vtbl;
+    object->IWMReaderStreamClock_iface.lpVtbl = &WMReaderStreamClockVtbl;
+    object->IWMReaderTypeNegotiation_iface.lpVtbl = &WMReaderTypeNegotiationVtbl;
+
+    InitializeCriticalSection(&object->stream_cs);
+    object->stream_cs.DebugInfo->Spare[0] = (DWORD_PTR)(__FILE__ ": async_reader.stream_cs");
+
+    QueryPerformanceFrequency(&object->clock_frequency);
+
+    TRACE("Created async reader %p.\n", object);
+    *reader = (IWMReader *)&object->IWMReader_iface;
+    return S_OK;
+}
diff --git a/dlls/mfplat/wm_reader.c b/dlls/mfplat/wm_reader.c
new file mode 100644
index 00000000000..cb667c957b4
--- /dev/null
+++ wine/dlls/mfplat/wm_reader.c
@@ -0,0 +1,2170 @@
+/*
+ * Copyright 2012 Austin English
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "gst_private.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(wmvcore);
+
+static struct wm_stream *get_stream_by_output_number(struct wm_reader *reader, DWORD output)
+{
+    if (output < reader->stream_count)
+        return &reader->streams[output];
+    WARN("Invalid output number %u.\n", output);
+    return NULL;
+}
+
+struct output_props
+{
+    IWMOutputMediaProps IWMOutputMediaProps_iface;
+    LONG refcount;
+
+    AM_MEDIA_TYPE mt;
+};
+
+static inline struct output_props *impl_from_IWMOutputMediaProps(IWMOutputMediaProps *iface)
+{
+    return CONTAINING_RECORD(iface, struct output_props, IWMOutputMediaProps_iface);
+}
+
+static HRESULT WINAPI output_props_QueryInterface(IWMOutputMediaProps *iface, REFIID iid, void **out)
+{
+    struct output_props *props = impl_from_IWMOutputMediaProps(iface);
+
+    TRACE("props %p, iid %s, out %p.\n", iface, debugstr_guid(iid), out);
+
+    if (IsEqualGUID(iid, &IID_IUnknown) || IsEqualGUID(iid, &IID_IWMOutputMediaProps))
+        *out = &props->IWMOutputMediaProps_iface;
+    else
+    {
+        *out = NULL;
+        WARN("%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid(iid));
+        return E_NOINTERFACE;
+    }
+
+    IUnknown_AddRef((IUnknown *)*out);
+    return S_OK;
+}
+
+static ULONG WINAPI output_props_AddRef(IWMOutputMediaProps *iface)
+{
+    struct output_props *props = impl_from_IWMOutputMediaProps(iface);
+    ULONG refcount = InterlockedIncrement(&props->refcount);
+
+    TRACE("%p increasing refcount to %u.\n", props, refcount);
+
+    return refcount;
+}
+
+static ULONG WINAPI output_props_Release(IWMOutputMediaProps *iface)
+{
+    struct output_props *props = impl_from_IWMOutputMediaProps(iface);
+    ULONG refcount = InterlockedDecrement(&props->refcount);
+
+    TRACE("%p decreasing refcount to %u.\n", props, refcount);
+
+    if (!refcount)
+        free(props);
+
+    return refcount;
+}
+
+static HRESULT WINAPI output_props_GetType(IWMOutputMediaProps *iface, GUID *major_type)
+{
+    const struct output_props *props = impl_from_IWMOutputMediaProps(iface);
+
+    TRACE("iface %p, major_type %p.\n", iface, major_type);
+
+    *major_type = props->mt.majortype;
+    return S_OK;
+}
+
+static HRESULT WINAPI output_props_GetMediaType(IWMOutputMediaProps *iface, WM_MEDIA_TYPE *mt, DWORD *size)
+{
+    const struct output_props *props = impl_from_IWMOutputMediaProps(iface);
+    const DWORD req_size = *size;
+
+    TRACE("iface %p, mt %p, size %p.\n", iface, mt, size);
+
+    *size = sizeof(*mt) + props->mt.cbFormat;
+    if (!mt)
+        return S_OK;
+    if (req_size < *size)
+        return ASF_E_BUFFERTOOSMALL;
+
+    strmbase_dump_media_type(&props->mt);
+
+    memcpy(mt, &props->mt, sizeof(*mt));
+    memcpy(mt + 1, props->mt.pbFormat, props->mt.cbFormat);
+    mt->pbFormat = (BYTE *)(mt + 1);
+    return S_OK;
+}
+
+static HRESULT WINAPI output_props_SetMediaType(IWMOutputMediaProps *iface, WM_MEDIA_TYPE *mt)
+{
+    FIXME("iface %p, mt %p, stub!\n", iface, mt);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI output_props_GetStreamGroupName(IWMOutputMediaProps *iface, WCHAR *name, WORD *len)
+{
+    FIXME("iface %p, name %p, len %p, stub!\n", iface, name, len);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI output_props_GetConnectionName(IWMOutputMediaProps *iface, WCHAR *name, WORD *len)
+{
+    FIXME("iface %p, name %p, len %p, stub!\n", iface, name, len);
+    return E_NOTIMPL;
+}
+
+static const struct IWMOutputMediaPropsVtbl output_props_vtbl =
+{
+    output_props_QueryInterface,
+    output_props_AddRef,
+    output_props_Release,
+    output_props_GetType,
+    output_props_GetMediaType,
+    output_props_SetMediaType,
+    output_props_GetStreamGroupName,
+    output_props_GetConnectionName,
+};
+
+static struct output_props *unsafe_impl_from_IWMOutputMediaProps(IWMOutputMediaProps *iface)
+{
+    if (!iface)
+        return NULL;
+    assert(iface->lpVtbl == &output_props_vtbl);
+    return impl_from_IWMOutputMediaProps(iface);
+}
+
+static IWMOutputMediaProps *output_props_create(const struct wg_format *format)
+{
+    struct output_props *object;
+
+    if (!(object = calloc(1, sizeof(*object))))
+        return NULL;
+    object->IWMOutputMediaProps_iface.lpVtbl = &output_props_vtbl;
+    object->refcount = 1;
+
+    if (!amt_from_wg_format(&object->mt, format, true))
+    {
+        free(object);
+        return NULL;
+    }
+
+    TRACE("Created output properties %p.\n", object);
+    return &object->IWMOutputMediaProps_iface;
+}
+
+struct buffer
+{
+    INSSBuffer INSSBuffer_iface;
+    LONG refcount;
+
+    DWORD size, capacity;
+    BYTE data[1];
+};
+
+static struct buffer *impl_from_INSSBuffer(INSSBuffer *iface)
+{
+    return CONTAINING_RECORD(iface, struct buffer, INSSBuffer_iface);
+}
+
+static HRESULT WINAPI buffer_QueryInterface(INSSBuffer *iface, REFIID iid, void **out)
+{
+    struct buffer *buffer = impl_from_INSSBuffer(iface);
+
+    TRACE("buffer %p, iid %s, out %p.\n", iface, debugstr_guid(iid), out);
+
+    if (IsEqualGUID(iid, &IID_IUnknown) || IsEqualGUID(iid, &IID_INSSBuffer))
+        *out = &buffer->INSSBuffer_iface;
+    else
+    {
+        *out = NULL;
+        WARN("%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid(iid));
+        return E_NOINTERFACE;
+    }
+
+    IUnknown_AddRef((IUnknown *)*out);
+    return S_OK;
+}
+
+static ULONG WINAPI buffer_AddRef(INSSBuffer *iface)
+{
+    struct buffer *buffer = impl_from_INSSBuffer(iface);
+    ULONG refcount = InterlockedIncrement(&buffer->refcount);
+
+    TRACE("%p increasing refcount to %u.\n", buffer, refcount);
+
+    return refcount;
+}
+
+static ULONG WINAPI buffer_Release(INSSBuffer *iface)
+{
+    struct buffer *buffer = impl_from_INSSBuffer(iface);
+    ULONG refcount = InterlockedDecrement(&buffer->refcount);
+
+    TRACE("%p decreasing refcount to %u.\n", buffer, refcount);
+
+    if (!refcount)
+        free(buffer);
+
+    return refcount;
+}
+
+static HRESULT WINAPI buffer_GetLength(INSSBuffer *iface, DWORD *size)
+{
+    FIXME("iface %p, size %p, stub!\n", iface, size);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI buffer_SetLength(INSSBuffer *iface, DWORD size)
+{
+    struct buffer *buffer = impl_from_INSSBuffer(iface);
+
+    TRACE("iface %p, size %u.\n", buffer, size);
+
+    if (size > buffer->capacity)
+        return E_INVALIDARG;
+
+    buffer->size = size;
+    return S_OK;
+}
+
+static HRESULT WINAPI buffer_GetMaxLength(INSSBuffer *iface, DWORD *size)
+{
+    struct buffer *buffer = impl_from_INSSBuffer(iface);
+
+    TRACE("buffer %p, size %p.\n", buffer, size);
+
+    *size = buffer->capacity;
+    return S_OK;
+}
+
+static HRESULT WINAPI buffer_GetBuffer(INSSBuffer *iface, BYTE **data)
+{
+    struct buffer *buffer = impl_from_INSSBuffer(iface);
+
+    TRACE("buffer %p, data %p.\n", buffer, data);
+
+    *data = buffer->data;
+    return S_OK;
+}
+
+static HRESULT WINAPI buffer_GetBufferAndLength(INSSBuffer *iface, BYTE **data, DWORD *size)
+{
+    struct buffer *buffer = impl_from_INSSBuffer(iface);
+
+    TRACE("buffer %p, data %p, size %p.\n", buffer, data, size);
+
+    *size = buffer->size;
+    *data = buffer->data;
+    return S_OK;
+}
+
+static const INSSBufferVtbl buffer_vtbl =
+{
+    buffer_QueryInterface,
+    buffer_AddRef,
+    buffer_Release,
+    buffer_GetLength,
+    buffer_SetLength,
+    buffer_GetMaxLength,
+    buffer_GetBuffer,
+    buffer_GetBufferAndLength,
+};
+
+struct stream_config
+{
+    IWMStreamConfig IWMStreamConfig_iface;
+    IWMMediaProps IWMMediaProps_iface;
+    LONG refcount;
+
+    const struct wm_stream *stream;
+};
+
+static struct stream_config *impl_from_IWMStreamConfig(IWMStreamConfig *iface)
+{
+    return CONTAINING_RECORD(iface, struct stream_config, IWMStreamConfig_iface);
+}
+
+static HRESULT WINAPI stream_config_QueryInterface(IWMStreamConfig *iface, REFIID iid, void **out)
+{
+    struct stream_config *config = impl_from_IWMStreamConfig(iface);
+
+    TRACE("config %p, iid %s, out %p.\n", config, debugstr_guid(iid), out);
+
+    if (IsEqualGUID(iid, &IID_IUnknown) || IsEqualGUID(iid, &IID_IWMStreamConfig))
+        *out = &config->IWMStreamConfig_iface;
+    else if (IsEqualGUID(iid, &IID_IWMMediaProps))
+        *out = &config->IWMMediaProps_iface;
+    else
+    {
+        *out = NULL;
+        WARN("%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid(iid));
+        return E_NOINTERFACE;
+    }
+
+    IUnknown_AddRef((IUnknown *)*out);
+    return S_OK;
+}
+
+static ULONG WINAPI stream_config_AddRef(IWMStreamConfig *iface)
+{
+    struct stream_config *config = impl_from_IWMStreamConfig(iface);
+    ULONG refcount = InterlockedIncrement(&config->refcount);
+
+    TRACE("%p increasing refcount to %u.\n", config, refcount);
+
+    return refcount;
+}
+
+static ULONG WINAPI stream_config_Release(IWMStreamConfig *iface)
+{
+    struct stream_config *config = impl_from_IWMStreamConfig(iface);
+    ULONG refcount = InterlockedDecrement(&config->refcount);
+
+    TRACE("%p decreasing refcount to %u.\n", config, refcount);
+
+    if (!refcount)
+    {
+        IWMProfile3_Release(&config->stream->reader->IWMProfile3_iface);
+        free(config);
+    }
+
+    return refcount;
+}
+
+static HRESULT WINAPI stream_config_GetStreamType(IWMStreamConfig *iface, GUID *type)
+{
+    struct stream_config *config = impl_from_IWMStreamConfig(iface);
+    struct wm_reader *reader = config->stream->reader;
+    AM_MEDIA_TYPE mt;
+
+    TRACE("config %p, type %p.\n", config, type);
+
+    EnterCriticalSection(&reader->cs);
+
+    if (!amt_from_wg_format(&mt, &config->stream->format, true))
+    {
+        LeaveCriticalSection(&reader->cs);
+        return E_OUTOFMEMORY;
+    }
+
+    *type = mt.majortype;
+    FreeMediaType(&mt);
+
+    LeaveCriticalSection(&reader->cs);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI stream_config_GetStreamNumber(IWMStreamConfig *iface, WORD *number)
+{
+    struct stream_config *config = impl_from_IWMStreamConfig(iface);
+
+    TRACE("config %p, number %p.\n", config, number);
+
+    *number = config->stream->index + 1;
+    return S_OK;
+}
+
+static HRESULT WINAPI stream_config_SetStreamNumber(IWMStreamConfig *iface, WORD number)
+{
+    FIXME("iface %p, number %u, stub!\n", iface, number);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI stream_config_GetStreamName(IWMStreamConfig *iface, WCHAR *name, WORD *len)
+{
+    FIXME("iface %p, name %p, len %p, stub!\n", iface, name, len);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI stream_config_SetStreamName(IWMStreamConfig *iface, const WCHAR *name)
+{
+    FIXME("iface %p, name %s, stub!\n", iface, debugstr_w(name));
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI stream_config_GetConnectionName(IWMStreamConfig *iface, WCHAR *name, WORD *len)
+{
+    FIXME("iface %p, name %p, len %p, stub!\n", iface, name, len);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI stream_config_SetConnectionName(IWMStreamConfig *iface, const WCHAR *name)
+{
+    FIXME("iface %p, name %s, stub!\n", iface, debugstr_w(name));
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI stream_config_GetBitrate(IWMStreamConfig *iface, DWORD *bitrate)
+{
+    FIXME("iface %p, bitrate %p, stub!\n", iface, bitrate);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI stream_config_SetBitrate(IWMStreamConfig *iface, DWORD bitrate)
+{
+    FIXME("iface %p, bitrate %u, stub!\n", iface, bitrate);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI stream_config_GetBufferWindow(IWMStreamConfig *iface, DWORD *window)
+{
+    FIXME("iface %p, window %p, stub!\n", iface, window);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI stream_config_SetBufferWindow(IWMStreamConfig *iface, DWORD window)
+{
+    FIXME("iface %p, window %u, stub!\n", iface, window);
+    return E_NOTIMPL;
+}
+
+static const IWMStreamConfigVtbl stream_config_vtbl =
+{
+    stream_config_QueryInterface,
+    stream_config_AddRef,
+    stream_config_Release,
+    stream_config_GetStreamType,
+    stream_config_GetStreamNumber,
+    stream_config_SetStreamNumber,
+    stream_config_GetStreamName,
+    stream_config_SetStreamName,
+    stream_config_GetConnectionName,
+    stream_config_SetConnectionName,
+    stream_config_GetBitrate,
+    stream_config_SetBitrate,
+    stream_config_GetBufferWindow,
+    stream_config_SetBufferWindow,
+};
+
+static struct stream_config *impl_from_IWMMediaProps(IWMMediaProps *iface)
+{
+    return CONTAINING_RECORD(iface, struct stream_config, IWMMediaProps_iface);
+}
+
+static HRESULT WINAPI stream_props_QueryInterface(IWMMediaProps *iface, REFIID iid, void **out)
+{
+    struct stream_config *config = impl_from_IWMMediaProps(iface);
+    return IWMStreamConfig_QueryInterface(&config->IWMStreamConfig_iface, iid, out);
+}
+
+static ULONG WINAPI stream_props_AddRef(IWMMediaProps *iface)
+{
+    struct stream_config *config = impl_from_IWMMediaProps(iface);
+    return IWMStreamConfig_AddRef(&config->IWMStreamConfig_iface);
+}
+
+static ULONG WINAPI stream_props_Release(IWMMediaProps *iface)
+{
+    struct stream_config *config = impl_from_IWMMediaProps(iface);
+    return IWMStreamConfig_Release(&config->IWMStreamConfig_iface);
+}
+
+static HRESULT WINAPI stream_props_GetType(IWMMediaProps *iface, GUID *major_type)
+{
+    FIXME("iface %p, major_type %p, stub!\n", iface, major_type);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI stream_props_GetMediaType(IWMMediaProps *iface, WM_MEDIA_TYPE *mt, DWORD *size)
+{
+    struct stream_config *config = impl_from_IWMMediaProps(iface);
+    const DWORD req_size = *size;
+    AM_MEDIA_TYPE stream_mt;
+
+    TRACE("iface %p, mt %p, size %p.\n", iface, mt, size);
+
+    if (!amt_from_wg_format(&stream_mt, &config->stream->format, true))
+        return E_OUTOFMEMORY;
+
+    *size = sizeof(stream_mt) + stream_mt.cbFormat;
+    if (!mt)
+        return S_OK;
+    if (req_size < *size)
+        return ASF_E_BUFFERTOOSMALL;
+
+    strmbase_dump_media_type(&stream_mt);
+
+    memcpy(mt, &stream_mt, sizeof(*mt));
+    memcpy(mt + 1, stream_mt.pbFormat, stream_mt.cbFormat);
+    mt->pbFormat = (BYTE *)(mt + 1);
+    return S_OK;
+}
+
+static HRESULT WINAPI stream_props_SetMediaType(IWMMediaProps *iface, WM_MEDIA_TYPE *mt)
+{
+    FIXME("iface %p, mt %p, stub!\n", iface, mt);
+    return E_NOTIMPL;
+}
+
+static const IWMMediaPropsVtbl stream_props_vtbl =
+{
+    stream_props_QueryInterface,
+    stream_props_AddRef,
+    stream_props_Release,
+    stream_props_GetType,
+    stream_props_GetMediaType,
+    stream_props_SetMediaType,
+};
+
+static DWORD CALLBACK read_thread(void *arg)
+{
+    struct wm_reader *reader = arg;
+    IStream *stream = reader->source_stream;
+    HANDLE file = reader->file;
+    size_t buffer_size = 4096;
+    uint64_t file_size;
+    void *data;
+
+    if (!(data = malloc(buffer_size)))
+        return 0;
+
+    if (file)
+    {
+        LARGE_INTEGER size;
+
+        GetFileSizeEx(file, &size);
+        file_size = size.QuadPart;
+    }
+    else
+    {
+        STATSTG stat;
+
+        IStream_Stat(stream, &stat, STATFLAG_NONAME);
+        file_size = stat.cbSize.QuadPart;
+    }
+
+    TRACE("Starting read thread for reader %p.\n", reader);
+
+    while (!reader->read_thread_shutdown)
+    {
+        LARGE_INTEGER large_offset;
+        uint64_t offset;
+        ULONG ret_size;
+        uint32_t size;
+        HRESULT hr;
+
+        if (!wg_parser_get_next_read_offset(reader->wg_parser, &offset, &size))
+            continue;
+
+        if (offset >= file_size)
+            size = 0;
+        else if (offset + size >= file_size)
+            size = file_size - offset;
+
+        if (!size)
+        {
+            wg_parser_push_data(reader->wg_parser, WG_READ_SUCCESS, data, 0);
+            continue;
+        }
+
+        if (!array_reserve(&data, &buffer_size, size, 1))
+        {
+            free(data);
+            return 0;
+        }
+
+        ret_size = 0;
+
+        large_offset.QuadPart = offset;
+        if (file)
+        {
+            if (!SetFilePointerEx(file, large_offset, NULL, FILE_BEGIN)
+                    || !ReadFile(file, data, size, &ret_size, NULL))
+            {
+                ERR("Failed to read %u bytes at offset %I64u, error %u.\n", size, offset, GetLastError());
+                wg_parser_push_data(reader->wg_parser, WG_READ_FAILURE, NULL, 0);
+                continue;
+            }
+        }
+        else
+        {
+            if (SUCCEEDED(hr = IStream_Seek(stream, large_offset, STREAM_SEEK_SET, NULL)))
+                hr = IStream_Read(stream, data, size, &ret_size);
+            if (FAILED(hr))
+            {
+                ERR("Failed to read %u bytes at offset %I64u, hr %#x.\n", size, offset, hr);
+                wg_parser_push_data(reader->wg_parser, WG_READ_FAILURE, NULL, 0);
+                continue;
+            }
+        }
+
+        if (ret_size != size)
+            ERR("Unexpected short read: requested %u bytes, got %u.\n", size, ret_size);
+        wg_parser_push_data(reader->wg_parser, WG_READ_SUCCESS, data, ret_size);
+    }
+
+    free(data);
+    TRACE("Reader is shutting down; exiting.\n");
+    return 0;
+}
+
+static struct wm_reader *impl_from_IWMProfile3(IWMProfile3 *iface)
+{
+    return CONTAINING_RECORD(iface, struct wm_reader, IWMProfile3_iface);
+}
+
+static HRESULT WINAPI profile_QueryInterface(IWMProfile3 *iface, REFIID iid, void **out)
+{
+    struct wm_reader *reader = impl_from_IWMProfile3(iface);
+
+    TRACE("reader %p, iid %s, out %p.\n", reader, debugstr_guid(iid), out);
+
+    if (IsEqualIID(iid, &IID_IWMHeaderInfo)
+            || IsEqualIID(iid, &IID_IWMHeaderInfo2)
+            || IsEqualIID(iid, &IID_IWMHeaderInfo3))
+    {
+        *out = &reader->IWMHeaderInfo3_iface;
+    }
+    else if (IsEqualIID(iid, &IID_IWMLanguageList))
+    {
+        *out = &reader->IWMLanguageList_iface;
+    }
+    else if (IsEqualIID(iid, &IID_IWMPacketSize)
+            || IsEqualIID(iid, &IID_IWMPacketSize2))
+    {
+        *out = &reader->IWMPacketSize2_iface;
+    }
+    else if (IsEqualIID(iid, &IID_IUnknown)
+            || IsEqualIID(iid, &IID_IWMProfile)
+            || IsEqualIID(iid, &IID_IWMProfile2)
+            || IsEqualIID(iid, &IID_IWMProfile3))
+    {
+        *out = &reader->IWMProfile3_iface;
+    }
+    else if (IsEqualIID(iid, &IID_IWMReaderPlaylistBurn))
+    {
+        *out = &reader->IWMReaderPlaylistBurn_iface;
+    }
+    else if (IsEqualIID(iid, &IID_IWMReaderTimecode))
+    {
+        *out = &reader->IWMReaderTimecode_iface;
+    }
+    else if (!(*out = reader->ops->query_interface(reader, iid)))
+    {
+        WARN("%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid(iid));
+        return E_NOINTERFACE;
+    }
+
+    IUnknown_AddRef((IUnknown *)*out);
+    return S_OK;
+}
+
+static ULONG WINAPI profile_AddRef(IWMProfile3 *iface)
+{
+    struct wm_reader *reader = impl_from_IWMProfile3(iface);
+    ULONG refcount = InterlockedIncrement(&reader->refcount);
+
+    TRACE("%p increasing refcount to %u.\n", reader, refcount);
+
+    return refcount;
+}
+
+static ULONG WINAPI profile_Release(IWMProfile3 *iface)
+{
+    struct wm_reader *reader = impl_from_IWMProfile3(iface);
+    ULONG refcount = InterlockedDecrement(&reader->refcount);
+
+    TRACE("%p decreasing refcount to %u.\n", reader, refcount);
+
+    if (!refcount)
+        reader->ops->destroy(reader);
+
+    return refcount;
+}
+
+static HRESULT WINAPI profile_GetVersion(IWMProfile3 *iface, WMT_VERSION *version)
+{
+    FIXME("iface %p, version %p, stub!\n", iface, version);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI profile_GetName(IWMProfile3 *iface, WCHAR *name, DWORD *length)
+{
+    FIXME("iface %p, name %p, length %p, stub!\n", iface, name, length);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI profile_SetName(IWMProfile3 *iface, const WCHAR *name)
+{
+    FIXME("iface %p, name %s, stub!\n", iface, debugstr_w(name));
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI profile_GetDescription(IWMProfile3 *iface, WCHAR *description, DWORD *length)
+{
+    FIXME("iface %p, description %p, length %p, stub!\n", iface, description, length);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI profile_SetDescription(IWMProfile3 *iface, const WCHAR *description)
+{
+    FIXME("iface %p, description %s, stub!\n", iface, debugstr_w(description));
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI profile_GetStreamCount(IWMProfile3 *iface, DWORD *count)
+{
+    struct wm_reader *reader = impl_from_IWMProfile3(iface);
+
+    TRACE("reader %p, count %p.\n", reader, count);
+
+    if (!count)
+        return E_INVALIDARG;
+
+    EnterCriticalSection(&reader->cs);
+    *count = reader->stream_count;
+    LeaveCriticalSection(&reader->cs);
+    return S_OK;
+}
+
+static HRESULT WINAPI profile_GetStream(IWMProfile3 *iface, DWORD index, IWMStreamConfig **config)
+{
+    struct wm_reader *reader = impl_from_IWMProfile3(iface);
+    struct stream_config *object;
+
+    TRACE("reader %p, index %u, config %p.\n", reader, index, config);
+
+    EnterCriticalSection(&reader->cs);
+
+    if (index >= reader->stream_count)
+    {
+        LeaveCriticalSection(&reader->cs);
+        WARN("Index %u exceeds stream count %u; returning E_INVALIDARG.\n", index, reader->stream_count);
+        return E_INVALIDARG;
+    }
+
+    if (!(object = calloc(1, sizeof(*object))))
+    {
+        LeaveCriticalSection(&reader->cs);
+        return E_OUTOFMEMORY;
+    }
+
+    object->IWMStreamConfig_iface.lpVtbl = &stream_config_vtbl;
+    object->IWMMediaProps_iface.lpVtbl = &stream_props_vtbl;
+    object->refcount = 1;
+    object->stream = &reader->streams[index];
+    IWMProfile3_AddRef(&reader->IWMProfile3_iface);
+
+    LeaveCriticalSection(&reader->cs);
+
+    TRACE("Created stream config %p.\n", object);
+    *config = &object->IWMStreamConfig_iface;
+    return S_OK;
+}
+
+static HRESULT WINAPI profile_GetStreamByNumber(IWMProfile3 *iface, WORD stream_number, IWMStreamConfig **config)
+{
+    FIXME("iface %p, stream_number %u, config %p, stub!\n", iface, stream_number, config);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI profile_RemoveStream(IWMProfile3 *iface, IWMStreamConfig *config)
+{
+    FIXME("iface %p, config %p, stub!\n", iface, config);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI profile_RemoveStreamByNumber(IWMProfile3 *iface, WORD stream_number)
+{
+    FIXME("iface %p, stream_number %u, stub!\n", iface, stream_number);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI profile_AddStream(IWMProfile3 *iface, IWMStreamConfig *config)
+{
+    FIXME("iface %p, config %p, stub!\n", iface, config);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI profile_ReconfigStream(IWMProfile3 *iface, IWMStreamConfig *config)
+{
+    FIXME("iface %p, config %p, stub!\n", iface, config);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI profile_CreateNewStream(IWMProfile3 *iface, REFGUID type, IWMStreamConfig **config)
+{
+    FIXME("iface %p, type %s, config %p, stub!\n", iface, debugstr_guid(type), config);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI profile_GetMutualExclusionCount(IWMProfile3 *iface, DWORD *count)
+{
+    FIXME("iface %p, count %p, stub!\n", iface, count);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI profile_GetMutualExclusion(IWMProfile3 *iface, DWORD index, IWMMutualExclusion **excl)
+{
+    FIXME("iface %p, index %u, excl %p, stub!\n", iface, index, excl);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI profile_RemoveMutualExclusion(IWMProfile3 *iface, IWMMutualExclusion *excl)
+{
+    FIXME("iface %p, excl %p, stub!\n", iface, excl);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI profile_AddMutualExclusion(IWMProfile3 *iface, IWMMutualExclusion *excl)
+{
+    FIXME("iface %p, excl %p, stub!\n", iface, excl);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI profile_CreateNewMutualExclusion(IWMProfile3 *iface, IWMMutualExclusion **excl)
+{
+    FIXME("iface %p, excl %p, stub!\n", iface, excl);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI profile_GetProfileID(IWMProfile3 *iface, GUID *id)
+{
+    FIXME("iface %p, id %p, stub!\n", iface, id);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI profile_GetStorageFormat(IWMProfile3 *iface, WMT_STORAGE_FORMAT *format)
+{
+    FIXME("iface %p, format %p, stub!\n", iface, format);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI profile_SetStorageFormat(IWMProfile3 *iface, WMT_STORAGE_FORMAT format)
+{
+    FIXME("iface %p, format %#x, stub!\n", iface, format);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI profile_GetBandwidthSharingCount(IWMProfile3 *iface, DWORD *count)
+{
+    FIXME("iface %p, count %p, stub!\n", iface, count);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI profile_GetBandwidthSharing(IWMProfile3 *iface, DWORD index, IWMBandwidthSharing **sharing)
+{
+    FIXME("iface %p, index %d, sharing %p, stub!\n", iface, index, sharing);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI profile_RemoveBandwidthSharing( IWMProfile3 *iface, IWMBandwidthSharing *sharing)
+{
+    FIXME("iface %p, sharing %p, stub!\n", iface, sharing);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI profile_AddBandwidthSharing(IWMProfile3 *iface, IWMBandwidthSharing *sharing)
+{
+    FIXME("iface %p, sharing %p, stub!\n", iface, sharing);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI profile_CreateNewBandwidthSharing( IWMProfile3 *iface, IWMBandwidthSharing **sharing)
+{
+    FIXME("iface %p, sharing %p, stub!\n", iface, sharing);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI profile_GetStreamPrioritization(IWMProfile3 *iface, IWMStreamPrioritization **stream)
+{
+    FIXME("iface %p, stream %p, stub!\n", iface, stream);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI profile_SetStreamPrioritization(IWMProfile3 *iface, IWMStreamPrioritization *stream)
+{
+    FIXME("iface %p, stream %p, stub!\n", iface, stream);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI profile_RemoveStreamPrioritization(IWMProfile3 *iface)
+{
+    FIXME("iface %p, stub!\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI profile_CreateNewStreamPrioritization(IWMProfile3 *iface, IWMStreamPrioritization **stream)
+{
+    FIXME("iface %p, stream %p, stub!\n", iface, stream);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI profile_GetExpectedPacketCount(IWMProfile3 *iface, QWORD duration, QWORD *count)
+{
+    FIXME("iface %p, duration %s, count %p, stub!\n", iface, debugstr_time(duration), count);
+    return E_NOTIMPL;
+}
+
+static const IWMProfile3Vtbl profile_vtbl =
+{
+    profile_QueryInterface,
+    profile_AddRef,
+    profile_Release,
+    profile_GetVersion,
+    profile_GetName,
+    profile_SetName,
+    profile_GetDescription,
+    profile_SetDescription,
+    profile_GetStreamCount,
+    profile_GetStream,
+    profile_GetStreamByNumber,
+    profile_RemoveStream,
+    profile_RemoveStreamByNumber,
+    profile_AddStream,
+    profile_ReconfigStream,
+    profile_CreateNewStream,
+    profile_GetMutualExclusionCount,
+    profile_GetMutualExclusion,
+    profile_RemoveMutualExclusion,
+    profile_AddMutualExclusion,
+    profile_CreateNewMutualExclusion,
+    profile_GetProfileID,
+    profile_GetStorageFormat,
+    profile_SetStorageFormat,
+    profile_GetBandwidthSharingCount,
+    profile_GetBandwidthSharing,
+    profile_RemoveBandwidthSharing,
+    profile_AddBandwidthSharing,
+    profile_CreateNewBandwidthSharing,
+    profile_GetStreamPrioritization,
+    profile_SetStreamPrioritization,
+    profile_RemoveStreamPrioritization,
+    profile_CreateNewStreamPrioritization,
+    profile_GetExpectedPacketCount,
+};
+
+static struct wm_reader *impl_from_IWMHeaderInfo3(IWMHeaderInfo3 *iface)
+{
+    return CONTAINING_RECORD(iface, struct wm_reader, IWMHeaderInfo3_iface);
+}
+
+static HRESULT WINAPI header_info_QueryInterface(IWMHeaderInfo3 *iface, REFIID iid, void **out)
+{
+    struct wm_reader *reader = impl_from_IWMHeaderInfo3(iface);
+
+    return IWMProfile3_QueryInterface(&reader->IWMProfile3_iface, iid, out);
+}
+
+static ULONG WINAPI header_info_AddRef(IWMHeaderInfo3 *iface)
+{
+    struct wm_reader *reader = impl_from_IWMHeaderInfo3(iface);
+
+    return IWMProfile3_AddRef(&reader->IWMProfile3_iface);
+}
+
+static ULONG WINAPI header_info_Release(IWMHeaderInfo3 *iface)
+{
+    struct wm_reader *reader = impl_from_IWMHeaderInfo3(iface);
+
+    return IWMProfile3_Release(&reader->IWMProfile3_iface);
+}
+
+static HRESULT WINAPI header_info_GetAttributeCount(IWMHeaderInfo3 *iface, WORD stream_number, WORD *count)
+{
+    FIXME("iface %p, stream_number %u, count %p, stub!\n", iface, stream_number, count);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI header_info_GetAttributeByIndex(IWMHeaderInfo3 *iface, WORD index, WORD *stream_number,
+        WCHAR *name, WORD *name_len, WMT_ATTR_DATATYPE *type, BYTE *value, WORD *size)
+{
+    FIXME("iface %p, index %u, stream_number %p, name %p, name_len %p, type %p, value %p, size %p, stub!\n",
+            iface, index, stream_number, name, name_len, type, value, size);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI header_info_GetAttributeByName(IWMHeaderInfo3 *iface, WORD *stream_number,
+        const WCHAR *name, WMT_ATTR_DATATYPE *type, BYTE *value, WORD *size)
+{
+    struct wm_reader *reader = impl_from_IWMHeaderInfo3(iface);
+    const WORD req_size = *size;
+
+    TRACE("reader %p, stream_number %p, name %s, type %p, value %p, size %u.\n",
+            reader, stream_number, debugstr_w(name), type, value, *size);
+
+    if (!stream_number)
+        return E_INVALIDARG;
+
+    if (!wcscmp(name, L"Duration"))
+    {
+        QWORD duration;
+
+        if (*stream_number)
+        {
+            WARN("Requesting duration for stream %u, returning ASF_E_NOTFOUND.\n", *stream_number);
+            return ASF_E_NOTFOUND;
+        }
+
+        *size = sizeof(QWORD);
+        if (!value)
+        {
+            *type = WMT_TYPE_QWORD;
+            return S_OK;
+        }
+        if (req_size < *size)
+            return ASF_E_BUFFERTOOSMALL;
+
+        *type = WMT_TYPE_QWORD;
+        EnterCriticalSection(&reader->cs);
+        duration = wg_parser_stream_get_duration(wg_parser_get_stream(reader->wg_parser, 0));
+        LeaveCriticalSection(&reader->cs);
+        TRACE("Returning duration %s.\n", debugstr_time(duration));
+        memcpy(value, &duration, sizeof(QWORD));
+        return S_OK;
+    }
+    else if (!wcscmp(name, L"Seekable"))
+    {
+        if (*stream_number)
+        {
+            WARN("Requesting duration for stream %u, returning ASF_E_NOTFOUND.\n", *stream_number);
+            return ASF_E_NOTFOUND;
+        }
+
+        *size = sizeof(BOOL);
+        if (!value)
+        {
+            *type = WMT_TYPE_BOOL;
+            return S_OK;
+        }
+        if (req_size < *size)
+            return ASF_E_BUFFERTOOSMALL;
+
+        *type = WMT_TYPE_BOOL;
+        *(BOOL *)value = TRUE;
+        return S_OK;
+    }
+    else
+    {
+        FIXME("Unknown attribute %s.\n", debugstr_w(name));
+        return ASF_E_NOTFOUND;
+    }
+}
+
+static HRESULT WINAPI header_info_SetAttribute(IWMHeaderInfo3 *iface, WORD stream_number,
+        const WCHAR *name, WMT_ATTR_DATATYPE type, const BYTE *value, WORD size)
+{
+    FIXME("iface %p, stream_number %u, name %s, type %#x, value %p, size %u, stub!\n",
+            iface, stream_number, debugstr_w(name), type, value, size);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI header_info_GetMarkerCount(IWMHeaderInfo3 *iface, WORD *count)
+{
+    FIXME("iface %p, count %p, stub!\n", iface, count);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI header_info_GetMarker(IWMHeaderInfo3 *iface,
+        WORD index, WCHAR *name, WORD *len, QWORD *time)
+{
+    FIXME("iface %p, index %u, name %p, len %p, time %p, stub!\n", iface, index, name, len, time);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI header_info_AddMarker(IWMHeaderInfo3 *iface, const WCHAR *name, QWORD time)
+{
+    FIXME("iface %p, name %s, time %s, stub!\n", iface, debugstr_w(name), debugstr_time(time));
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI header_info_RemoveMarker(IWMHeaderInfo3 *iface, WORD index)
+{
+    FIXME("iface %p, index %u, stub!\n", iface, index);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI header_info_GetScriptCount(IWMHeaderInfo3 *iface, WORD *count)
+{
+    FIXME("iface %p, count %p, stub!\n", iface, count);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI header_info_GetScript(IWMHeaderInfo3 *iface, WORD index, WCHAR *type,
+        WORD *type_len, WCHAR *command, WORD *command_len, QWORD *time)
+{
+    FIXME("iface %p, index %u, type %p, type_len %p, command %p, command_len %p, time %p, stub!\n",
+            iface, index, type, type_len, command, command_len, time);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI header_info_AddScript(IWMHeaderInfo3 *iface,
+        const WCHAR *type, const WCHAR *command, QWORD time)
+{
+    FIXME("iface %p, type %s, command %s, time %s, stub!\n",
+            iface, debugstr_w(type), debugstr_w(command), debugstr_time(time));
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI header_info_RemoveScript(IWMHeaderInfo3 *iface, WORD index)
+{
+    FIXME("iface %p, index %u, stub!\n", iface, index);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI header_info_GetCodecInfoCount(IWMHeaderInfo3 *iface, DWORD *count)
+{
+    FIXME("iface %p, count %p, stub!\n", iface, count);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI header_info_GetCodecInfo(IWMHeaderInfo3 *iface, DWORD index, WORD *name_len,
+        WCHAR *name, WORD *desc_len, WCHAR *desc, WMT_CODEC_INFO_TYPE *type, WORD *size, BYTE *info)
+{
+    FIXME("iface %p, index %u, name_len %p, name %p, desc_len %p, desc %p, type %p, size %p, info %p, stub!\n",
+            iface, index, name_len, name, desc_len, desc, type, size, info);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI header_info_GetAttributeCountEx(IWMHeaderInfo3 *iface, WORD stream_number, WORD *count)
+{
+    FIXME("iface %p, stream_number %u, count %p, stub!\n", iface, stream_number, count);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI header_info_GetAttributeIndices(IWMHeaderInfo3 *iface, WORD stream_number,
+        const WCHAR *name, WORD *lang_index, WORD *indices, WORD *count)
+{
+    FIXME("iface %p, stream_number %u, name %s, lang_index %p, indices %p, count %p, stub!\n",
+            iface, stream_number, debugstr_w(name), lang_index, indices, count);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI header_info_GetAttributeByIndexEx(IWMHeaderInfo3 *iface,
+        WORD stream_number, WORD index, WCHAR *name, WORD *name_len,
+        WMT_ATTR_DATATYPE *type, WORD *lang_index, BYTE *value, DWORD *size)
+{
+    FIXME("iface %p, stream_number %u, index %u, name %p, name_len %p,"
+            " type %p, lang_index %p, value %p, size %p, stub!\n",
+            iface, stream_number, index, name, name_len, type, lang_index, value, size);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI header_info_ModifyAttribute(IWMHeaderInfo3 *iface, WORD stream_number,
+        WORD index, WMT_ATTR_DATATYPE type, WORD lang_index, const BYTE *value, DWORD size)
+{
+    FIXME("iface %p, stream_number %u, index %u, type %#x, lang_index %u, value %p, size %u, stub!\n",
+            iface, stream_number, index, type, lang_index, value, size);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI header_info_AddAttribute(IWMHeaderInfo3 *iface,
+        WORD stream_number, const WCHAR *name, WORD *index,
+        WMT_ATTR_DATATYPE type, WORD lang_index, const BYTE *value, DWORD size)
+{
+    FIXME("iface %p, stream_number %u, name %s, index %p, type %#x, lang_index %u, value %p, size %u, stub!\n",
+            iface, stream_number, debugstr_w(name), index, type, lang_index, value, size);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI header_info_DeleteAttribute(IWMHeaderInfo3 *iface, WORD stream_number, WORD index)
+{
+    FIXME("iface %p, stream_number %u, index %u, stub!\n", iface, stream_number, index);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI header_info_AddCodecInfo(IWMHeaderInfo3 *iface, const WCHAR *name,
+        const WCHAR *desc, WMT_CODEC_INFO_TYPE type, WORD size, BYTE *info)
+{
+    FIXME("iface %p, name %s, desc %s, type %#x, size %u, info %p, stub!\n",
+            info, debugstr_w(name), debugstr_w(desc), type, size, info);
+    return E_NOTIMPL;
+}
+
+static const IWMHeaderInfo3Vtbl header_info_vtbl =
+{
+    header_info_QueryInterface,
+    header_info_AddRef,
+    header_info_Release,
+    header_info_GetAttributeCount,
+    header_info_GetAttributeByIndex,
+    header_info_GetAttributeByName,
+    header_info_SetAttribute,
+    header_info_GetMarkerCount,
+    header_info_GetMarker,
+    header_info_AddMarker,
+    header_info_RemoveMarker,
+    header_info_GetScriptCount,
+    header_info_GetScript,
+    header_info_AddScript,
+    header_info_RemoveScript,
+    header_info_GetCodecInfoCount,
+    header_info_GetCodecInfo,
+    header_info_GetAttributeCountEx,
+    header_info_GetAttributeIndices,
+    header_info_GetAttributeByIndexEx,
+    header_info_ModifyAttribute,
+    header_info_AddAttribute,
+    header_info_DeleteAttribute,
+    header_info_AddCodecInfo,
+};
+
+static struct wm_reader *impl_from_IWMLanguageList(IWMLanguageList *iface)
+{
+    return CONTAINING_RECORD(iface, struct wm_reader, IWMLanguageList_iface);
+}
+
+static HRESULT WINAPI language_list_QueryInterface(IWMLanguageList *iface, REFIID iid, void **out)
+{
+    struct wm_reader *reader = impl_from_IWMLanguageList(iface);
+
+    return IWMProfile3_QueryInterface(&reader->IWMProfile3_iface, iid, out);
+}
+
+static ULONG WINAPI language_list_AddRef(IWMLanguageList *iface)
+{
+    struct wm_reader *reader = impl_from_IWMLanguageList(iface);
+
+    return IWMProfile3_AddRef(&reader->IWMProfile3_iface);
+}
+
+static ULONG WINAPI language_list_Release(IWMLanguageList *iface)
+{
+    struct wm_reader *reader = impl_from_IWMLanguageList(iface);
+
+    return IWMProfile3_Release(&reader->IWMProfile3_iface);
+}
+
+static HRESULT WINAPI language_list_GetLanguageCount(IWMLanguageList *iface, WORD *count)
+{
+    FIXME("iface %p, count %p, stub!\n", iface, count);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI language_list_GetLanguageDetails(IWMLanguageList *iface,
+        WORD index, WCHAR *lang, WORD *len)
+{
+    FIXME("iface %p, index %u, lang %p, len %p, stub!\n", iface, index, lang, len);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI language_list_AddLanguageByRFC1766String(IWMLanguageList *iface,
+        const WCHAR *lang, WORD *index)
+{
+    FIXME("iface %p, lang %s, index %p, stub!\n", iface, debugstr_w(lang), index);
+    return E_NOTIMPL;
+}
+
+static const IWMLanguageListVtbl language_list_vtbl =
+{
+    language_list_QueryInterface,
+    language_list_AddRef,
+    language_list_Release,
+    language_list_GetLanguageCount,
+    language_list_GetLanguageDetails,
+    language_list_AddLanguageByRFC1766String,
+};
+
+static struct wm_reader *impl_from_IWMPacketSize2(IWMPacketSize2 *iface)
+{
+    return CONTAINING_RECORD(iface, struct wm_reader, IWMPacketSize2_iface);
+}
+
+static HRESULT WINAPI packet_size_QueryInterface(IWMPacketSize2 *iface, REFIID iid, void **out)
+{
+    struct wm_reader *reader = impl_from_IWMPacketSize2(iface);
+
+    return IWMProfile3_QueryInterface(&reader->IWMProfile3_iface, iid, out);
+}
+
+static ULONG WINAPI packet_size_AddRef(IWMPacketSize2 *iface)
+{
+    struct wm_reader *reader = impl_from_IWMPacketSize2(iface);
+
+    return IWMProfile3_AddRef(&reader->IWMProfile3_iface);
+}
+
+static ULONG WINAPI packet_size_Release(IWMPacketSize2 *iface)
+{
+    struct wm_reader *reader = impl_from_IWMPacketSize2(iface);
+
+    return IWMProfile3_Release(&reader->IWMProfile3_iface);
+}
+
+static HRESULT WINAPI packet_size_GetMaxPacketSize(IWMPacketSize2 *iface, DWORD *size)
+{
+    FIXME("iface %p, size %p, stub!\n", iface, size);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI packet_size_SetMaxPacketSize(IWMPacketSize2 *iface, DWORD size)
+{
+    FIXME("iface %p, size %u, stub!\n", iface, size);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI packet_size_GetMinPacketSize(IWMPacketSize2 *iface, DWORD *size)
+{
+    FIXME("iface %p, size %p, stub!\n", iface, size);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI packet_size_SetMinPacketSize(IWMPacketSize2 *iface, DWORD size)
+{
+    FIXME("iface %p, size %u, stub!\n", iface, size);
+    return E_NOTIMPL;
+}
+
+static const IWMPacketSize2Vtbl packet_size_vtbl =
+{
+    packet_size_QueryInterface,
+    packet_size_AddRef,
+    packet_size_Release,
+    packet_size_GetMaxPacketSize,
+    packet_size_SetMaxPacketSize,
+    packet_size_GetMinPacketSize,
+    packet_size_SetMinPacketSize,
+};
+
+static struct wm_reader *impl_from_IWMReaderPlaylistBurn(IWMReaderPlaylistBurn *iface)
+{
+    return CONTAINING_RECORD(iface, struct wm_reader, IWMReaderPlaylistBurn_iface);
+}
+
+static HRESULT WINAPI playlist_QueryInterface(IWMReaderPlaylistBurn *iface, REFIID iid, void **out)
+{
+    struct wm_reader *reader = impl_from_IWMReaderPlaylistBurn(iface);
+
+    return IWMProfile3_QueryInterface(&reader->IWMProfile3_iface, iid, out);
+}
+
+static ULONG WINAPI playlist_AddRef(IWMReaderPlaylistBurn *iface)
+{
+    struct wm_reader *reader = impl_from_IWMReaderPlaylistBurn(iface);
+
+    return IWMProfile3_AddRef(&reader->IWMProfile3_iface);
+}
+
+static ULONG WINAPI playlist_Release(IWMReaderPlaylistBurn *iface)
+{
+    struct wm_reader *reader = impl_from_IWMReaderPlaylistBurn(iface);
+
+    return IWMProfile3_Release(&reader->IWMProfile3_iface);
+}
+
+static HRESULT WINAPI playlist_InitPlaylistBurn(IWMReaderPlaylistBurn *iface, DWORD count,
+        const WCHAR **filenames, IWMStatusCallback *callback, void *context)
+{
+    FIXME("iface %p, count %u, filenames %p, callback %p, context %p, stub!\n",
+            iface, count, filenames, callback, context);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI playlist_GetInitResults(IWMReaderPlaylistBurn *iface, DWORD count, HRESULT *hrs)
+{
+    FIXME("iface %p, count %u, hrs %p, stub!\n", iface, count, hrs);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI playlist_Cancel(IWMReaderPlaylistBurn *iface)
+{
+    FIXME("iface %p, stub!\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI playlist_EndPlaylistBurn(IWMReaderPlaylistBurn *iface, HRESULT hr)
+{
+    FIXME("iface %p, hr %#x, stub!\n", iface, hr);
+    return E_NOTIMPL;
+}
+
+static const IWMReaderPlaylistBurnVtbl playlist_vtbl =
+{
+    playlist_QueryInterface,
+    playlist_AddRef,
+    playlist_Release,
+    playlist_InitPlaylistBurn,
+    playlist_GetInitResults,
+    playlist_Cancel,
+    playlist_EndPlaylistBurn,
+};
+
+static struct wm_reader *impl_from_IWMReaderTimecode(IWMReaderTimecode *iface)
+{
+    return CONTAINING_RECORD(iface, struct wm_reader, IWMReaderTimecode_iface);
+}
+
+static HRESULT WINAPI timecode_QueryInterface(IWMReaderTimecode *iface, REFIID iid, void **out)
+{
+    struct wm_reader *reader = impl_from_IWMReaderTimecode(iface);
+
+    return IWMProfile3_QueryInterface(&reader->IWMProfile3_iface, iid, out);
+}
+
+static ULONG WINAPI timecode_AddRef(IWMReaderTimecode *iface)
+{
+    struct wm_reader *reader = impl_from_IWMReaderTimecode(iface);
+
+    return IWMProfile3_AddRef(&reader->IWMProfile3_iface);
+}
+
+static ULONG WINAPI timecode_Release(IWMReaderTimecode *iface)
+{
+    struct wm_reader *reader = impl_from_IWMReaderTimecode(iface);
+
+    return IWMProfile3_Release(&reader->IWMProfile3_iface);
+}
+
+static HRESULT WINAPI timecode_GetTimecodeRangeCount(IWMReaderTimecode *iface,
+        WORD stream_number, WORD *count)
+{
+    FIXME("iface %p, stream_number %u, count %p, stub!\n", iface, stream_number, count);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI timecode_GetTimecodeRangeBounds(IWMReaderTimecode *iface,
+        WORD stream_number, WORD index, DWORD *start, DWORD *end)
+{
+    FIXME("iface %p, stream_number %u, index %u, start %p, end %p, stub!\n",
+            iface, stream_number, index, start, end);
+    return E_NOTIMPL;
+}
+
+static const IWMReaderTimecodeVtbl timecode_vtbl =
+{
+    timecode_QueryInterface,
+    timecode_AddRef,
+    timecode_Release,
+    timecode_GetTimecodeRangeCount,
+    timecode_GetTimecodeRangeBounds,
+};
+
+static HRESULT init_stream(struct wm_reader *reader, QWORD file_size)
+{
+    struct wg_parser *wg_parser;
+    HRESULT hr;
+    WORD i;
+
+    if (!(wg_parser = wg_parser_create(WG_PARSER_DECODEBIN, true)))
+        return E_OUTOFMEMORY;
+
+    reader->wg_parser = wg_parser;
+    reader->read_thread_shutdown = false;
+    if (!(reader->read_thread = CreateThread(NULL, 0, read_thread, reader, 0, NULL)))
+    {
+        hr = E_OUTOFMEMORY;
+        goto out_destroy_parser;
+    }
+
+    if (FAILED(hr = wg_parser_connect(reader->wg_parser, file_size)))
+    {
+        ERR("Failed to connect parser, hr %#x.\n", hr);
+        goto out_shutdown_thread;
+    }
+
+    reader->stream_count = wg_parser_get_stream_count(reader->wg_parser);
+
+    if (!(reader->streams = calloc(reader->stream_count, sizeof(*reader->streams))))
+    {
+        hr = E_OUTOFMEMORY;
+        goto out_disconnect_parser;
+    }
+
+    for (i = 0; i < reader->stream_count; ++i)
+    {
+        struct wm_stream *stream = &reader->streams[i];
+
+        stream->wg_stream = wg_parser_get_stream(reader->wg_parser, reader->stream_count - i - 1);
+        stream->reader = reader;
+        stream->index = i;
+        stream->selection = WMT_ON;
+        wg_parser_stream_get_preferred_format(stream->wg_stream, &stream->format);
+        if (stream->format.major_type == WG_MAJOR_TYPE_AUDIO)
+        {
+            /* R.U.S.E enumerates available audio types, picks the first one it
+             * likes, and then sets the wrong stream to that type. libav might
+             * give us WG_AUDIO_FORMAT_F32LE by default, which will result in
+             * the game incorrectly interpreting float data as integer.
+             * Therefore just match native and always set our default format to
+             * S16LE. */
+            stream->format.u.audio.format = WG_AUDIO_FORMAT_S16LE;
+        }
+        else if (stream->format.major_type == WG_MAJOR_TYPE_VIDEO)
+        {
+            /* Call of Juarez: Bound in Blood breaks if I420 is enumerated.
+             * Some native decoders output I420, but the msmpeg4v3 decoder
+             * never does.
+             *
+             * Shadowgrounds provides wmv3 video and assumes that the initial
+             * video type will be BGR. */
+            stream->format.u.video.format = WG_VIDEO_FORMAT_BGR;
+            {
+                /* HACK: Persona 4 Golden tries to read compressed samples, and
+                 * then autoplug them via quartz to a filter that only accepts
+                 * BGRx. This is not trivial to implement. Return BGRx from the
+                 * wmvcore reader for now. */
+
+                const char *id = getenv("SteamGameId");
+
+                if (id && !strcmp(id, "1113000"))
+                    stream->format.u.video.format = WG_VIDEO_FORMAT_BGRx;
+            }
+        }
+        wg_parser_stream_enable(stream->wg_stream, &stream->format, NULL, STREAM_ENABLE_FLAG_FLIP_RGB);
+    }
+
+    /* We probably discarded events because streams weren't enabled yet.
+     * Now that they're all enabled seek back to the start again. */
+    wg_parser_stream_seek(reader->streams[0].wg_stream, 1.0, 0, 0,
+            AM_SEEKING_AbsolutePositioning, AM_SEEKING_NoPositioning);
+
+    return S_OK;
+
+out_disconnect_parser:
+    wg_parser_disconnect(reader->wg_parser);
+
+out_shutdown_thread:
+    reader->read_thread_shutdown = true;
+    WaitForSingleObject(reader->read_thread, INFINITE);
+    CloseHandle(reader->read_thread);
+    reader->read_thread = NULL;
+
+out_destroy_parser:
+    wg_parser_destroy(reader->wg_parser);
+    reader->wg_parser = NULL;
+
+    return hr;
+}
+
+HRESULT wm_reader_open_stream(struct wm_reader *reader, IStream *stream)
+{
+    STATSTG stat;
+    HRESULT hr;
+
+    if (FAILED(hr = IStream_Stat(stream, &stat, STATFLAG_NONAME)))
+    {
+        ERR("Failed to stat stream, hr %#x.\n", hr);
+        return hr;
+    }
+
+    EnterCriticalSection(&reader->cs);
+
+    IStream_AddRef(reader->source_stream = stream);
+    if (FAILED(hr = init_stream(reader, stat.cbSize.QuadPart)))
+    {
+        IStream_Release(stream);
+        reader->source_stream = NULL;
+    }
+
+    LeaveCriticalSection(&reader->cs);
+    return hr;
+}
+
+HRESULT wm_reader_open_file(struct wm_reader *reader, const WCHAR *filename)
+{
+    LARGE_INTEGER size;
+    HANDLE file;
+    HRESULT hr;
+
+    if ((file = CreateFileW(filename, GENERIC_READ, FILE_SHARE_READ, NULL,
+            OPEN_EXISTING, 0, NULL)) == INVALID_HANDLE_VALUE)
+    {
+        ERR("Failed to open %s, error %u.\n", debugstr_w(filename), GetLastError());
+        return HRESULT_FROM_WIN32(GetLastError());
+    }
+
+    if (!GetFileSizeEx(file, &size))
+    {
+        ERR("Failed to get the size of %s, error %u.\n", debugstr_w(filename), GetLastError());
+        CloseHandle(file);
+        return HRESULT_FROM_WIN32(GetLastError());
+    }
+
+    EnterCriticalSection(&reader->cs);
+
+    reader->file = file;
+
+    if (FAILED(hr = init_stream(reader, size.QuadPart)))
+        reader->file = NULL;
+
+    LeaveCriticalSection(&reader->cs);
+    return hr;
+}
+
+HRESULT wm_reader_close(struct wm_reader *reader)
+{
+    EnterCriticalSection(&reader->cs);
+
+    if (!reader->wg_parser)
+    {
+        LeaveCriticalSection(&reader->cs);
+        return NS_E_INVALID_REQUEST;
+    }
+
+    wg_parser_disconnect(reader->wg_parser);
+
+    reader->read_thread_shutdown = true;
+    WaitForSingleObject(reader->read_thread, INFINITE);
+    CloseHandle(reader->read_thread);
+    reader->read_thread = NULL;
+
+    if (reader->callback_advanced)
+        IWMReaderCallbackAdvanced_Release(reader->callback_advanced);
+    reader->callback_advanced = NULL;
+
+    wg_parser_destroy(reader->wg_parser);
+    reader->wg_parser = NULL;
+
+    if (reader->source_stream)
+        IStream_Release(reader->source_stream);
+    reader->source_stream = NULL;
+    if (reader->file)
+        CloseHandle(reader->file);
+    reader->file = NULL;
+
+    LeaveCriticalSection(&reader->cs);
+    return S_OK;
+}
+
+struct wm_stream *wm_reader_get_stream_by_stream_number(struct wm_reader *reader, WORD stream_number)
+{
+    if (stream_number && stream_number <= reader->stream_count)
+        return &reader->streams[stream_number - 1];
+    WARN("Invalid stream number %u.\n", stream_number);
+    return NULL;
+}
+
+HRESULT wm_reader_get_output_props(struct wm_reader *reader, DWORD output, IWMOutputMediaProps **props)
+{
+    struct wm_stream *stream;
+
+    EnterCriticalSection(&reader->cs);
+
+    if (!(stream = get_stream_by_output_number(reader, output)))
+    {
+        LeaveCriticalSection(&reader->cs);
+        return E_INVALIDARG;
+    }
+
+    *props = output_props_create(&stream->format);
+    LeaveCriticalSection(&reader->cs);
+    return *props ? S_OK : E_OUTOFMEMORY;
+}
+
+static const enum wg_video_format video_formats[] =
+{
+    /* Try to prefer YUV formats over RGB ones. Most decoders output in the
+     * YUV color space, and it's generally much less expensive for
+     * videoconvert to do YUV -> YUV transformations. */
+    WG_VIDEO_FORMAT_NV12,
+    WG_VIDEO_FORMAT_YV12,
+    WG_VIDEO_FORMAT_YUY2,
+    WG_VIDEO_FORMAT_UYVY,
+    WG_VIDEO_FORMAT_YVYU,
+    WG_VIDEO_FORMAT_BGRx,
+    WG_VIDEO_FORMAT_BGR,
+    WG_VIDEO_FORMAT_RGB16,
+    WG_VIDEO_FORMAT_RGB15,
+};
+
+HRESULT wm_reader_get_output_format_count(struct wm_reader *reader, DWORD output, DWORD *count)
+{
+    struct wm_stream *stream;
+    struct wg_format format;
+
+    EnterCriticalSection(&reader->cs);
+
+    if (!(stream = get_stream_by_output_number(reader, output)))
+    {
+        LeaveCriticalSection(&reader->cs);
+        return E_INVALIDARG;
+    }
+
+    wg_parser_stream_get_preferred_format(stream->wg_stream, &format);
+    switch (format.major_type)
+    {
+        case WG_MAJOR_TYPE_VIDEO:
+            *count = ARRAY_SIZE(video_formats);
+            break;
+
+        case WG_MAJOR_TYPE_AUDIO:
+        case WG_MAJOR_TYPE_UNKNOWN:
+            *count = 1;
+            break;
+    }
+
+    LeaveCriticalSection(&reader->cs);
+    return S_OK;
+}
+
+HRESULT wm_reader_get_output_format(struct wm_reader *reader, DWORD output,
+        DWORD index, IWMOutputMediaProps **props)
+{
+    struct wm_stream *stream;
+    struct wg_format format;
+
+    EnterCriticalSection(&reader->cs);
+
+    if (!(stream = get_stream_by_output_number(reader, output)))
+    {
+        LeaveCriticalSection(&reader->cs);
+        return E_INVALIDARG;
+    }
+
+    wg_parser_stream_get_preferred_format(stream->wg_stream, &format);
+
+    switch (format.major_type)
+    {
+        case WG_MAJOR_TYPE_VIDEO:
+            if (index >= ARRAY_SIZE(video_formats))
+            {
+                LeaveCriticalSection(&reader->cs);
+                return NS_E_INVALID_OUTPUT_FORMAT;
+            }
+            format.u.video.format = video_formats[index];
+            break;
+
+        case WG_MAJOR_TYPE_AUDIO:
+            if (index)
+            {
+                LeaveCriticalSection(&reader->cs);
+                return NS_E_INVALID_OUTPUT_FORMAT;
+            }
+            format.u.audio.format = WG_AUDIO_FORMAT_S16LE;
+            break;
+
+        case WG_MAJOR_TYPE_UNKNOWN:
+            break;
+    }
+
+    LeaveCriticalSection(&reader->cs);
+
+    *props = output_props_create(&format);
+    return *props ? S_OK : E_OUTOFMEMORY;
+}
+
+HRESULT wm_reader_set_output_props(struct wm_reader *reader, DWORD output,
+        IWMOutputMediaProps *props_iface)
+{
+    struct output_props *props = unsafe_impl_from_IWMOutputMediaProps(props_iface);
+    struct wg_format format, pref_format;
+    struct wm_stream *stream;
+
+    strmbase_dump_media_type(&props->mt);
+
+    if (!amt_to_wg_format(&props->mt, &format))
+    {
+        ERR("Failed to convert media type to winegstreamer format.\n");
+        return E_FAIL;
+    }
+
+    EnterCriticalSection(&reader->cs);
+
+    if (!(stream = get_stream_by_output_number(reader, output)))
+    {
+        LeaveCriticalSection(&reader->cs);
+        return E_INVALIDARG;
+    }
+
+    wg_parser_stream_get_preferred_format(stream->wg_stream, &pref_format);
+    if (pref_format.major_type != format.major_type)
+    {
+        /* R.U.S.E sets the type of the wrong stream, apparently by accident. */
+        LeaveCriticalSection(&reader->cs);
+        WARN("Major types don't match; returning NS_E_INCOMPATIBLE_FORMAT.\n");
+        return NS_E_INCOMPATIBLE_FORMAT;
+    }
+
+    stream->format = format;
+    wg_parser_stream_enable(stream->wg_stream, &format, NULL, STREAM_ENABLE_FLAG_FLIP_RGB);
+
+    /* Re-decode any buffers that might have been generated with the old format.
+     *
+     * FIXME: Seeking in-place will cause some buffers to be dropped.
+     * Unfortunately, we can't really store the last received PTS and seek there
+     * either: since seeks are inexact and we aren't guaranteed to receive
+     * samples in order, some buffers might be duplicated or dropped anyway.
+     * In order to really seamlessly allow for format changes, we need
+     * cooperation from each individual GStreamer stream, to be able to tell
+     * upstream exactly which buffers they need resent...
+     *
+     * In all likelihood this function is being called not mid-stream but rather
+     * while setting the stream up, before consuming any events. Accordingly
+     * let's just seek back to the beginning. */
+    wg_parser_stream_seek(reader->streams[0].wg_stream, 1.0, reader->start_time, 0,
+            AM_SEEKING_AbsolutePositioning, AM_SEEKING_NoPositioning);
+
+    LeaveCriticalSection(&reader->cs);
+    return S_OK;
+}
+
+static const char *get_major_type_string(enum wg_major_type type)
+{
+    switch (type)
+    {
+        case WG_MAJOR_TYPE_AUDIO:
+            return "audio";
+        case WG_MAJOR_TYPE_VIDEO:
+            return "video";
+        case WG_MAJOR_TYPE_UNKNOWN:
+            return "unknown";
+    }
+    assert(0);
+    return NULL;
+}
+
+/* Find the earliest buffer by PTS.
+ *
+ * Native seems to behave similarly to this with the async reader, although our
+ * unit tests show that it's not entirely consistent—some frames are received
+ * slightly out of order. It's possible that one stream is being manually offset
+ * to account for decoding latency.
+ *
+ * The behaviour with the synchronous reader, when stream 0 is requested, seems
+ * consistent with this hypothesis, but with a much larger offset—the video
+ * stream seems to be "behind" by about 150 ms.
+ *
+ * The main reason for doing this is that the video and audio stream probably
+ * don't have quite the same "frame rate", and we don't want to force one stream
+ * to decode faster just to keep up with the other. Delivering samples in PTS
+ * order should avoid that problem. */
+static WORD get_earliest_buffer(struct wm_reader *reader, struct wg_parser_buffer *ret_buffer)
+{
+    struct wg_parser_buffer buffer;
+    QWORD earliest_pts = UI64_MAX;
+    WORD stream_number = 0;
+    WORD i;
+
+    for (i = 0; i < reader->stream_count; ++i)
+    {
+        struct wm_stream *stream = &reader->streams[i];
+
+        if (stream->selection == WMT_OFF)
+            continue;
+
+        if (!wg_parser_stream_get_buffer(stream->wg_stream, &buffer))
+            continue;
+
+        if (buffer.has_pts && buffer.pts < earliest_pts)
+        {
+            stream_number = i + 1;
+            earliest_pts = buffer.pts;
+            *ret_buffer = buffer;
+        }
+    }
+
+    return stream_number;
+}
+
+HRESULT wm_reader_get_stream_sample(struct wm_reader *reader, WORD stream_number,
+        INSSBuffer **ret_sample, QWORD *pts, QWORD *duration, DWORD *flags, WORD *ret_stream_number)
+{
+    IWMReaderCallbackAdvanced *callback_advanced = reader->callback_advanced;
+    struct wg_parser_stream *wg_stream;
+    struct wg_parser_buffer wg_buffer;
+    struct wm_stream *stream;
+    DWORD size, capacity;
+    INSSBuffer *sample;
+    HRESULT hr;
+    BYTE *data;
+
+    for (;;)
+    {
+        if (!stream_number)
+        {
+            if (!(stream_number = get_earliest_buffer(reader, &wg_buffer)))
+            {
+                /* All streams are disabled or EOS. */
+                return NS_E_NO_MORE_SAMPLES;
+            }
+
+            stream = wm_reader_get_stream_by_stream_number(reader, stream_number);
+            wg_stream = stream->wg_stream;
+        }
+        else
+        {
+            if (!(stream = wm_reader_get_stream_by_stream_number(reader, stream_number)))
+            {
+                WARN("Invalid stream number %u; returning E_INVALIDARG.\n", stream_number);
+                return E_INVALIDARG;
+            }
+            wg_stream = stream->wg_stream;
+
+            if (stream->selection == WMT_OFF)
+            {
+                WARN("Stream %u is deselected; returning NS_E_INVALID_REQUEST.\n", stream_number);
+                return NS_E_INVALID_REQUEST;
+            }
+
+            if (stream->eos)
+                return NS_E_NO_MORE_SAMPLES;
+
+            if (!wg_parser_stream_get_buffer(wg_stream, &wg_buffer))
+            {
+                stream->eos = true;
+                TRACE("End of stream.\n");
+                return NS_E_NO_MORE_SAMPLES;
+            }
+        }
+
+        TRACE("Got buffer for '%s' stream %p.\n", get_major_type_string(stream->format.major_type), stream);
+
+        if (callback_advanced && stream->read_compressed && stream->allocate_stream)
+        {
+            if (FAILED(hr = IWMReaderCallbackAdvanced_AllocateForStream(callback_advanced,
+                    stream->index + 1, wg_buffer.size, &sample, NULL)))
+            {
+                ERR("Failed to allocate stream sample of %u bytes, hr %#x.\n", wg_buffer.size, hr);
+                wg_parser_stream_release_buffer(wg_stream);
+                return hr;
+            }
+        }
+        else if (callback_advanced && !stream->read_compressed && stream->allocate_output)
+        {
+            if (FAILED(hr = IWMReaderCallbackAdvanced_AllocateForOutput(callback_advanced,
+                    stream->index, wg_buffer.size, &sample, NULL)))
+            {
+                ERR("Failed to allocate output sample of %u bytes, hr %#x.\n", wg_buffer.size, hr);
+                wg_parser_stream_release_buffer(wg_stream);
+                return hr;
+            }
+        }
+        else
+        {
+            struct buffer *object;
+
+            /* FIXME: Should these be pooled? */
+            if (!(object = calloc(1, offsetof(struct buffer, data[wg_buffer.size]))))
+            {
+                wg_parser_stream_release_buffer(wg_stream);
+                return E_OUTOFMEMORY;
+            }
+
+            object->INSSBuffer_iface.lpVtbl = &buffer_vtbl;
+            object->refcount = 1;
+            object->capacity = wg_buffer.size;
+
+            TRACE("Created buffer %p.\n", object);
+            sample = &object->INSSBuffer_iface;
+        }
+
+        if (FAILED(hr = INSSBuffer_GetBufferAndLength(sample, &data, &size)))
+            ERR("Failed to get data pointer, hr %#x.\n", hr);
+        if (FAILED(hr = INSSBuffer_GetMaxLength(sample, &capacity)))
+            ERR("Failed to get capacity, hr %#x.\n", hr);
+        if (wg_buffer.size > capacity)
+            ERR("Returned capacity %u is less than requested capacity %u.\n", capacity, wg_buffer.size);
+
+        if (!wg_parser_stream_copy_buffer(wg_stream, data, 0, wg_buffer.size))
+        {
+            /* The GStreamer pin has been flushed. */
+            INSSBuffer_Release(sample);
+            continue;
+        }
+
+        if (FAILED(hr = INSSBuffer_SetLength(sample, wg_buffer.size)))
+            ERR("Failed to set size %u, hr %#x.\n", wg_buffer.size, hr);
+
+        wg_parser_stream_release_buffer(wg_stream);
+
+        if (!wg_buffer.has_pts)
+            FIXME("Missing PTS.\n");
+        if (!wg_buffer.has_duration)
+            FIXME("Missing duration.\n");
+
+        *pts = wg_buffer.pts;
+        *duration = wg_buffer.duration;
+        *flags = 0;
+        if (wg_buffer.discontinuity)
+            *flags |= WM_SF_DISCONTINUITY;
+        if (!wg_buffer.delta)
+            *flags |= WM_SF_CLEANPOINT;
+
+        *ret_sample = sample;
+        *ret_stream_number = stream_number;
+        return S_OK;
+    }
+}
+
+void wm_reader_seek(struct wm_reader *reader, QWORD start, LONGLONG duration)
+{
+    WORD i;
+
+    EnterCriticalSection(&reader->cs);
+
+    reader->start_time = start;
+
+    wg_parser_stream_seek(reader->streams[0].wg_stream, 1.0, start, start + duration,
+            AM_SEEKING_AbsolutePositioning, duration ? AM_SEEKING_AbsolutePositioning : AM_SEEKING_NoPositioning);
+
+    for (i = 0; i < reader->stream_count; ++i)
+        reader->streams[i].eos = false;
+
+    LeaveCriticalSection(&reader->cs);
+}
+
+HRESULT wm_reader_set_streams_selected(struct wm_reader *reader, WORD count,
+        const WORD *stream_numbers, const WMT_STREAM_SELECTION *selections)
+{
+    struct wm_stream *stream;
+    WORD i;
+
+    if (!count)
+        return E_INVALIDARG;
+
+    EnterCriticalSection(&reader->cs);
+
+    for (i = 0; i < count; ++i)
+    {
+        if (!(stream = wm_reader_get_stream_by_stream_number(reader, stream_numbers[i])))
+        {
+            LeaveCriticalSection(&reader->cs);
+            WARN("Invalid stream number %u; returning NS_E_INVALID_REQUEST.\n", stream_numbers[i]);
+            return NS_E_INVALID_REQUEST;
+        }
+    }
+
+    for (i = 0; i < count; ++i)
+    {
+        stream = wm_reader_get_stream_by_stream_number(reader, stream_numbers[i]);
+        stream->selection = selections[i];
+        if (selections[i] == WMT_OFF)
+        {
+            TRACE("Disabling stream %u.\n", stream_numbers[i]);
+            wg_parser_stream_disable(stream->wg_stream);
+        }
+        else if (selections[i] == WMT_ON)
+        {
+            if (selections[i] != WMT_ON)
+                FIXME("Ignoring selection %#x for stream %u; treating as enabled.\n",
+                        selections[i], stream_numbers[i]);
+            TRACE("Enabling stream %u.\n", stream_numbers[i]);
+            wg_parser_stream_enable(stream->wg_stream, &stream->format, NULL, STREAM_ENABLE_FLAG_FLIP_RGB);
+        }
+    }
+
+    LeaveCriticalSection(&reader->cs);
+    return S_OK;
+}
+
+HRESULT wm_reader_get_stream_selection(struct wm_reader *reader,
+        WORD stream_number, WMT_STREAM_SELECTION *selection)
+{
+    struct wm_stream *stream;
+
+    EnterCriticalSection(&reader->cs);
+
+    if (!(stream = wm_reader_get_stream_by_stream_number(reader, stream_number)))
+    {
+        LeaveCriticalSection(&reader->cs);
+        return E_INVALIDARG;
+    }
+
+    *selection = stream->selection;
+
+    LeaveCriticalSection(&reader->cs);
+    return S_OK;
+}
+
+HRESULT wm_reader_set_allocate_for_output(struct wm_reader *reader, DWORD output, BOOL allocate)
+{
+    struct wm_stream *stream;
+
+    EnterCriticalSection(&reader->cs);
+
+    if (!(stream = get_stream_by_output_number(reader, output)))
+    {
+        LeaveCriticalSection(&reader->cs);
+        return E_INVALIDARG;
+    }
+
+    stream->allocate_output = !!allocate;
+
+    LeaveCriticalSection(&reader->cs);
+    return S_OK;
+}
+
+HRESULT wm_reader_set_allocate_for_stream(struct wm_reader *reader, WORD stream_number, BOOL allocate)
+{
+    struct wm_stream *stream;
+
+    EnterCriticalSection(&reader->cs);
+
+    if (!(stream = wm_reader_get_stream_by_stream_number(reader, stream_number)))
+    {
+        LeaveCriticalSection(&reader->cs);
+        return E_INVALIDARG;
+    }
+
+    stream->allocate_stream = !!allocate;
+
+    LeaveCriticalSection(&reader->cs);
+    return S_OK;
+}
+
+HRESULT wm_reader_set_read_compressed(struct wm_reader *reader, WORD stream_number, BOOL compressed)
+{
+    struct wm_stream *stream;
+
+    EnterCriticalSection(&reader->cs);
+
+    if (!(stream = wm_reader_get_stream_by_stream_number(reader, stream_number)))
+    {
+        LeaveCriticalSection(&reader->cs);
+        return E_INVALIDARG;
+    }
+
+    stream->read_compressed = compressed;
+
+    LeaveCriticalSection(&reader->cs);
+    return S_OK;
+}
+
+HRESULT wm_reader_get_max_stream_size(struct wm_reader *reader, WORD stream_number, DWORD *size)
+{
+    struct wm_stream *stream;
+
+    EnterCriticalSection(&reader->cs);
+
+    if (!(stream = wm_reader_get_stream_by_stream_number(reader, stream_number)))
+    {
+        LeaveCriticalSection(&reader->cs);
+        return E_INVALIDARG;
+    }
+
+    *size = wg_format_get_max_size(&stream->format);
+
+    LeaveCriticalSection(&reader->cs);
+    return S_OK;
+}
+
+void wm_reader_init(struct wm_reader *reader, const struct wm_reader_ops *ops)
+{
+    reader->IWMHeaderInfo3_iface.lpVtbl = &header_info_vtbl;
+    reader->IWMLanguageList_iface.lpVtbl = &language_list_vtbl;
+    reader->IWMPacketSize2_iface.lpVtbl = &packet_size_vtbl;
+    reader->IWMProfile3_iface.lpVtbl = &profile_vtbl;
+    reader->IWMReaderPlaylistBurn_iface.lpVtbl = &playlist_vtbl;
+    reader->IWMReaderTimecode_iface.lpVtbl = &timecode_vtbl;
+    reader->refcount = 1;
+    reader->ops = ops;
+
+    InitializeCriticalSection(&reader->cs);
+    reader->cs.DebugInfo->Spare[0] = (DWORD_PTR)(__FILE__ ": wm_reader.cs");
+}
+
+void wm_reader_cleanup(struct wm_reader *reader)
+{
+    reader->cs.DebugInfo->Spare[0] = 0;
+    DeleteCriticalSection(&reader->cs);
+}
diff --git a/dlls/mfplat/wm_syncreader.c b/dlls/mfplat/wm_syncreader.c
new file mode 100644
index 00000000000..b03aa69d030
--- /dev/null
+++ wine/dlls/mfplat/wm_syncreader.c
@@ -0,0 +1,407 @@
+/*
+ * Copyright 2012 Austin English
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "gst_private.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(wmvcore);
+
+struct sync_reader
+{
+    struct wm_reader reader;
+
+    IWMSyncReader2 IWMSyncReader2_iface;
+};
+
+static struct sync_reader *impl_from_IWMSyncReader2(IWMSyncReader2 *iface)
+{
+    return CONTAINING_RECORD(iface, struct sync_reader, IWMSyncReader2_iface);
+}
+
+static HRESULT WINAPI WMSyncReader_QueryInterface(IWMSyncReader2 *iface, REFIID iid, void **out)
+{
+    struct sync_reader *reader = impl_from_IWMSyncReader2(iface);
+
+    return IWMProfile3_QueryInterface(&reader->reader.IWMProfile3_iface, iid, out);
+}
+
+static ULONG WINAPI WMSyncReader_AddRef(IWMSyncReader2 *iface)
+{
+    struct sync_reader *reader = impl_from_IWMSyncReader2(iface);
+
+    return IWMProfile3_AddRef(&reader->reader.IWMProfile3_iface);
+}
+
+static ULONG WINAPI WMSyncReader_Release(IWMSyncReader2 *iface)
+{
+    struct sync_reader *reader = impl_from_IWMSyncReader2(iface);
+
+    return IWMProfile3_Release(&reader->reader.IWMProfile3_iface);
+}
+
+static HRESULT WINAPI WMSyncReader_Close(IWMSyncReader2 *iface)
+{
+    struct sync_reader *reader = impl_from_IWMSyncReader2(iface);
+
+    TRACE("reader %p.\n", reader);
+
+    return wm_reader_close(&reader->reader);
+}
+
+static HRESULT WINAPI WMSyncReader_GetMaxOutputSampleSize(IWMSyncReader2 *iface, DWORD output, DWORD *max)
+{
+    struct sync_reader *This = impl_from_IWMSyncReader2(iface);
+    FIXME("(%p)->(%d %p): stub!\n", This, output, max);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI WMSyncReader_GetMaxStreamSampleSize(IWMSyncReader2 *iface, WORD stream, DWORD *max)
+{
+    struct sync_reader *This = impl_from_IWMSyncReader2(iface);
+    FIXME("(%p)->(%d %p): stub!\n", This, stream, max);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI WMSyncReader_GetNextSample(IWMSyncReader2 *iface,
+        WORD stream_number, INSSBuffer **sample, QWORD *pts, QWORD *duration,
+        DWORD *flags, DWORD *output_number, WORD *ret_stream_number)
+{
+    struct sync_reader *reader = impl_from_IWMSyncReader2(iface);
+    HRESULT hr = NS_E_NO_MORE_SAMPLES;
+
+    TRACE("reader %p, stream_number %u, sample %p, pts %p, duration %p,"
+            " flags %p, output_number %p, ret_stream_number %p.\n",
+            reader, stream_number, sample, pts, duration, flags, output_number, ret_stream_number);
+
+    if (!stream_number && !output_number && !ret_stream_number)
+        return E_INVALIDARG;
+
+    EnterCriticalSection(&reader->reader.cs);
+
+    hr = wm_reader_get_stream_sample(&reader->reader, stream_number, sample, pts, duration, flags, &stream_number);
+    if (output_number && hr == S_OK)
+        *output_number = stream_number - 1;
+    if (ret_stream_number && (hr == S_OK || stream_number))
+        *ret_stream_number = stream_number;
+
+    LeaveCriticalSection(&reader->reader.cs);
+    return hr;
+}
+
+static HRESULT WINAPI WMSyncReader_GetOutputCount(IWMSyncReader2 *iface, DWORD *count)
+{
+    struct sync_reader *reader = impl_from_IWMSyncReader2(iface);
+
+    TRACE("reader %p, count %p.\n", reader, count);
+
+    EnterCriticalSection(&reader->reader.cs);
+    *count = reader->reader.stream_count;
+    LeaveCriticalSection(&reader->reader.cs);
+    return S_OK;
+}
+
+static HRESULT WINAPI WMSyncReader_GetOutputFormat(IWMSyncReader2 *iface,
+        DWORD output, DWORD index, IWMOutputMediaProps **props)
+{
+    struct sync_reader *reader = impl_from_IWMSyncReader2(iface);
+
+    TRACE("reader %p, output %u, index %u, props %p.\n", reader, output, index, props);
+
+    return wm_reader_get_output_format(&reader->reader, output, index, props);
+}
+
+static HRESULT WINAPI WMSyncReader_GetOutputFormatCount(IWMSyncReader2 *iface, DWORD output, DWORD *count)
+{
+    struct sync_reader *reader = impl_from_IWMSyncReader2(iface);
+
+    TRACE("reader %p, output %u, count %p.\n", reader, output, count);
+
+    return wm_reader_get_output_format_count(&reader->reader, output, count);
+}
+
+static HRESULT WINAPI WMSyncReader_GetOutputNumberForStream(IWMSyncReader2 *iface,
+        WORD stream_number, DWORD *output)
+{
+    struct sync_reader *reader = impl_from_IWMSyncReader2(iface);
+
+    TRACE("reader %p, stream_number %u, output %p.\n", reader, stream_number, output);
+
+    *output = stream_number - 1;
+    return S_OK;
+}
+
+static HRESULT WINAPI WMSyncReader_GetOutputProps(IWMSyncReader2 *iface,
+        DWORD output, IWMOutputMediaProps **props)
+{
+    struct sync_reader *reader = impl_from_IWMSyncReader2(iface);
+
+    TRACE("reader %p, output %u, props %p.\n", reader, output, props);
+
+    return wm_reader_get_output_props(&reader->reader, output, props);
+}
+
+static HRESULT WINAPI WMSyncReader_GetOutputSetting(IWMSyncReader2 *iface, DWORD output_num, const WCHAR *name,
+        WMT_ATTR_DATATYPE *type, BYTE *value, WORD *length)
+{
+    struct sync_reader *This = impl_from_IWMSyncReader2(iface);
+    FIXME("(%p)->(%u %s %p %p %p): stub!\n", This, output_num, debugstr_w(name), type, value, length);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI WMSyncReader_GetReadStreamSamples(IWMSyncReader2 *iface, WORD stream_num, BOOL *compressed)
+{
+    struct sync_reader *This = impl_from_IWMSyncReader2(iface);
+    FIXME("(%p)->(%d %p): stub!\n", This, stream_num, compressed);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI WMSyncReader_GetStreamNumberForOutput(IWMSyncReader2 *iface,
+        DWORD output, WORD *stream_number)
+{
+    struct sync_reader *reader = impl_from_IWMSyncReader2(iface);
+
+    TRACE("reader %p, output %u, stream_number %p.\n", reader, output, stream_number);
+
+    *stream_number = output + 1;
+    return S_OK;
+}
+
+static HRESULT WINAPI WMSyncReader_GetStreamSelected(IWMSyncReader2 *iface,
+        WORD stream_number, WMT_STREAM_SELECTION *selection)
+{
+    struct sync_reader *reader = impl_from_IWMSyncReader2(iface);
+
+    TRACE("reader %p, stream_number %u, selection %p.\n", reader, stream_number, selection);
+
+    return wm_reader_get_stream_selection(&reader->reader, stream_number, selection);
+}
+
+static HRESULT WINAPI WMSyncReader_Open(IWMSyncReader2 *iface, const WCHAR *filename)
+{
+    struct sync_reader *reader = impl_from_IWMSyncReader2(iface);
+
+    TRACE("reader %p, filename %s.\n", reader, debugstr_w(filename));
+
+    return wm_reader_open_file(&reader->reader, filename);
+}
+
+static HRESULT WINAPI WMSyncReader_OpenStream(IWMSyncReader2 *iface, IStream *stream)
+{
+    struct sync_reader *reader = impl_from_IWMSyncReader2(iface);
+
+    TRACE("reader %p, stream %p.\n", reader, stream);
+
+    return wm_reader_open_stream(&reader->reader, stream);
+}
+
+static HRESULT WINAPI WMSyncReader_SetOutputProps(IWMSyncReader2 *iface, DWORD output, IWMOutputMediaProps *props)
+{
+    struct sync_reader *reader = impl_from_IWMSyncReader2(iface);
+
+    TRACE("reader %p, output %u, props %p.\n", reader, output, props);
+
+    return wm_reader_set_output_props(&reader->reader, output, props);
+}
+
+static HRESULT WINAPI WMSyncReader_SetOutputSetting(IWMSyncReader2 *iface, DWORD output,
+        const WCHAR *name, WMT_ATTR_DATATYPE type, const BYTE *value, WORD size)
+{
+    struct sync_reader *reader = impl_from_IWMSyncReader2(iface);
+
+    TRACE("reader %p, output %u, name %s, type %#x, value %p, size %u.\n",
+            reader, output, debugstr_w(name), type, value, size);
+
+    if (!wcscmp(name, L"VideoSampleDurations"))
+    {
+        FIXME("Ignoring VideoSampleDurations setting.\n");
+        return S_OK;
+    }
+    else
+    {
+        FIXME("Unknown setting %s; returning E_NOTIMPL.\n", debugstr_w(name));
+        return E_NOTIMPL;
+    }
+}
+
+static HRESULT WINAPI WMSyncReader_SetRange(IWMSyncReader2 *iface, QWORD start, LONGLONG duration)
+{
+    struct sync_reader *reader = impl_from_IWMSyncReader2(iface);
+
+    TRACE("reader %p, start %I64u, duration %I64d.\n", reader, start, duration);
+
+    wm_reader_seek(&reader->reader, start, duration);
+    return S_OK;
+}
+
+static HRESULT WINAPI WMSyncReader_SetRangeByFrame(IWMSyncReader2 *iface, WORD stream_num, QWORD frame_num,
+        LONGLONG frames)
+{
+    struct sync_reader *This = impl_from_IWMSyncReader2(iface);
+    FIXME("(%p)->(%d %s %s): stub!\n", This, stream_num, wine_dbgstr_longlong(frame_num), wine_dbgstr_longlong(frames));
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI WMSyncReader_SetReadStreamSamples(IWMSyncReader2 *iface, WORD stream_number, BOOL compressed)
+{
+    struct sync_reader *reader = impl_from_IWMSyncReader2(iface);
+
+    TRACE("reader %p, stream_index %u, compressed %d.\n", reader, stream_number, compressed);
+
+    return wm_reader_set_read_compressed(&reader->reader, stream_number, compressed);
+}
+
+static HRESULT WINAPI WMSyncReader_SetStreamsSelected(IWMSyncReader2 *iface,
+        WORD count, WORD *stream_numbers, WMT_STREAM_SELECTION *selections)
+{
+    struct sync_reader *reader = impl_from_IWMSyncReader2(iface);
+
+    TRACE("reader %p, count %u, stream_numbers %p, selections %p.\n",
+            reader, count, stream_numbers, selections);
+
+    return wm_reader_set_streams_selected(&reader->reader, count, stream_numbers, selections);
+}
+
+static HRESULT WINAPI WMSyncReader2_SetRangeByTimecode(IWMSyncReader2 *iface, WORD stream_num,
+        WMT_TIMECODE_EXTENSION_DATA *start, WMT_TIMECODE_EXTENSION_DATA *end)
+{
+    struct sync_reader *This = impl_from_IWMSyncReader2(iface);
+    FIXME("(%p)->(%u %p %p): stub!\n", This, stream_num, start, end);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI WMSyncReader2_SetRangeByFrameEx(IWMSyncReader2 *iface, WORD stream_num, QWORD frame_num,
+        LONGLONG frames_to_read, QWORD *starttime)
+{
+    struct sync_reader *This = impl_from_IWMSyncReader2(iface);
+    FIXME("(%p)->(%u %s %s %p): stub!\n", This, stream_num, wine_dbgstr_longlong(frame_num),
+          wine_dbgstr_longlong(frames_to_read), starttime);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI WMSyncReader2_SetAllocateForOutput(IWMSyncReader2 *iface, DWORD output_num, IWMReaderAllocatorEx *allocator)
+{
+    struct sync_reader *This = impl_from_IWMSyncReader2(iface);
+    FIXME("(%p)->(%d %p): stub!\n", This, output_num, allocator);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI WMSyncReader2_GetAllocateForOutput(IWMSyncReader2 *iface, DWORD output_num, IWMReaderAllocatorEx **allocator)
+{
+    struct sync_reader *This = impl_from_IWMSyncReader2(iface);
+    FIXME("(%p)->(%d %p): stub!\n", This, output_num, allocator);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI WMSyncReader2_SetAllocateForStream(IWMSyncReader2 *iface, DWORD stream_num, IWMReaderAllocatorEx *allocator)
+{
+    struct sync_reader *This = impl_from_IWMSyncReader2(iface);
+    FIXME("(%p)->(%d %p): stub!\n", This, stream_num, allocator);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI WMSyncReader2_GetAllocateForStream(IWMSyncReader2 *iface, DWORD stream_num, IWMReaderAllocatorEx **allocator)
+{
+    struct sync_reader *This = impl_from_IWMSyncReader2(iface);
+    FIXME("(%p)->(%d %p): stub!\n", This, stream_num, allocator);
+    return E_NOTIMPL;
+}
+
+static const IWMSyncReader2Vtbl WMSyncReader2Vtbl = {
+    WMSyncReader_QueryInterface,
+    WMSyncReader_AddRef,
+    WMSyncReader_Release,
+    WMSyncReader_Open,
+    WMSyncReader_Close,
+    WMSyncReader_SetRange,
+    WMSyncReader_SetRangeByFrame,
+    WMSyncReader_GetNextSample,
+    WMSyncReader_SetStreamsSelected,
+    WMSyncReader_GetStreamSelected,
+    WMSyncReader_SetReadStreamSamples,
+    WMSyncReader_GetReadStreamSamples,
+    WMSyncReader_GetOutputSetting,
+    WMSyncReader_SetOutputSetting,
+    WMSyncReader_GetOutputCount,
+    WMSyncReader_GetOutputProps,
+    WMSyncReader_SetOutputProps,
+    WMSyncReader_GetOutputFormatCount,
+    WMSyncReader_GetOutputFormat,
+    WMSyncReader_GetOutputNumberForStream,
+    WMSyncReader_GetStreamNumberForOutput,
+    WMSyncReader_GetMaxOutputSampleSize,
+    WMSyncReader_GetMaxStreamSampleSize,
+    WMSyncReader_OpenStream,
+    WMSyncReader2_SetRangeByTimecode,
+    WMSyncReader2_SetRangeByFrameEx,
+    WMSyncReader2_SetAllocateForOutput,
+    WMSyncReader2_GetAllocateForOutput,
+    WMSyncReader2_SetAllocateForStream,
+    WMSyncReader2_GetAllocateForStream
+};
+
+static struct sync_reader *impl_from_wm_reader(struct wm_reader *iface)
+{
+    return CONTAINING_RECORD(iface, struct sync_reader, reader);
+}
+
+static void *sync_reader_query_interface(struct wm_reader *iface, REFIID iid)
+{
+    struct sync_reader *reader = impl_from_wm_reader(iface);
+
+    TRACE("reader %p, iid %s.\n", reader, debugstr_guid(iid));
+
+    if (IsEqualIID(iid, &IID_IWMSyncReader)
+            || IsEqualIID(iid, &IID_IWMSyncReader2))
+        return &reader->IWMSyncReader2_iface;
+
+    return NULL;
+}
+
+static void sync_reader_destroy(struct wm_reader *iface)
+{
+    struct sync_reader *reader = impl_from_wm_reader(iface);
+
+    TRACE("reader %p.\n", reader);
+
+    wm_reader_close(&reader->reader);
+    wm_reader_cleanup(&reader->reader);
+    free(reader);
+}
+
+static const struct wm_reader_ops sync_reader_ops =
+{
+    .query_interface = sync_reader_query_interface,
+    .destroy = sync_reader_destroy,
+};
+
+HRESULT WINAPI winegstreamer_create_wm_sync_reader(IWMSyncReader **reader)
+{
+    struct sync_reader *object;
+
+    TRACE("reader %p.\n", reader);
+
+    if (!(object = calloc(1, sizeof(*object))))
+        return E_OUTOFMEMORY;
+
+    wm_reader_init(&object->reader, &sync_reader_ops);
+
+    object->IWMSyncReader2_iface.lpVtbl = &WMSyncReader2Vtbl;
+
+    TRACE("Created sync reader %p.\n", object);
+    *reader = (IWMSyncReader *)&object->IWMSyncReader2_iface;
+    return S_OK;
+}
diff --git a/dlls/mfplat/wma_decoder.c b/dlls/mfplat/wma_decoder.c
new file mode 100644
index 00000000000..021d0beb935
--- /dev/null
+++ wine/dlls/mfplat/wma_decoder.c
@@ -0,0 +1,861 @@
+/* WMA Decoder Transform
+ *
+ * Copyright 2022 Rémi Bernon for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "gst_private.h"
+
+#include "mfapi.h"
+#include "mferror.h"
+#include "mfobjects.h"
+#include "mftransform.h"
+#include "wmcodecdsp.h"
+
+#include "wine/debug.h"
+#include "wine/heap.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(mfplat);
+
+DEFINE_MEDIATYPE_GUID(MFAudioFormat_XMAudio2, 0x0166);
+
+static const GUID *wma_decoder_input_types[] =
+{
+    &MEDIASUBTYPE_MSAUDIO1,
+    &MFAudioFormat_WMAudioV8,
+    &MFAudioFormat_WMAudioV9,
+    &MFAudioFormat_WMAudio_Lossless,
+    &MFAudioFormat_XMAudio2,
+};
+static const GUID *wma_decoder_output_types[] =
+{
+    &MFAudioFormat_Float,
+    &MFAudioFormat_PCM,
+};
+
+struct wma_decoder
+{
+    IUnknown IUnknown_inner;
+    IMFTransform IMFTransform_iface;
+    IMediaObject IMediaObject_iface;
+    IUnknown *outer;
+    LONG refcount;
+    IMFMediaType *input_type;
+    IMFMediaType *output_type;
+
+    IMFSample *input_sample;
+    struct wg_transform *wg_transform;
+};
+
+static inline struct wma_decoder *impl_from_IUnknown(IUnknown *iface)
+{
+    return CONTAINING_RECORD(iface, struct wma_decoder, IUnknown_inner);
+}
+
+static HRESULT WINAPI wma_unknown_QueryInterface(IUnknown *iface, REFIID iid, void **out)
+{
+    struct wma_decoder *decoder = impl_from_IUnknown(iface);
+
+    TRACE("iface %p, iid %s, out %p.\n", iface, debugstr_guid(iid), out);
+
+    if (IsEqualGUID(iid, &IID_IUnknown))
+        *out = &decoder->IUnknown_inner;
+    else if (IsEqualGUID(iid, &IID_IMFTransform))
+        *out = &decoder->IMFTransform_iface;
+    else if (IsEqualGUID(iid, &IID_IMediaObject))
+        *out = &decoder->IMediaObject_iface;
+    else
+    {
+        *out = NULL;
+        WARN("%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid(iid));
+        return E_NOINTERFACE;
+    }
+
+    IUnknown_AddRef((IUnknown *)*out);
+    return S_OK;
+}
+
+static ULONG WINAPI wma_unknown_AddRef(IUnknown *iface)
+{
+    struct wma_decoder *decoder = impl_from_IUnknown(iface);
+    ULONG refcount = InterlockedIncrement(&decoder->refcount);
+
+    TRACE("iface %p increasing refcount to %u.\n", decoder, refcount);
+
+    return refcount;
+}
+
+static ULONG WINAPI wma_unknown_Release(IUnknown *iface)
+{
+    struct wma_decoder *decoder = impl_from_IUnknown(iface);
+    ULONG refcount = InterlockedDecrement(&decoder->refcount);
+
+    TRACE("iface %p decreasing refcount to %u.\n", decoder, refcount);
+
+    if (!refcount)
+    {
+        if (decoder->input_sample)
+            IMFSample_Release(decoder->input_sample);
+        if (decoder->wg_transform)
+            wg_transform_destroy(decoder->wg_transform);
+        if (decoder->input_type)
+            IMFMediaType_Release(decoder->input_type);
+        if (decoder->output_type)
+            IMFMediaType_Release(decoder->output_type);
+        free(decoder);
+    }
+
+    return refcount;
+}
+
+static const IUnknownVtbl wma_unknown_vtbl =
+{
+    wma_unknown_QueryInterface,
+    wma_unknown_AddRef,
+    wma_unknown_Release,
+};
+
+static struct wma_decoder *impl_from_IMFTransform(IMFTransform *iface)
+{
+    return CONTAINING_RECORD(iface, struct wma_decoder, IMFTransform_iface);
+}
+
+static HRESULT try_create_wg_transform(struct wma_decoder *decoder)
+{
+    struct wg_encoded_format input_format;
+    struct wg_format output_format;
+
+    if (decoder->wg_transform)
+        wg_transform_destroy(decoder->wg_transform);
+    decoder->wg_transform = NULL;
+
+    mf_media_type_to_wg_encoded_format(decoder->input_type, &input_format);
+    if (input_format.encoded_type == WG_ENCODED_TYPE_UNKNOWN)
+        return MF_E_INVALIDMEDIATYPE;
+
+    mf_media_type_to_wg_format(decoder->output_type, &output_format);
+    if (output_format.major_type == WG_MAJOR_TYPE_UNKNOWN)
+        return MF_E_INVALIDMEDIATYPE;
+
+    decoder->wg_transform = wg_transform_create(&input_format, &output_format);
+    if (decoder->wg_transform)
+        return S_OK;
+
+    WARN("Failed to create wg_transform.\n");
+    return E_FAIL;
+}
+
+static HRESULT WINAPI wma_decoder_QueryInterface(IMFTransform *iface, REFIID iid, void **out)
+{
+    struct wma_decoder *decoder = impl_from_IMFTransform(iface);
+    return IUnknown_QueryInterface(decoder->outer, iid, out);
+}
+
+static ULONG WINAPI wma_decoder_AddRef(IMFTransform *iface)
+{
+    struct wma_decoder *decoder = impl_from_IMFTransform(iface);
+    return IUnknown_AddRef(decoder->outer);
+}
+
+static ULONG WINAPI wma_decoder_Release(IMFTransform *iface)
+{
+    struct wma_decoder *decoder = impl_from_IMFTransform(iface);
+    return IUnknown_Release(decoder->outer);
+}
+
+static HRESULT WINAPI wma_decoder_GetStreamLimits(IMFTransform *iface, DWORD *input_minimum,
+        DWORD *input_maximum, DWORD *output_minimum, DWORD *output_maximum)
+{
+    FIXME("iface %p, input_minimum %p, input_maximum %p, output_minimum %p, output_maximum %p stub!\n",
+            iface, input_minimum, input_maximum, output_minimum, output_maximum);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI wma_decoder_GetStreamCount(IMFTransform *iface, DWORD *inputs, DWORD *outputs)
+{
+    FIXME("iface %p, inputs %p, outputs %p stub!\n", iface, inputs, outputs);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI wma_decoder_GetStreamIDs(IMFTransform *iface, DWORD input_size, DWORD *inputs,
+        DWORD output_size, DWORD *outputs)
+{
+    FIXME("iface %p, input_size %u, inputs %p, output_size %u, outputs %p stub!\n", iface,
+            input_size, inputs, output_size, outputs);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI wma_decoder_GetInputStreamInfo(IMFTransform *iface, DWORD id, MFT_INPUT_STREAM_INFO *info)
+{
+    struct wma_decoder *decoder = impl_from_IMFTransform(iface);
+    UINT32 block_alignment;
+    HRESULT hr;
+
+    TRACE("iface %p, id %u, info %p.\n", iface, id, info);
+
+    if (!decoder->input_type || !decoder->output_type)
+        return MF_E_TRANSFORM_TYPE_NOT_SET;
+
+    if (FAILED(hr = IMFMediaType_GetUINT32(decoder->input_type, &MF_MT_AUDIO_BLOCK_ALIGNMENT, &block_alignment)))
+        return hr;
+
+    info->hnsMaxLatency = 0;
+    info->dwFlags = 0;
+    info->cbSize = block_alignment;
+    info->cbMaxLookahead = 0;
+    info->cbAlignment = 1;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI wma_decoder_GetOutputStreamInfo(IMFTransform *iface, DWORD id, MFT_OUTPUT_STREAM_INFO *info)
+{
+    struct wma_decoder *decoder = impl_from_IMFTransform(iface);
+    UINT32 channel_count, block_alignment;
+    HRESULT hr;
+
+    TRACE("iface %p, id %u, info %p.\n", iface, id, info);
+
+    if (!decoder->input_type || !decoder->output_type)
+        return MF_E_TRANSFORM_TYPE_NOT_SET;
+
+    if (FAILED(hr = IMFMediaType_GetUINT32(decoder->output_type, &MF_MT_AUDIO_NUM_CHANNELS, &channel_count)))
+        return hr;
+    if (FAILED(hr = IMFMediaType_GetUINT32(decoder->output_type, &MF_MT_AUDIO_BLOCK_ALIGNMENT, &block_alignment)))
+        return hr;
+
+    info->dwFlags = 0;
+    info->cbSize = 1024 * block_alignment * channel_count;
+    info->cbAlignment = 1;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI wma_decoder_GetAttributes(IMFTransform *iface, IMFAttributes **attributes)
+{
+    FIXME("iface %p, attributes %p stub!\n", iface, attributes);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI wma_decoder_GetInputStreamAttributes(IMFTransform *iface, DWORD id, IMFAttributes **attributes)
+{
+    FIXME("iface %p, id %u, attributes %p stub!\n", iface, id, attributes);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI wma_decoder_GetOutputStreamAttributes(IMFTransform *iface, DWORD id, IMFAttributes **attributes)
+{
+    FIXME("iface %p, id %u, attributes %p stub!\n", iface, id, attributes);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI wma_decoder_DeleteInputStream(IMFTransform *iface, DWORD id)
+{
+    FIXME("iface %p, id %u stub!\n", iface, id);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI wma_decoder_AddInputStreams(IMFTransform *iface, DWORD streams, DWORD *ids)
+{
+    FIXME("iface %p, streams %u, ids %p stub!\n", iface, streams, ids);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI wma_decoder_GetInputAvailableType(IMFTransform *iface, DWORD id, DWORD index,
+        IMFMediaType **type)
+{
+    FIXME("iface %p, id %u, index %u, type %p stub!\n", iface, id, index, type);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI wma_decoder_GetOutputAvailableType(IMFTransform *iface, DWORD id, DWORD index,
+        IMFMediaType **type)
+{
+    UINT32 channel_count, sample_size, sample_rate, block_alignment;
+    struct wma_decoder *decoder = impl_from_IMFTransform(iface);
+    IMFMediaType *media_type;
+    const GUID *output_type;
+    HRESULT hr;
+
+    TRACE("iface %p, id %u, index %u, type %p.\n", iface, id, index, type);
+
+    if (!decoder->input_type)
+        return MF_E_TRANSFORM_TYPE_NOT_SET;
+
+    *type = NULL;
+
+    if (index >= ARRAY_SIZE(wma_decoder_output_types))
+        return MF_E_NO_MORE_TYPES;
+    output_type = wma_decoder_output_types[index];
+
+    if (FAILED(hr = MFCreateMediaType(&media_type)))
+        return hr;
+
+    if (FAILED(hr = IMFMediaType_SetGUID(media_type, &MF_MT_MAJOR_TYPE, &MFMediaType_Audio)))
+        goto done;
+    if (FAILED(hr = IMFMediaType_SetGUID(media_type, &MF_MT_SUBTYPE, output_type)))
+        goto done;
+
+    if (IsEqualGUID(output_type, &MFAudioFormat_Float))
+        sample_size = 32;
+    else if (IsEqualGUID(output_type, &MFAudioFormat_PCM))
+        sample_size = 16;
+    else
+    {
+        FIXME("Subtype %s not implemented!\n", debugstr_guid(output_type));
+        hr = E_NOTIMPL;
+        goto done;
+    }
+
+    if (FAILED(hr = IMFMediaType_SetUINT32(media_type, &MF_MT_AUDIO_BITS_PER_SAMPLE, sample_size)))
+        goto done;
+
+    if (FAILED(hr = IMFMediaType_GetUINT32(decoder->input_type, &MF_MT_AUDIO_NUM_CHANNELS, &channel_count)))
+        goto done;
+    if (FAILED(hr = IMFMediaType_SetUINT32(media_type, &MF_MT_AUDIO_NUM_CHANNELS, channel_count)))
+        goto done;
+
+    if (FAILED(hr = IMFMediaType_GetUINT32(decoder->input_type, &MF_MT_AUDIO_SAMPLES_PER_SECOND, &sample_rate)))
+        goto done;
+    if (FAILED(hr = IMFMediaType_SetUINT32(media_type, &MF_MT_AUDIO_SAMPLES_PER_SECOND, sample_rate)))
+        goto done;
+
+    block_alignment = sample_size * channel_count / 8;
+    if (FAILED(hr = IMFMediaType_SetUINT32(media_type, &MF_MT_AUDIO_BLOCK_ALIGNMENT, block_alignment)))
+        goto done;
+    if (FAILED(hr = IMFMediaType_SetUINT32(media_type, &MF_MT_AUDIO_AVG_BYTES_PER_SECOND, sample_rate * block_alignment)))
+        goto done;
+
+    if (FAILED(hr = IMFMediaType_SetUINT32(media_type, &MF_MT_ALL_SAMPLES_INDEPENDENT, 1)))
+        goto done;
+    if (FAILED(hr = IMFMediaType_SetUINT32(media_type, &MF_MT_FIXED_SIZE_SAMPLES, 1)))
+        goto done;
+    if (FAILED(hr = IMFMediaType_SetUINT32(media_type, &MF_MT_AUDIO_PREFER_WAVEFORMATEX, 1)))
+        goto done;
+
+done:
+    if (SUCCEEDED(hr))
+        IMFMediaType_AddRef((*type = media_type));
+
+    IMFMediaType_Release(media_type);
+    return hr;
+}
+
+static HRESULT WINAPI wma_decoder_SetInputType(IMFTransform *iface, DWORD id, IMFMediaType *type, DWORD flags)
+{
+    struct wma_decoder *decoder = impl_from_IMFTransform(iface);
+    MF_ATTRIBUTE_TYPE item_type;
+    GUID major, subtype;
+    HRESULT hr;
+    ULONG i;
+
+    TRACE("iface %p, id %u, type %p, flags %#x.\n", iface, id, type, flags);
+
+    if (FAILED(hr = IMFMediaType_GetGUID(type, &MF_MT_MAJOR_TYPE, &major)) ||
+        FAILED(hr = IMFMediaType_GetGUID(type, &MF_MT_SUBTYPE, &subtype)))
+        return hr;
+
+    if (!IsEqualGUID(&major, &MFMediaType_Audio))
+        return MF_E_INVALIDMEDIATYPE;
+
+    for (i = 0; i < ARRAY_SIZE(wma_decoder_input_types); ++i)
+        if (IsEqualGUID(&subtype, wma_decoder_input_types[i]))
+            break;
+    if (i == ARRAY_SIZE(wma_decoder_input_types))
+        return MF_E_INVALIDMEDIATYPE;
+
+    if (FAILED(IMFMediaType_GetItemType(type, &MF_MT_USER_DATA, &item_type)) ||
+        item_type != MF_ATTRIBUTE_BLOB)
+        return MF_E_INVALIDMEDIATYPE;
+    if (FAILED(IMFMediaType_GetItemType(type, &MF_MT_AUDIO_BLOCK_ALIGNMENT, &item_type)) ||
+        item_type != MF_ATTRIBUTE_UINT32)
+        return MF_E_INVALIDMEDIATYPE;
+    if (FAILED(IMFMediaType_GetItemType(type, &MF_MT_AUDIO_SAMPLES_PER_SECOND, &item_type)) ||
+        item_type != MF_ATTRIBUTE_UINT32)
+        return MF_E_INVALIDMEDIATYPE;
+    if (FAILED(IMFMediaType_GetItemType(type, &MF_MT_AUDIO_NUM_CHANNELS, &item_type)) ||
+        item_type != MF_ATTRIBUTE_UINT32)
+        return MF_E_INVALIDMEDIATYPE;
+
+    if (!decoder->input_type && FAILED(hr = MFCreateMediaType(&decoder->input_type)))
+        return hr;
+
+    if (decoder->output_type)
+    {
+        IMFMediaType_Release(decoder->output_type);
+        decoder->output_type = NULL;
+    }
+
+    if (FAILED(hr = IMFMediaType_CopyAllItems(type, (IMFAttributes *)decoder->input_type)))
+    {
+        IMFMediaType_Release(decoder->input_type);
+        decoder->input_type = NULL;
+    }
+
+    return hr;
+}
+
+static HRESULT WINAPI wma_decoder_SetOutputType(IMFTransform *iface, DWORD id, IMFMediaType *type, DWORD flags)
+{
+    struct wma_decoder *decoder = impl_from_IMFTransform(iface);
+    MF_ATTRIBUTE_TYPE item_type;
+    ULONG i, sample_size;
+    GUID major, subtype;
+    HRESULT hr;
+
+    TRACE("iface %p, id %u, type %p, flags %#x.\n", iface, id, type, flags);
+
+    if (FAILED(hr = IMFMediaType_GetGUID(type, &MF_MT_MAJOR_TYPE, &major)) ||
+        FAILED(hr = IMFMediaType_GetGUID(type, &MF_MT_SUBTYPE, &subtype)))
+        return hr;
+
+    if (!IsEqualGUID(&major, &MFMediaType_Audio))
+        return MF_E_INVALIDMEDIATYPE;
+
+    for (i = 0; i < ARRAY_SIZE(wma_decoder_output_types); ++i)
+        if (IsEqualGUID(&subtype, wma_decoder_output_types[i]))
+            break;
+    if (i == ARRAY_SIZE(wma_decoder_output_types))
+        return MF_E_INVALIDMEDIATYPE;
+
+    if (IsEqualGUID(&subtype, &MFAudioFormat_Float))
+        sample_size = 32;
+    else if (IsEqualGUID(&subtype, &MFAudioFormat_PCM))
+        sample_size = 16;
+    else
+    {
+        FIXME("Subtype %s not implemented!\n", debugstr_guid(&subtype));
+        hr = E_NOTIMPL;
+        return hr;
+    }
+
+    if (FAILED(IMFMediaType_SetUINT32(decoder->input_type, &MF_MT_AUDIO_BITS_PER_SAMPLE, sample_size)))
+        return MF_E_INVALIDMEDIATYPE;
+
+    if (FAILED(IMFMediaType_GetItemType(type, &MF_MT_AUDIO_AVG_BYTES_PER_SECOND, &item_type)) ||
+        item_type != MF_ATTRIBUTE_UINT32)
+        return MF_E_INVALIDMEDIATYPE;
+    if (FAILED(IMFMediaType_GetItemType(type, &MF_MT_AUDIO_BITS_PER_SAMPLE, &item_type)) ||
+        item_type != MF_ATTRIBUTE_UINT32)
+        return MF_E_INVALIDMEDIATYPE;
+    if (FAILED(IMFMediaType_GetItemType(type, &MF_MT_AUDIO_NUM_CHANNELS, &item_type)) ||
+        item_type != MF_ATTRIBUTE_UINT32)
+        return MF_E_INVALIDMEDIATYPE;
+    if (FAILED(IMFMediaType_GetItemType(type, &MF_MT_AUDIO_SAMPLES_PER_SECOND, &item_type)) ||
+        item_type != MF_ATTRIBUTE_UINT32)
+        return MF_E_INVALIDMEDIATYPE;
+    if (FAILED(IMFMediaType_GetItemType(type, &MF_MT_AUDIO_BLOCK_ALIGNMENT, &item_type)) ||
+        item_type != MF_ATTRIBUTE_UINT32)
+        return MF_E_INVALIDMEDIATYPE;
+
+    if (!decoder->output_type && FAILED(hr = MFCreateMediaType(&decoder->output_type)))
+        return hr;
+
+    if (FAILED(hr = IMFMediaType_CopyAllItems(type, (IMFAttributes *)decoder->output_type)))
+        goto failed;
+
+    if (FAILED(hr = try_create_wg_transform(decoder)))
+        goto failed;
+
+    return S_OK;
+
+failed:
+    IMFMediaType_Release(decoder->output_type);
+    decoder->output_type = NULL;
+    return hr;
+}
+
+static HRESULT WINAPI wma_decoder_GetInputCurrentType(IMFTransform *iface, DWORD id, IMFMediaType **type)
+{
+    FIXME("iface %p, id %u, type %p stub!\n", iface, id, type);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI wma_decoder_GetOutputCurrentType(IMFTransform *iface, DWORD id, IMFMediaType **type)
+{
+    FIXME("iface %p, id %u, type %p stub!\n", iface, id, type);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI wma_decoder_GetInputStatus(IMFTransform *iface, DWORD id, DWORD *flags)
+{
+    FIXME("iface %p, id %u, flags %p stub!\n", iface, id, flags);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI wma_decoder_GetOutputStatus(IMFTransform *iface, DWORD *flags)
+{
+    FIXME("iface %p, flags %p stub!\n", iface, flags);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI wma_decoder_SetOutputBounds(IMFTransform *iface, LONGLONG lower, LONGLONG upper)
+{
+    FIXME("iface %p, lower %s, upper %s stub!\n", iface, wine_dbgstr_longlong(lower),
+            wine_dbgstr_longlong(upper));
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI wma_decoder_ProcessEvent(IMFTransform *iface, DWORD id, IMFMediaEvent *event)
+{
+    FIXME("iface %p, id %u, event %p stub!\n", iface, id, event);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI wma_decoder_ProcessMessage(IMFTransform *iface, MFT_MESSAGE_TYPE message, ULONG_PTR param)
+{
+    FIXME("iface %p, message %#x, param %p stub!\n", iface, message, (void *)param);
+    return S_OK;
+}
+
+static HRESULT WINAPI wma_decoder_ProcessInput(IMFTransform *iface, DWORD id, IMFSample *sample, DWORD flags)
+{
+    struct wma_decoder *decoder = impl_from_IMFTransform(iface);
+    IMFMediaBuffer *media_buffer;
+    MFT_INPUT_STREAM_INFO info;
+    UINT32 buffer_size;
+    BYTE *buffer;
+    HRESULT hr;
+
+    TRACE("iface %p, id %u, sample %p, flags %#x.\n", iface, id, sample, flags);
+
+    if (FAILED(hr = IMFTransform_GetInputStreamInfo(iface, 0, &info)))
+        return hr;
+
+    if (!decoder->wg_transform)
+        return MF_E_TRANSFORM_TYPE_NOT_SET;
+
+    if (decoder->input_sample)
+        return MF_E_NOTACCEPTING;
+
+    if (FAILED(hr = IMFSample_ConvertToContiguousBuffer(sample, &media_buffer)))
+        return hr;
+
+    if (FAILED(hr = IMFMediaBuffer_GetCurrentLength(media_buffer, &buffer_size)))
+        return hr;
+
+    if (!(buffer_size = (buffer_size / info.cbSize) * info.cbSize))
+        return S_OK;
+
+    if (FAILED(hr = IMFMediaBuffer_Lock(media_buffer, &buffer, NULL, NULL)))
+        goto done;
+
+    if (SUCCEEDED(hr = wg_transform_push_data(decoder->wg_transform, buffer, buffer_size)))
+        IMFSample_AddRef((decoder->input_sample = sample));
+
+    IMFMediaBuffer_Unlock(media_buffer);
+
+done:
+    IMFMediaBuffer_Release(media_buffer);
+    return hr;
+}
+
+static HRESULT WINAPI wma_decoder_ProcessOutput(IMFTransform *iface, DWORD flags, DWORD count,
+        MFT_OUTPUT_DATA_BUFFER *samples, DWORD *status)
+{
+    struct wma_decoder *decoder = impl_from_IMFTransform(iface);
+    struct wg_sample wg_sample = {0};
+    IMFMediaBuffer *media_buffer;
+    MFT_OUTPUT_STREAM_INFO info;
+    HRESULT hr;
+
+    TRACE("iface %p, flags %#x, count %u, samples %p, status %p.\n", iface, flags, count, samples, status);
+
+    if (count > 1)
+    {
+        FIXME("Not implemented count %u\n", count);
+        return E_NOTIMPL;
+    }
+
+    if (FAILED(hr = IMFTransform_GetOutputStreamInfo(iface, 0, &info)))
+        return hr;
+
+    if (!decoder->wg_transform)
+        return MF_E_TRANSFORM_TYPE_NOT_SET;
+
+    *status = 0;
+    samples[0].dwStatus = 0;
+    if (!samples[0].pSample)
+    {
+        samples[0].dwStatus = MFT_OUTPUT_DATA_BUFFER_NO_SAMPLE;
+        return MF_E_TRANSFORM_NEED_MORE_INPUT;
+    }
+
+    if (FAILED(hr = IMFSample_ConvertToContiguousBuffer(samples[0].pSample, &media_buffer)))
+        return hr;
+
+    if (FAILED(hr = IMFMediaBuffer_Lock(media_buffer, &wg_sample.data, &wg_sample.size, NULL)))
+        goto done;
+
+    if (wg_sample.size < info.cbSize)
+        hr = MF_E_BUFFERTOOSMALL;
+    else if (SUCCEEDED(hr = wg_transform_read_data(decoder->wg_transform, &wg_sample)))
+    {
+        if (wg_sample.flags & WG_SAMPLE_FLAG_INCOMPLETE)
+            samples[0].dwStatus |= MFT_OUTPUT_DATA_BUFFER_INCOMPLETE;
+    }
+    else
+    {
+        if (decoder->input_sample)
+            IMFSample_Release(decoder->input_sample);
+        decoder->input_sample = NULL;
+    }
+
+    IMFMediaBuffer_Unlock(media_buffer);
+
+done:
+    IMFMediaBuffer_SetCurrentLength(media_buffer, wg_sample.size);
+    IMFMediaBuffer_Release(media_buffer);
+    return hr;
+}
+
+static const IMFTransformVtbl mf_transform_vtbl =
+{
+    wma_decoder_QueryInterface,
+    wma_decoder_AddRef,
+    wma_decoder_Release,
+    wma_decoder_GetStreamLimits,
+    wma_decoder_GetStreamCount,
+    wma_decoder_GetStreamIDs,
+    wma_decoder_GetInputStreamInfo,
+    wma_decoder_GetOutputStreamInfo,
+    wma_decoder_GetAttributes,
+    wma_decoder_GetInputStreamAttributes,
+    wma_decoder_GetOutputStreamAttributes,
+    wma_decoder_DeleteInputStream,
+    wma_decoder_AddInputStreams,
+    wma_decoder_GetInputAvailableType,
+    wma_decoder_GetOutputAvailableType,
+    wma_decoder_SetInputType,
+    wma_decoder_SetOutputType,
+    wma_decoder_GetInputCurrentType,
+    wma_decoder_GetOutputCurrentType,
+    wma_decoder_GetInputStatus,
+    wma_decoder_GetOutputStatus,
+    wma_decoder_SetOutputBounds,
+    wma_decoder_ProcessEvent,
+    wma_decoder_ProcessMessage,
+    wma_decoder_ProcessInput,
+    wma_decoder_ProcessOutput,
+};
+
+static inline struct wma_decoder *impl_from_IMediaObject(IMediaObject *iface)
+{
+    return CONTAINING_RECORD(iface, struct wma_decoder, IMediaObject_iface);
+}
+
+static HRESULT WINAPI wma_media_object_QueryInterface(IMediaObject *iface, REFIID iid, void **obj)
+{
+    struct wma_decoder *decoder = impl_from_IMediaObject(iface);
+    return IUnknown_QueryInterface(decoder->outer, iid, obj);
+}
+
+static ULONG WINAPI wma_media_object_AddRef(IMediaObject *iface)
+{
+    struct wma_decoder *decoder = impl_from_IMediaObject(iface);
+    return IUnknown_AddRef(decoder->outer);
+}
+
+static ULONG WINAPI wma_media_object_Release(IMediaObject *iface)
+{
+    struct wma_decoder *decoder = impl_from_IMediaObject(iface);
+    return IUnknown_Release(decoder->outer);
+}
+
+static HRESULT WINAPI wma_media_object_GetStreamCount(IMediaObject *iface, DWORD *input, DWORD *output)
+{
+    FIXME("iface %p, input %p, output %p stub!\n", iface, input, output);
+    *input = *output = 1;
+    return S_OK;
+}
+
+static HRESULT WINAPI wma_media_object_GetInputStreamInfo(IMediaObject *iface, DWORD index, DWORD *flags)
+{
+    FIXME("iface %p, index %u, flags %p stub!\n", iface, index, flags);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI wma_media_object_GetOutputStreamInfo(IMediaObject *iface, DWORD index, DWORD *flags)
+{
+    FIXME("iface %p, index %u, flags %p stub!\n", iface, index, flags);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI wma_media_object_GetInputType(IMediaObject *iface, DWORD index,
+        DWORD type_index, DMO_MEDIA_TYPE *type)
+{
+    FIXME("iface %p, index %u, type_index %u, type %p stub!\n", iface, index, type_index, type);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI wma_media_object_GetOutputType(IMediaObject *iface, DWORD index,
+        DWORD type_index, DMO_MEDIA_TYPE *type)
+{
+    FIXME("iface %p, index %u, type_index %u, type %p stub!\n", iface, index, type_index, type);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI wma_media_object_SetInputType(IMediaObject *iface, DWORD index,
+        const DMO_MEDIA_TYPE *type, DWORD flags)
+{
+    FIXME("iface %p, index %u, type %p, flags %#x stub!\n", iface, index, type, flags);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI wma_media_object_SetOutputType(IMediaObject *iface, DWORD index,
+        const DMO_MEDIA_TYPE *type, DWORD flags)
+{
+    FIXME("iface %p, index %u, type %p, flags %#x stub!\n", iface, index, type, flags);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI wma_media_object_GetInputCurrentType(IMediaObject *iface, DWORD index, DMO_MEDIA_TYPE *type)
+{
+    FIXME("iface %p, index %u, type %p stub!\n", iface, index, type);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI wma_media_object_GetOutputCurrentType(IMediaObject *iface, DWORD index, DMO_MEDIA_TYPE *type)
+{
+    FIXME("iface %p, index %u, type %p stub!\n", iface, index, type);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI wma_media_object_GetInputSizeInfo(IMediaObject *iface, DWORD index,
+        DWORD *size, DWORD *lookahead, DWORD *alignment)
+{
+    FIXME("iface %p, index %u, size %p, lookahead %p, alignment %p stub!\n", iface, index, size,
+            lookahead, alignment);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI wma_media_object_GetOutputSizeInfo(IMediaObject *iface, DWORD index,
+        DWORD *size, DWORD *alignment)
+{
+    FIXME("iface %p, index %u, size %p, alignment %p stub!\n", iface, index, size, alignment);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI wma_media_object_GetInputMaxLatency(IMediaObject *iface, DWORD index, REFERENCE_TIME *latency)
+{
+    FIXME("iface %p, index %u, latency %p stub!\n", iface, index, latency);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI wma_media_object_SetInputMaxLatency(IMediaObject *iface, DWORD index, REFERENCE_TIME latency)
+{
+    FIXME("iface %p, index %u, latency %s stub!\n", iface, index, wine_dbgstr_longlong(latency));
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI wma_media_object_Flush(IMediaObject *iface)
+{
+    FIXME("iface %p stub!\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI wma_media_object_Discontinuity(IMediaObject *iface, DWORD index)
+{
+    FIXME("iface %p, index %u stub!\n", iface, index);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI wma_media_object_AllocateStreamingResources(IMediaObject *iface)
+{
+    FIXME("iface %p stub!\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI wma_media_object_FreeStreamingResources(IMediaObject *iface)
+{
+    FIXME("iface %p stub!\n", iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI wma_media_object_GetInputStatus(IMediaObject *iface, DWORD index, DWORD *flags)
+{
+    FIXME("iface %p, index %u, flags %p stub!\n", iface, index, flags);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI wma_media_object_ProcessInput(IMediaObject *iface, DWORD index,
+        IMediaBuffer *buffer, DWORD flags, REFERENCE_TIME timestamp, REFERENCE_TIME timelength)
+{
+    FIXME("iface %p, index %u, buffer %p, flags %#x, timestamp %s, timelength %s stub!\n", iface,
+            index, buffer, flags, wine_dbgstr_longlong(timestamp), wine_dbgstr_longlong(timelength));
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI wma_media_object_ProcessOutput(IMediaObject *iface, DWORD flags, DWORD count,
+        DMO_OUTPUT_DATA_BUFFER *buffers, DWORD *status)
+{
+    FIXME("iface %p, flags %#x, count %u, buffers %p, status %p stub!\n", iface, flags, count, buffers, status);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI wma_media_object_Lock(IMediaObject *iface, LONG lock)
+{
+    FIXME("iface %p, lock %d stub!\n", iface, lock);
+    return E_NOTIMPL;
+}
+
+static const IMediaObjectVtbl wma_media_object_vtbl =
+{
+    wma_media_object_QueryInterface,
+    wma_media_object_AddRef,
+    wma_media_object_Release,
+    wma_media_object_GetStreamCount,
+    wma_media_object_GetInputStreamInfo,
+    wma_media_object_GetOutputStreamInfo,
+    wma_media_object_GetInputType,
+    wma_media_object_GetOutputType,
+    wma_media_object_SetInputType,
+    wma_media_object_SetOutputType,
+    wma_media_object_GetInputCurrentType,
+    wma_media_object_GetOutputCurrentType,
+    wma_media_object_GetInputSizeInfo,
+    wma_media_object_GetOutputSizeInfo,
+    wma_media_object_GetInputMaxLatency,
+    wma_media_object_SetInputMaxLatency,
+    wma_media_object_Flush,
+    wma_media_object_Discontinuity,
+    wma_media_object_AllocateStreamingResources,
+    wma_media_object_FreeStreamingResources,
+    wma_media_object_GetInputStatus,
+    wma_media_object_ProcessInput,
+    wma_media_object_ProcessOutput,
+    wma_media_object_Lock,
+};
+
+HRESULT wma_decoder_create(IUnknown *outer, IUnknown **out)
+{
+    struct wma_decoder *decoder;
+
+    TRACE("outer %p, out %p.\n", outer, out);
+
+    if (!(decoder = calloc(1, sizeof(*decoder))))
+        return E_OUTOFMEMORY;
+
+    decoder->IUnknown_inner.lpVtbl = &wma_unknown_vtbl;
+    decoder->IMFTransform_iface.lpVtbl = &mf_transform_vtbl;
+    decoder->IMediaObject_iface.lpVtbl = &wma_media_object_vtbl;
+    decoder->refcount = 1;
+    decoder->outer = outer ? outer : &decoder->IUnknown_inner;
+
+    *out = &decoder->IUnknown_inner;
+    TRACE("Created decoder %p\n", *out);
+    return S_OK;
+}
diff --git a/dlls/qcap/Makefile.in b/dlls/qcap/Makefile.in
index b61a4a05ab2..634bcca2ff4 100644
--- wine/dlls/qcap/Makefile.in
+++ wine/dlls/qcap/Makefile.in
@@ -1,3 +1,4 @@
+EXTRADEFS = -DWINE_NO_LONG_TYPES
 MODULE    = qcap.dll
 UNIXLIB   = qcap.so
 IMPORTS   = strmbase strmiids uuid ole32 oleaut32
diff --git a/dlls/qcap/audiorecord.c b/dlls/qcap/audiorecord.c
index a6f27cf4f26..c77a214b06b 100644
--- wine/dlls/qcap/audiorecord.c
+++ wine/dlls/qcap/audiorecord.c
@@ -115,7 +115,13 @@ static HRESULT WINAPI PPB_Load(IPersistPropertyBag *iface, IPropertyBag *pPropBa
     hr = IPropertyBag_Read(pPropBag, L"WaveInID", &var, pErrorLog);
     if (SUCCEEDED(hr))
     {
-        FIXME("FIXME: implement opening waveIn device %ld\n", V_I4(&var));
+        char sgi[64];
+        FIXME("FIXME: implement opening waveIn device %d\n", V_I4(&var));
+        if (GetEnvironmentVariableA("SteamGameId", sgi, sizeof(sgi)) && !strcmp(sgi, "470220"))
+        {
+            FIXME("HACK: returning error.\n");
+            return E_FAIL;
+        }
     }
 
     return hr;
diff --git a/dlls/qcap/avico.c b/dlls/qcap/avico.c
index 2a347bd2027..e8a452fc7f5 100644
--- wine/dlls/qcap/avico.c
+++ wine/dlls/qcap/avico.c
@@ -142,7 +142,7 @@ static HRESULT avi_compressor_init_stream(struct strmbase_filter *iface)
 
     if (filter->source.pAllocator && FAILED(hr = IMemAllocator_Commit(filter->source.pAllocator)))
     {
-        ERR("Failed to commit allocator, hr %#lx.\n", hr);
+        ERR("Failed to commit allocator, hr %#x.\n", hr);
         return hr;
     }
 
@@ -216,7 +216,7 @@ static HRESULT WINAPI AVICompressorPropertyBag_Load(IPersistPropertyBag *iface,
     V_VT(&v) = VT_BSTR;
     hres = IPropertyBag_Read(pPropBag, L"FccHandler", &v, NULL);
     if(FAILED(hres)) {
-        ERR("Failed to read FccHandler value, hr %#lx.\n", hres);
+        WARN("Could not read FccHandler: %08x\n", hres);
         return hres;
     }
 
@@ -309,7 +309,7 @@ static HRESULT WINAPI AVICompressorIn_Receive(struct strmbase_sink *base, IMedia
     BOOL is_preroll;
     BOOL sync_point;
     BYTE *ptr, *buf;
-    LRESULT res;
+    DWORD res;
     HRESULT hres;
 
     TRACE("(%p)->(%p)\n", base, pSample);
@@ -336,7 +336,7 @@ static HRESULT WINAPI AVICompressorIn_Receive(struct strmbase_sink *base, IMedia
 
     hres = IMediaSample_GetTime(pSample, &start, &stop);
     if(FAILED(hres)) {
-        WARN("Failed to get sample time, hr %#lx.\n", hres);
+        WARN("GetTime failed: %08x\n", hres);
         return hres;
     }
 
@@ -346,18 +346,13 @@ static HRESULT WINAPI AVICompressorIn_Receive(struct strmbase_sink *base, IMedia
 
     hres = IMediaSample_GetPointer(pSample, &ptr);
     if(FAILED(hres)) {
-        ERR("Failed to get input buffer pointer, hr %#lx.\n", hres);
+        WARN("GetPointer failed: %08x\n", hres);
         return hres;
     }
 
-    if (FAILED(hres = IMemAllocator_GetBuffer(This->source.pAllocator, &out_sample, &start, &stop, 0)))
-    {
-        ERR("Failed to get sample, hr %#lx.\n", hres);
+    hres = BaseOutputPinImpl_GetDeliveryBuffer(&This->source, &out_sample, &start, &stop, 0);
+    if(FAILED(hres))
         return hres;
-    }
-
-    if (FAILED(hres = IMediaSample_SetTime(out_sample, &start, &stop)))
-        ERR("Failed to set time, hr %#lx.\n", hres);
 
     hres = IMediaSample_GetPointer(out_sample, &buf);
     if(FAILED(hres))
@@ -371,7 +366,7 @@ static HRESULT WINAPI AVICompressorIn_Receive(struct strmbase_sink *base, IMedia
     res = ICCompress(This->hic, sync_point ? ICCOMPRESS_KEYFRAME : 0, &This->videoinfo->bmiHeader, buf,
             &src_videoinfo->bmiHeader, ptr, 0, &comp_flags, This->frame_cnt, 0, 0, NULL, NULL);
     if(res != ICERR_OK) {
-        ERR("Failed to compress frame, error %Id.\n", res);
+        WARN("ICCompress failed: %d\n", res);
         IMediaSample_Release(out_sample);
         return E_FAIL;
     }
@@ -388,7 +383,7 @@ static HRESULT WINAPI AVICompressorIn_Receive(struct strmbase_sink *base, IMedia
 
     hres = IMemInputPin_Receive(meminput, out_sample);
     if(FAILED(hres))
-        WARN("Failed to deliver sample, hr %#lx.\n", hres);
+        WARN("Deliver failed: %08x\n", hres);
 
     IMediaSample_Release(out_sample);
     This->frame_cnt++;
@@ -480,10 +475,7 @@ HRESULT avi_compressor_create(IUnknown *outer, IUnknown **out)
     object->IPersistPropertyBag_iface.lpVtbl = &PersistPropertyBagVtbl;
 
     strmbase_sink_init(&object->sink, &object->filter, L"In", &sink_ops, NULL);
-    wcscpy(object->sink.pin.name, L"Input");
-
     strmbase_source_init(&object->source, &object->filter, L"Out", &source_ops);
-    wcscpy(object->source.pin.name, L"Output");
 
     TRACE("Created AVI compressor %p.\n", object);
     *out = &object->filter.IUnknown_inner;
diff --git a/dlls/qcap/avimux.c b/dlls/qcap/avimux.c
index 2e8c2a96681..fe4add83b7c 100644
--- wine/dlls/qcap/avimux.c
+++ wine/dlls/qcap/avimux.c
@@ -684,7 +684,7 @@ static ULONG WINAPI ConfigAviMux_Release(IConfigAviMux *iface)
 static HRESULT WINAPI ConfigAviMux_SetMasterStream(IConfigAviMux *iface, LONG iStream)
 {
     AviMux *This = impl_from_IConfigAviMux(iface);
-    FIXME("filter %p, index %ld, stub!\n", This, iStream);
+    FIXME("(%p)->(%d)\n", This, iStream);
     return E_NOTIMPL;
 }
 
@@ -925,7 +925,7 @@ static HRESULT WINAPI MediaSeeking_SetPositions(IMediaSeeking *iface, LONGLONG *
         DWORD dwCurrentFlags, LONGLONG *pStop, DWORD dwStopFlags)
 {
     AviMux *This = impl_from_IMediaSeeking(iface);
-    FIXME("(%p)->(%p %#lx %p %#lx)\n", This, pCurrent, dwCurrentFlags, pStop, dwStopFlags);
+    FIXME("(%p)->(%p %x %p %x)\n", This, pCurrent, dwCurrentFlags, pStop, dwStopFlags);
     return E_NOTIMPL;
 }
 
@@ -1177,12 +1177,9 @@ static HRESULT WINAPI AviMuxOut_DecideAllocator(struct strmbase_source *base,
 
     TRACE("(%p)->(%p %p)\n", base, pPin, pAlloc);
 
-    if (FAILED(hr = CoCreateInstance(&CLSID_MemoryAllocator, NULL,
-            CLSCTX_INPROC_SERVER, &IID_IMemAllocator, (void **)pAlloc)))
-    {
-        ERR("Failed to create allocator, hr %#lx.\n", hr);
+    hr = BaseOutputPinImpl_InitAllocator(base, pAlloc);
+    if(FAILED(hr))
         return hr;
-    }
 
     hr = IMemInputPin_GetAllocatorRequirements(pPin, &req);
     if(FAILED(hr))
@@ -1232,14 +1229,13 @@ static ULONG WINAPI AviMuxOut_QualityControl_Release(IQualityControl *iface)
 }
 
 static HRESULT WINAPI AviMuxOut_QualityControl_Notify(IQualityControl *iface,
-        IBaseFilter *sender, Quality q)
+        IBaseFilter *pSelf, Quality q)
 {
-    AviMux *filter = impl_from_out_IQualityControl(iface);
-
-    FIXME("filter %p, sender %p, type %#x, proportion %ld, late %s, timestamp %s, stub!\n",
-            filter, sender, q.Type, q.Proportion,
-            wine_dbgstr_longlong(q.Late), wine_dbgstr_longlong(q.TimeStamp));
-
+    AviMux *This = impl_from_out_IQualityControl(iface);
+    FIXME("(%p)->(%p { 0x%x %u %s %s })\n", This, pSelf,
+            q.Type, q.Proportion,
+            wine_dbgstr_longlong(q.Late),
+            wine_dbgstr_longlong(q.TimeStamp));
     return E_NOTIMPL;
 }
 
@@ -1519,14 +1515,14 @@ static ULONG WINAPI AviMuxIn_AMStreamControl_Release(IAMStreamControl *iface)
 static HRESULT WINAPI AviMuxIn_AMStreamControl_StartAt(IAMStreamControl *iface,
         const REFERENCE_TIME *start, DWORD cookie)
 {
-    FIXME("iface %p, start %p, cookie %#lx, stub!\n", iface, start, cookie);
+    FIXME("iface %p, start %p, cookie %#x, stub!\n", iface, start, cookie);
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI AviMuxIn_AMStreamControl_StopAt(IAMStreamControl *iface,
         const REFERENCE_TIME *stop, BOOL send_extra, DWORD cookie)
 {
-    FIXME("iface %p, stop %p, send_extra %d, cookie %#lx, stub!\n", iface, stop, send_extra, cookie);
+    FIXME("iface %p, stop %p, send_extra %d, cookie %#x, stub!\n", iface, stop, send_extra, cookie);
     return E_NOTIMPL;
 }
 
@@ -1640,7 +1636,7 @@ static HRESULT WINAPI AviMuxIn_MemInputPin_ReceiveMultiple(IMemInputPin *iface,
     AviMuxIn *avimuxin = AviMuxIn_from_IMemInputPin(iface);
     HRESULT hr = S_OK;
 
-    TRACE("pin %p, pSamples %p, nSamples %ld, nSamplesProcessed %p.\n",
+    TRACE("pin %p, pSamples %p, nSamples %d, nSamplesProcessed %p.\n",
             avimuxin, pSamples, nSamples, nSamplesProcessed);
 
     for(*nSamplesProcessed=0; *nSamplesProcessed<nSamples; (*nSamplesProcessed)++)
@@ -1759,7 +1755,7 @@ static ULONG WINAPI AviMuxIn_QualityControl_Release(IQualityControl *iface)
 static HRESULT WINAPI AviMuxIn_QualityControl_Notify(IQualityControl *iface,
         IBaseFilter *filter, Quality q)
 {
-    FIXME("iface %p, filter %p, type %u, proportion %ld, late %s, timestamp %s, stub!\n",
+    FIXME("iface %p, filter %p, type %u, proportion %d, late %s, timestamp %s, stub!\n",
             iface, filter, q.Type, q.Proportion, wine_dbgstr_longlong(q.Late),
             wine_dbgstr_longlong(q.TimeStamp));
     return E_NOTIMPL;
diff --git a/dlls/qcap/capturegraph.c b/dlls/qcap/capturegraph.c
index 45cef802ba2..157cfc6178d 100644
--- wine/dlls/qcap/capturegraph.c
+++ wine/dlls/qcap/capturegraph.c
@@ -104,17 +104,16 @@ fnCaptureGraphBuilder2_AddRef(ICaptureGraphBuilder2 * iface)
     CaptureGraphImpl *This = impl_from_ICaptureGraphBuilder2(iface);
     DWORD ref = InterlockedIncrement(&This->ref);
 
-    TRACE("%p increasing refcount to %lu.\n", This, ref);
-
+    TRACE("(%p/%p)->() AddRef from %d\n", This, iface, ref - 1);
     return ref;
 }
 
 static ULONG WINAPI fnCaptureGraphBuilder2_Release(ICaptureGraphBuilder2 * iface)
 {
     CaptureGraphImpl *This = impl_from_ICaptureGraphBuilder2(iface);
-    ULONG ref = InterlockedDecrement(&This->ref);
+    DWORD ref = InterlockedDecrement(&This->ref);
 
-    TRACE("%p decreasing refcount to %lu.\n", This, ref);
+    TRACE("(%p/%p)->() Release from %d\n", This, iface, ref + 1);
 
     if (!ref)
     {
@@ -225,7 +224,7 @@ static BOOL pin_matches(IPin *pin, PIN_DIRECTION dir, const GUID *category,
     IPin *peer;
 
     if (FAILED(hr = IPin_QueryDirection(pin, &candidate_dir)))
-        ERR("Failed to query direction, hr %#lx.\n", hr);
+        ERR("Failed to query direction, hr %#x.\n", hr);
 
     if (dir != candidate_dir)
         return FALSE;
@@ -273,7 +272,7 @@ static HRESULT find_interface_recurse(PIN_DIRECTION dir, const GUID *category,
 
     if (FAILED(hr = IBaseFilter_EnumPins(filter, &enumpins)))
     {
-        ERR("Failed to enumerate pins, hr %#lx.\n", hr);
+        ERR("Failed to enumerate pins, hr %#x.\n", hr);
         return hr;
     }
 
@@ -443,7 +442,7 @@ static HRESULT match_smart_tee_pin(CaptureGraphImpl *This,
             }
         }
         if (FAILED(hr)) {
-            TRACE("adding SmartTee failed with hr=0x%08lx\n", hr);
+            TRACE("adding SmartTee failed with hr=0x%08x\n", hr);
             hr = E_INVALIDARG;
             goto end;
         }
@@ -468,7 +467,7 @@ end:
         IPin_Release(peer);
     if (smartTee)
         IBaseFilter_Release(smartTee);
-    TRACE("for %s returning hr=0x%08lx, *source_out=%p\n", IsEqualIID(pCategory, &PIN_CATEGORY_CAPTURE) ? "capture" : "preview", hr, source_out ? *source_out : 0);
+    TRACE("for %s returning hr=0x%08x, *source_out=%p\n", IsEqualIID(pCategory, &PIN_CATEGORY_CAPTURE) ? "capture" : "preview", hr, source_out ? *source_out : 0);
     return hr;
 }
 
diff --git a/dlls/qcap/filewriter.c b/dlls/qcap/filewriter.c
index bc63abcb8cb..e49e6039604 100644
--- wine/dlls/qcap/filewriter.c
+++ wine/dlls/qcap/filewriter.c
@@ -68,27 +68,26 @@ static HRESULT WINAPI file_writer_sink_receive(struct strmbase_sink *iface, IMed
     struct file_writer *filter = impl_from_strmbase_pin(&iface->pin);
     REFERENCE_TIME start, stop;
     LARGE_INTEGER offset;
-    DWORD size, ret_size;
     HRESULT hr;
+    DWORD size;
     BYTE *data;
 
     if ((hr = IMediaSample_GetTime(sample, &start, &stop)) != S_OK)
-        ERR("Failed to get sample time, hr %#lx.\n", hr);
-    size = stop - start;
+        ERR("Failed to get sample time, hr %#x.\n", hr);
 
     if ((hr = IMediaSample_GetPointer(sample, &data)) != S_OK)
-        ERR("Failed to get sample pointer, hr %#lx.\n", hr);
+        ERR("Failed to get sample pointer, hr %#x.\n", hr);
 
     offset.QuadPart = start;
     if (!SetFilePointerEx(filter->file, offset, NULL, FILE_BEGIN)
-            || !WriteFile(filter->file, data, size, &ret_size, NULL))
+            || !WriteFile(filter->file, data, stop - start, &size, NULL))
     {
-        ERR("Failed to write file, error %lu.\n", GetLastError());
+        ERR("Failed to write file, error %u.\n", GetLastError());
         return HRESULT_FROM_WIN32(hr);
     }
 
-    if (ret_size != size)
-        ERR("Short write, %lu/%lu.\n", ret_size, size);
+    if (size != stop - start)
+        ERR("Short write, %u/%u.\n", size, (DWORD)(stop - start));
 
     return S_OK;
 }
@@ -176,7 +175,7 @@ static HRESULT file_writer_init_stream(struct strmbase_filter *iface)
     if ((file = CreateFileW(filter->filename, GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE,
             NULL, CREATE_ALWAYS, 0, NULL)) == INVALID_HANDLE_VALUE)
     {
-        ERR("Failed to create %s, error %lu.\n", debugstr_w(filter->filename), GetLastError());
+        ERR("Failed to create %s, error %u.\n", debugstr_w(filter->filename), GetLastError());
         return HRESULT_FROM_WIN32(GetLastError());
     }
     filter->file = file;
diff --git a/dlls/qcap/tests/Makefile.in b/dlls/qcap/tests/Makefile.in
index 6e2fb2d4d2a..3fc00bf05ff 100644
--- wine/dlls/qcap/tests/Makefile.in
+++ wine/dlls/qcap/tests/Makefile.in
@@ -1,3 +1,4 @@
+EXTRADEFS = -DWINE_NO_LONG_TYPES
 TESTDLL   = qcap.dll
 IMPORTS   = strmbase strmiids uuid oleaut32 ole32 advapi32 msvfw32
 
diff --git a/dlls/qcap/tests/audiorecord.c b/dlls/qcap/tests/audiorecord.c
index 5705925a50d..350ae986b44 100644
--- wine/dlls/qcap/tests/audiorecord.c
+++ wine/dlls/qcap/tests/audiorecord.c
@@ -39,7 +39,7 @@ static void check_interface_(unsigned int line, void *iface_ptr, REFIID iid, BOO
     expected_hr = supported ? S_OK : E_NOINTERFACE;
 
     hr = IUnknown_QueryInterface(iface, iid, (void **)&unk);
-    ok_(__FILE__, line)(hr == expected_hr, "Got hr %#lx, expected %#lx.\n", hr, expected_hr);
+    ok_(__FILE__, line)(hr == expected_hr, "Got hr %#x, expected %#x.\n", hr, expected_hr);
     if (SUCCEEDED(hr))
         IUnknown_Release(unk);
 }
@@ -110,53 +110,53 @@ static void test_aggregation(void)
     filter = (IBaseFilter *)0xdeadbeef;
     hr = CoCreateInstance(&CLSID_AudioRecord, &test_outer, CLSCTX_INPROC_SERVER,
             &IID_IBaseFilter, (void **)&filter);
-    ok(hr == E_NOINTERFACE, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOINTERFACE, "Got hr %#x.\n", hr);
     ok(!filter, "Got interface %p.\n", filter);
 
     hr = CoCreateInstance(&CLSID_AudioRecord, &test_outer, CLSCTX_INPROC_SERVER,
             &IID_IUnknown, (void **)&unk);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(outer_ref == 1, "Got unexpected refcount %ld.\n", outer_ref);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
     ok(unk != &test_outer, "Returned IUnknown should not be outer IUnknown.\n");
     ref = get_refcount(unk);
-    ok(ref == 1, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
 
     ref = IUnknown_AddRef(unk);
-    ok(ref == 2, "Got unexpected refcount %ld.\n", ref);
-    ok(outer_ref == 1, "Got unexpected refcount %ld.\n", outer_ref);
+    ok(ref == 2, "Got unexpected refcount %d.\n", ref);
+    ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
 
     ref = IUnknown_Release(unk);
-    ok(ref == 1, "Got unexpected refcount %ld.\n", ref);
-    ok(outer_ref == 1, "Got unexpected refcount %ld.\n", outer_ref);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
+    ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
 
     hr = IUnknown_QueryInterface(unk, &IID_IUnknown, (void **)&unk2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(unk2 == unk, "Got unexpected IUnknown %p.\n", unk2);
     IUnknown_Release(unk2);
 
     hr = IUnknown_QueryInterface(unk, &IID_IBaseFilter, (void **)&filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_QueryInterface(filter, &IID_IUnknown, (void **)&unk2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(unk2 == (IUnknown *)0xdeadbeef, "Got unexpected IUnknown %p.\n", unk2);
 
     hr = IBaseFilter_QueryInterface(filter, &IID_IBaseFilter, (void **)&filter2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(filter2 == (IBaseFilter *)0xdeadbeef, "Got unexpected IBaseFilter %p.\n", filter2);
 
     hr = IUnknown_QueryInterface(unk, &test_iid, (void **)&unk2);
-    ok(hr == E_NOINTERFACE, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOINTERFACE, "Got hr %#x.\n", hr);
     ok(!unk2, "Got unexpected IUnknown %p.\n", unk2);
 
     hr = IBaseFilter_QueryInterface(filter, &test_iid, (void **)&unk2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(unk2 == (IUnknown *)0xdeadbeef, "Got unexpected IUnknown %p.\n", unk2);
 
     IBaseFilter_Release(filter);
     ref = IUnknown_Release(unk);
-    ok(!ref, "Got unexpected refcount %ld.\n", ref);
-    ok(outer_ref == 1, "Got unexpected refcount %ld.\n", outer_ref);
+    ok(!ref, "Got unexpected refcount %d.\n", ref);
+    ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
 }
 
 static HRESULT WINAPI property_bag_QueryInterface(IPropertyBag *iface, REFIID iid, void **out)
@@ -216,27 +216,27 @@ static void test_property_bag(IMoniker *mon)
     ULONG ref;
 
     hr = IMoniker_BindToStorage(mon, NULL, NULL, &IID_IPropertyBag, (void **)&devenum_bag);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     VariantInit(&var);
     hr = IPropertyBag_Read(devenum_bag, L"WaveInId", &var, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ppb_id = V_I4(&var);
 
     hr = CoCreateInstance(&CLSID_AudioRecord, NULL, CLSCTX_INPROC_SERVER,
             &IID_IPersistPropertyBag, (void **)&ppb);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IPersistPropertyBag_InitNew(ppb);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     ppb_got_read = 0;
     hr = IPersistPropertyBag_Load(ppb, &property_bag, NULL);
-    ok(hr == S_OK || broken(hr == E_FAIL) /* 8+, intermittent */, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK || broken(hr == E_FAIL) /* 8+, intermittent */, "Got hr %#x.\n", hr);
     ok(ppb_got_read == 1, "Got %u calls to Read().\n", ppb_got_read);
 
     ref = IPersistPropertyBag_Release(ppb);
-    ok(!ref, "Got unexpected refcount %ld.\n", ref);
+    ok(!ref, "Got unexpected refcount %d.\n", ref);
 
     VariantClear(&var);
     IPropertyBag_Release(devenum_bag);
@@ -248,49 +248,49 @@ static void test_unconnected_filter_state(IBaseFilter *filter)
     HRESULT hr;
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(state == State_Stopped, "Got state %u.\n", state);
 
     hr = IBaseFilter_Pause(filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    todo_wine ok(hr == VFW_S_CANT_CUE, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == VFW_S_CANT_CUE, "Got hr %#x.\n", hr);
     ok(state == State_Paused, "Got state %u.\n", state);
 
     hr = IBaseFilter_Run(filter, 0);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(state == State_Running, "Got state %u.\n", state);
 
     hr = IBaseFilter_Pause(filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    todo_wine ok(hr == VFW_S_CANT_CUE, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == VFW_S_CANT_CUE, "Got hr %#x.\n", hr);
     ok(state == State_Paused, "Got state %u.\n", state);
 
     hr = IBaseFilter_Stop(filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(state == State_Stopped, "Got state %u.\n", state);
 
     hr = IBaseFilter_Run(filter, 0);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(state == State_Running, "Got state %u.\n", state);
 
     hr = IBaseFilter_Stop(filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(state == State_Stopped, "Got state %u.\n", state);
 }
 
@@ -308,7 +308,7 @@ START_TEST(audiorecord)
 
     hr = CoCreateInstance(&CLSID_SystemDeviceEnum, NULL, CLSCTX_INPROC_SERVER,
             &IID_ICreateDevEnum, (void **)&devenum);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = ICreateDevEnum_CreateClassEnumerator(devenum, &CLSID_AudioInputDeviceCategory, &enummon, 0);
     if (hr == S_FALSE)
     {
@@ -317,27 +317,27 @@ START_TEST(audiorecord)
         CoUninitialize();
         return;
     }
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     test_aggregation();
 
     while (IEnumMoniker_Next(enummon, 1, &mon, NULL) == S_OK)
     {
         hr = IMoniker_GetDisplayName(mon, NULL, NULL, &name);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
         trace("Testing device %s.\n", wine_dbgstr_w(name));
         CoTaskMemFree(name);
 
         test_property_bag(mon);
 
         hr = IMoniker_BindToObject(mon, NULL, NULL, &IID_IBaseFilter, (void **)&filter);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
 
         test_interfaces(filter);
         test_unconnected_filter_state(filter);
 
         ref = IBaseFilter_Release(filter);
-        ok(!ref, "Got outstanding refcount %ld.\n", ref);
+        ok(!ref, "Got outstanding refcount %d.\n", ref);
         IMoniker_Release(mon);
     }
 
diff --git a/dlls/qcap/tests/avico.c b/dlls/qcap/tests/avico.c
index abd4fa8e5e7..332ca5a8e7d 100644
--- wine/dlls/qcap/tests/avico.c
+++ wine/dlls/qcap/tests/avico.c
@@ -35,7 +35,7 @@ static void check_interface_(unsigned int line, void *iface_ptr, REFIID iid, BOO
     expected_hr = supported ? S_OK : E_NOINTERFACE;
 
     hr = IUnknown_QueryInterface(iface, iid, (void **)&unk);
-    ok_(__FILE__, line)(hr == expected_hr, "Got hr %#lx, expected %#lx.\n", hr, expected_hr);
+    ok_(__FILE__, line)(hr == expected_hr, "Got hr %#x, expected %#x.\n", hr, expected_hr);
     if (SUCCEEDED(hr))
         IUnknown_Release(unk);
 }
@@ -138,53 +138,53 @@ static void test_aggregation(void)
     filter = (IBaseFilter *)0xdeadbeef;
     hr = CoCreateInstance(&CLSID_AVICo, &test_outer, CLSCTX_INPROC_SERVER,
             &IID_IBaseFilter, (void **)&filter);
-    ok(hr == E_NOINTERFACE, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOINTERFACE, "Got hr %#x.\n", hr);
     ok(!filter, "Got interface %p.\n", filter);
 
     hr = CoCreateInstance(&CLSID_AVICo, &test_outer, CLSCTX_INPROC_SERVER,
             &IID_IUnknown, (void **)&unk);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(outer_ref == 1, "Got unexpected refcount %ld.\n", outer_ref);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
     ok(unk != &test_outer, "Returned IUnknown should not be outer IUnknown.\n");
     ref = get_refcount(unk);
-    ok(ref == 1, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
 
     ref = IUnknown_AddRef(unk);
-    ok(ref == 2, "Got unexpected refcount %ld.\n", ref);
-    ok(outer_ref == 1, "Got unexpected refcount %ld.\n", outer_ref);
+    ok(ref == 2, "Got unexpected refcount %d.\n", ref);
+    ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
 
     ref = IUnknown_Release(unk);
-    ok(ref == 1, "Got unexpected refcount %ld.\n", ref);
-    ok(outer_ref == 1, "Got unexpected refcount %ld.\n", outer_ref);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
+    ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
 
     hr = IUnknown_QueryInterface(unk, &IID_IUnknown, (void **)&unk2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(unk2 == unk, "Got unexpected IUnknown %p.\n", unk2);
     IUnknown_Release(unk2);
 
     hr = IUnknown_QueryInterface(unk, &IID_IBaseFilter, (void **)&filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_QueryInterface(filter, &IID_IUnknown, (void **)&unk2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(unk2 == (IUnknown *)0xdeadbeef, "Got unexpected IUnknown %p.\n", unk2);
 
     hr = IBaseFilter_QueryInterface(filter, &IID_IBaseFilter, (void **)&filter2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(filter2 == (IBaseFilter *)0xdeadbeef, "Got unexpected IBaseFilter %p.\n", filter2);
 
     hr = IUnknown_QueryInterface(unk, &test_iid, (void **)&unk2);
-    ok(hr == E_NOINTERFACE, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOINTERFACE, "Got hr %#x.\n", hr);
     ok(!unk2, "Got unexpected IUnknown %p.\n", unk2);
 
     hr = IBaseFilter_QueryInterface(filter, &test_iid, (void **)&unk2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(unk2 == (IUnknown *)0xdeadbeef, "Got unexpected IUnknown %p.\n", unk2);
 
     IBaseFilter_Release(filter);
     ref = IUnknown_Release(unk);
-    ok(!ref, "Got unexpected refcount %ld.\n", ref);
-    ok(outer_ref == 1, "Got unexpected refcount %ld.\n", outer_ref);
+    ok(!ref, "Got unexpected refcount %d.\n", ref);
+    ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
 }
 
 static void test_enum_pins(IBaseFilter *filter)
@@ -195,110 +195,110 @@ static void test_enum_pins(IBaseFilter *filter)
     HRESULT hr;
 
     ref = get_refcount(filter);
-    ok(ref == 1, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
 
     hr = IBaseFilter_EnumPins(filter, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_EnumPins(filter, &enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ref = get_refcount(filter);
-    ok(ref == 2, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 2, "Got unexpected refcount %d.\n", ref);
     ref = get_refcount(enum1);
-    ok(ref == 1, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
 
     hr = IEnumPins_Next(enum1, 1, NULL, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum1, 1, pins, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ref = get_refcount(filter);
-    ok(ref == 3, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 3, "Got unexpected refcount %d.\n", ref);
     ref = get_refcount(pins[0]);
-    ok(ref == 3, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 3, "Got unexpected refcount %d.\n", ref);
     ref = get_refcount(enum1);
-    ok(ref == 1, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
     IPin_Release(pins[0]);
     ref = get_refcount(filter);
-    ok(ref == 2, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 2, "Got unexpected refcount %d.\n", ref);
 
     hr = IEnumPins_Next(enum1, 1, pins, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ref = get_refcount(filter);
-    ok(ref == 3, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 3, "Got unexpected refcount %d.\n", ref);
     ref = get_refcount(pins[0]);
-    ok(ref == 3, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 3, "Got unexpected refcount %d.\n", ref);
     ref = get_refcount(enum1);
-    ok(ref == 1, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
     IPin_Release(pins[0]);
     ref = get_refcount(filter);
-    ok(ref == 2, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 2, "Got unexpected refcount %d.\n", ref);
 
     hr = IEnumPins_Next(enum1, 1, pins, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum1, 1, pins, &count);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(count == 1, "Got count %lu.\n", count);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(count == 1, "Got count %u.\n", count);
     IPin_Release(pins[0]);
 
     hr = IEnumPins_Next(enum1, 1, pins, &count);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(count == 1, "Got count %lu.\n", count);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(count == 1, "Got count %u.\n", count);
     IPin_Release(pins[0]);
 
     hr = IEnumPins_Next(enum1, 1, pins, &count);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
-    ok(!count, "Got count %lu.\n", count);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    ok(!count, "Got count %u.\n", count);
 
     hr = IEnumPins_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum1, 2, pins, NULL);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum1, 2, pins, &count);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(count == 2, "Got count %lu.\n", count);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(count == 2, "Got count %u.\n", count);
     IPin_Release(pins[0]);
     IPin_Release(pins[1]);
 
     hr = IEnumPins_Next(enum1, 2, pins, &count);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
-    ok(!count, "Got count %lu.\n", count);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    ok(!count, "Got count %u.\n", count);
 
     hr = IEnumPins_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum1, 3, pins, &count);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
-    ok(count == 2, "Got count %lu.\n", count);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    ok(count == 2, "Got count %u.\n", count);
     IPin_Release(pins[0]);
     IPin_Release(pins[1]);
 
     hr = IEnumPins_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Clone(enum1, &enum2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Skip(enum1, 3);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Skip(enum1, 2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Skip(enum1, 1);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum1, 1, pins, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum2, 1, pins, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     IPin_Release(pins[0]);
 
     IEnumPins_Release(enum2);
@@ -312,28 +312,28 @@ static void test_find_pin(IBaseFilter *filter)
     HRESULT hr;
 
     hr = IBaseFilter_EnumPins(filter, &enum_pins);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_FindPin(filter, L"In", &pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IEnumPins_Next(enum_pins, 1, &pin2, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(pin == pin2, "Pins didn't match.\n");
     IPin_Release(pin);
     IPin_Release(pin2);
 
     hr = IBaseFilter_FindPin(filter, L"Out", &pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IEnumPins_Next(enum_pins, 1, &pin2, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(pin == pin2, "Pins didn't match.\n");
     IPin_Release(pin);
     IPin_Release(pin2);
 
     hr = IBaseFilter_FindPin(filter, L"Input", &pin);
-    ok(hr == VFW_E_NOT_FOUND, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_FOUND, "Got hr %#x.\n", hr);
     hr = IBaseFilter_FindPin(filter, L"Output", &pin);
-    ok(hr == VFW_E_NOT_FOUND, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_FOUND, "Got hr %#x.\n", hr);
 
     IEnumPins_Release(enum_pins);
 }
@@ -347,42 +347,42 @@ static void test_pin_info(IBaseFilter *filter)
     IPin *pin;
 
     hr = IBaseFilter_FindPin(filter, L"In", &pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IPin_QueryPinInfo(pin, &info);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(info.pFilter == filter, "Expected filter %p, got %p.\n", filter, info.pFilter);
     ok(info.dir == PINDIR_INPUT, "Got direction %d.\n", info.dir);
-    ok(!lstrcmpW(info.achName, L"Input"), "Got name %s.\n", wine_dbgstr_w(info.achName));
+    todo_wine ok(!lstrcmpW(info.achName, L"Input"), "Got name %s.\n", wine_dbgstr_w(info.achName));
     IBaseFilter_Release(info.pFilter);
 
     hr = IPin_QueryDirection(pin, &dir);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(dir == PINDIR_INPUT, "Got direction %d.\n", dir);
 
     hr = IPin_QueryId(pin, &id);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(!lstrcmpW(id, L"In"), "Got id %s.\n", wine_dbgstr_w(id));
     CoTaskMemFree(id);
 
     IPin_Release(pin);
 
     hr = IBaseFilter_FindPin(filter, L"Out", &pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IPin_QueryPinInfo(pin, &info);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(info.pFilter == filter, "Expected filter %p, got %p.\n", filter, info.pFilter);
     ok(info.dir == PINDIR_OUTPUT, "Got direction %d.\n", info.dir);
-    ok(!lstrcmpW(info.achName, L"Output"), "Got name %s.\n", wine_dbgstr_w(info.achName));
+    todo_wine ok(!lstrcmpW(info.achName, L"Output"), "Got name %s.\n", wine_dbgstr_w(info.achName));
     IBaseFilter_Release(info.pFilter);
 
     hr = IPin_QueryDirection(pin, &dir);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(dir == PINDIR_OUTPUT, "Got direction %d.\n", dir);
 
     hr = IPin_QueryId(pin, &id);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(!lstrcmpW(id, L"Out"), "Got id %s.\n", wine_dbgstr_w(id));
     CoTaskMemFree(id);
 
@@ -392,7 +392,7 @@ static void test_pin_info(IBaseFilter *filter)
 static LRESULT CALLBACK driver_proc(DWORD_PTR id, HDRVR driver, UINT msg,
         LPARAM lparam1, LPARAM lparam2)
 {
-    if (winetest_debug > 1) trace("msg %#x, lparam1 %#Ix, lparam2 %#Ix.\n", msg, lparam1, lparam2);
+    if (winetest_debug > 1) trace("msg %#x, lparam1 %#lx, lparam2 %#lx.\n", msg, lparam1, lparam2);
 
     switch (msg)
     {
@@ -478,27 +478,27 @@ static void test_property_bag(IMoniker *mon)
     ULONG ref;
 
     hr = IMoniker_BindToStorage(mon, NULL, NULL, &IID_IPropertyBag, (void **)&devenum_bag);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     VariantInit(&var);
     hr = IPropertyBag_Read(devenum_bag, L"FccHandler", &var, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ppb_handler = V_BSTR(&var);
 
     hr = CoCreateInstance(&CLSID_AVICo, NULL, CLSCTX_INPROC_SERVER,
             &IID_IPersistPropertyBag, (void **)&ppb);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IPersistPropertyBag_InitNew(ppb);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     ppb_got_read = 0;
     hr = IPersistPropertyBag_Load(ppb, &property_bag, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(ppb_got_read == 1, "Got %u calls to Read().\n", ppb_got_read);
 
     ref = IPersistPropertyBag_Release(ppb);
-    ok(!ref, "Got unexpected refcount %ld.\n", ref);
+    ok(!ref, "Got unexpected refcount %d.\n", ref);
 
     VariantClear(&var);
     IPropertyBag_Release(devenum_bag);
@@ -520,10 +520,10 @@ static void test_media_types(IBaseFilter *filter)
     IBaseFilter_FindPin(filter, L"In", &pin);
 
     hr = IPin_EnumMediaTypes(pin, &enummt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enummt, 1, &pmt, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     IEnumMediaTypes_Release(enummt);
 
@@ -532,11 +532,11 @@ static void test_media_types(IBaseFilter *filter)
     mt.cbFormat = sizeof(VIDEOINFOHEADER);
     mt.pbFormat = (BYTE *)&vih;
     hr = IPin_QueryAccept(pin, &mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     vih.bmiHeader.biBitCount = 32;
     hr = IPin_QueryAccept(pin, &mt);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     vih.bmiHeader.biBitCount = 16;
 
     mt.bFixedSizeSamples = TRUE;
@@ -544,22 +544,22 @@ static void test_media_types(IBaseFilter *filter)
     mt.lSampleSize = 123;
     mt.subtype = MEDIASUBTYPE_RGB565;
     hr = IPin_QueryAccept(pin, &mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     mt.subtype = MEDIASUBTYPE_WAVE;
     hr = IPin_QueryAccept(pin, &mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     mt.formattype = GUID_NULL;
     hr = IPin_QueryAccept(pin, &mt);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     mt.formattype = FORMAT_None;
     hr = IPin_QueryAccept(pin, &mt);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     mt.formattype = FORMAT_VideoInfo;
 
     mt.majortype = MEDIATYPE_NULL;
     hr = IPin_QueryAccept(pin, &mt);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     mt.majortype = MEDIATYPE_Video;
 
     IPin_Release(pin);
@@ -567,10 +567,10 @@ static void test_media_types(IBaseFilter *filter)
     IBaseFilter_FindPin(filter, L"Out", &pin);
 
     hr = IPin_EnumMediaTypes(pin, &enummt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enummt, 1, &pmt, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     IEnumMediaTypes_Release(enummt);
     IPin_Release(pin);
@@ -587,29 +587,29 @@ static void test_enum_media_types(IBaseFilter *filter)
     IBaseFilter_FindPin(filter, L"In", &pin);
 
     hr = IPin_EnumMediaTypes(pin, &enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enum1, 1, mts, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enum1, 1, mts, &count);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
-    ok(!count, "Got count %lu.\n", count);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    ok(!count, "Got count %u.\n", count);
 
     hr = IEnumMediaTypes_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enum1, 1, mts, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Clone(enum1, &enum2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Skip(enum1, 1);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enum2, 1, mts, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     IEnumMediaTypes_Release(enum1);
     IEnumMediaTypes_Release(enum2);
@@ -618,29 +618,29 @@ static void test_enum_media_types(IBaseFilter *filter)
     IBaseFilter_FindPin(filter, L"Out", &pin);
 
     hr = IPin_EnumMediaTypes(pin, &enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enum1, 1, mts, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enum1, 1, mts, &count);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
-    ok(!count, "Got count %lu.\n", count);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    ok(!count, "Got count %u.\n", count);
 
     hr = IEnumMediaTypes_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enum1, 1, mts, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Clone(enum1, &enum2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Skip(enum1, 1);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enum2, 1, mts, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     IEnumMediaTypes_Release(enum1);
     IEnumMediaTypes_Release(enum2);
@@ -653,49 +653,49 @@ static void test_unconnected_filter_state(IBaseFilter *filter)
     HRESULT hr;
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(state == State_Stopped, "Got state %u.\n", state);
 
     hr = IBaseFilter_Pause(filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(state == State_Paused, "Got state %u.\n", state);
 
     hr = IBaseFilter_Run(filter, 0);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(state == State_Running, "Got state %u.\n", state);
 
     hr = IBaseFilter_Pause(filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(state == State_Paused, "Got state %u.\n", state);
 
     hr = IBaseFilter_Stop(filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(state == State_Stopped, "Got state %u.\n", state);
 
     hr = IBaseFilter_Run(filter, 0);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(state == State_Running, "Got state %u.\n", state);
 
     hr = IBaseFilter_Stop(filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(state == State_Stopped, "Got state %u.\n", state);
 }
 
@@ -719,18 +719,18 @@ START_TEST(avico)
 
     hr = CoCreateInstance(&CLSID_SystemDeviceEnum, NULL, CLSCTX_INPROC_SERVER,
             &IID_ICreateDevEnum, (void **)&devenum);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = ICreateDevEnum_CreateClassEnumerator(devenum, &CLSID_VideoCompressorCategory, &enummon, 0);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     while (IEnumMoniker_Next(enummon, 1, &mon, NULL) == S_OK)
     {
         hr = IMoniker_GetDisplayName(mon, NULL, NULL, &name);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
         if (!lstrcmpW(name, test_display_name))
         {
             hr = IMoniker_BindToObject(mon, NULL, NULL, &IID_IBaseFilter, (void **)&filter);
-            ok(hr == S_OK, "Got hr %#lx.\n", hr);
+            ok(hr == S_OK, "Got hr %#x.\n", hr);
 
             test_aggregation();
             test_interfaces(filter);
@@ -742,7 +742,7 @@ START_TEST(avico)
             test_unconnected_filter_state(filter);
 
             ref = IBaseFilter_Release(filter);
-            ok(!ref, "Got outstanding refcount %ld.\n", ref);
+            ok(!ref, "Got outstanding refcount %d.\n", ref);
         }
 
         if (!memcmp(name, test_display_name, 11 * sizeof(WCHAR)))
diff --git a/dlls/qcap/tests/avimux.c b/dlls/qcap/tests/avimux.c
index 8d11c5cbf04..70575281cee 100644
--- wine/dlls/qcap/tests/avimux.c
+++ wine/dlls/qcap/tests/avimux.c
@@ -30,7 +30,7 @@ static IBaseFilter *create_avi_mux(void)
     IBaseFilter *filter = NULL;
     HRESULT hr = CoCreateInstance(&CLSID_AviDest, NULL, CLSCTX_INPROC_SERVER,
             &IID_IBaseFilter, (void **)&filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     return filter;
 }
 
@@ -51,7 +51,7 @@ static void check_interface_(unsigned int line, void *iface_ptr, REFIID iid, BOO
     expected_hr = supported ? S_OK : E_NOINTERFACE;
 
     hr = IUnknown_QueryInterface(iface, iid, (void **)&unk);
-    ok_(__FILE__, line)(hr == expected_hr, "Got hr %#lx, expected %#lx.\n", hr, expected_hr);
+    ok_(__FILE__, line)(hr == expected_hr, "Got hr %#x, expected %#x.\n", hr, expected_hr);
     if (SUCCEEDED(hr))
         IUnknown_Release(unk);
 }
@@ -159,53 +159,53 @@ static void test_aggregation(void)
     filter = (IBaseFilter *)0xdeadbeef;
     hr = CoCreateInstance(&CLSID_AviDest, &test_outer, CLSCTX_INPROC_SERVER,
             &IID_IBaseFilter, (void **)&filter);
-    ok(hr == E_NOINTERFACE, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOINTERFACE, "Got hr %#x.\n", hr);
     ok(!filter, "Got interface %p.\n", filter);
 
     hr = CoCreateInstance(&CLSID_AviDest, &test_outer, CLSCTX_INPROC_SERVER,
             &IID_IUnknown, (void **)&unk);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(outer_ref == 1, "Got unexpected refcount %ld.\n", outer_ref);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
     ok(unk != &test_outer, "Returned IUnknown should not be outer IUnknown.\n");
     ref = get_refcount(unk);
-    ok(ref == 1, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
 
     ref = IUnknown_AddRef(unk);
-    ok(ref == 2, "Got unexpected refcount %ld.\n", ref);
-    ok(outer_ref == 1, "Got unexpected refcount %ld.\n", outer_ref);
+    ok(ref == 2, "Got unexpected refcount %d.\n", ref);
+    ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
 
     ref = IUnknown_Release(unk);
-    ok(ref == 1, "Got unexpected refcount %ld.\n", ref);
-    ok(outer_ref == 1, "Got unexpected refcount %ld.\n", outer_ref);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
+    ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
 
     hr = IUnknown_QueryInterface(unk, &IID_IUnknown, (void **)&unk2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(unk2 == unk, "Got unexpected IUnknown %p.\n", unk2);
     IUnknown_Release(unk2);
 
     hr = IUnknown_QueryInterface(unk, &IID_IBaseFilter, (void **)&filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_QueryInterface(filter, &IID_IUnknown, (void **)&unk2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(unk2 == (IUnknown *)0xdeadbeef, "Got unexpected IUnknown %p.\n", unk2);
 
     hr = IBaseFilter_QueryInterface(filter, &IID_IBaseFilter, (void **)&filter2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(filter2 == (IBaseFilter *)0xdeadbeef, "Got unexpected IBaseFilter %p.\n", filter2);
 
     hr = IUnknown_QueryInterface(unk, &test_iid, (void **)&unk2);
-    ok(hr == E_NOINTERFACE, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOINTERFACE, "Got hr %#x.\n", hr);
     ok(!unk2, "Got unexpected IUnknown %p.\n", unk2);
 
     hr = IBaseFilter_QueryInterface(filter, &test_iid, (void **)&unk2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(unk2 == (IUnknown *)0xdeadbeef, "Got unexpected IUnknown %p.\n", unk2);
 
     IBaseFilter_Release(filter);
     ref = IUnknown_Release(unk);
-    ok(!ref, "Got unexpected refcount %ld.\n", ref);
-    ok(outer_ref == 1, "Got unexpected refcount %ld.\n", outer_ref);
+    ok(!ref, "Got unexpected refcount %d.\n", ref);
+    ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
 }
 
 static void test_enum_pins(void)
@@ -217,116 +217,116 @@ static void test_enum_pins(void)
     HRESULT hr;
 
     ref = get_refcount(filter);
-    ok(ref == 1, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
 
     hr = IBaseFilter_EnumPins(filter, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_EnumPins(filter, &enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ref = get_refcount(filter);
-    ok(ref == 2, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 2, "Got unexpected refcount %d.\n", ref);
     ref = get_refcount(enum1);
-    ok(ref == 1, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
 
     hr = IEnumPins_Next(enum1, 1, NULL, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum1, 1, pins, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ref = get_refcount(filter);
-    ok(ref == 3, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 3, "Got unexpected refcount %d.\n", ref);
     ref = get_refcount(pins[0]);
-    ok(ref == 3, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 3, "Got unexpected refcount %d.\n", ref);
     ref = get_refcount(enum1);
-    ok(ref == 1, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
     IPin_Release(pins[0]);
     ref = get_refcount(filter);
-    ok(ref == 2, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 2, "Got unexpected refcount %d.\n", ref);
 
     hr = IEnumPins_Next(enum1, 1, pins, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ref = get_refcount(filter);
-    ok(ref == 3, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 3, "Got unexpected refcount %d.\n", ref);
     ref = get_refcount(pins[0]);
-    ok(ref == 3, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 3, "Got unexpected refcount %d.\n", ref);
     ref = get_refcount(enum1);
-    ok(ref == 1, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
     IPin_Release(pins[0]);
     ref = get_refcount(filter);
-    ok(ref == 2, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 2, "Got unexpected refcount %d.\n", ref);
 
     hr = IEnumPins_Next(enum1, 1, pins, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum1, 1, pins, &count);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(count == 1, "Got count %lu.\n", count);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(count == 1, "Got count %u.\n", count);
     IPin_Release(pins[0]);
 
     hr = IEnumPins_Next(enum1, 1, pins, &count);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(count == 1, "Got count %lu.\n", count);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(count == 1, "Got count %u.\n", count);
     IPin_Release(pins[0]);
 
     hr = IEnumPins_Next(enum1, 1, pins, &count);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
-    ok(!count, "Got count %lu.\n", count);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    ok(!count, "Got count %u.\n", count);
 
     hr = IEnumPins_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum1, 2, pins, NULL);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum1, 2, pins, &count);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(count == 2, "Got count %lu.\n", count);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(count == 2, "Got count %u.\n", count);
     IPin_Release(pins[0]);
     IPin_Release(pins[1]);
 
     hr = IEnumPins_Next(enum1, 2, pins, &count);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
-    ok(!count, "Got count %lu.\n", count);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    ok(!count, "Got count %u.\n", count);
 
     hr = IEnumPins_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum1, 3, pins, &count);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
-    ok(count == 2, "Got count %lu.\n", count);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    ok(count == 2, "Got count %u.\n", count);
     IPin_Release(pins[0]);
     IPin_Release(pins[1]);
 
     hr = IEnumPins_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Clone(enum1, &enum2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Skip(enum1, 3);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Skip(enum1, 2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Skip(enum1, 1);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum1, 1, pins, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum2, 1, pins, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     IPin_Release(pins[0]);
 
     IEnumPins_Release(enum2);
     IEnumPins_Release(enum1);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 static void test_find_pin(void)
@@ -338,27 +338,27 @@ static void test_find_pin(void)
     ULONG ref;
 
     hr = IBaseFilter_EnumPins(filter, &enum_pins);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_FindPin(filter, L"AVI Out", &pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IEnumPins_Next(enum_pins, 1, &pin2, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(pin == pin2, "Pins didn't match.\n");
     IPin_Release(pin);
     IPin_Release(pin2);
 
     hr = IBaseFilter_FindPin(filter, L"Input 01", &pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IEnumPins_Next(enum_pins, 1, &pin2, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(pin == pin2, "Pins didn't match.\n");
     IPin_Release(pin);
     IPin_Release(pin2);
 
     IEnumPins_Release(enum_pins);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 static void test_pin_info(void)
@@ -372,63 +372,63 @@ static void test_pin_info(void)
     IPin *pin;
 
     hr = IBaseFilter_FindPin(filter, L"AVI Out", &pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ref = get_refcount(filter);
-    ok(ref == 2, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 2, "Got unexpected refcount %d.\n", ref);
     ref = get_refcount(pin);
-    ok(ref == 2, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 2, "Got unexpected refcount %d.\n", ref);
 
     hr = IPin_QueryPinInfo(pin, &info);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(info.pFilter == filter, "Expected filter %p, got %p.\n", filter, info.pFilter);
     ok(info.dir == PINDIR_OUTPUT, "Got direction %d.\n", info.dir);
     ok(!lstrcmpW(info.achName, L"AVI Out"), "Got name %s.\n", wine_dbgstr_w(info.achName));
     ref = get_refcount(filter);
-    ok(ref == 3, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 3, "Got unexpected refcount %d.\n", ref);
     ref = get_refcount(pin);
-    ok(ref == 3, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 3, "Got unexpected refcount %d.\n", ref);
     IBaseFilter_Release(info.pFilter);
 
     hr = IPin_QueryDirection(pin, &dir);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(dir == PINDIR_OUTPUT, "Got direction %d.\n", dir);
 
     hr = IPin_QueryId(pin, &id);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(!lstrcmpW(id, L"AVI Out"), "Got id %s.\n", wine_dbgstr_w(id));
     CoTaskMemFree(id);
 
     hr = IPin_QueryInternalConnections(pin, NULL, NULL);
-    ok(hr == E_NOTIMPL, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOTIMPL, "Got hr %#x.\n", hr);
 
     IPin_Release(pin);
 
     hr = IBaseFilter_FindPin(filter, L"Input 01", &pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IPin_QueryPinInfo(pin, &info);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(info.pFilter == filter, "Expected filter %p, got %p.\n", filter, info.pFilter);
     ok(info.dir == PINDIR_INPUT, "Got direction %d.\n", info.dir);
     ok(!lstrcmpW(info.achName, L"Input 01"), "Got name %s.\n", wine_dbgstr_w(info.achName));
     IBaseFilter_Release(info.pFilter);
 
     hr = IPin_QueryDirection(pin, &dir);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(dir == PINDIR_INPUT, "Got direction %d.\n", dir);
 
     hr = IPin_QueryId(pin, &id);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(!lstrcmpW(id, L"Input 01"), "Got id %s.\n", wine_dbgstr_w(id));
     CoTaskMemFree(id);
 
     hr = IPin_QueryInternalConnections(pin, NULL, NULL);
-    ok(hr == E_NOTIMPL, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOTIMPL, "Got hr %#x.\n", hr);
 
     IPin_Release(pin);
 
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 static void test_media_types(void)
@@ -445,53 +445,53 @@ static void test_media_types(void)
     IBaseFilter_FindPin(filter, L"AVI Out", &pin);
 
     hr = IPin_EnumMediaTypes(pin, &enummt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enummt, 1, &pmt, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(IsEqualGUID(&pmt->majortype, &MEDIATYPE_Stream), "Got major type %s\n",
             wine_dbgstr_guid(&pmt->majortype));
     ok(IsEqualGUID(&pmt->subtype, &MEDIASUBTYPE_Avi), "Got subtype %s\n",
             wine_dbgstr_guid(&pmt->subtype));
     ok(pmt->bFixedSizeSamples == TRUE, "Got fixed size %d.\n", pmt->bFixedSizeSamples);
     ok(!pmt->bTemporalCompression, "Got temporal compression %d.\n", pmt->bTemporalCompression);
-    ok(pmt->lSampleSize == 1, "Got sample size %lu.\n", pmt->lSampleSize);
+    ok(pmt->lSampleSize == 1, "Got sample size %u.\n", pmt->lSampleSize);
     ok(IsEqualGUID(&pmt->formattype, &GUID_NULL), "Got format type %s.\n",
             wine_dbgstr_guid(&pmt->formattype));
     ok(!pmt->pUnk, "Got pUnk %p.\n", pmt->pUnk);
-    ok(!pmt->cbFormat, "Got format size %lu.\n", pmt->cbFormat);
-    ok(!pmt->pbFormat, "Got format block %lu.\n", pmt->cbFormat);
+    ok(!pmt->cbFormat, "Got format size %u.\n", pmt->cbFormat);
+    ok(!pmt->pbFormat, "Got format block %u.\n", pmt->cbFormat);
 
     hr = IPin_QueryAccept(pin, pmt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     pmt->bFixedSizeSamples = FALSE;
     pmt->bTemporalCompression = TRUE;
     pmt->lSampleSize = 123;
     pmt->formattype = FORMAT_VideoInfo;
     hr = IPin_QueryAccept(pin, pmt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     pmt->majortype = GUID_NULL;
     hr = IPin_QueryAccept(pin, pmt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     pmt->majortype = MEDIATYPE_Video;
     hr = IPin_QueryAccept(pin, pmt);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     pmt->majortype = MEDIATYPE_Stream;
 
     pmt->subtype = GUID_NULL;
     hr = IPin_QueryAccept(pin, pmt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     pmt->subtype = MEDIASUBTYPE_RGB8;
     hr = IPin_QueryAccept(pin, pmt);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     pmt->subtype = MEDIASUBTYPE_Avi;
 
     CoTaskMemFree(pmt);
 
     hr = IEnumMediaTypes_Next(enummt, 1, &pmt, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     IEnumMediaTypes_Release(enummt);
     IPin_Release(pin);
@@ -499,10 +499,10 @@ static void test_media_types(void)
     IBaseFilter_FindPin(filter, L"Input 01", &pin);
 
     hr = IPin_EnumMediaTypes(pin, &enummt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enummt, 1, &pmt, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     IEnumMediaTypes_Release(enummt);
 
@@ -512,46 +512,46 @@ static void test_media_types(void)
     mt.pbFormat = (BYTE *)&wfx;
     wfx.nBlockAlign = 1;
     hr = IPin_QueryAccept(pin, &mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     mt.subtype = MEDIASUBTYPE_RGB8;
     mt.bFixedSizeSamples = TRUE;
     mt.bTemporalCompression = TRUE;
     mt.lSampleSize = 123;
     hr = IPin_QueryAccept(pin, &mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     mt.majortype = MEDIATYPE_Video;
     hr = IPin_QueryAccept(pin, &mt);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     mt.majortype = GUID_NULL;
     hr = IPin_QueryAccept(pin, &mt);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     mt.majortype = MEDIATYPE_Interleaved;
     hr = IPin_QueryAccept(pin, &mt);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     mt.majortype = MEDIATYPE_Video;
     mt.formattype = FORMAT_VideoInfo;
     mt.cbFormat = sizeof(vih);
     mt.pbFormat = (BYTE *)&vih;
     hr = IPin_QueryAccept(pin, &mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     mt.majortype = MEDIATYPE_Audio;
     hr = IPin_QueryAccept(pin, &mt);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     mt.majortype = GUID_NULL;
     hr = IPin_QueryAccept(pin, &mt);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     mt.majortype = MEDIATYPE_Interleaved;
     hr = IPin_QueryAccept(pin, &mt);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     IPin_Release(pin);
 
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 static void test_enum_media_types(void)
@@ -566,61 +566,61 @@ static void test_enum_media_types(void)
     IBaseFilter_FindPin(filter, L"AVI Out", &pin);
 
     hr = IPin_EnumMediaTypes(pin, &enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enum1, 1, mts, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     CoTaskMemFree(mts[0]);
 
     hr = IEnumMediaTypes_Next(enum1, 1, mts, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enum1, 1, mts, &count);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(count == 1, "Got count %lu.\n", count);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(count == 1, "Got count %u.\n", count);
     CoTaskMemFree(mts[0]);
 
     hr = IEnumMediaTypes_Next(enum1, 1, mts, &count);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
-    ok(!count, "Got count %lu.\n", count);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    ok(!count, "Got count %u.\n", count);
 
     hr = IEnumMediaTypes_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enum1, 2, mts, &count);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
-    ok(count == 1, "Got count %lu.\n", count);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    ok(count == 1, "Got count %u.\n", count);
     CoTaskMemFree(mts[0]);
 
     hr = IEnumMediaTypes_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Clone(enum1, &enum2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Skip(enum1, 2);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Skip(enum1, 1);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Skip(enum1, 1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Skip(enum1, 1);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enum1, 1, mts, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enum2, 1, mts, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     CoTaskMemFree(mts[0]);
 
     IEnumMediaTypes_Release(enum1);
@@ -630,36 +630,36 @@ static void test_enum_media_types(void)
     IBaseFilter_FindPin(filter, L"Input 01", &pin);
 
     hr = IPin_EnumMediaTypes(pin, &enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enum1, 1, mts, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enum1, 1, mts, &count);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
-    ok(!count, "Got count %lu.\n", count);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    ok(!count, "Got count %u.\n", count);
 
     hr = IEnumMediaTypes_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enum1, 1, mts, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Clone(enum1, &enum2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Skip(enum1, 1);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enum2, 1, mts, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     IEnumMediaTypes_Release(enum1);
     IEnumMediaTypes_Release(enum2);
     IPin_Release(pin);
 
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 static void test_seeking(void)
@@ -693,109 +693,109 @@ static void test_seeking(void)
     IBaseFilter_QueryInterface(filter, &IID_IMediaSeeking, (void **)&seeking);
 
     hr = IMediaSeeking_GetCapabilities(seeking, &caps);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    todo_wine ok(caps == (AM_SEEKING_CanGetCurrentPos | AM_SEEKING_CanGetDuration), "Got caps %#lx.\n", caps);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
+    todo_wine ok(caps == (AM_SEEKING_CanGetCurrentPos | AM_SEEKING_CanGetDuration), "Got caps %#x.\n", caps);
 
     caps = AM_SEEKING_CanGetCurrentPos;
     hr = IMediaSeeking_CheckCapabilities(seeking, &caps);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(caps == AM_SEEKING_CanGetCurrentPos, "Got caps %#lx.\n", caps);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(caps == AM_SEEKING_CanGetCurrentPos, "Got caps %#x.\n", caps);
 
     caps = AM_SEEKING_CanDoSegments | AM_SEEKING_CanGetCurrentPos;
     hr = IMediaSeeking_CheckCapabilities(seeking, &caps);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    todo_wine ok(caps == AM_SEEKING_CanGetCurrentPos, "Got caps %#lx.\n", caps);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
+    todo_wine ok(caps == AM_SEEKING_CanGetCurrentPos, "Got caps %#x.\n", caps);
 
     caps = AM_SEEKING_CanDoSegments;
     hr = IMediaSeeking_CheckCapabilities(seeking, &caps);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    todo_wine ok(!caps, "Got caps %#lx.\n", caps);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
+    todo_wine ok(!caps, "Got caps %#x.\n", caps);
 
     for (i = 0; i < ARRAY_SIZE(format_tests); ++i)
     {
         hr = IMediaSeeking_IsFormatSupported(seeking, format_tests[i].guid);
-        todo_wine ok(hr == format_tests[i].hr, "Got hr %#lx for format %s.\n", hr, wine_dbgstr_guid(format_tests[i].guid));
+        todo_wine ok(hr == format_tests[i].hr, "Got hr %#x for format %s.\n", hr, wine_dbgstr_guid(format_tests[i].guid));
     }
 
     hr = IMediaSeeking_QueryPreferredFormat(seeking, &format);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
     todo_wine ok(IsEqualGUID(&format, &TIME_FORMAT_MEDIA_TIME), "Got format %s.\n", wine_dbgstr_guid(&format));
 
     hr = IMediaSeeking_GetTimeFormat(seeking, &format);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
     todo_wine ok(IsEqualGUID(&format, &TIME_FORMAT_MEDIA_TIME), "Got format %s.\n", wine_dbgstr_guid(&format));
 
     hr = IMediaSeeking_IsUsingTimeFormat(seeking, &TIME_FORMAT_MEDIA_TIME);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMediaSeeking_IsUsingTimeFormat(seeking, &TIME_FORMAT_BYTE);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaSeeking_SetTimeFormat(seeking, &TIME_FORMAT_SAMPLE);
-    todo_wine ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
 
     hr = IMediaSeeking_SetTimeFormat(seeking, &TIME_FORMAT_BYTE);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaSeeking_QueryPreferredFormat(seeking, &format);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
     todo_wine ok(IsEqualGUID(&format, &TIME_FORMAT_MEDIA_TIME), "Got format %s.\n", wine_dbgstr_guid(&format));
 
     hr = IMediaSeeking_GetTimeFormat(seeking, &format);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
     todo_wine ok(IsEqualGUID(&format, &TIME_FORMAT_BYTE), "Got format %s.\n", wine_dbgstr_guid(&format));
 
     hr = IMediaSeeking_IsUsingTimeFormat(seeking, &TIME_FORMAT_MEDIA_TIME);
-    todo_wine ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     hr = IMediaSeeking_IsUsingTimeFormat(seeking, &TIME_FORMAT_BYTE);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaSeeking_SetTimeFormat(seeking, &TIME_FORMAT_MEDIA_TIME);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaSeeking_IsUsingTimeFormat(seeking, &TIME_FORMAT_MEDIA_TIME);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMediaSeeking_IsUsingTimeFormat(seeking, &TIME_FORMAT_BYTE);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaSeeking_ConvertTimeFormat(seeking, &time, NULL, 0x123456789a, NULL);
-    ok(hr == E_NOTIMPL, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOTIMPL, "Got hr %#x.\n", hr);
     hr = IMediaSeeking_ConvertTimeFormat(seeking, &time, &TIME_FORMAT_MEDIA_TIME, 0x123456789a, &TIME_FORMAT_BYTE);
-    ok(hr == E_NOTIMPL, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOTIMPL, "Got hr %#x.\n", hr);
 
     current = 0x123;
     stop = 0x321;
     hr = IMediaSeeking_SetPositions(seeking, &current, AM_SEEKING_AbsolutePositioning,
             &stop, AM_SEEKING_AbsolutePositioning);
-    ok(hr == E_NOTIMPL, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOTIMPL, "Got hr %#x.\n", hr);
     hr = IMediaSeeking_SetPositions(seeking, &current, AM_SEEKING_NoPositioning,
             &stop, AM_SEEKING_NoPositioning);
-    ok(hr == E_NOTIMPL, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOTIMPL, "Got hr %#x.\n", hr);
 
     hr = IMediaSeeking_GetPositions(seeking, NULL, NULL);
-    ok(hr == E_NOTIMPL, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOTIMPL, "Got hr %#x.\n", hr);
     hr = IMediaSeeking_GetPositions(seeking, NULL, &stop);
-    ok(hr == E_NOTIMPL, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOTIMPL, "Got hr %#x.\n", hr);
     hr = IMediaSeeking_GetPositions(seeking, &current, &stop);
-    ok(hr == E_NOTIMPL, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOTIMPL, "Got hr %#x.\n", hr);
     hr = IMediaSeeking_GetPositions(seeking, &current, NULL);
-    ok(hr == E_NOTIMPL, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOTIMPL, "Got hr %#x.\n", hr);
 
     hr = IMediaSeeking_GetDuration(seeking, &time);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
     if (hr == S_OK)
         ok(!time, "Got duration %s.\n", wine_dbgstr_longlong(time));
 
     hr = IMediaSeeking_GetCurrentPosition(seeking, &time);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
     if (hr == S_OK)
         ok(!time, "Got duration %s.\n", wine_dbgstr_longlong(time));
 
     hr = IMediaSeeking_GetStopPosition(seeking, &time);
-    ok(hr == E_NOTIMPL, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOTIMPL, "Got hr %#x.\n", hr);
 
     IMediaSeeking_Release(seeking);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got unexpected refcount %ld.\n", ref);
+    ok(!ref, "Got unexpected refcount %d.\n", ref);
 }
 
 static void test_unconnected_filter_state(void)
@@ -806,53 +806,53 @@ static void test_unconnected_filter_state(void)
     ULONG ref;
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(state == State_Stopped, "Got state %u.\n", state);
 
     hr = IBaseFilter_Pause(filter);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     todo_wine ok(state == State_Paused, "Got state %u.\n", state);
 
     hr = IBaseFilter_Run(filter, 0);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     todo_wine ok(state == State_Running, "Got state %u.\n", state);
 
     hr = IBaseFilter_Pause(filter);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     todo_wine ok(state == State_Paused, "Got state %u.\n", state);
 
     hr = IBaseFilter_Stop(filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(state == State_Stopped, "Got state %u.\n", state);
 
     hr = IBaseFilter_Run(filter, 0);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     todo_wine ok(state == State_Running, "Got state %u.\n", state);
 
     hr = IBaseFilter_Stop(filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(state == State_Stopped, "Got state %u.\n", state);
 
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 START_TEST(avimux)
diff --git a/dlls/qcap/tests/capturegraph.c b/dlls/qcap/tests/capturegraph.c
index 1fade929331..cdd9a27828a 100644
--- wine/dlls/qcap/tests/capturegraph.c
+++ wine/dlls/qcap/tests/capturegraph.c
@@ -29,7 +29,7 @@ static ICaptureGraphBuilder2 *create_capture_graph(void)
     ICaptureGraphBuilder2 *ret;
     HRESULT hr = CoCreateInstance(&CLSID_CaptureGraphBuilder2, NULL,
             CLSCTX_INPROC_SERVER, &IID_ICaptureGraphBuilder2, (void **)&ret);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to create capture graph builder, hr %#x.\n", hr);
     return ret;
 }
 
@@ -149,10 +149,10 @@ static HRESULT WINAPI property_set_Get(IKsPropertySet *iface, REFGUID set, DWORD
     if (winetest_debug > 1) trace("%s->Get()\n", debugstr_w(pin->pin.pin.name));
 
     ok(IsEqualGUID(set, &AMPROPSETID_Pin), "Got set %s.\n", debugstr_guid(set));
-    ok(id == AMPROPERTY_PIN_CATEGORY, "Got id %#lx.\n", id);
+    ok(id == AMPROPERTY_PIN_CATEGORY, "Got id %#x.\n", id);
     ok(!instance_data, "Got instance data %p.\n", instance_data);
-    ok(!instance_size, "Got instance size %lu.\n", instance_size);
-    ok(property_size == sizeof(GUID), "Got property size %lu.\n", property_size);
+    ok(!instance_size, "Got instance size %u.\n", instance_size);
+    ok(property_size == sizeof(GUID), "Got property size %u.\n", property_size);
     ok(!!ret_size, "Expected non-NULL return size.\n");
     memcpy(property_data, &pin->category, sizeof(GUID));
     return S_OK;
@@ -368,7 +368,7 @@ static void test_find_interface(void)
 
     CoCreateInstance(&CLSID_FilterGraph, NULL, CLSCTX_INPROC_SERVER, &IID_IGraphBuilder, (void **)&graph);
     hr = ICaptureGraphBuilder2_SetFiltergraph(capture_graph, graph);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     testfilter_init(&filter1);
     IGraphBuilder_AddFilter(graph, &filter1.filter.IBaseFilter_iface, L"filter1");
@@ -378,21 +378,21 @@ static void test_find_interface(void)
     IGraphBuilder_AddFilter(graph, &filter3.filter.IBaseFilter_iface, L"filter3");
 
     hr = IGraphBuilder_ConnectDirect(graph, &filter1.source1.pin.pin.IPin_iface, &filter2.sink1.pin.pin.IPin_iface, &mt1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IGraphBuilder_ConnectDirect(graph, &filter2.source1.pin.pin.IPin_iface, &filter3.sink1.pin.pin.IPin_iface, &mt2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     /* Test search order without any restrictions applied. */
 
     hr = ICaptureGraphBuilder2_FindInterface(capture_graph, NULL, &bogus_majortype,
                 NULL, &testiid, (void **)&unk);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "got hr %#x.\n", hr);
 
     for (i = 0; i < ARRAY_SIZE(tests_from_filter2); ++i)
     {
         hr = ICaptureGraphBuilder2_FindInterface(capture_graph, NULL, &bogus_majortype,
                 &filter2.filter.IBaseFilter_iface, &testiid, (void **)&unk);
-        ok(hr == S_OK, "Test %u: got hr %#lx.\n", i, hr);
+        ok(hr == S_OK, "Test %u: got hr %#x.\n", i, hr);
         ok(unk == tests_from_filter2[i].iface, "Test %u: got wrong interface %p.\n", i, unk);
         IUnknown_Release(unk);
         *tests_from_filter2[i].expose = FALSE;
@@ -400,7 +400,7 @@ static void test_find_interface(void)
 
     hr = ICaptureGraphBuilder2_FindInterface(capture_graph, NULL, &bogus_majortype,
             &filter2.filter.IBaseFilter_iface, &testiid, (void **)&unk);
-    ok(hr == E_FAIL, "Got hr %#lx.\n", hr);
+    ok(hr == E_FAIL, "Got hr %#x.\n", hr);
 
     reset_interfaces(&filter1);
     reset_interfaces(&filter2);
@@ -410,7 +410,7 @@ static void test_find_interface(void)
     {
         hr = ICaptureGraphBuilder2_FindInterface(capture_graph, NULL, &bogus_majortype,
                 &filter1.filter.IBaseFilter_iface, &testiid, (void **)&unk);
-        ok(hr == S_OK, "Test %u: got hr %#lx.\n", i, hr);
+        ok(hr == S_OK, "Test %u: got hr %#x.\n", i, hr);
         ok(unk == tests_from_filter1[i].iface, "Test %u: got wrong interface %p.\n", i, unk);
         IUnknown_Release(unk);
         *tests_from_filter1[i].expose = FALSE;
@@ -418,7 +418,7 @@ static void test_find_interface(void)
 
     hr = ICaptureGraphBuilder2_FindInterface(capture_graph, NULL, &bogus_majortype,
             &filter1.filter.IBaseFilter_iface, &testiid, (void **)&unk);
-    ok(hr == E_FAIL, "Got hr %#lx.\n", hr);
+    ok(hr == E_FAIL, "Got hr %#x.\n", hr);
 
     /* Test with upstream/downstream flags. */
 
@@ -430,7 +430,7 @@ static void test_find_interface(void)
     {
         hr = ICaptureGraphBuilder2_FindInterface(capture_graph, &LOOK_UPSTREAM_ONLY, &bogus_majortype,
                 &filter2.filter.IBaseFilter_iface, &testiid, (void **)&unk);
-        ok(hr == S_OK, "Test %u: got hr %#lx.\n", i, hr);
+        ok(hr == S_OK, "Test %u: got hr %#x.\n", i, hr);
         ok(unk == look_upstream_tests[i].iface, "Test %u: got wrong interface %p.\n", i, unk);
         IUnknown_Release(unk);
         *look_upstream_tests[i].expose = FALSE;
@@ -438,7 +438,7 @@ static void test_find_interface(void)
 
     hr = ICaptureGraphBuilder2_FindInterface(capture_graph, &LOOK_UPSTREAM_ONLY, &bogus_majortype,
             &filter2.filter.IBaseFilter_iface, &testiid, (void **)&unk);
-    ok(hr == E_FAIL, "Got hr %#lx.\n", hr);
+    ok(hr == E_FAIL, "Got hr %#x.\n", hr);
 
     reset_interfaces(&filter1);
     reset_interfaces(&filter2);
@@ -448,7 +448,7 @@ static void test_find_interface(void)
     {
         hr = ICaptureGraphBuilder2_FindInterface(capture_graph, &LOOK_DOWNSTREAM_ONLY, &bogus_majortype,
                 &filter2.filter.IBaseFilter_iface, &testiid, (void **)&unk);
-        ok(hr == S_OK, "Test %u: got hr %#lx.\n", i, hr);
+        ok(hr == S_OK, "Test %u: got hr %#x.\n", i, hr);
         ok(unk == look_downstream_tests[i].iface, "Test %u: got wrong interface %p.\n", i, unk);
         IUnknown_Release(unk);
         *look_downstream_tests[i].expose = FALSE;
@@ -456,7 +456,7 @@ static void test_find_interface(void)
 
     hr = ICaptureGraphBuilder2_FindInterface(capture_graph, &LOOK_DOWNSTREAM_ONLY, &bogus_majortype,
             &filter2.filter.IBaseFilter_iface, &testiid, (void **)&unk);
-    ok(hr == E_FAIL, "Got hr %#lx.\n", hr);
+    ok(hr == E_FAIL, "Got hr %#x.\n", hr);
 
     /* Test with a category flag. */
 
@@ -466,20 +466,20 @@ static void test_find_interface(void)
 
     hr = ICaptureGraphBuilder2_FindInterface(capture_graph, &PIN_CATEGORY_CAPTURE, NULL,
             &filter2.filter.IBaseFilter_iface, &testiid, (void **)&unk);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x\n", hr);
     ok(unk == (IUnknown *)&filter2.filter.IBaseFilter_iface, "Got wrong interface %p.\n", unk);
     IUnknown_Release(unk);
     filter2.filter_has_iface = FALSE;
 
     hr = ICaptureGraphBuilder2_FindInterface(capture_graph, &PIN_CATEGORY_CAPTURE, NULL,
             &filter2.filter.IBaseFilter_iface, &testiid, (void **)&unk);
-    ok(hr == E_NOINTERFACE, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOINTERFACE, "Got hr %#x.\n", hr);
 
     filter2.source1.IKsPropertySet_iface.lpVtbl = &property_set_vtbl;
     filter2.source1.category = PIN_CATEGORY_CAPTURE;
     hr = ICaptureGraphBuilder2_FindInterface(capture_graph, &PIN_CATEGORY_CAPTURE, NULL,
             &filter2.filter.IBaseFilter_iface, &testiid, (void **)&unk);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(unk == (IUnknown *)&filter2.source1.pin.pin.IPin_iface, "Got wrong interface %p.\n", unk);
     IUnknown_Release(unk);
     filter2.source1.has_iface = FALSE;
@@ -492,7 +492,7 @@ static void test_find_interface(void)
     {
         hr = ICaptureGraphBuilder2_FindInterface(capture_graph, &PIN_CATEGORY_CAPTURE, NULL,
                 &filter2.filter.IBaseFilter_iface, &testiid, (void **)&unk);
-        ok(hr == S_OK, "Test %u: got hr %#lx.\n", i, hr);
+        ok(hr == S_OK, "Test %u: got hr %#x.\n", i, hr);
         ok(unk == category_tests[i].iface, "Test %u: got wrong interface %p.\n", i, unk);
         IUnknown_Release(unk);
         *category_tests[i].expose = FALSE;
@@ -500,7 +500,7 @@ static void test_find_interface(void)
 
     hr = ICaptureGraphBuilder2_FindInterface(capture_graph, &PIN_CATEGORY_CAPTURE, NULL,
             &filter2.filter.IBaseFilter_iface, &testiid, (void **)&unk);
-    ok(hr == E_FAIL, "Got hr %#lx.\n", hr);
+    ok(hr == E_FAIL, "Got hr %#x.\n", hr);
 
     /* Test with a media type. */
 
@@ -512,22 +512,22 @@ static void test_find_interface(void)
 
     hr = ICaptureGraphBuilder2_FindInterface(capture_graph, &PIN_CATEGORY_CAPTURE, &bogus_majortype,
             &filter2.filter.IBaseFilter_iface, &testiid, (void **)&unk);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x\n", hr);
     ok(unk == (IUnknown *)&filter2.filter.IBaseFilter_iface, "Got wrong interface %p.\n", unk);
     IUnknown_Release(unk);
     filter2.filter_has_iface = FALSE;
 
     hr = ICaptureGraphBuilder2_FindInterface(capture_graph, &PIN_CATEGORY_CAPTURE, &bogus_majortype,
             &filter2.filter.IBaseFilter_iface, &testiid, (void **)&unk);
-    ok(hr == E_NOINTERFACE, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOINTERFACE, "Got hr %#x.\n", hr);
 
     hr = ICaptureGraphBuilder2_FindInterface(capture_graph, &PIN_CATEGORY_CAPTURE, &mt2.majortype,
             &filter2.filter.IBaseFilter_iface, &testiid, (void **)&unk);
-    ok(hr == E_NOINTERFACE, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOINTERFACE, "Got hr %#x.\n", hr);
 
     hr = ICaptureGraphBuilder2_FindInterface(capture_graph, &PIN_CATEGORY_CAPTURE, &testtype,
             &filter2.filter.IBaseFilter_iface, &testiid, (void **)&unk);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(unk == (IUnknown *)&filter2.source1.pin.pin.IPin_iface, "Got wrong interface %p.\n", unk);
     IUnknown_Release(unk);
     filter2.source1.has_iface = FALSE;
@@ -538,7 +538,7 @@ static void test_find_interface(void)
     {
         hr = ICaptureGraphBuilder2_FindInterface(capture_graph, &PIN_CATEGORY_CAPTURE, NULL,
                 &filter2.filter.IBaseFilter_iface, &testiid, (void **)&unk);
-        ok(hr == S_OK, "Test %u: got hr %#lx.\n", i, hr);
+        ok(hr == S_OK, "Test %u: got hr %#x.\n", i, hr);
         ok(unk == category_tests[i].iface, "Test %u: got wrong interface %p.\n", i, unk);
         IUnknown_Release(unk);
         *category_tests[i].expose = FALSE;
@@ -546,18 +546,18 @@ static void test_find_interface(void)
 
     hr = ICaptureGraphBuilder2_FindInterface(capture_graph, &PIN_CATEGORY_CAPTURE, NULL,
             &filter2.filter.IBaseFilter_iface, &testiid, (void **)&unk);
-    ok(hr == E_FAIL, "Got hr %#lx.\n", hr);
+    ok(hr == E_FAIL, "Got hr %#x.\n", hr);
 
     ref = ICaptureGraphBuilder2_Release(capture_graph);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ref = IGraphBuilder_Release(graph);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ref = IBaseFilter_Release(&filter1.filter.IBaseFilter_iface);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ref = IBaseFilter_Release(&filter2.filter.IBaseFilter_iface);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ref = IBaseFilter_Release(&filter3.filter.IBaseFilter_iface);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 static void test_find_pin(void)
@@ -578,7 +578,7 @@ static void test_find_pin(void)
 
     CoCreateInstance(&CLSID_FilterGraph, NULL, CLSCTX_INPROC_SERVER, &IID_IGraphBuilder, (void **)&graph);
     hr = ICaptureGraphBuilder2_SetFiltergraph(capture_graph, graph);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     testfilter_init(&filter1);
     testfilter_init(&filter2);
@@ -587,51 +587,51 @@ static void test_find_pin(void)
 
     hr = IGraphBuilder_ConnectDirect(graph, &filter1.source1.pin.pin.IPin_iface,
             &filter2.sink1.pin.pin.IPin_iface, &mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = ICaptureGraphBuilder2_FindPin(capture_graph, (IUnknown *)&filter1.filter.IBaseFilter_iface,
             PINDIR_INPUT, NULL, NULL, FALSE, 0, &pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(pin == &filter1.sink1.pin.pin.IPin_iface, "Got wrong pin.\n");
     IPin_Release(pin);
 
     hr = ICaptureGraphBuilder2_FindPin(capture_graph, (IUnknown *)&filter1.filter.IBaseFilter_iface,
             PINDIR_INPUT, NULL, NULL, FALSE, 1, &pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(pin == &filter1.sink2.pin.pin.IPin_iface, "Got wrong pin.\n");
     IPin_Release(pin);
 
     hr = ICaptureGraphBuilder2_FindPin(capture_graph, (IUnknown *)&filter1.filter.IBaseFilter_iface,
             PINDIR_INPUT, NULL, NULL, FALSE, 2, &pin);
-    ok(hr == E_FAIL, "Got hr %#lx.\n", hr);
+    ok(hr == E_FAIL, "Got hr %#x.\n", hr);
 
     hr = ICaptureGraphBuilder2_FindPin(capture_graph, (IUnknown *)&filter1.filter.IBaseFilter_iface,
             PINDIR_OUTPUT, NULL, NULL, FALSE, 0, &pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(pin == &filter1.source1.pin.pin.IPin_iface, "Got wrong pin.\n");
     IPin_Release(pin);
 
     hr = ICaptureGraphBuilder2_FindPin(capture_graph, (IUnknown *)&filter1.filter.IBaseFilter_iface,
             PINDIR_OUTPUT, NULL, NULL, FALSE, 1, &pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(pin == &filter1.source2.pin.pin.IPin_iface, "Got wrong pin.\n");
     IPin_Release(pin);
 
     hr = ICaptureGraphBuilder2_FindPin(capture_graph, (IUnknown *)&filter1.filter.IBaseFilter_iface,
             PINDIR_OUTPUT, NULL, NULL, FALSE, 2, &pin);
-    ok(hr == E_FAIL, "Got hr %#lx.\n", hr);
+    ok(hr == E_FAIL, "Got hr %#x.\n", hr);
 
     /* Test the unconnected flag. */
 
     hr = ICaptureGraphBuilder2_FindPin(capture_graph, (IUnknown *)&filter1.filter.IBaseFilter_iface,
             PINDIR_OUTPUT, NULL, NULL, TRUE, 0, &pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(pin == &filter1.source2.pin.pin.IPin_iface, "Got wrong pin.\n");
     IPin_Release(pin);
 
     hr = ICaptureGraphBuilder2_FindPin(capture_graph, (IUnknown *)&filter1.filter.IBaseFilter_iface,
             PINDIR_OUTPUT, NULL, NULL, TRUE, 1, &pin);
-    ok(hr == E_FAIL, "Got hr %#lx.\n", hr);
+    ok(hr == E_FAIL, "Got hr %#x.\n", hr);
 
     /* Test categories. */
 
@@ -640,31 +640,31 @@ static void test_find_pin(void)
 
     hr = ICaptureGraphBuilder2_FindPin(capture_graph, (IUnknown *)&filter1.filter.IBaseFilter_iface,
             PINDIR_OUTPUT, &PIN_CATEGORY_CAPTURE, NULL, FALSE, 0, &pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(pin == &filter1.source1.pin.pin.IPin_iface, "Got wrong pin.\n");
     IPin_Release(pin);
 
     hr = ICaptureGraphBuilder2_FindPin(capture_graph, (IUnknown *)&filter1.filter.IBaseFilter_iface,
             PINDIR_OUTPUT, &PIN_CATEGORY_CAPTURE, NULL, FALSE, 1, &pin);
-    ok(hr == E_FAIL, "Got hr %#lx.\n", hr);
+    ok(hr == E_FAIL, "Got hr %#x.\n", hr);
 
     ref = ICaptureGraphBuilder2_Release(capture_graph);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ref = IGraphBuilder_Release(graph);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ref = IBaseFilter_Release(&filter1.filter.IBaseFilter_iface);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ref = IBaseFilter_Release(&filter2.filter.IBaseFilter_iface);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 static void disconnect_pins(IGraphBuilder *graph, struct testsource *pin)
 {
     HRESULT hr;
     hr = IGraphBuilder_Disconnect(graph, pin->pin.pin.peer);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IGraphBuilder_Disconnect(graph, &pin->pin.pin.IPin_iface);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 }
 
 static void check_smart_tee_pin_(int line, IPin *pin, const WCHAR *name)
@@ -694,7 +694,7 @@ static void test_render_stream(void)
 
     CoCreateInstance(&CLSID_FilterGraph, NULL, CLSCTX_INPROC_SERVER, &IID_IGraphBuilder, (void **)&graph);
     hr = ICaptureGraphBuilder2_SetFiltergraph(capture_graph, graph);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     testfilter_init(&source);
     testfilter_init(&transform);
@@ -711,7 +711,7 @@ static void test_render_stream(void)
 
     hr = ICaptureGraphBuilder2_RenderStream(capture_graph, NULL, NULL,
             (IUnknown *)&source.filter.IBaseFilter_iface, NULL, &sink.filter.IBaseFilter_iface);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(source.source1.pin.pin.peer == &transform.sink1.pin.pin.IPin_iface, "Got wrong connection.\n");
     ok(transform.source1.pin.pin.peer == &sink.sink1.pin.pin.IPin_iface, "Got wrong connection.\n");
     ok(!source.source2.pin.pin.peer, "Pin should not be connected.\n");
@@ -719,7 +719,7 @@ static void test_render_stream(void)
 
     hr = ICaptureGraphBuilder2_RenderStream(capture_graph, NULL, NULL,
             (IUnknown *)&source.filter.IBaseFilter_iface, NULL, &sink.filter.IBaseFilter_iface);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(source.source1.pin.pin.peer == &transform.sink1.pin.pin.IPin_iface, "Got wrong connection.\n");
     ok(transform.source1.pin.pin.peer == &sink.sink1.pin.pin.IPin_iface, "Got wrong connection.\n");
     todo_wine ok(source.source2.pin.pin.peer == &transform.sink2.pin.pin.IPin_iface, "Got wrong connection.\n");
@@ -727,14 +727,14 @@ static void test_render_stream(void)
 
     hr = ICaptureGraphBuilder2_RenderStream(capture_graph, NULL, NULL,
             (IUnknown *)&source.filter.IBaseFilter_iface, NULL, &sink.filter.IBaseFilter_iface);
-    todo_wine ok(hr == E_FAIL, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == E_FAIL, "Got hr %#x.\n", hr);
 
     todo_wine disconnect_pins(graph, &source.source2);
     todo_wine disconnect_pins(graph, &transform.source2);
 
     hr = ICaptureGraphBuilder2_RenderStream(capture_graph, NULL, NULL,
             (IUnknown *)&transform.source2.pin.pin.IPin_iface, NULL, &sink.filter.IBaseFilter_iface);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(source.source1.pin.pin.peer == &transform.sink1.pin.pin.IPin_iface, "Got wrong connection.\n");
     ok(transform.source1.pin.pin.peer == &sink.sink1.pin.pin.IPin_iface, "Got wrong connection.\n");
     ok(transform.source2.pin.pin.peer == &sink.sink2.pin.pin.IPin_iface, "Got wrong connection.\n");
@@ -742,20 +742,20 @@ static void test_render_stream(void)
 
     hr = ICaptureGraphBuilder2_RenderStream(capture_graph, NULL, NULL,
             (IUnknown *)&source.filter.IBaseFilter_iface, NULL, &sink.filter.IBaseFilter_iface);
-    ok(hr == E_FAIL, "Got hr %#lx.\n", hr);
+    ok(hr == E_FAIL, "Got hr %#x.\n", hr);
 
     disconnect_pins(graph, &transform.source2);
 
     hr = ICaptureGraphBuilder2_RenderStream(capture_graph, NULL, NULL,
             (IUnknown *)&source.filter.IBaseFilter_iface, NULL, &transform.filter.IBaseFilter_iface);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(source.source1.pin.pin.peer == &transform.sink1.pin.pin.IPin_iface, "Got wrong connection.\n");
     ok(transform.source1.pin.pin.peer == &sink.sink1.pin.pin.IPin_iface, "Got wrong connection.\n");
     todo_wine ok(source.source2.pin.pin.peer == &transform.sink2.pin.pin.IPin_iface, "Got wrong connection.\n");
 
     hr = ICaptureGraphBuilder2_RenderStream(capture_graph, NULL, NULL,
             (IUnknown *)&source.filter.IBaseFilter_iface, NULL, &sink.filter.IBaseFilter_iface);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(source.source1.pin.pin.peer == &transform.sink1.pin.pin.IPin_iface, "Got wrong connection.\n");
     ok(transform.source1.pin.pin.peer == &sink.sink1.pin.pin.IPin_iface, "Got wrong connection.\n");
     todo_wine ok(source.source2.pin.pin.peer == &transform.sink2.pin.pin.IPin_iface, "Got wrong connection.\n");
@@ -766,7 +766,7 @@ static void test_render_stream(void)
     /* Test from a source pin. */
     hr = ICaptureGraphBuilder2_RenderStream(capture_graph, NULL, NULL,
             (IUnknown *)&source.source1.pin.pin.IPin_iface, NULL, &sink.filter.IBaseFilter_iface);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(source.source1.pin.pin.peer == &transform.sink1.pin.pin.IPin_iface, "Got wrong connection.\n");
     ok(transform.source1.pin.pin.peer == &sink.sink1.pin.pin.IPin_iface, "Got wrong connection.\n");
     todo_wine ok(transform.source2.pin.pin.peer == &sink.sink2.pin.pin.IPin_iface, "Got wrong connection.\n");
@@ -777,7 +777,7 @@ static void test_render_stream(void)
     source.source_type = bad_type;
     hr = ICaptureGraphBuilder2_RenderStream(capture_graph, NULL, NULL,
             (IUnknown *)&source.filter.IBaseFilter_iface, NULL, &sink.filter.IBaseFilter_iface);
-    ok(hr == VFW_E_CANNOT_CONNECT, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_CANNOT_CONNECT, "Got hr %#x.\n", hr);
     source.source_type = source_type;
 
     disconnect_pins(graph, &transform.source1);
@@ -791,7 +791,7 @@ static void test_render_stream(void)
     hr = ICaptureGraphBuilder2_RenderStream(capture_graph, NULL, NULL,
             (IUnknown *)&source.filter.IBaseFilter_iface,
             &identity.filter.IBaseFilter_iface, &sink.filter.IBaseFilter_iface);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(source.source1.pin.pin.peer == &identity.sink1.pin.pin.IPin_iface, "Got wrong connection.\n");
     ok(identity.source1.pin.pin.peer == &transform.sink1.pin.pin.IPin_iface, "Got wrong connection.\n");
     ok(transform.source1.pin.pin.peer == &sink.sink1.pin.pin.IPin_iface, "Got wrong connection.\n");
@@ -803,7 +803,7 @@ static void test_render_stream(void)
     hr = ICaptureGraphBuilder2_RenderStream(capture_graph, NULL, NULL,
             (IUnknown *)&source.filter.IBaseFilter_iface,
             &identity.filter.IBaseFilter_iface, &sink.filter.IBaseFilter_iface);
-    todo_wine ok(hr == E_FAIL, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == E_FAIL, "Got hr %#x.\n", hr);
     ok(!source.source1.pin.pin.peer, "Pin should not be connected.\n");
     ok(!identity.source1.pin.pin.peer, "Pin should not be connected.\n");
     ok(!transform.source1.pin.pin.peer, "Pin should not be connected.\n");
@@ -813,7 +813,7 @@ static void test_render_stream(void)
     hr = ICaptureGraphBuilder2_RenderStream(capture_graph, NULL, NULL,
             (IUnknown *)&source.filter.IBaseFilter_iface,
             &identity.filter.IBaseFilter_iface, &sink.filter.IBaseFilter_iface);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(source.source1.pin.pin.peer == &transform.sink1.pin.pin.IPin_iface, "Got wrong connection.\n");
     ok(transform.source1.pin.pin.peer == &identity.sink1.pin.pin.IPin_iface, "Got wrong connection.\n");
     ok(identity.source1.pin.pin.peer == &sink.sink1.pin.pin.IPin_iface, "Got wrong connection.\n");
@@ -825,7 +825,7 @@ static void test_render_stream(void)
     hr = ICaptureGraphBuilder2_RenderStream(capture_graph, NULL, NULL,
             (IUnknown *)&source.filter.IBaseFilter_iface,
             &identity.filter.IBaseFilter_iface, &sink.filter.IBaseFilter_iface);
-    ok(hr == VFW_E_CANNOT_CONNECT, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_CANNOT_CONNECT, "Got hr %#x.\n", hr);
     ok(source.source1.pin.pin.peer == &transform.sink1.pin.pin.IPin_iface, "Got wrong connection.\n");
     ok(transform.source1.pin.pin.peer == &identity.sink1.pin.pin.IPin_iface, "Got wrong connection.\n");
     ok(!identity.source1.pin.pin.peer, "Pin should not be connected.\n");
@@ -836,7 +836,7 @@ static void test_render_stream(void)
 
     hr = ICaptureGraphBuilder2_RenderStream(capture_graph, NULL, &bad_type,
             (IUnknown *)&source.filter.IBaseFilter_iface, NULL, &sink.filter.IBaseFilter_iface);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(!source.source1.pin.pin.peer, "Pin should not be connected.\n");
     ok(!source.source2.pin.pin.peer, "Pin should not be connected.\n");
     ok(!sink.sink1.pin.pin.peer, "Pin should not be connected.\n");
@@ -844,7 +844,7 @@ static void test_render_stream(void)
 
     hr = ICaptureGraphBuilder2_RenderStream(capture_graph, NULL, &sink1_type,
             (IUnknown *)&source.filter.IBaseFilter_iface, NULL, &sink.filter.IBaseFilter_iface);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(!source.source1.pin.pin.peer, "Pin should not be connected.\n");
     ok(!source.source2.pin.pin.peer, "Pin should not be connected.\n");
     ok(!sink.sink1.pin.pin.peer, "Pin should not be connected.\n");
@@ -855,7 +855,7 @@ static void test_render_stream(void)
     hr = ICaptureGraphBuilder2_RenderStream(capture_graph, NULL, &sink1_type,
             (IUnknown *)&source.filter.IBaseFilter_iface,
             &identity.filter.IBaseFilter_iface, &sink.filter.IBaseFilter_iface);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(!source.source1.pin.pin.peer, "Pin should not be connected.\n");
     ok(!source.source2.pin.pin.peer, "Pin should not be connected.\n");
     ok(!sink.sink1.pin.pin.peer, "Pin should not be connected.\n");
@@ -863,7 +863,7 @@ static void test_render_stream(void)
 
     hr = ICaptureGraphBuilder2_RenderStream(capture_graph, NULL, &source_type,
             (IUnknown *)&source.filter.IBaseFilter_iface, NULL, &sink.filter.IBaseFilter_iface);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(source.source1.pin.pin.peer == &transform.sink1.pin.pin.IPin_iface, "Got wrong connection.\n");
     ok(transform.source1.pin.pin.peer == &sink.sink1.pin.pin.IPin_iface, "Got wrong connection.\n");
     ok(!source.source2.pin.pin.peer, "Pin should not be connected.\n");
@@ -871,7 +871,7 @@ static void test_render_stream(void)
 
     hr = ICaptureGraphBuilder2_RenderStream(capture_graph, NULL, &sink1_type,
             (IUnknown *)&source.filter.IBaseFilter_iface, NULL, &sink.filter.IBaseFilter_iface);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(source.source1.pin.pin.peer == &transform.sink1.pin.pin.IPin_iface, "Got wrong connection.\n");
     ok(transform.source1.pin.pin.peer == &sink.sink1.pin.pin.IPin_iface, "Got wrong connection.\n");
     ok(transform.source2.pin.pin.peer == &sink.sink2.pin.pin.IPin_iface, "Got wrong connection.\n");
@@ -885,7 +885,7 @@ static void test_render_stream(void)
 
     hr = ICaptureGraphBuilder2_RenderStream(capture_graph, &PIN_CATEGORY_CC, NULL,
             (IUnknown *)&source.filter.IBaseFilter_iface, NULL, &sink.filter.IBaseFilter_iface);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
     ok(!source.source1.pin.pin.peer, "Pin should not be connected.\n");
     ok(!source.source2.pin.pin.peer, "Pin should not be connected.\n");
     ok(!sink.sink1.pin.pin.peer, "Pin should not be connected.\n");
@@ -894,7 +894,7 @@ static void test_render_stream(void)
     source.source1.IKsPropertySet_iface.lpVtbl = &property_set_vtbl;
     hr = ICaptureGraphBuilder2_RenderStream(capture_graph, &PIN_CATEGORY_CC, NULL,
             (IUnknown *)&source.filter.IBaseFilter_iface, NULL, &sink.filter.IBaseFilter_iface);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
     ok(!source.source1.pin.pin.peer, "Pin should not be connected.\n");
     ok(!source.source2.pin.pin.peer, "Pin should not be connected.\n");
     ok(!sink.sink1.pin.pin.peer, "Pin should not be connected.\n");
@@ -903,7 +903,7 @@ static void test_render_stream(void)
     source.source1.category = PIN_CATEGORY_CC;
     hr = ICaptureGraphBuilder2_RenderStream(capture_graph, &PIN_CATEGORY_CC, NULL,
             (IUnknown *)&source.filter.IBaseFilter_iface, NULL, &sink.filter.IBaseFilter_iface);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(source.source1.pin.pin.peer == &transform.sink1.pin.pin.IPin_iface, "Got wrong connection.\n");
     ok(transform.source1.pin.pin.peer == &sink.sink1.pin.pin.IPin_iface, "Got wrong connection.\n");
     ok(!source.source2.pin.pin.peer, "Pin should not be connected.\n");
@@ -913,7 +913,7 @@ static void test_render_stream(void)
 
     hr = ICaptureGraphBuilder2_RenderStream(capture_graph, &PIN_CATEGORY_CC, NULL,
             (IUnknown *)&source.filter.IBaseFilter_iface, NULL, &sink.filter.IBaseFilter_iface);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
     ok(source.source1.pin.pin.peer == &transform.sink1.pin.pin.IPin_iface, "Got wrong connection.\n");
     ok(!transform.source1.pin.pin.peer, "Pin should not be connected.\n");
 
@@ -921,14 +921,14 @@ static void test_render_stream(void)
     transform.source1.category = PIN_CATEGORY_CC;
     hr = ICaptureGraphBuilder2_RenderStream(capture_graph, &PIN_CATEGORY_CC, NULL,
             (IUnknown *)&source.filter.IBaseFilter_iface, NULL, &sink.filter.IBaseFilter_iface);
-    todo_wine ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
     ok(source.source1.pin.pin.peer == &transform.sink1.pin.pin.IPin_iface, "Got wrong connection.\n");
     todo_wine ok(!transform.source1.pin.pin.peer, "Pin should not be connected.\n");
     todo_wine ok(!sink.sink1.pin.pin.peer, "Pin should not be connected.\n");
 
     hr = ICaptureGraphBuilder2_RenderStream(capture_graph, &PIN_CATEGORY_CC, NULL,
             (IUnknown *)&source.source1.pin.pin.IPin_iface, NULL, &sink.filter.IBaseFilter_iface);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
 
     disconnect_pins(graph, &source.source1);
 
@@ -937,53 +937,53 @@ static void test_render_stream(void)
     source.source1.IKsPropertySet_iface.lpVtbl = transform.source1.IKsPropertySet_iface.lpVtbl = NULL;
     hr = ICaptureGraphBuilder2_RenderStream(capture_graph, &PIN_CATEGORY_CAPTURE, NULL,
             (IUnknown *)&source.filter.IBaseFilter_iface, NULL, &sink.filter.IBaseFilter_iface);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
     hr = ICaptureGraphBuilder2_RenderStream(capture_graph, &PIN_CATEGORY_PREVIEW, NULL,
             (IUnknown *)&source.filter.IBaseFilter_iface, NULL, &sink.filter.IBaseFilter_iface);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
 
     source.source1.IKsPropertySet_iface.lpVtbl = &property_set_vtbl;
     hr = ICaptureGraphBuilder2_RenderStream(capture_graph, &PIN_CATEGORY_CAPTURE, NULL,
             (IUnknown *)&source.filter.IBaseFilter_iface, NULL, &sink.filter.IBaseFilter_iface);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
     hr = ICaptureGraphBuilder2_RenderStream(capture_graph, &PIN_CATEGORY_PREVIEW, NULL,
             (IUnknown *)&source.filter.IBaseFilter_iface, NULL, &sink.filter.IBaseFilter_iface);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
 
     source.source1.category = PIN_CATEGORY_PREVIEW;
     hr = ICaptureGraphBuilder2_RenderStream(capture_graph, &PIN_CATEGORY_CAPTURE, NULL,
             (IUnknown *)&source.filter.IBaseFilter_iface, NULL, &sink.filter.IBaseFilter_iface);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
     ok(!source.source1.pin.pin.peer, "Pin should not be connected.\n");
     todo_wine ok(!sink.sink1.pin.pin.peer, "Pin should not be connected.\n");
 
     hr = ICaptureGraphBuilder2_RenderStream(capture_graph, &PIN_CATEGORY_PREVIEW, NULL,
             (IUnknown *)&source.filter.IBaseFilter_iface, NULL, &sink.filter.IBaseFilter_iface);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
     todo_wine ok(source.source1.pin.pin.peer == &transform.sink1.pin.pin.IPin_iface, "Got wrong connection.\n");
     ok(transform.source1.pin.pin.peer == &sink.sink1.pin.pin.IPin_iface, "Got wrong connection.\n");
     disconnect_pins(graph, &transform.source1);
 
     hr = ICaptureGraphBuilder2_RenderStream(capture_graph, &PIN_CATEGORY_PREVIEW, NULL,
             (IUnknown *)&source.filter.IBaseFilter_iface, NULL, &sink.filter.IBaseFilter_iface);
-    todo_wine ok(hr == E_FAIL, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == E_FAIL, "Got hr %#x.\n", hr);
     todo_wine disconnect_pins(graph, &source.source1);
 
     source.source1.category = PIN_CATEGORY_CAPTURE;
     hr = ICaptureGraphBuilder2_RenderStream(capture_graph, &PIN_CATEGORY_CAPTURE, NULL,
             (IUnknown *)&source.filter.IBaseFilter_iface, NULL, &sink.filter.IBaseFilter_iface);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_smart_tee_pin(source.source1.pin.pin.peer, L"Input");
     check_smart_tee_pin(transform.sink1.pin.pin.peer, L"Capture");
     ok(transform.source1.pin.pin.peer == &sink.sink1.pin.pin.IPin_iface, "Got wrong connection.\n");
 
     hr = ICaptureGraphBuilder2_RenderStream(capture_graph, &PIN_CATEGORY_CAPTURE, NULL,
             (IUnknown *)&source.filter.IBaseFilter_iface, NULL, &sink.filter.IBaseFilter_iface);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
 
     hr = ICaptureGraphBuilder2_RenderStream(capture_graph, &PIN_CATEGORY_PREVIEW, NULL,
             (IUnknown *)&source.filter.IBaseFilter_iface, NULL, &sink.filter.IBaseFilter_iface);
-    ok(hr == VFW_S_NOPREVIEWPIN, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_S_NOPREVIEWPIN, "Got hr %#x.\n", hr);
     check_smart_tee_pin(source.source1.pin.pin.peer, L"Input");
     check_smart_tee_pin(transform.sink1.pin.pin.peer, L"Capture");
     check_smart_tee_pin(transform.sink2.pin.pin.peer, L"Preview");
@@ -996,18 +996,18 @@ static void test_render_stream(void)
 
     hr = ICaptureGraphBuilder2_RenderStream(capture_graph, &PIN_CATEGORY_CC, NULL,
             (IUnknown *)&source.filter.IBaseFilter_iface, NULL, &sink.filter.IBaseFilter_iface);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
 
     hr = ICaptureGraphBuilder2_RenderStream(capture_graph, &PIN_CATEGORY_PREVIEW, NULL,
             (IUnknown *)&source.filter.IBaseFilter_iface, NULL, &sink.filter.IBaseFilter_iface);
-    ok(hr == VFW_S_NOPREVIEWPIN, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_S_NOPREVIEWPIN, "Got hr %#x.\n", hr);
     check_smart_tee_pin(source.source1.pin.pin.peer, L"Input");
     check_smart_tee_pin(transform.sink1.pin.pin.peer, L"Preview");
     ok(transform.source1.pin.pin.peer == &sink.sink1.pin.pin.IPin_iface, "Got wrong connection.\n");
 
     hr = ICaptureGraphBuilder2_RenderStream(capture_graph, &PIN_CATEGORY_PREVIEW, NULL,
             (IUnknown *)&source.filter.IBaseFilter_iface, NULL, &sink.filter.IBaseFilter_iface);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
 
     disconnect_pins(graph, &source.source1);
     IGraphBuilder_RemoveFilter(graph, &transform.filter.IBaseFilter_iface);
@@ -1018,7 +1018,7 @@ static void test_render_stream(void)
     source.source1.category = PIN_CATEGORY_CAPTURE;
     hr = ICaptureGraphBuilder2_RenderStream(capture_graph, &PIN_CATEGORY_CAPTURE, NULL,
             (IUnknown *)&source.source1.pin.pin.IPin_iface, NULL, &sink.filter.IBaseFilter_iface);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_smart_tee_pin(source.source1.pin.pin.peer, L"Input");
     check_smart_tee_pin(transform.sink1.pin.pin.peer, L"Capture");
     ok(transform.source1.pin.pin.peer == &sink.sink1.pin.pin.IPin_iface, "Got wrong connection.\n");
@@ -1033,7 +1033,7 @@ static void test_render_stream(void)
 
     hr = ICaptureGraphBuilder2_RenderStream(capture_graph, &PIN_CATEGORY_CAPTURE, NULL,
             (IUnknown *)&source.filter.IBaseFilter_iface, NULL, &sink.filter.IBaseFilter_iface);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(source.source1.pin.pin.peer == &transform.sink1.pin.pin.IPin_iface, "Got wrong connection.\n");
     ok(transform.source1.pin.pin.peer == &sink.sink1.pin.pin.IPin_iface, "Got wrong connection.\n");
     disconnect_pins(graph, &source.source1);
@@ -1041,7 +1041,7 @@ static void test_render_stream(void)
 
     hr = ICaptureGraphBuilder2_RenderStream(capture_graph, &PIN_CATEGORY_PREVIEW, NULL,
             (IUnknown *)&source.filter.IBaseFilter_iface, NULL, &sink.filter.IBaseFilter_iface);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(source.source2.pin.pin.peer == &transform.sink1.pin.pin.IPin_iface, "Got wrong connection.\n");
     ok(transform.source1.pin.pin.peer == &sink.sink1.pin.pin.IPin_iface, "Got wrong connection.\n");
     disconnect_pins(graph, &source.source2);
@@ -1049,7 +1049,7 @@ static void test_render_stream(void)
 
     hr = ICaptureGraphBuilder2_RenderStream(capture_graph, &PIN_CATEGORY_CAPTURE, NULL,
             (IUnknown *)&source.source1.pin.pin.IPin_iface, NULL, &sink.filter.IBaseFilter_iface);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_smart_tee_pin(source.source1.pin.pin.peer, L"Input");
     check_smart_tee_pin(transform.sink1.pin.pin.peer, L"Capture");
     ok(transform.source1.pin.pin.peer == &sink.sink1.pin.pin.IPin_iface, "Got wrong connection.\n");
@@ -1057,15 +1057,15 @@ static void test_render_stream(void)
     disconnect_pins(graph, &transform.source1);
 
     ref = ICaptureGraphBuilder2_Release(capture_graph);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ref = IGraphBuilder_Release(graph);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ref = IBaseFilter_Release(&source.filter.IBaseFilter_iface);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ref = IBaseFilter_Release(&transform.filter.IBaseFilter_iface);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ref = IBaseFilter_Release(&sink.filter.IBaseFilter_iface);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 START_TEST(capturegraph)
diff --git a/dlls/qcap/tests/filewriter.c b/dlls/qcap/tests/filewriter.c
index 3713af1a43a..d6dbc3faded 100644
--- wine/dlls/qcap/tests/filewriter.c
+++ wine/dlls/qcap/tests/filewriter.c
@@ -28,7 +28,7 @@ static IBaseFilter *create_file_writer(void)
     IBaseFilter *filter = NULL;
     HRESULT hr = CoCreateInstance(&CLSID_FileWriter, NULL,
             CLSCTX_INPROC_SERVER, &IID_IBaseFilter, (void **)&filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     return filter;
 }
 
@@ -45,7 +45,7 @@ static WCHAR *set_filename(IBaseFilter *filter)
 
     IBaseFilter_QueryInterface(filter, &IID_IFileSinkFilter, (void **)&filesink);
     hr = IFileSinkFilter_SetFileName(filesink, filename, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     IFileSinkFilter_Release(filesink);
     return filename;
 }
@@ -67,7 +67,7 @@ static void check_interface_(unsigned int line, void *iface_ptr, REFIID iid, BOO
     expected_hr = supported ? S_OK : E_NOINTERFACE;
 
     hr = IUnknown_QueryInterface(iface, iid, (void **)&unk);
-    ok_(__FILE__, line)(hr == expected_hr, "Got hr %#lx, expected %#lx.\n", hr, expected_hr);
+    ok_(__FILE__, line)(hr == expected_hr, "Got hr %#x, expected %#x.\n", hr, expected_hr);
     if (SUCCEEDED(hr))
         IUnknown_Release(unk);
 }
@@ -112,7 +112,7 @@ static void test_interfaces(void)
 
     IPin_Release(pin);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got unexpected refcount %ld.\n", ref);
+    ok(!ref, "Got unexpected refcount %d.\n", ref);
 }
 
 static const GUID test_iid = {0x33333333};
@@ -160,53 +160,53 @@ static void test_aggregation(void)
     filter = (IBaseFilter *)0xdeadbeef;
     hr = CoCreateInstance(&CLSID_FileWriter, &test_outer, CLSCTX_INPROC_SERVER,
             &IID_IBaseFilter, (void **)&filter);
-    ok(hr == E_NOINTERFACE, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOINTERFACE, "Got hr %#x.\n", hr);
     ok(!filter, "Got interface %p.\n", filter);
 
     hr = CoCreateInstance(&CLSID_FileWriter, &test_outer, CLSCTX_INPROC_SERVER,
             &IID_IUnknown, (void **)&unk);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(outer_ref == 1, "Got unexpected refcount %ld.\n", outer_ref);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
     ok(unk != &test_outer, "Returned IUnknown should not be outer IUnknown.\n");
     ref = get_refcount(unk);
-    ok(ref == 1, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
 
     ref = IUnknown_AddRef(unk);
-    ok(ref == 2, "Got unexpected refcount %ld.\n", ref);
-    ok(outer_ref == 1, "Got unexpected refcount %ld.\n", outer_ref);
+    ok(ref == 2, "Got unexpected refcount %d.\n", ref);
+    ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
 
     ref = IUnknown_Release(unk);
-    ok(ref == 1, "Got unexpected refcount %ld.\n", ref);
-    ok(outer_ref == 1, "Got unexpected refcount %ld.\n", outer_ref);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
+    ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
 
     hr = IUnknown_QueryInterface(unk, &IID_IUnknown, (void **)&unk2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(unk2 == unk, "Got unexpected IUnknown %p.\n", unk2);
     IUnknown_Release(unk2);
 
     hr = IUnknown_QueryInterface(unk, &IID_IBaseFilter, (void **)&filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_QueryInterface(filter, &IID_IUnknown, (void **)&unk2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(unk2 == (IUnknown *)0xdeadbeef, "Got unexpected IUnknown %p.\n", unk2);
 
     hr = IBaseFilter_QueryInterface(filter, &IID_IBaseFilter, (void **)&filter2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(filter2 == (IBaseFilter *)0xdeadbeef, "Got unexpected IBaseFilter %p.\n", filter2);
 
     hr = IUnknown_QueryInterface(unk, &test_iid, (void **)&unk2);
-    ok(hr == E_NOINTERFACE, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOINTERFACE, "Got hr %#x.\n", hr);
     ok(!unk2, "Got unexpected IUnknown %p.\n", unk2);
 
     hr = IBaseFilter_QueryInterface(filter, &test_iid, (void **)&unk2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(unk2 == (IUnknown *)0xdeadbeef, "Got unexpected IUnknown %p.\n", unk2);
 
     IBaseFilter_Release(filter);
     ref = IUnknown_Release(unk);
-    ok(!ref, "Got unexpected refcount %ld.\n", ref);
-    ok(outer_ref == 1, "Got unexpected refcount %ld.\n", outer_ref);
+    ok(!ref, "Got unexpected refcount %d.\n", ref);
+    ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
 }
 
 static void test_enum_pins(void)
@@ -218,85 +218,85 @@ static void test_enum_pins(void)
     HRESULT hr;
 
     ref = get_refcount(filter);
-    ok(ref == 1, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
 
     hr = IBaseFilter_EnumPins(filter, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_EnumPins(filter, &enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ref = get_refcount(filter);
-    ok(ref == 2, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 2, "Got unexpected refcount %d.\n", ref);
     ref = get_refcount(enum1);
-    ok(ref == 1, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
 
     hr = IEnumPins_Next(enum1, 1, NULL, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum1, 1, pins, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ref = get_refcount(filter);
-    ok(ref == 3, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 3, "Got unexpected refcount %d.\n", ref);
     ref = get_refcount(pins[0]);
-    ok(ref == 3, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 3, "Got unexpected refcount %d.\n", ref);
     ref = get_refcount(enum1);
-    ok(ref == 1, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
     IPin_Release(pins[0]);
     ref = get_refcount(filter);
-    ok(ref == 2, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 2, "Got unexpected refcount %d.\n", ref);
 
     hr = IEnumPins_Next(enum1, 1, pins, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum1, 1, pins, &count);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(count == 1, "Got count %lu.\n", count);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(count == 1, "Got count %u.\n", count);
     IPin_Release(pins[0]);
 
     hr = IEnumPins_Next(enum1, 1, pins, &count);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
-    ok(!count, "Got count %lu.\n", count);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    ok(!count, "Got count %u.\n", count);
 
     hr = IEnumPins_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum1, 2, pins, NULL);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum1, 2, pins, &count);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
-    ok(count == 1, "Got count %lu.\n", count);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    ok(count == 1, "Got count %u.\n", count);
     IPin_Release(pins[0]);
 
     hr = IEnumPins_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Clone(enum1, &enum2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Skip(enum1, 2);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Skip(enum1, 1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Skip(enum1, 1);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum1, 1, pins, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum2, 1, pins, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     IPin_Release(pins[0]);
 
     IEnumPins_Release(enum2);
     IEnumPins_Release(enum1);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 static void test_find_pin(void)
@@ -308,19 +308,19 @@ static void test_find_pin(void)
     ULONG ref;
 
     hr = IBaseFilter_EnumPins(filter, &enum_pins);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_FindPin(filter, L"in", &pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IEnumPins_Next(enum_pins, 1, &pin2, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(pin2 == pin, "Expected pin %p, got %p.\n", pin, pin2);
     IPin_Release(pin2);
     IPin_Release(pin);
 
     IEnumPins_Release(enum_pins);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 static void test_pin_info(void)
@@ -334,38 +334,38 @@ static void test_pin_info(void)
     IPin *pin;
 
     hr = IBaseFilter_FindPin(filter, L"in", &pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ref = get_refcount(filter);
-    ok(ref == 2, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 2, "Got unexpected refcount %d.\n", ref);
     ref = get_refcount(pin);
-    ok(ref == 2, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 2, "Got unexpected refcount %d.\n", ref);
 
     hr = IPin_QueryPinInfo(pin, &info);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(info.pFilter == filter, "Expected filter %p, got %p.\n", filter, info.pFilter);
     ok(info.dir == PINDIR_INPUT, "Got direction %d.\n", info.dir);
     ok(!wcscmp(info.achName, L"in"), "Got name %s.\n", wine_dbgstr_w(info.achName));
     ref = get_refcount(filter);
-    ok(ref == 3, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 3, "Got unexpected refcount %d.\n", ref);
     ref = get_refcount(pin);
-    ok(ref == 3, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 3, "Got unexpected refcount %d.\n", ref);
     IBaseFilter_Release(info.pFilter);
 
     hr = IPin_QueryDirection(pin, &dir);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(dir == PINDIR_INPUT, "Got direction %d.\n", dir);
 
     hr = IPin_QueryId(pin, &id);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(!wcscmp(id, L"in"), "Got id %s.\n", wine_dbgstr_w(id));
     CoTaskMemFree(id);
 
     hr = IPin_QueryInternalConnections(pin, NULL, NULL);
-    ok(hr == E_NOTIMPL, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOTIMPL, "Got hr %#x.\n", hr);
 
     IPin_Release(pin);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 static void test_media_types(void)
@@ -381,52 +381,52 @@ static void test_media_types(void)
     IBaseFilter_FindPin(filter, L"in", &pin);
 
     hr = IPin_EnumMediaTypes(pin, &enummt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enummt, 1, &pmt, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     IEnumMediaTypes_Release(enummt);
 
     hr = IPin_QueryAccept(pin, &mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     mt.majortype = MEDIATYPE_Audio;
     mt.subtype = MEDIASUBTYPE_PCM;
     mt.formattype = FORMAT_WaveFormatEx;
     hr = IPin_QueryAccept(pin, &mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     filename = set_filename(filter);
 
     hr = IPin_EnumMediaTypes(pin, &enummt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enummt, 1, &pmt, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     IEnumMediaTypes_Release(enummt);
 
     memset(&mt, 0, sizeof(AM_MEDIA_TYPE));
     hr = IPin_QueryAccept(pin, &mt);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     mt.majortype = MEDIATYPE_Video;
     hr = IPin_QueryAccept(pin, &mt);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     mt.majortype = MEDIATYPE_Audio;
     hr = IPin_QueryAccept(pin, &mt);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     mt.majortype = MEDIATYPE_Stream;
     hr = IPin_QueryAccept(pin, &mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     mt.subtype = MEDIASUBTYPE_PCM;
     mt.formattype = FORMAT_WaveFormatEx;
     hr = IPin_QueryAccept(pin, &mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     IPin_Release(pin);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ok(GetFileAttributesW(filename) == INVALID_FILE_ATTRIBUTES, "File should not exist.\n");
 }
 
@@ -442,36 +442,36 @@ static void test_enum_media_types(void)
     IBaseFilter_FindPin(filter, L"in", &pin);
 
     hr = IPin_EnumMediaTypes(pin, &enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enum1, 1, mts, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enum1, 1, mts, &count);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
-    ok(!count, "Got count %lu.\n", count);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    ok(!count, "Got count %u.\n", count);
 
     hr = IEnumMediaTypes_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enum1, 1, mts, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Clone(enum1, &enum2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Skip(enum1, 1);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enum2, 1, mts, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     IEnumMediaTypes_Release(enum1);
     IEnumMediaTypes_Release(enum2);
     IPin_Release(pin);
 
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 struct testfilter
@@ -533,33 +533,33 @@ static void test_allocator(IMemInputPin *input, IMemAllocator *allocator)
 
     memset(&props, 0xcc, sizeof(props));
     hr = IMemInputPin_GetAllocatorRequirements(input, &props);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
     if (hr == S_OK)
     {
-        ok(!props.cBuffers, "Got %ld buffers.\n", props.cBuffers);
-        ok(!props.cbBuffer, "Got size %ld.\n", props.cbBuffer);
-        ok(props.cbAlign == 512, "Got alignment %ld.\n", props.cbAlign);
-        ok(!props.cbPrefix, "Got prefix %ld.\n", props.cbPrefix);
+        ok(!props.cBuffers, "Got %d buffers.\n", props.cBuffers);
+        ok(!props.cbBuffer, "Got size %d.\n", props.cbBuffer);
+        ok(props.cbAlign == 512, "Got alignment %d.\n", props.cbAlign);
+        ok(!props.cbPrefix, "Got prefix %d.\n", props.cbPrefix);
     }
 
     hr = IMemInputPin_GetAllocator(input, &ret_allocator);
-    todo_wine ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
 
     hr = IMemInputPin_NotifyAllocator(input, NULL, TRUE);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
 
     props.cBuffers = 1;
     props.cbBuffer = 512;
     props.cbAlign = 512;
     props.cbPrefix = 0;
     hr = IMemAllocator_SetProperties(allocator, &props, &ret_props);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMemInputPin_NotifyAllocator(input, allocator, TRUE);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMemInputPin_GetAllocator(input, &ret_allocator);
-    todo_wine ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
     if (hr == S_OK)
         IMemAllocator_Release(ret_allocator);
 }
@@ -570,50 +570,50 @@ static void test_filter_state(IMediaControl *control)
     HRESULT hr;
 
     hr = IMediaControl_GetState(control, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(state == State_Stopped, "Got state %lu.\n", state);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(state == State_Stopped, "Got state %u.\n", state);
 
     hr = IMediaControl_Pause(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_GetState(control, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(state == State_Paused, "Got state %lu.\n", state);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(state == State_Paused, "Got state %u.\n", state);
 
     hr = IMediaControl_Run(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_GetState(control, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(state == State_Running, "Got state %lu.\n", state);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(state == State_Running, "Got state %u.\n", state);
 
     hr = IMediaControl_Pause(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_GetState(control, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(state == State_Paused, "Got state %lu.\n", state);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(state == State_Paused, "Got state %u.\n", state);
 
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_GetState(control, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(state == State_Stopped, "Got state %lu.\n", state);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(state == State_Stopped, "Got state %u.\n", state);
 
     hr = IMediaControl_Run(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_GetState(control, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(state == State_Running, "Got state %lu.\n", state);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(state == State_Running, "Got state %u.\n", state);
 
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_GetState(control, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(state == State_Stopped, "Got state %lu.\n", state);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(state == State_Stopped, "Got state %u.\n", state);
 }
 
 static void test_sample_processing(IMediaControl *control, IMemInputPin *input,
@@ -628,53 +628,53 @@ static void test_sample_processing(IMediaControl *control, IMemInputPin *input,
     LONG size;
 
     hr = IMemInputPin_ReceiveCanBlock(input);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_Pause(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMemAllocator_GetBuffer(allocator, &sample, NULL, NULL, 0);
-    ok(hr == VFW_E_NOT_COMMITTED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_COMMITTED, "Got hr %#x.\n", hr);
 
     hr = IMemAllocator_Commit(allocator);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMemAllocator_GetBuffer(allocator, &sample, NULL, NULL, 0);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaSample_GetPointer(sample, &data);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     size = IMediaSample_GetSize(sample);
-    ok(size == 512, "Got size %ld.\n", size);
+    ok(size == 512, "Got size %d.\n", size);
     memset(data, 0xcc, size);
     start = 0;
     stop = 512;
     hr = IMediaSample_SetTime(sample, &start, &stop);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     strcpy((char *)data, "abcdefghi");
     hr = IMediaSample_SetActualDataLength(sample, 9);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMemInputPin_Receive(input, sample);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     memset(data, 0xcc, size);
     strcpy((char *)data, "123456");
     hr = IMediaSample_SetActualDataLength(sample, 6);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMemInputPin_Receive(input, sample);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     file = _wfopen(filename, L"rb");
     ok(!!file, "Failed to open file: %s.\n", strerror(errno));
     size = fread(buffer, 1, sizeof(buffer), file);
-    ok(size == 512, "Got size %ld.\n", size);
+    ok(size == 512, "Got size %d.\n", size);
     ok(!memcmp(buffer, "123456\0\xcc\xcc\xcc", 10), "Got data %s.\n",
             debugstr_an((char *)buffer, size));
     fclose(file);
 
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     IMediaSample_Release(sample);
 }
 
@@ -689,14 +689,14 @@ static unsigned int check_ec_complete(IMediaEvent *eventsrc, DWORD timeout)
     {
         if (code == EC_COMPLETE)
         {
-            ok(param1 == S_OK, "Got param1 %#Ix.\n", param1);
-            ok(!param2, "Got param2 %#Ix.\n", param2);
+            ok(param1 == S_OK, "Got param1 %#lx.\n", param1);
+            ok(!param2, "Got param2 %#lx.\n", param2);
             ret++;
         }
         IMediaEvent_FreeEventParams(eventsrc, code, param1, param2);
         timeout = 0;
     }
-    ok(hr == E_ABORT, "Got hr %#lx.\n", hr);
+    ok(hr == E_ABORT, "Got hr %#x.\n", hr);
 
     return ret;
 }
@@ -710,22 +710,22 @@ static void test_eos(IFilterGraph2 *graph, IMediaControl *control, IPin *pin)
     IFilterGraph2_QueryInterface(graph, &IID_IMediaEvent, (void **)&eventsrc);
 
     hr = IMediaControl_Pause(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ret = check_ec_complete(eventsrc, 0);
     ok(!ret, "Got unexpected EC_COMPLETE.\n");
 
     hr = IPin_EndOfStream(pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ret = check_ec_complete(eventsrc, 0);
     ok(!ret, "Got unexpected EC_COMPLETE.\n");
 
     hr = IMediaControl_Run(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ret = check_ec_complete(eventsrc, 0);
     ok(ret == 1, "Expected EC_COMPLETE.\n");
 
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     IMediaEvent_Release(eventsrc);
 }
 
@@ -755,47 +755,47 @@ static void test_connect_pin(void)
     CoCreateInstance(&CLSID_FilterGraph, NULL, CLSCTX_INPROC_SERVER, &IID_IFilterGraph2, (void **)&graph);
     IFilterGraph2_QueryInterface(graph, &IID_IMediaControl, (void **)&control);
     hr = IFilterGraph2_AddFilter(graph, filter, L"filewriter");
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     IFilterGraph2_AddFilter(graph, &source.filter.IBaseFilter_iface, L"source");
     IBaseFilter_FindPin(filter, L"in", &pin);
     IPin_QueryInterface(pin, &IID_IMemInputPin, (void **)&meminput);
 
     peer = (IPin *)0xdeadbeef;
     hr = IPin_ConnectedTo(pin, &peer);
-    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#x.\n", hr);
     ok(!peer, "Got peer %p.\n", peer);
 
     hr = IPin_ConnectionMediaType(pin, &mt);
-    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_Pause(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IFilterGraph2_ConnectDirect(graph, &source.source.pin.IPin_iface, pin, &req_mt);
-    ok(hr == VFW_E_NOT_STOPPED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_STOPPED, "Got hr %#x.\n", hr);
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IFilterGraph2_ConnectDirect(graph, &source.source.pin.IPin_iface, pin, &req_mt);
-    ok(hr == VFW_E_TYPE_NOT_ACCEPTED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_TYPE_NOT_ACCEPTED, "Got hr %#x.\n", hr);
     req_mt.majortype = MEDIATYPE_Stream;
     hr = IFilterGraph2_ConnectDirect(graph, &source.source.pin.IPin_iface, pin, &req_mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IPin_ConnectedTo(pin, &peer);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(peer == &source.source.pin.IPin_iface, "Got peer %p.\n", peer);
     IPin_Release(peer);
 
     hr = IPin_ConnectionMediaType(pin, &mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(!memcmp(&mt, &req_mt, sizeof(AM_MEDIA_TYPE)), "Media types didn't match.\n");
 
     hr = IMediaControl_Pause(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IFilterGraph2_Disconnect(graph, pin);
-    ok(hr == VFW_E_NOT_STOPPED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_STOPPED, "Got hr %#x.\n", hr);
     hr = IMediaControl_Stop(control);
-    todo_wine ok(hr == VFW_E_NO_ALLOCATOR, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == VFW_E_NO_ALLOCATOR, "Got hr %#x.\n", hr);
 
     CoCreateInstance(&CLSID_MemoryAllocator, NULL, CLSCTX_INPROC_SERVER,
             &IID_IMemAllocator, (void **)&allocator);
@@ -806,33 +806,33 @@ static void test_connect_pin(void)
     test_eos(graph, control, pin);
 
     hr = IFilterGraph2_Disconnect(graph, pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IFilterGraph2_Disconnect(graph, pin);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     ok(source.source.pin.peer == pin, "Got peer %p.\n", source.source.pin.peer);
     IFilterGraph2_Disconnect(graph, &source.source.pin.IPin_iface);
 
     peer = (IPin *)0xdeadbeef;
     hr = IPin_ConnectedTo(pin, &peer);
-    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#x.\n", hr);
     ok(!peer, "Got peer %p.\n", peer);
 
     hr = IPin_ConnectionMediaType(pin, &mt);
-    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#x.\n", hr);
 
     ret = DeleteFileW(filename);
-    ok(ret, "Failed to delete file, error %lu.\n", GetLastError());
+    ok(ret, "Failed to delete file, error %u.\n", GetLastError());
     IMediaControl_Release(control);
     ref = IFilterGraph2_Release(graph);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     IMemInputPin_Release(meminput);
     IPin_Release(pin);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ref = IMemAllocator_Release(allocator);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ref = IBaseFilter_Release(&source.filter.IBaseFilter_iface);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 static void test_misc_flags(void)
@@ -844,11 +844,11 @@ static void test_misc_flags(void)
     IBaseFilter_QueryInterface(filter, &IID_IAMFilterMiscFlags, (void **)&misc_flags);
 
     flags = IAMFilterMiscFlags_GetMiscFlags(misc_flags);
-    ok(flags == AM_FILTER_MISC_FLAGS_IS_RENDERER, "Got flags %#lx.\n", flags);
+    ok(flags == AM_FILTER_MISC_FLAGS_IS_RENDERER, "Got flags %#x.\n", flags);
 
     IAMFilterMiscFlags_Release(misc_flags);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 START_TEST(filewriter)
diff --git a/dlls/qcap/tests/qcap.c b/dlls/qcap/tests/qcap.c
index a1e3e31bfff..d1b2cb810f4 100644
--- wine/dlls/qcap/tests/qcap.c
+++ wine/dlls/qcap/tests/qcap.c
@@ -499,7 +499,7 @@ static HRESULT WINAPI EnumPins_Next(IEnumPins *iface,
     test_filter *This = impl_from_IEnumPins(iface);
     check_calls_list("EnumPins_Next", ENUMPINS_NEXT, This->filter_type);
 
-    ok(cPins == 1, "cPins = %ld\n", cPins);
+    ok(cPins == 1, "cPins = %d\n", cPins);
     ok(ppPins != NULL, "ppPins == NULL\n");
     ok(pcFetched != NULL, "pcFetched == NULL\n");
 
@@ -601,11 +601,11 @@ static HRESULT WINAPI Pin_ReceiveConnection(IPin *iface,
             wine_dbgstr_guid(&pmt->subtype));
     ok(pmt->bFixedSizeSamples, "bFixedSizeSamples = %x\n", pmt->bFixedSizeSamples);
     ok(!pmt->bTemporalCompression, "bTemporalCompression = %x\n", pmt->bTemporalCompression);
-    ok(pmt->lSampleSize == 1, "lSampleSize = %ld\n", pmt->lSampleSize);
+    ok(pmt->lSampleSize == 1, "lSampleSize = %d\n", pmt->lSampleSize);
     ok(IsEqualIID(&pmt->formattype, &GUID_NULL), "formattype = %s\n",
             wine_dbgstr_guid(&pmt->formattype));
     ok(!pmt->pUnk, "pUnk = %p\n", pmt->pUnk);
-    ok(!pmt->cbFormat, "cbFormat = %ld\n", pmt->cbFormat);
+    ok(!pmt->cbFormat, "cbFormat = %d\n", pmt->cbFormat);
     ok(!pmt->pbFormat, "pbFormat = %p\n", pmt->pbFormat);
     return S_OK;
 }
@@ -758,10 +758,10 @@ static HRESULT WINAPI KsPropertySet_Get(IKsPropertySet *iface, REFGUID guidPropS
     check_calls_list("KsPropertySet_Get", KSPROPERTYSET_GET, This->filter_type);
 
     ok(IsEqualIID(guidPropSet, &AMPROPSETID_Pin), "guidPropSet = %s\n", wine_dbgstr_guid(guidPropSet));
-    ok(dwPropID == 0, "dwPropID = %ld\n", dwPropID);
+    ok(dwPropID == 0, "dwPropID = %d\n", dwPropID);
     ok(pInstanceData == NULL, "pInstanceData != NULL\n");
     ok(cbInstanceData == 0, "cbInstanceData != 0\n");
-    ok(cbPropData == sizeof(GUID), "cbPropData = %ld\n", cbPropData);
+    ok(cbPropData == sizeof(GUID), "cbPropData = %d\n", cbPropData);
     *pcbReturned = sizeof(GUID);
     memcpy(pPropData, &PIN_CATEGORY_EDS, sizeof(GUID));
     return S_OK;
@@ -829,11 +829,11 @@ static HRESULT WINAPI MemInputPin_NotifyAllocator(IMemInputPin *iface,
     ok(bReadOnly, "bReadOnly = %x\n", bReadOnly);
 
     hr = IMemAllocator_GetProperties(pAllocator, &ap);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(ap.cBuffers == 32, "cBuffers = %ld\n", ap.cBuffers);
-    ok(ap.cbBuffer == 0, "cbBuffer = %ld\n", ap.cbBuffer);
-    ok(ap.cbAlign == 1, "cbAlign = %ld\n", ap.cbAlign);
-    ok(ap.cbPrefix == 0, "cbPrefix = %ld\n", ap.cbPrefix);
+    ok(hr == S_OK, "GetProperties returned %x\n", hr);
+    ok(ap.cBuffers == 32, "cBuffers = %d\n", ap.cBuffers);
+    ok(ap.cbBuffer == 0, "cbBuffer = %d\n", ap.cbBuffer);
+    ok(ap.cbAlign == 1, "cbAlign = %d\n", ap.cbAlign);
+    ok(ap.cbPrefix == 0, "cbPrefix = %d\n", ap.cbPrefix);
     return S_OK;
 }
 
@@ -852,9 +852,9 @@ static HRESULT WINAPI MemInputPin_Receive(IMemInputPin *iface, IMediaSample *pSa
     HRESULT hr;
 
     hr = IMediaSample_GetTime(pSample, &off, &tmp);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "got 0x%08x\n", hr);
     hr = IMediaSample_GetPointer(pSample, &data);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "got 0x%08x\n", hr);
     li.QuadPart = off;
     IStream_Seek(avi_stream, li, STREAM_SEEK_SET, NULL);
     IStream_Write(avi_stream, data, IMediaSample_GetActualDataLength(pSample), NULL);
@@ -1069,7 +1069,7 @@ static HRESULT WINAPI EnumMediaTypes_Next(IEnumMediaTypes *iface, ULONG cMediaTy
     test_filter *This = impl_from_IEnumMediaTypes(iface);
     check_calls_list("EnumMediaTypes_Next", ENUMMEDIATYPES_NEXT, This->filter_type);
 
-    ok(cMediaTypes == 1, "cMediaTypes = %ld\n", cMediaTypes);
+    ok(cMediaTypes == 1, "cMediaTypes = %d\n", cMediaTypes);
     ok(ppMediaTypes != NULL, "ppMediaTypes == NULL\n");
     ok(pcFetched != NULL, "pcFetched == NULL\n");
 
@@ -1381,30 +1381,30 @@ static void test_AviMux(char *arg)
 
     hr = CoCreateInstance(&CLSID_AviDest, NULL, CLSCTX_INPROC_SERVER, &IID_IBaseFilter, (void**)&avimux);
     ok(hr == S_OK || broken(hr == REGDB_E_CLASSNOTREG),
-            "Got hr %#lx.\n", hr);
+            "couldn't create AVI Mux filter, hr = %08x\n", hr);
     if(hr != S_OK) {
         win_skip("AVI Mux filter is not registered\n");
         return;
     }
 
     hr = IBaseFilter_EnumPins(avimux, &ep);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "EnumPins returned %x\n", hr);
 
     hr = IEnumPins_Next(ep, 1, &avimux_out, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Next returned %x\n", hr);
     hr = IPin_QueryDirection(avimux_out, &dir);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "QueryDirection returned %x\n", hr);
     ok(dir == PINDIR_OUTPUT, "dir = %d\n", dir);
 
     hr = IEnumPins_Next(ep, 1, &avimux_in, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Next returned %x\n", hr);
     hr = IPin_QueryDirection(avimux_in, &dir);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "QueryDirection returned %x\n", hr);
     ok(dir == PINDIR_INPUT, "dir = %d\n", dir);
     IEnumPins_Release(ep);
 
     hr = IPin_ReceiveConnection(avimux_in, &source_filter.IPin_iface, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "ReceiveConnection returned %x\n", hr);
 
     current_calls_list = NULL;
     memset(&source_media_type, 0, sizeof(AM_MEDIA_TYPE));
@@ -1425,100 +1425,100 @@ static void test_AviMux(char *arg)
     videoinfo.bmiHeader.biSizeImage = 40000;
     videoinfo.bmiHeader.biClrImportant = 256;
     hr = IPin_ReceiveConnection(avimux_in, &source_filter.IPin_iface, &source_media_type);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "ReceiveConnection returned %x\n", hr);
 
     hr = IPin_ConnectedTo(avimux_in, &pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "ConnectedTo returned %x\n", hr);
     ok(pin == &source_filter.IPin_iface, "incorrect pin: %p, expected %p\n",
             pin, &source_filter.IPin_iface);
 
     hr = IPin_Connect(avimux_out, &source_filter.IPin_iface, NULL);
-    ok(hr == VFW_E_INVALID_DIRECTION, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_INVALID_DIRECTION, "Connect returned %x\n", hr);
 
     hr = IBaseFilter_JoinFilterGraph(avimux, (IFilterGraph*)&GraphBuilder, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "JoinFilterGraph returned %x\n", hr);
 
     SET_EXPECT(ReceiveConnection);
     SET_EXPECT(GetAllocatorRequirements);
     SET_EXPECT(NotifyAllocator);
     SET_EXPECT(Reconnect);
     hr = IPin_Connect(avimux_out, &sink_filter.IPin_iface, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Connect returned %x\n", hr);
     CHECK_CALLED(ReceiveConnection);
     CHECK_CALLED(GetAllocatorRequirements);
     CHECK_CALLED(NotifyAllocator);
     CHECK_CALLED(Reconnect);
 
     hr = IPin_ConnectedTo(avimux_out, &pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "ConnectedTo returned %x\n", hr);
     ok(pin == &sink_filter.IPin_iface, "incorrect pin: %p, expected %p\n",
             pin, &source_filter.IPin_iface);
 
     hr = IPin_QueryInterface(avimux_in, &IID_IMemInputPin, (void**)&memin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "QueryInterface returned %x\n", hr);
 
     props.cBuffers = 0xdeadbee1;
     props.cbBuffer = 0xdeadbee2;
     props.cbAlign = 0xdeadbee3;
     props.cbPrefix = 0xdeadbee4;
     hr = IMemInputPin_GetAllocatorRequirements(memin, &props);
-    ok(hr==S_OK || broken(hr==E_INVALIDARG), "Got hr %#lx.\n", hr);
+    ok(hr==S_OK || broken(hr==E_INVALIDARG), "GetAllocatorRequirements returned %x\n", hr);
     if(hr == S_OK) {
-        ok(props.cBuffers == 0xdeadbee1, "cBuffers = %ld\n", props.cBuffers);
-        ok(props.cbBuffer == 0xdeadbee2, "cbBuffer = %ld\n", props.cbBuffer);
-        ok(props.cbAlign == 1, "cbAlign = %ld\n", props.cbAlign);
-        ok(props.cbPrefix == 8, "cbPrefix = %ld\n", props.cbPrefix);
+        ok(props.cBuffers == 0xdeadbee1, "cBuffers = %d\n", props.cBuffers);
+        ok(props.cbBuffer == 0xdeadbee2, "cbBuffer = %d\n", props.cbBuffer);
+        ok(props.cbAlign == 1, "cbAlign = %d\n", props.cbAlign);
+        ok(props.cbPrefix == 8, "cbPrefix = %d\n", props.cbPrefix);
     }
 
     hr = IMemInputPin_GetAllocator(memin, &memalloc);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "GetAllocator returned %x\n", hr);
 
     props.cBuffers = 0xdeadbee1;
     props.cbBuffer = 0xdeadbee2;
     props.cbAlign = 0xdeadbee3;
     props.cbPrefix = 0xdeadbee4;
     hr = IMemAllocator_GetProperties(memalloc, &props);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(props.cBuffers == 0, "cBuffers = %ld\n", props.cBuffers);
-    ok(props.cbBuffer == 0, "cbBuffer = %ld\n", props.cbBuffer);
-    ok(props.cbAlign == 0, "cbAlign = %ld\n", props.cbAlign);
-    ok(props.cbPrefix == 0, "cbPrefix = %ld\n", props.cbPrefix);
+    ok(hr == S_OK, "GetProperties returned %x\n", hr);
+    ok(props.cBuffers == 0, "cBuffers = %d\n", props.cBuffers);
+    ok(props.cbBuffer == 0, "cbBuffer = %d\n", props.cbBuffer);
+    ok(props.cbAlign == 0, "cbAlign = %d\n", props.cbAlign);
+    ok(props.cbPrefix == 0, "cbPrefix = %d\n", props.cbPrefix);
     IMemAllocator_Release(memalloc);
 
     hr = IBaseFilter_QueryInterface(avimux, &IID_IConfigInterleaving, (void**)&ci);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "QueryInterface(IID_IConfigInterleaving) returned %x\n", hr);
     hr = IConfigInterleaving_put_Mode(ci, 5);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "put_Mode returned %x\n", hr);
     SET_EXPECT(Reconnect);
     hr = IConfigInterleaving_put_Mode(ci, INTERLEAVE_FULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "put_Mode returned %x\n", hr);
     CHECK_CALLED(Reconnect);
     IConfigInterleaving_Release(ci);
 
     hr = IBaseFilter_GetState(avimux, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "GetState returned %x\n", hr);
     ok(state == State_Stopped, "state = %d\n", state);
 
     SET_EXPECT(MemAllocator_GetProperties);
     hr = IMemInputPin_NotifyAllocator(memin, &MemAllocator, TRUE);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "NotifyAllocator returned %x\n", hr);
     CHECK_CALLED(MemAllocator_GetProperties);
 
     hr = IMemInputPin_GetAllocator(memin, &memalloc);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "GetAllocator returned %x\n", hr);
     ok(memalloc != &MemAllocator, "memalloc == &MemAllocator\n");
     IMemAllocator_Release(memalloc);
 
     hr = CreateStreamOnHGlobal(NULL, TRUE, &avi_stream);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "got 0x%08x\n", hr);
     SET_EXPECT(MediaSeeking_GetPositions);
     SET_EXPECT(MemInputPin_QueryInterface_IStream);
     hr = IBaseFilter_Run(avimux, 0);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Run returned %x\n", hr);
     CHECK_CALLED(MediaSeeking_GetPositions);
 
     hr = IBaseFilter_GetState(avimux, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "GetState returned %x\n", hr);
     ok(state == State_Running, "state = %d\n", state);
 
     SET_EXPECT(MediaSample_QueryInterface_MediaSample2);
@@ -1533,7 +1533,7 @@ static void test_AviMux(char *arg)
     SET_EXPECT(MediaSample_GetMediaTime);
     start_time = end_time = 0;
     hr = IMemInputPin_Receive(memin, &MediaSample);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Receive returned %x\n", hr);
     CHECK_CALLED(MediaSample_QueryInterface_MediaSample2);
     todo_wine CHECK_CALLED(MediaSample_IsDiscontinuity);
     todo_wine CHECK_CALLED(MediaSample_IsPreroll);
@@ -1556,7 +1556,7 @@ static void test_AviMux(char *arg)
     SET_EXPECT(MediaSample_GetSize);
     SET_EXPECT(MediaSample_GetMediaTime);
     hr = IMemInputPin_Receive(memin, &MediaSample);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Receive returned %x\n", hr);
     CHECK_CALLED(MediaSample_QueryInterface_MediaSample2);
     todo_wine CHECK_CALLED(MediaSample_IsDiscontinuity);
     todo_wine CHECK_CALLED(MediaSample_IsPreroll);
@@ -1581,7 +1581,7 @@ static void test_AviMux(char *arg)
     start_time = 20000000;
     end_time = 21000000;
     hr = IMemInputPin_Receive(memin, &MediaSample);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Receive returned %x\n", hr);
     CHECK_CALLED(MediaSample_QueryInterface_MediaSample2);
     todo_wine CHECK_CALLED(MediaSample_IsDiscontinuity);
     todo_wine CHECK_CALLED(MediaSample_IsPreroll);
@@ -1595,20 +1595,20 @@ static void test_AviMux(char *arg)
     IMemInputPin_Release(memin);
 
     hr = IBaseFilter_Stop(avimux);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Stop returned %x\n", hr);
     CHECK_CALLED(MemInputPin_QueryInterface_IStream);
 
     hr = IBaseFilter_GetState(avimux, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "GetState returned %x\n", hr);
     ok(state == State_Stopped, "state = %d\n", state);
 
     hr = IPin_Disconnect(avimux_out);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Disconnect returned %x\n", hr);
 
     IPin_Release(avimux_in);
     IPin_Release(avimux_out);
     ref = IBaseFilter_Release(avimux);
-    ok(ref == 0, "Avi Mux filter was not destroyed (%ld)\n", ref);
+    ok(ref == 0, "Avi Mux filter was not destroyed (%d)\n", ref);
 
     if(arg && !strcmp(arg, "save")) {
         LARGE_INTEGER li;
@@ -1622,12 +1622,12 @@ static void test_AviMux(char *arg)
 
         li.QuadPart = 0;
         hr = IStream_Seek(avi_stream, li, STREAM_SEEK_SET, NULL);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "IStream_Seek failed: %x\n", hr);
 
         while(1) {
             hr = IStream_Read(avi_stream, buf, sizeof(buf), &read);
             if(FAILED(hr)) {
-                ok(0, "Got hr %#lx.\n", hr);
+                ok(0, "IStream_Read failed: %x\n", hr);
                 break;
             }
             if(!read)
@@ -1640,7 +1640,7 @@ static void test_AviMux(char *arg)
     }
 
     ref = IStream_Release(avi_stream);
-    ok(ref == 0, "IStream was not destroyed (%ld)\n", ref);
+    ok(ref == 0, "IStream was not destroyed (%d)\n", ref);
 }
 
 START_TEST(qcap)
diff --git a/dlls/qcap/tests/smartteefilter.c b/dlls/qcap/tests/smartteefilter.c
index a25889d2a4d..b6ba3ca75c9 100644
--- wine/dlls/qcap/tests/smartteefilter.c
+++ wine/dlls/qcap/tests/smartteefilter.c
@@ -30,7 +30,7 @@ static IBaseFilter *create_smart_tee(void)
     IBaseFilter *filter = NULL;
     HRESULT hr = CoCreateInstance(&CLSID_SmartTee, NULL, CLSCTX_INPROC_SERVER,
             &IID_IBaseFilter, (void **)&filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     return filter;
 }
 
@@ -57,7 +57,7 @@ static void check_interface_(unsigned int line, void *iface_ptr, REFIID iid, BOO
     expected_hr = supported ? S_OK : E_NOINTERFACE;
 
     hr = IUnknown_QueryInterface(iface, iid, (void **)&unk);
-    ok_(__FILE__, line)(hr == expected_hr, "Got hr %#lx, expected %#lx.\n", hr, expected_hr);
+    ok_(__FILE__, line)(hr == expected_hr, "Got hr %#x, expected %#x.\n", hr, expected_hr);
     if (SUCCEEDED(hr))
         IUnknown_Release(unk);
 }
@@ -135,7 +135,7 @@ static void test_interfaces(void)
     IPin_Release(pin);
 
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got unexpected refcount %ld.\n", ref);
+    ok(!ref, "Got unexpected refcount %d.\n", ref);
 }
 
 static const GUID test_iid = {0x33333333};
@@ -183,53 +183,53 @@ static void test_aggregation(void)
     filter = (IBaseFilter *)0xdeadbeef;
     hr = CoCreateInstance(&CLSID_SmartTee, &test_outer, CLSCTX_INPROC_SERVER,
             &IID_IBaseFilter, (void **)&filter);
-    ok(hr == E_NOINTERFACE, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOINTERFACE, "Got hr %#x.\n", hr);
     ok(!filter, "Got interface %p.\n", filter);
 
     hr = CoCreateInstance(&CLSID_SmartTee, &test_outer, CLSCTX_INPROC_SERVER,
             &IID_IUnknown, (void **)&unk);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(outer_ref == 1, "Got unexpected refcount %ld.\n", outer_ref);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
     ok(unk != &test_outer, "Returned IUnknown should not be outer IUnknown.\n");
     ref = get_refcount(unk);
-    ok(ref == 1, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
 
     ref = IUnknown_AddRef(unk);
-    ok(ref == 2, "Got unexpected refcount %ld.\n", ref);
-    ok(outer_ref == 1, "Got unexpected refcount %ld.\n", outer_ref);
+    ok(ref == 2, "Got unexpected refcount %d.\n", ref);
+    ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
 
     ref = IUnknown_Release(unk);
-    ok(ref == 1, "Got unexpected refcount %ld.\n", ref);
-    ok(outer_ref == 1, "Got unexpected refcount %ld.\n", outer_ref);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
+    ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
 
     hr = IUnknown_QueryInterface(unk, &IID_IUnknown, (void **)&unk2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(unk2 == unk, "Got unexpected IUnknown %p.\n", unk2);
     IUnknown_Release(unk2);
 
     hr = IUnknown_QueryInterface(unk, &IID_IBaseFilter, (void **)&filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_QueryInterface(filter, &IID_IUnknown, (void **)&unk2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(unk2 == (IUnknown *)0xdeadbeef, "Got unexpected IUnknown %p.\n", unk2);
 
     hr = IBaseFilter_QueryInterface(filter, &IID_IBaseFilter, (void **)&filter2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(filter2 == (IBaseFilter *)0xdeadbeef, "Got unexpected IBaseFilter %p.\n", filter2);
 
     hr = IUnknown_QueryInterface(unk, &test_iid, (void **)&unk2);
-    ok(hr == E_NOINTERFACE, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOINTERFACE, "Got hr %#x.\n", hr);
     ok(!unk2, "Got unexpected IUnknown %p.\n", unk2);
 
     hr = IBaseFilter_QueryInterface(filter, &test_iid, (void **)&unk2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(unk2 == (IUnknown *)0xdeadbeef, "Got unexpected IUnknown %p.\n", unk2);
 
     IBaseFilter_Release(filter);
     ref = IUnknown_Release(unk);
-    ok(!ref, "Got unexpected refcount %ld.\n", ref);
-    ok(outer_ref == 1, "Got unexpected refcount %ld.\n", outer_ref);
+    ok(!ref, "Got unexpected refcount %d.\n", ref);
+    ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
 }
 
 static void test_enum_pins(void)
@@ -241,135 +241,135 @@ static void test_enum_pins(void)
     HRESULT hr;
 
     ref = get_refcount(filter);
-    ok(ref == 1, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
 
     hr = IBaseFilter_EnumPins(filter, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_EnumPins(filter, &enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ref = get_refcount(filter);
-    ok(ref == 2, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 2, "Got unexpected refcount %d.\n", ref);
     ref = get_refcount(enum1);
-    ok(ref == 1, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
 
     hr = IEnumPins_Next(enum1, 1, NULL, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum1, 1, pins, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ref = get_refcount(filter);
-    ok(ref == 3, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 3, "Got unexpected refcount %d.\n", ref);
     ref = get_refcount(pins[0]);
-    ok(ref == 3, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 3, "Got unexpected refcount %d.\n", ref);
     ref = get_refcount(enum1);
-    ok(ref == 1, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
     IPin_Release(pins[0]);
     ref = get_refcount(filter);
-    ok(ref == 2, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 2, "Got unexpected refcount %d.\n", ref);
 
     hr = IEnumPins_Next(enum1, 1, pins, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ref = get_refcount(filter);
-    ok(ref == 3, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 3, "Got unexpected refcount %d.\n", ref);
     ref = get_refcount(pins[0]);
-    ok(ref == 3, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 3, "Got unexpected refcount %d.\n", ref);
     ref = get_refcount(enum1);
-    ok(ref == 1, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
     IPin_Release(pins[0]);
     ref = get_refcount(filter);
-    ok(ref == 2, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 2, "Got unexpected refcount %d.\n", ref);
 
     hr = IEnumPins_Next(enum1, 1, pins, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ref = get_refcount(filter);
-    ok(ref == 3, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 3, "Got unexpected refcount %d.\n", ref);
     ref = get_refcount(pins[0]);
-    ok(ref == 3, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 3, "Got unexpected refcount %d.\n", ref);
     ref = get_refcount(enum1);
-    ok(ref == 1, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
     IPin_Release(pins[0]);
     ref = get_refcount(filter);
-    ok(ref == 2, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 2, "Got unexpected refcount %d.\n", ref);
 
     hr = IEnumPins_Next(enum1, 1, pins, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum1, 1, pins, &count);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(count == 1, "Got count %lu.\n", count);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(count == 1, "Got count %u.\n", count);
     IPin_Release(pins[0]);
 
     hr = IEnumPins_Next(enum1, 1, pins, &count);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(count == 1, "Got count %lu.\n", count);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(count == 1, "Got count %u.\n", count);
     IPin_Release(pins[0]);
 
     hr = IEnumPins_Next(enum1, 1, pins, &count);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(count == 1, "Got count %lu.\n", count);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(count == 1, "Got count %u.\n", count);
     IPin_Release(pins[0]);
 
     hr = IEnumPins_Next(enum1, 1, pins, &count);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
-    ok(!count, "Got count %lu.\n", count);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    ok(!count, "Got count %u.\n", count);
 
     hr = IEnumPins_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum1, 2, pins, NULL);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum1, 2, pins, &count);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(count == 2, "Got count %lu.\n", count);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(count == 2, "Got count %u.\n", count);
     IPin_Release(pins[0]);
     IPin_Release(pins[1]);
 
     hr = IEnumPins_Next(enum1, 2, pins, &count);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
-    ok(count == 1, "Got count %lu.\n", count);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    ok(count == 1, "Got count %u.\n", count);
     IPin_Release(pins[0]);
 
     hr = IEnumPins_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum1, 4, pins, &count);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
-    ok(count == 3, "Got count %lu.\n", count);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    ok(count == 3, "Got count %u.\n", count);
     IPin_Release(pins[0]);
     IPin_Release(pins[1]);
     IPin_Release(pins[2]);
 
     hr = IEnumPins_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Clone(enum1, &enum2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Skip(enum1, 4);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Skip(enum1, 3);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Skip(enum1, 1);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum1, 1, pins, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum2, 1, pins, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     IPin_Release(pins[0]);
 
     IEnumPins_Release(enum2);
     IEnumPins_Release(enum1);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 static void test_find_pin(void)
@@ -381,35 +381,35 @@ static void test_find_pin(void)
     ULONG ref;
 
     hr = IBaseFilter_EnumPins(filter, &enum_pins);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_FindPin(filter, L"Input", &pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IEnumPins_Next(enum_pins, 1, &pin2, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(pin2 == pin, "Expected pin %p, got %p.\n", pin, pin2);
     IPin_Release(pin2);
     IPin_Release(pin);
 
     hr = IBaseFilter_FindPin(filter, L"Capture", &pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IEnumPins_Next(enum_pins, 1, &pin2, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(pin2 == pin, "Expected pin %p, got %p.\n", pin, pin2);
     IPin_Release(pin2);
     IPin_Release(pin);
 
     hr = IBaseFilter_FindPin(filter, L"Preview", &pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IEnumPins_Next(enum_pins, 1, &pin2, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(pin2 == pin, "Expected pin %p, got %p.\n", pin, pin2);
     IPin_Release(pin2);
     IPin_Release(pin);
 
     IEnumPins_Release(enum_pins);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 static void test_pin_info(void)
@@ -424,95 +424,95 @@ static void test_pin_info(void)
     IPin *pin;
 
     hr = IBaseFilter_FindPin(filter, L"Input", &pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ref = get_refcount(filter);
-    ok(ref == 2, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 2, "Got unexpected refcount %d.\n", ref);
     ref = get_refcount(pin);
-    ok(ref == 2, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 2, "Got unexpected refcount %d.\n", ref);
 
     hr = IPin_QueryPinInfo(pin, &info);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(info.pFilter == filter, "Expected filter %p, got %p.\n", filter, info.pFilter);
     ok(info.dir == PINDIR_INPUT, "Got direction %d.\n", info.dir);
     ok(!lstrcmpW(info.achName, L"Input"), "Got name %s.\n", wine_dbgstr_w(info.achName));
     ref = get_refcount(filter);
-    ok(ref == 3, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 3, "Got unexpected refcount %d.\n", ref);
     ref = get_refcount(pin);
-    ok(ref == 3, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 3, "Got unexpected refcount %d.\n", ref);
     IBaseFilter_Release(info.pFilter);
 
     hr = IPin_QueryDirection(pin, &dir);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(dir == PINDIR_INPUT, "Got direction %d.\n", dir);
 
     hr = IPin_QueryId(pin, &id);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(!lstrcmpW(id, L"Input"), "Got id %s.\n", wine_dbgstr_w(id));
     CoTaskMemFree(id);
 
     hr = IPin_QueryInternalConnections(pin, NULL, &count);
-    ok(hr == E_NOTIMPL, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOTIMPL, "Got hr %#x.\n", hr);
 
     IPin_Release(pin);
 
     hr = IBaseFilter_FindPin(filter, L"Capture", &pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IPin_QueryPinInfo(pin, &info);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(info.pFilter == filter, "Expected filter %p, got %p.\n", filter, info.pFilter);
     ok(info.dir == PINDIR_OUTPUT, "Got direction %d.\n", info.dir);
     ok(!lstrcmpW(info.achName, L"Capture"), "Got name %s.\n", wine_dbgstr_w(info.achName));
     ref = get_refcount(filter);
-    ok(ref == 3, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 3, "Got unexpected refcount %d.\n", ref);
     ref = get_refcount(pin);
-    ok(ref == 3, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 3, "Got unexpected refcount %d.\n", ref);
     IBaseFilter_Release(info.pFilter);
 
     hr = IPin_QueryDirection(pin, &dir);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(dir == PINDIR_OUTPUT, "Got direction %d.\n", dir);
 
     hr = IPin_QueryId(pin, &id);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(!lstrcmpW(id, L"Capture"), "Got id %s.\n", wine_dbgstr_w(id));
     CoTaskMemFree(id);
 
     hr = IPin_QueryInternalConnections(pin, NULL, &count);
-    ok(hr == E_NOTIMPL, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOTIMPL, "Got hr %#x.\n", hr);
 
     IPin_Release(pin);
 
     hr = IBaseFilter_FindPin(filter, L"Preview", &pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IPin_QueryPinInfo(pin, &info);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(info.pFilter == filter, "Expected filter %p, got %p.\n", filter, info.pFilter);
     ok(info.dir == PINDIR_OUTPUT, "Got direction %d.\n", info.dir);
     ok(!lstrcmpW(info.achName, L"Preview"), "Got name %s.\n", wine_dbgstr_w(info.achName));
     ref = get_refcount(filter);
-    ok(ref == 3, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 3, "Got unexpected refcount %d.\n", ref);
     ref = get_refcount(pin);
-    ok(ref == 3, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 3, "Got unexpected refcount %d.\n", ref);
     IBaseFilter_Release(info.pFilter);
 
     hr = IPin_QueryDirection(pin, &dir);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(dir == PINDIR_OUTPUT, "Got direction %d.\n", dir);
 
     hr = IPin_QueryId(pin, &id);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(!lstrcmpW(id, L"Preview"), "Got id %s.\n", wine_dbgstr_w(id));
     CoTaskMemFree(id);
 
     hr = IPin_QueryInternalConnections(pin, NULL, &count);
-    ok(hr == E_NOTIMPL, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOTIMPL, "Got hr %#x.\n", hr);
 
     IPin_Release(pin);
 
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 static void test_enum_media_types(void)
@@ -527,36 +527,36 @@ static void test_enum_media_types(void)
     IBaseFilter_FindPin(filter, L"Input", &pin);
 
     hr = IPin_EnumMediaTypes(pin, &enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enum1, 1, mts, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enum1, 1, mts, &count);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
-    ok(!count, "Got count %lu.\n", count);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    ok(!count, "Got count %u.\n", count);
 
     hr = IEnumMediaTypes_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enum1, 1, mts, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Clone(enum1, &enum2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Skip(enum1, 1);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enum2, 1, mts, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     IEnumMediaTypes_Release(enum1);
     IEnumMediaTypes_Release(enum2);
     IPin_Release(pin);
 
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 static void test_unconnected_filter_state(void)
@@ -567,53 +567,53 @@ static void test_unconnected_filter_state(void)
     ULONG ref;
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(state == State_Stopped, "Got state %u.\n", state);
 
     hr = IBaseFilter_Pause(filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == VFW_S_CANT_CUE, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_S_CANT_CUE, "Got hr %#x.\n", hr);
     ok(state == State_Paused, "Got state %u.\n", state);
 
     hr = IBaseFilter_Run(filter, 0);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(state == State_Running, "Got state %u.\n", state);
 
     hr = IBaseFilter_Pause(filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == VFW_S_CANT_CUE, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_S_CANT_CUE, "Got hr %#x.\n", hr);
     ok(state == State_Paused, "Got state %u.\n", state);
 
     hr = IBaseFilter_Stop(filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(state == State_Stopped, "Got state %u.\n", state);
 
     hr = IBaseFilter_Run(filter, 0);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(state == State_Running, "Got state %u.\n", state);
 
     hr = IBaseFilter_Stop(filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(state == State_Stopped, "Got state %u.\n", state);
 
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 struct testfilter
@@ -688,28 +688,28 @@ static void test_sink_allocator(IPin *pin)
     IPin_QueryInterface(pin, &IID_IMemInputPin, (void **)&input);
 
     hr = IMemInputPin_GetAllocatorRequirements(input, &ret_props);
-    ok(hr == E_NOTIMPL, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOTIMPL, "Got hr %#x.\n", hr);
 
     hr = IMemInputPin_GetAllocator(input, &ret_allocator);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMemInputPin_NotifyAllocator(input, ret_allocator, TRUE);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     IMemAllocator_Release(ret_allocator);
 
     CoCreateInstance(&CLSID_MemoryAllocator, NULL, CLSCTX_INPROC_SERVER,
             &IID_IMemAllocator, (void **)&req_allocator);
 
     hr = IMemInputPin_NotifyAllocator(input, req_allocator, TRUE);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMemInputPin_GetAllocator(input, &ret_allocator);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(ret_allocator == req_allocator, "Allocators didn't match.\n");
     IMemAllocator_Release(ret_allocator);
 
     hr = IMemAllocator_SetProperties(req_allocator, &req_props, &ret_props);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     IMemAllocator_Release(req_allocator);
     IMemInputPin_Release(input);
@@ -726,7 +726,7 @@ static HRESULT WINAPI testsource_AttemptConnection(struct strmbase_source *iface
 
     if (FAILED(hr = IPin_ReceiveConnection(peer, &iface->pin.IPin_iface, mt)))
     {
-        ok(hr == VFW_E_TYPE_NOT_ACCEPTED, "Got hr %#lx.\n", hr);
+        ok(hr == VFW_E_TYPE_NOT_ACCEPTED, "Got hr %#x.\n", hr);
         IPin_Release(peer);
         iface->pin.peer = NULL;
         FreeMediaType(&iface->pin.mt);
@@ -785,12 +785,12 @@ static HRESULT WINAPI testsink_Receive(struct strmbase_sink *iface, IMediaSample
     HRESULT hr;
 
     size = IMediaSample_GetSize(sample);
-    ok(size == 256, "Got size %lu.\n", size);
+    ok(size == 256, "Got size %u.\n", size);
     size = IMediaSample_GetActualDataLength(sample);
-    ok(size == 200, "Got valid size %lu.\n", size);
+    ok(size == 200, "Got valid size %u.\n", size);
 
     hr = IMediaSample_GetPointer(sample, &data);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     for (i = 0; i < size; ++i)
         expect[i] = i;
     ok(!memcmp(data, expect, size), "Data didn't match.\n");
@@ -798,11 +798,11 @@ static HRESULT WINAPI testsink_Receive(struct strmbase_sink *iface, IMediaSample
     hr = IMediaSample_GetTime(sample, &start, &stop);
     if (filter->preview)
     {
-        ok(hr == VFW_E_SAMPLE_TIME_NOT_SET, "Got hr %#lx.\n", hr);
+        ok(hr == VFW_E_SAMPLE_TIME_NOT_SET, "Got hr %#x.\n", hr);
     }
     else
     {
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
         ok(start == 30000, "Got start time %s.\n", wine_dbgstr_longlong(start));
         ok(stop == 40000, "Got stop time %s.\n", wine_dbgstr_longlong(stop));
     }
@@ -810,21 +810,21 @@ static HRESULT WINAPI testsink_Receive(struct strmbase_sink *iface, IMediaSample
     hr = IMediaSample_GetMediaTime(sample, &start, &stop);
     if (filter->preview)
     {
-        todo_wine ok(hr == VFW_E_MEDIA_TIME_NOT_SET, "Got hr %#lx.\n", hr);
+        todo_wine ok(hr == VFW_E_MEDIA_TIME_NOT_SET, "Got hr %#x.\n", hr);
     }
     else
     {
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
         ok(start == 10000, "Got start time %s.\n", wine_dbgstr_longlong(start));
         ok(stop == 20000, "Got stop time %s.\n", wine_dbgstr_longlong(stop));
     }
 
     hr = IMediaSample_IsDiscontinuity(sample);
-    todo_wine_if (filter->preview) ok(hr == filter->preview ? S_FALSE : S_OK, "Got hr %#lx.\n", hr);
+    todo_wine_if (filter->preview) ok(hr == filter->preview ? S_FALSE : S_OK, "Got hr %#x.\n", hr);
     hr = IMediaSample_IsPreroll(sample);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMediaSample_IsSyncPoint(sample);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     SetEvent(filter->sample_event);
 
@@ -895,10 +895,10 @@ static void test_source_media_types(AM_MEDIA_TYPE req_mt, const AM_MEDIA_TYPE *s
     HRESULT hr;
 
     hr = IPin_EnumMediaTypes(source, &enummt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IEnumMediaTypes_Next(enummt, 3, mts, &count);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
-    todo_wine ok(count == 2, "Got %lu types.\n", count);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    todo_wine ok(count == 2, "Got %u types.\n", count);
     ok(compare_media_types(mts[0], &req_mt), "Media types didn't match.\n");
     if (count > 1)
         ok(compare_media_types(mts[1], source_mt), "Media types didn't match.\n");
@@ -908,42 +908,42 @@ static void test_source_media_types(AM_MEDIA_TYPE req_mt, const AM_MEDIA_TYPE *s
     IEnumMediaTypes_Release(enummt);
 
     hr = IPin_QueryAccept(source, &req_mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     req_mt.lSampleSize = 2;
     req_mt.bFixedSizeSamples = TRUE;
     hr = IPin_QueryAccept(source, &req_mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     req_mt.cbFormat = sizeof(count);
     req_mt.pbFormat = (BYTE *)&count;
     hr = IPin_QueryAccept(source, &req_mt);
-    todo_wine ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     req_mt.cbFormat = 0;
     req_mt.pbFormat = NULL;
 
     req_mt.majortype = MEDIATYPE_Audio;
     hr = IPin_QueryAccept(source, &req_mt);
-    todo_wine ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     req_mt.majortype = GUID_NULL;
     hr = IPin_QueryAccept(source, &req_mt);
-    todo_wine ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     req_mt.majortype = MEDIATYPE_Stream;
 
     req_mt.subtype = MEDIASUBTYPE_PCM;
     hr = IPin_QueryAccept(source, &req_mt);
-    todo_wine ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     req_mt.subtype = GUID_NULL;
     hr = IPin_QueryAccept(source, &req_mt);
-    todo_wine ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     req_mt.subtype = MEDIASUBTYPE_Avi;
 
     req_mt.formattype = FORMAT_WaveFormatEx;
     hr = IPin_QueryAccept(source, &req_mt);
-    todo_wine ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     req_mt.formattype = GUID_NULL;
     hr = IPin_QueryAccept(source, &req_mt);
-    todo_wine ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     req_mt.formattype = FORMAT_None;
 
     req_mt.majortype = MEDIATYPE_Audio;
@@ -953,7 +953,7 @@ static void test_source_media_types(AM_MEDIA_TYPE req_mt, const AM_MEDIA_TYPE *s
     req_mt.pbFormat = (BYTE *)&count;
     req_mt.bTemporalCompression = TRUE;
     hr = IPin_QueryAccept(source, &req_mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 }
 
 static void test_source_connection(AM_MEDIA_TYPE req_mt, IFilterGraph2 *graph,
@@ -966,51 +966,51 @@ static void test_source_connection(AM_MEDIA_TYPE req_mt, IFilterGraph2 *graph,
 
     peer = (IPin *)0xdeadbeef;
     hr = IPin_ConnectedTo(source, &peer);
-    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#x.\n", hr);
     ok(!peer, "Got peer %p.\n", peer);
 
     hr = IPin_ConnectionMediaType(source, &mt);
-    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#x.\n", hr);
 
     /* Exact connection. */
 
     hr = IMediaControl_Pause(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IFilterGraph2_ConnectDirect(graph, source, &testsink->sink.pin.IPin_iface, &req_mt);
-    ok(hr == VFW_E_NOT_STOPPED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_STOPPED, "Got hr %#x.\n", hr);
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IFilterGraph2_ConnectDirect(graph, source, &testsink->sink.pin.IPin_iface, &req_mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IPin_ConnectedTo(source, &peer);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(peer == &testsink->sink.pin.IPin_iface, "Got peer %p.\n", peer);
     IPin_Release(peer);
 
     hr = IPin_ConnectionMediaType(source, &mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(compare_media_types(&mt, &req_mt), "Media types didn't match.\n");
     ok(compare_media_types(&testsink->sink.pin.mt, &req_mt), "Media types didn't match.\n");
 
     hr = IMediaControl_Pause(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IFilterGraph2_Disconnect(graph, source);
-    ok(hr == VFW_E_NOT_STOPPED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_STOPPED, "Got hr %#x.\n", hr);
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IFilterGraph2_Disconnect(graph, source);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IFilterGraph2_Disconnect(graph, source);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     ok(testsink->sink.pin.peer == source, "Got peer %p.\n", testsink->sink.pin.peer);
     IFilterGraph2_Disconnect(graph, &testsink->sink.pin.IPin_iface);
 
     req_mt.subtype = GUID_NULL;
     hr = IFilterGraph2_ConnectDirect(graph, source, &testsink->sink.pin.IPin_iface, &req_mt);
-    todo_wine ok(hr == VFW_E_TYPE_NOT_ACCEPTED, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == VFW_E_TYPE_NOT_ACCEPTED, "Got hr %#x.\n", hr);
     if (hr == S_OK)
     {
         IFilterGraph2_Disconnect(graph, source);
@@ -1020,7 +1020,7 @@ static void test_source_connection(AM_MEDIA_TYPE req_mt, IFilterGraph2 *graph,
 
     req_mt.majortype = MEDIATYPE_Audio;
     hr = IFilterGraph2_ConnectDirect(graph, source, &testsink->sink.pin.IPin_iface, &req_mt);
-    todo_wine ok(hr == VFW_E_TYPE_NOT_ACCEPTED, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == VFW_E_TYPE_NOT_ACCEPTED, "Got hr %#x.\n", hr);
     if (hr == S_OK)
     {
         IFilterGraph2_Disconnect(graph, source);
@@ -1030,61 +1030,61 @@ static void test_source_connection(AM_MEDIA_TYPE req_mt, IFilterGraph2 *graph,
     /* Connection with wildcards. */
 
     hr = IFilterGraph2_ConnectDirect(graph, source, &testsink->sink.pin.IPin_iface, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(compare_media_types(&testsink->sink.pin.mt, &sink_mt), "Media types didn't match.\n");
     IFilterGraph2_Disconnect(graph, source);
     IFilterGraph2_Disconnect(graph, &testsink->sink.pin.IPin_iface);
 
     req_mt.majortype = GUID_NULL;
     hr = IFilterGraph2_ConnectDirect(graph, source, &testsink->sink.pin.IPin_iface, &req_mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(compare_media_types(&testsink->sink.pin.mt, &sink_mt), "Media types didn't match.\n");
     IFilterGraph2_Disconnect(graph, source);
     IFilterGraph2_Disconnect(graph, &testsink->sink.pin.IPin_iface);
 
     req_mt.subtype = MEDIASUBTYPE_RGB32;
     hr = IFilterGraph2_ConnectDirect(graph, source, &testsink->sink.pin.IPin_iface, &req_mt);
-    ok(hr == VFW_E_NO_ACCEPTABLE_TYPES, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NO_ACCEPTABLE_TYPES, "Got hr %#x.\n", hr);
 
     req_mt.subtype = GUID_NULL;
     hr = IFilterGraph2_ConnectDirect(graph, source, &testsink->sink.pin.IPin_iface, &req_mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(compare_media_types(&testsink->sink.pin.mt, &sink_mt), "Media types didn't match.\n");
     IFilterGraph2_Disconnect(graph, source);
     IFilterGraph2_Disconnect(graph, &testsink->sink.pin.IPin_iface);
 
     req_mt.formattype = FORMAT_WaveFormatEx;
     hr = IFilterGraph2_ConnectDirect(graph, source, &testsink->sink.pin.IPin_iface, &req_mt);
-    ok(hr == VFW_E_NO_ACCEPTABLE_TYPES, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NO_ACCEPTABLE_TYPES, "Got hr %#x.\n", hr);
 
     req_mt = sink_mt;
     req_mt.formattype = GUID_NULL;
     hr = IFilterGraph2_ConnectDirect(graph, source, &testsink->sink.pin.IPin_iface, &req_mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(compare_media_types(&testsink->sink.pin.mt, &sink_mt), "Media types didn't match.\n");
     IFilterGraph2_Disconnect(graph, source);
     IFilterGraph2_Disconnect(graph, &testsink->sink.pin.IPin_iface);
 
     req_mt.subtype = MEDIASUBTYPE_RGB32;
     hr = IFilterGraph2_ConnectDirect(graph, source, &testsink->sink.pin.IPin_iface, &req_mt);
-    ok(hr == VFW_E_NO_ACCEPTABLE_TYPES, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NO_ACCEPTABLE_TYPES, "Got hr %#x.\n", hr);
 
     req_mt.subtype = GUID_NULL;
     hr = IFilterGraph2_ConnectDirect(graph, source, &testsink->sink.pin.IPin_iface, &req_mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(compare_media_types(&testsink->sink.pin.mt, &sink_mt), "Media types didn't match.\n");
     IFilterGraph2_Disconnect(graph, source);
     IFilterGraph2_Disconnect(graph, &testsink->sink.pin.IPin_iface);
 
     req_mt.majortype = MEDIATYPE_Audio;
     hr = IFilterGraph2_ConnectDirect(graph, source, &testsink->sink.pin.IPin_iface, &req_mt);
-    ok(hr == VFW_E_NO_ACCEPTABLE_TYPES, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NO_ACCEPTABLE_TYPES, "Got hr %#x.\n", hr);
 
     /* Test enumeration of sink media types. */
 
     testsink->sink_mt = &req_mt;
     hr = IFilterGraph2_ConnectDirect(graph, source, &testsink->sink.pin.IPin_iface, NULL);
-    todo_wine ok(hr == VFW_E_NO_ACCEPTABLE_TYPES, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == VFW_E_NO_ACCEPTABLE_TYPES, "Got hr %#x.\n", hr);
     if (hr == S_OK)
     {
         IFilterGraph2_Disconnect(graph, source);
@@ -1094,7 +1094,7 @@ static void test_source_connection(AM_MEDIA_TYPE req_mt, IFilterGraph2 *graph,
     req_mt = sink_mt;
     req_mt.lSampleSize = 3;
     hr = IFilterGraph2_ConnectDirect(graph, source, &testsink->sink.pin.IPin_iface, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(compare_media_types(&testsink->sink.pin.mt, &req_mt), "Media types didn't match.\n");
     IFilterGraph2_Disconnect(graph, source);
     IFilterGraph2_Disconnect(graph, &testsink->sink.pin.IPin_iface);
@@ -1138,56 +1138,56 @@ static void test_connect_pin(void)
     testsource.source_mt.formattype = FORMAT_VideoInfo;
 
     hr = IPin_EnumMediaTypes(sink, &enummt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IEnumMediaTypes_Next(enummt, 1, mts, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     IEnumMediaTypes_Release(enummt);
 
     hr = IPin_EnumMediaTypes(capture, &enummt);
-    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#x.\n", hr);
     hr = IPin_EnumMediaTypes(preview, &enummt);
-    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#x.\n", hr);
 
     hr = IPin_QueryAccept(sink, &req_mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IPin_QueryAccept(capture, &req_mt);
-    todo_wine ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     hr = IPin_QueryAccept(preview, &req_mt);
-    todo_wine ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     /* Test sink connection. */
 
     peer = (IPin *)0xdeadbeef;
     hr = IPin_ConnectedTo(sink, &peer);
-    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#x.\n", hr);
     ok(!peer, "Got peer %p.\n", peer);
 
     hr = IPin_ConnectionMediaType(sink, &mt);
-    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_Pause(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IFilterGraph2_ConnectDirect(graph, &testsource.source.pin.IPin_iface, sink, &req_mt);
-    ok(hr == VFW_E_NOT_STOPPED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_STOPPED, "Got hr %#x.\n", hr);
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IFilterGraph2_ConnectDirect(graph, &testsource.source.pin.IPin_iface, sink, &req_mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IPin_ConnectedTo(sink, &peer);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(peer == &testsource.source.pin.IPin_iface, "Got peer %p.\n", peer);
     IPin_Release(peer);
 
     hr = IPin_ConnectionMediaType(sink, &mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(compare_media_types(&mt, &req_mt), "Media types didn't match.\n");
 
     hr = IPin_EnumMediaTypes(sink, &enummt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IEnumMediaTypes_Next(enummt, 1, mts, NULL);
-    todo_wine ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     IEnumMediaTypes_Release(enummt);
 
     test_source_media_types(req_mt, &testsource.source_mt, capture);
@@ -1196,39 +1196,39 @@ static void test_connect_pin(void)
     test_source_connection(req_mt, graph, control, &testsink, preview);
 
     hr = IMediaControl_Pause(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IFilterGraph2_Disconnect(graph, sink);
-    ok(hr == VFW_E_NOT_STOPPED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_STOPPED, "Got hr %#x.\n", hr);
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IFilterGraph2_Disconnect(graph, sink);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IFilterGraph2_Disconnect(graph, sink);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     ok(testsource.source.pin.peer == sink, "Got peer %p.\n", testsource.source.pin.peer);
     IFilterGraph2_Disconnect(graph, &testsource.source.pin.IPin_iface);
 
     peer = (IPin *)0xdeadbeef;
     hr = IPin_ConnectedTo(sink, &peer);
-    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#x.\n", hr);
     ok(!peer, "Got peer %p.\n", peer);
 
     hr = IPin_ConnectionMediaType(sink, &mt);
-    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#x.\n", hr);
 
     IPin_Release(sink);
     IPin_Release(capture);
     IPin_Release(preview);
     IMediaControl_Release(control);
     ref = IFilterGraph2_Release(graph);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ref = IBaseFilter_Release(&testsource.filter.IBaseFilter_iface);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ref = IBaseFilter_Release(&testsink.filter.IBaseFilter_iface);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 static void test_streaming(void)
@@ -1270,111 +1270,111 @@ static void test_streaming(void)
     IBaseFilter_FindPin(filter, L"Preview", &preview);
 
     hr = IFilterGraph2_ConnectDirect(graph, &testsource.source.pin.IPin_iface, sink, &req_mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IFilterGraph2_ConnectDirect(graph, capture, &testsink1.sink.pin.IPin_iface, &req_mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IFilterGraph2_ConnectDirect(graph, preview, &testsink2.sink.pin.IPin_iface, &req_mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMemInputPin_ReceiveCanBlock(input);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMemInputPin_GetAllocator(input, &allocator);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMemAllocator_GetBuffer(allocator, &sample, NULL, NULL, 0);
-    ok(hr == VFW_E_NOT_COMMITTED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_COMMITTED, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_Pause(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMemAllocator_GetBuffer(allocator, &sample, NULL, NULL, 0);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
     if (hr != S_OK)
     {
         IMemAllocator_Commit(allocator);
         hr = IMemAllocator_GetBuffer(allocator, &sample, NULL, NULL, 0);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
     }
 
     hr = IMediaSample_GetPointer(sample, &data);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     size = IMediaSample_GetSize(sample);
-    ok(size == 256, "Got size %ld.\n", size);
+    ok(size == 256, "Got size %d.\n", size);
     for (i = 0; i < 200; ++i)
         data[i] = i;
     hr = IMediaSample_SetActualDataLength(sample, 200);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     start = 10000;
     stop = 20000;
     hr = IMediaSample_SetMediaTime(sample, &start, &stop);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     start = 30000;
     stop = 40000;
     hr = IMediaSample_SetTime(sample, &start, &stop);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMediaSample_SetDiscontinuity(sample, TRUE);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMediaSample_SetPreroll(sample, TRUE);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMediaSample_SetSyncPoint(sample, TRUE);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMemInputPin_Receive(input, sample);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(!WaitForSingleObject(testsink1.sample_event, 1000), "Wait timed out.\n");
     ok(!WaitForSingleObject(testsink2.sample_event, 1000), "Wait timed out.\n");
 
     hr = IPin_NewSegment(sink, 10000, 20000, 1.0);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(!WaitForSingleObject(testsink1.segment_event, 1000), "Wait timed out.\n");
     ok(!WaitForSingleObject(testsink2.segment_event, 1000), "Wait timed out.\n");
 
     hr = IPin_EndOfStream(sink);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(!WaitForSingleObject(testsink1.eos_event, 1000), "Wait timed out.\n");
     ok(!WaitForSingleObject(testsink2.eos_event, 1000), "Wait timed out.\n");
 
     hr = IPin_EndOfStream(sink);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(!WaitForSingleObject(testsink1.eos_event, 1000), "Wait timed out.\n");
     ok(!WaitForSingleObject(testsink2.eos_event, 1000), "Wait timed out.\n");
 
     ok(!testsink1.got_begin_flush, "Got %u calls to IPin::BeginFlush().\n", testsink1.got_begin_flush);
     ok(!testsink2.got_begin_flush, "Got %u calls to IPin::BeginFlush().\n", testsink2.got_begin_flush);
     hr = IPin_BeginFlush(sink);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(testsink1.got_begin_flush == 1, "Got %u calls to IPin::BeginFlush().\n", testsink1.got_begin_flush);
     ok(testsink2.got_begin_flush == 1, "Got %u calls to IPin::BeginFlush().\n", testsink2.got_begin_flush);
 
     hr = IMemInputPin_Receive(input, sample);
-    todo_wine ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IPin_EndOfStream(sink);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
     /* No EOS events are sent downstream, however. */
 
     ok(!testsink1.got_end_flush, "Got %u calls to IPin::EndFlush().\n", testsink1.got_end_flush);
     ok(!testsink2.got_end_flush, "Got %u calls to IPin::EndFlush().\n", testsink2.got_end_flush);
     hr = IPin_EndFlush(sink);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(testsink1.got_end_flush == 1, "Got %u calls to IPin::EndFlush().\n", testsink1.got_end_flush);
     ok(testsink2.got_end_flush == 1, "Got %u calls to IPin::EndFlush().\n", testsink2.got_end_flush);
 
     hr = IMemInputPin_Receive(input, sample);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(!WaitForSingleObject(testsink1.sample_event, 1000), "Wait timed out.\n");
     ok(!WaitForSingleObject(testsink2.sample_event, 1000), "Wait timed out.\n");
 
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMemInputPin_Receive(input, sample);
-    todo_wine ok(hr == VFW_E_WRONG_STATE, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == VFW_E_WRONG_STATE, "Got hr %#x.\n", hr);
 
     hr = IPin_EndOfStream(sink);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     /* No EOS events are sent downstream, however. */
 
     IMediaSample_Release(sample);
@@ -1385,15 +1385,15 @@ static void test_streaming(void)
     IPin_Release(preview);
     IMediaControl_Release(control);
     ref = IFilterGraph2_Release(graph);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ref = IBaseFilter_Release(&testsource.filter.IBaseFilter_iface);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ref = IBaseFilter_Release(&testsink1.filter.IBaseFilter_iface);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ref = IBaseFilter_Release(&testsink2.filter.IBaseFilter_iface);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 START_TEST(smartteefilter)
diff --git a/dlls/qcap/tests/videocapture.c b/dlls/qcap/tests/videocapture.c
index 41b2cbc6a3f..c44070b0bd5 100644
--- wine/dlls/qcap/tests/videocapture.c
+++ wine/dlls/qcap/tests/videocapture.c
@@ -39,7 +39,7 @@ static void check_interface_(unsigned int line, void *iface_ptr, REFIID iid, BOO
     expected_hr = supported ? S_OK : E_NOINTERFACE;
 
     hr = IUnknown_QueryInterface(iface, iid, (void **)&unk);
-    ok_(__FILE__, line)(hr == expected_hr, "Got hr %#lx, expected %#lx.\n", hr, expected_hr);
+    ok_(__FILE__, line)(hr == expected_hr, "Got hr %#x, expected %#x.\n", hr, expected_hr);
     if (SUCCEEDED(hr))
         IUnknown_Release(unk);
 }
@@ -51,78 +51,77 @@ static void test_media_types(IPin *pin)
     HRESULT hr;
 
     hr = IPin_EnumMediaTypes(pin, &enum_media_types);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     while (IEnumMediaTypes_Next(enum_media_types, 1, &pmt, NULL) == S_OK)
     {
         hr = IPin_QueryAccept(pin, pmt);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
         CoTaskMemFree(pmt);
     }
     IEnumMediaTypes_Release(enum_media_types);
 
     hr = IPin_QueryAccept(pin, NULL);
-    todo_wine ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == E_POINTER, "Got hr %#x.\n", hr);
 
     memset(&mt, 0, sizeof(mt));
     hr = IPin_QueryAccept(pin, &mt);
-    ok(hr != S_OK, "Got hr %#lx.\n", hr);
+    ok(hr != S_OK, "Got hr %#x.\n", hr);
 
     mt.majortype = MEDIATYPE_Video;
     hr = IPin_QueryAccept(pin, &mt);
-    ok(hr != S_OK, "Got hr %#lx.\n", hr);
+    ok(hr != S_OK, "Got hr %#x.\n", hr);
 
     mt.formattype = FORMAT_VideoInfo;
     hr = IPin_QueryAccept(pin, &mt);
-    ok(hr != S_OK, "Got hr %#lx.\n", hr);
+    ok(hr != S_OK, "Got hr %#x.\n", hr);
 
     mt.formattype = FORMAT_None;
     hr = IPin_QueryAccept(pin, &mt);
-    ok(hr != S_OK, "Got hr %#lx.\n", hr);
+    ok(hr != S_OK, "Got hr %#x.\n", hr);
 }
 
 static void test_stream_config(IPin *pin)
 {
     VIDEOINFOHEADER *video_info, *video_info2;
+    LONG depth, compression, count, size, i;
     IEnumMediaTypes *enum_media_types;
     AM_MEDIA_TYPE *format, *format2;
     IAMStreamConfig *stream_config;
     VIDEO_STREAM_CONFIG_CAPS vscc;
-    LONG depth, compression;
-    int count, size, i;
     HRESULT hr;
 
     hr = IPin_QueryInterface(pin, &IID_IAMStreamConfig, (void **)&stream_config);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IAMStreamConfig_GetFormat(stream_config, &format);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(IsEqualGUID(&format->majortype, &MEDIATYPE_Video), "Got wrong majortype: %s.\n",
             debugstr_guid(&format->majortype));
 
     hr = IAMStreamConfig_SetFormat(stream_config, format);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     /* After setting the format, a single media type is enumerated.
      * This persists until the filter is released. */
     IPin_EnumMediaTypes(pin, &enum_media_types);
     hr = IEnumMediaTypes_Next(enum_media_types, 1, &format2, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     DeleteMediaType(format2);
     hr = IEnumMediaTypes_Next(enum_media_types, 1, &format2, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     IEnumMediaTypes_Release(enum_media_types);
 
     format->majortype = MEDIATYPE_Audio;
     hr = IAMStreamConfig_SetFormat(stream_config, format);
-    ok(hr == E_FAIL, "Got hr %#lx.\n", hr);
+    ok(hr == E_FAIL, "Got hr %#x.\n", hr);
 
     format->majortype = MEDIATYPE_Video;
     video_info = (VIDEOINFOHEADER *)format->pbFormat;
     video_info->bmiHeader.biWidth--;
     video_info->bmiHeader.biHeight--;
     hr = IAMStreamConfig_SetFormat(stream_config, format);
-    ok(hr == E_FAIL, "Got hr %#lx.\n", hr);
+    ok(hr == E_FAIL, "Got hr %#x.\n", hr);
 
     depth = video_info->bmiHeader.biBitCount;
     compression = video_info->bmiHeader.biCompression;
@@ -131,23 +130,23 @@ static void test_stream_config(IPin *pin)
     video_info->bmiHeader.biBitCount = 0;
     video_info->bmiHeader.biCompression = 0;
     hr = IAMStreamConfig_SetFormat(stream_config, format);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IAMStreamConfig_GetFormat(stream_config, &format2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(IsEqualGUID(&format2->majortype, &MEDIATYPE_Video), "Got wrong majortype: %s.\n",
             debugstr_guid(&format2->majortype));
     video_info2 = (VIDEOINFOHEADER *)format2->pbFormat;
     ok(video_info2->bmiHeader.biBitCount == depth, "Got wrong depth: %d.\n",
             video_info2->bmiHeader.biBitCount);
     ok(video_info2->bmiHeader.biCompression == compression,
-            "Got wrong compression: %ld.\n", video_info2->bmiHeader.biCompression);
+            "Got wrong compression: %d.\n", video_info2->bmiHeader.biCompression);
     FreeMediaType(format2);
 
     video_info->bmiHeader.biWidth = 10000000;
     video_info->bmiHeader.biHeight = 10000000;
     hr = IAMStreamConfig_SetFormat(stream_config, format);
-    ok(hr == E_FAIL, "Got hr %#lx.\n", hr);
+    ok(hr == E_FAIL, "Got hr %#x.\n", hr);
     FreeMediaType(format);
 
     count = 0xdeadbeef;
@@ -156,33 +155,33 @@ static void test_stream_config(IPin *pin)
     if (0)
     {
         hr = IAMStreamConfig_GetNumberOfCapabilities(stream_config, &count, NULL);
-        ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+        ok(hr == E_POINTER, "Got hr %#x.\n", hr);
 
         hr = IAMStreamConfig_GetNumberOfCapabilities(stream_config, NULL, &size);
-        ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+        ok(hr == E_POINTER, "Got hr %#x.\n", hr);
 
         hr = IAMStreamConfig_GetStreamCaps(stream_config, 0, NULL, (BYTE *)&vscc);
-        ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+        ok(hr == E_POINTER, "Got hr %#x.\n", hr);
 
         hr = IAMStreamConfig_GetStreamCaps(stream_config, 0, &format, NULL);
-        ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+        ok(hr == E_POINTER, "Got hr %#x.\n", hr);
     }
 
     hr = IAMStreamConfig_GetNumberOfCapabilities(stream_config, &count, &size);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(count != 0xdeadbeef, "Got wrong count: %d.\n", count);
     ok(size == sizeof(VIDEO_STREAM_CONFIG_CAPS), "Got wrong size: %d.\n", size);
 
     hr = IAMStreamConfig_GetStreamCaps(stream_config, 100000, NULL, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IAMStreamConfig_GetStreamCaps(stream_config, 100000, &format, (BYTE *)&vscc);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     for (i = 0; i < count; ++i)
     {
         hr = IAMStreamConfig_GetStreamCaps(stream_config, i, &format, (BYTE *)&vscc);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
         ok(IsEqualGUID(&format->majortype, &MEDIATYPE_Video), "Got wrong majortype: %s.\n",
                 debugstr_guid(&MEDIATYPE_Video));
         ok(IsEqualGUID(&vscc.guid, &FORMAT_VideoInfo)
@@ -190,17 +189,17 @@ static void test_stream_config(IPin *pin)
                 debugstr_guid(&vscc.guid));
 
         hr = IAMStreamConfig_SetFormat(stream_config, format);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
 
         hr = IAMStreamConfig_GetFormat(stream_config, &format2);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
         ok(compare_media_types(format, format2), "Media types didn't match.\n");
         DeleteMediaType(format2);
 
         hr = IPin_EnumMediaTypes(pin, &enum_media_types);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
         hr = IEnumMediaTypes_Next(enum_media_types, 1, &format2, NULL);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
         ok(compare_media_types(format, format2), "Media types didn't match.\n");
         DeleteMediaType(format2);
         IEnumMediaTypes_Release(enum_media_types);
@@ -241,7 +240,7 @@ static void test_pins(IBaseFilter *filter)
     HRESULT hr;
 
     hr = IBaseFilter_EnumPins(filter, &enum_pins);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     while ((hr = IEnumPins_Next(enum_pins, 1, &pin, NULL)) == S_OK)
     {
@@ -288,67 +287,15 @@ static void test_misc_flags(IBaseFilter *filter)
     HRESULT hr;
 
     hr = IBaseFilter_QueryInterface(filter, &IID_IAMFilterMiscFlags, (void **)&misc_flags);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     flags = IAMFilterMiscFlags_GetMiscFlags(misc_flags);
     ok(flags == AM_FILTER_MISC_FLAGS_IS_SOURCE
-            || broken(!flags) /* win7 */, "Got wrong flags: %#lx.\n", flags);
+            || broken(!flags) /* win7 */, "Got wrong flags: %#x.\n", flags);
 
     IAMFilterMiscFlags_Release(misc_flags);
 }
 
-static void test_unconnected_filter_state(IBaseFilter *filter)
-{
-    FILTER_STATE state;
-    HRESULT hr;
-
-    hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(state == State_Stopped, "Got state %u.\n", state);
-
-    hr = IBaseFilter_Pause(filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-
-    hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(state == State_Paused, "Got state %u.\n", state);
-
-    hr = IBaseFilter_Run(filter, 0);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-
-    hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(state == State_Running, "Got state %u.\n", state);
-
-    hr = IBaseFilter_Pause(filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-
-    hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(state == State_Paused, "Got state %u.\n", state);
-
-    hr = IBaseFilter_Stop(filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-
-    hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(state == State_Stopped, "Got state %u.\n", state);
-
-    hr = IBaseFilter_Run(filter, 0);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-
-    hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(state == State_Running, "Got state %u.\n", state);
-
-    hr = IBaseFilter_Stop(filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-
-    hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(state == State_Stopped, "Got state %u.\n", state);
-}
-
 struct testfilter
 {
     struct strmbase_filter filter;
@@ -420,81 +367,81 @@ static void test_filter_state(IMediaControl *control, IMemAllocator *allocator)
     HRESULT hr;
 
     hr = IMediaControl_GetState(control, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(state == State_Stopped, "Got state %lu.\n", state);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(state == State_Stopped, "Got state %u.\n", state);
 
     hr = IMemAllocator_GetBuffer(allocator, &sample, NULL, NULL, 0);
-    ok(hr == VFW_E_NOT_COMMITTED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_COMMITTED, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_Pause(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_GetState(control, 0, &state);
-    ok(hr == VFW_S_CANT_CUE, "Got hr %#lx.\n", hr);
-    ok(state == State_Paused, "Got state %lu.\n", state);
+    ok(hr == VFW_S_CANT_CUE, "Got hr %#x.\n", hr);
+    ok(state == State_Paused, "Got state %u.\n", state);
 
     hr = IMemAllocator_GetBuffer(allocator, &sample, NULL, NULL, AM_GBF_NOWAIT);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     IMediaSample_Release(sample);
 
     hr = IMediaControl_Run(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_GetState(control, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(state == State_Running, "Got state %lu.\n", state);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(state == State_Running, "Got state %u.\n", state);
 
     hr = IMediaControl_Pause(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_GetState(control, 0, &state);
-    ok(hr == VFW_S_CANT_CUE, "Got hr %#lx.\n", hr);
-    ok(state == State_Paused, "Got state %lu.\n", state);
+    ok(hr == VFW_S_CANT_CUE, "Got hr %#x.\n", hr);
+    ok(state == State_Paused, "Got state %u.\n", state);
 
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_GetState(control, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(state == State_Stopped, "Got state %lu.\n", state);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(state == State_Stopped, "Got state %u.\n", state);
 
     hr = IMemAllocator_GetBuffer(allocator, &sample, NULL, NULL, 0);
-    ok(hr == VFW_E_NOT_COMMITTED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_COMMITTED, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_Run(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_GetState(control, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(state == State_Running, "Got state %lu.\n", state);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(state == State_Running, "Got state %u.\n", state);
 
     hr = IMemAllocator_GetBuffer(allocator, &sample, NULL, NULL, AM_GBF_NOWAIT);
-    todo_wine ok(hr == VFW_E_TIMEOUT, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == VFW_E_TIMEOUT, "Got hr %#x.\n", hr);
     if (hr == S_OK) IMediaSample_Release(sample);
 
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_GetState(control, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(state == State_Stopped, "Got state %lu.\n", state);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(state == State_Stopped, "Got state %u.\n", state);
 
     hr = IMemAllocator_GetBuffer(allocator, &sample, NULL, NULL, 0);
-    ok(hr == VFW_E_NOT_COMMITTED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_COMMITTED, "Got hr %#x.\n", hr);
 
     /* Test committing the allocator before the capture filter does. */
 
     hr = IMemAllocator_Commit(allocator);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_Pause(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMemAllocator_Decommit(allocator);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 }
 
 static void test_connect_pin(IBaseFilter *filter, IPin *source)
@@ -516,20 +463,20 @@ static void test_connect_pin(IBaseFilter *filter, IPin *source)
     IFilterGraph2_AddFilter(graph, &testsink.filter.IBaseFilter_iface, L"sink");
     IFilterGraph2_AddFilter(graph, filter, L"source");
     hr = IPin_QueryInterface(source, &IID_IAMStreamConfig, (void **)&stream_config);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     peer = (IPin *)0xdeadbeef;
     hr = IPin_ConnectedTo(source, &peer);
-    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#x.\n", hr);
     ok(!peer, "Got peer %p.\n", peer);
 
     hr = IPin_ConnectionMediaType(source, &mt);
-    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#x.\n", hr);
 
     hr = IPin_EnumMediaTypes(source, &enummt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IEnumMediaTypes_Next(enummt, 2, mts, &count);
-    ok(SUCCEEDED(hr), "Got hr %#lx.\n", hr);
+    ok(SUCCEEDED(hr), "Got hr %#x.\n", hr);
     CopyMediaType(&req_mt, mts[count - 1]);
     CopyMediaType(&default_mt, mts[0]);
     DeleteMediaType(mts[0]);
@@ -538,50 +485,50 @@ static void test_connect_pin(IBaseFilter *filter, IPin *source)
     IEnumMediaTypes_Release(enummt);
 
     hr = IAMStreamConfig_GetFormat(stream_config, &mts[0]);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(compare_media_types(mts[0], &default_mt), "Media types didn't match.\n");
     DeleteMediaType(mts[0]);
 
     hr = IFilterGraph2_ConnectDirect(graph, source, &testsink.sink.pin.IPin_iface, &req_mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     ok(!!testsink.sink.pAllocator, "Expected to be assigned an allocator.\n");
 
     test_filter_state(control, testsink.sink.pAllocator);
 
     hr = IPin_ConnectedTo(source, &peer);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(peer == &testsink.sink.pin.IPin_iface, "Got peer %p.\n", peer);
     IPin_Release(peer);
 
     hr = IPin_ConnectionMediaType(source, &mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(compare_media_types(&mt, &req_mt), "Media types didn't match.\n");
     ok(compare_media_types(&testsink.sink.pin.mt, &req_mt), "Media types didn't match.\n");
     FreeMediaType(&mt);
 
     hr = IAMStreamConfig_GetFormat(stream_config, &mts[0]);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(compare_media_types(mts[0], &req_mt), "Media types didn't match.\n");
     DeleteMediaType(mts[0]);
 
     hr = IPin_EnumMediaTypes(source, &enummt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IEnumMediaTypes_Next(enummt, 1, mts, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(compare_media_types(mts[0], &default_mt), "Media types didn't match.\n");
     DeleteMediaType(mts[0]);
     IEnumMediaTypes_Release(enummt);
 
     hr = IFilterGraph2_Disconnect(graph, source);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IFilterGraph2_Disconnect(graph, source);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     ok(testsink.sink.pin.peer == source, "Got peer %p.\n", testsink.sink.pin.peer);
     IFilterGraph2_Disconnect(graph, &testsink.sink.pin.IPin_iface);
 
     hr = IAMStreamConfig_GetFormat(stream_config, &mts[0]);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(compare_media_types(mts[0], &default_mt), "Media types didn't match.\n");
     DeleteMediaType(mts[0]);
 
@@ -590,9 +537,9 @@ static void test_connect_pin(IBaseFilter *filter, IPin *source)
     IAMStreamConfig_Release(stream_config);
     IMediaControl_Release(control);
     ref = IFilterGraph2_Release(graph);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ref = IBaseFilter_Release(&testsink.filter.IBaseFilter_iface);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 static void test_connection(IMoniker *moniker)
@@ -604,10 +551,10 @@ static void test_connection(IMoniker *moniker)
     IPin *pin;
 
     hr = IMoniker_BindToObject(moniker, NULL, NULL, &IID_IBaseFilter, (void **)&filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_EnumPins(filter, &enum_pins);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     while (IEnumPins_Next(enum_pins, 1, &pin, NULL) == S_OK)
     {
@@ -622,7 +569,7 @@ static void test_connection(IMoniker *moniker)
 
     IEnumPins_Release(enum_pins);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 START_TEST(videocapture)
@@ -639,7 +586,7 @@ START_TEST(videocapture)
 
     hr = CoCreateInstance(&CLSID_SystemDeviceEnum, NULL, CLSCTX_INPROC,
             &IID_ICreateDevEnum, (void **)&dev_enum);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = ICreateDevEnum_CreateClassEnumerator(dev_enum, &CLSID_VideoInputDeviceCategory, &class_enum, 0);
     if (hr == S_FALSE)
@@ -649,18 +596,18 @@ START_TEST(videocapture)
         CoUninitialize();
         return;
     }
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr=%#x.\n", hr);
 
     while (IEnumMoniker_Next(class_enum, 1, &moniker, NULL) == S_OK)
     {
         hr = IMoniker_GetDisplayName(moniker, NULL, NULL, &name);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
         trace("Testing device %s.\n", wine_dbgstr_w(name));
         CoTaskMemFree(name);
 
         if (FAILED(hr = IMoniker_BindToObject(moniker, NULL, NULL, &IID_IBaseFilter, (void **)&filter)))
         {
-            skip("Failed to open device %s, hr %#lx.\n", debugstr_w(name), hr);
+            skip("Failed to open device %s, hr %#x.\n", debugstr_w(name), hr);
             IMoniker_Release(moniker);
             continue;
         }
@@ -668,10 +615,9 @@ START_TEST(videocapture)
         test_filter_interfaces(filter);
         test_pins(filter);
         test_misc_flags(filter);
-        test_unconnected_filter_state(filter);
 
         ref = IBaseFilter_Release(filter);
-        ok(!ref, "Got outstanding refcount %ld.\n", ref);
+        ok(!ref, "Got outstanding refcount %d.\n", ref);
 
         test_connection(moniker);
 
diff --git a/dlls/qcap/v4l.c b/dlls/qcap/v4l.c
index 577cc829329..ae663389d14 100644
--- wine/dlls/qcap/v4l.c
+++ wine/dlls/qcap/v4l.c
@@ -558,8 +558,8 @@ static NTSTATUS v4l_device_create( void *args )
     }
 
     TRACE("Format: %d bpp - %dx%d.\n", device->current_caps->video_info.bmiHeader.biBitCount,
-            (int)device->current_caps->video_info.bmiHeader.biWidth,
-            (int)device->current_caps->video_info.bmiHeader.biHeight);
+            device->current_caps->video_info.bmiHeader.biWidth,
+            device->current_caps->video_info.bmiHeader.biHeight);
 
     *params->device = (ULONG_PTR)device;
     return S_OK;
diff --git a/dlls/qcap/vfwcapture.c b/dlls/qcap/vfwcapture.c
index d842117e9a5..6b82af9d155 100644
--- wine/dlls/qcap/vfwcapture.c
+++ wine/dlls/qcap/vfwcapture.c
@@ -165,9 +165,9 @@ static DWORD WINAPI stream_thread(void *arg)
 
         LeaveCriticalSection(&filter->state_cs);
 
-        if (FAILED(hr = IMemAllocator_GetBuffer(filter->source.pAllocator, &sample, NULL, NULL, 0)))
+        if (FAILED(hr = BaseOutputPinImpl_GetDeliveryBuffer(&filter->source, &sample, NULL, NULL, 0)))
         {
-            ERR("Failed to get sample, hr %#lx.\n", hr);
+            ERR("Failed to get sample, hr %#x.\n", hr);
             break;
         }
 
@@ -186,7 +186,7 @@ static DWORD WINAPI stream_thread(void *arg)
         IMediaSample_Release(sample);
         if (FAILED(hr))
         {
-            ERR("IMemInputPin::Receive() returned %#lx.\n", hr);
+            ERR("IMemInputPin::Receive() returned %#x.\n", hr);
             break;
         }
     }
@@ -199,11 +199,8 @@ static HRESULT vfw_capture_init_stream(struct strmbase_filter *iface)
     struct vfw_capture *filter = impl_from_strmbase_filter(iface);
     HRESULT hr;
 
-    if (!filter->source.pin.peer)
-        return S_OK;
-
     if (FAILED(hr = IMemAllocator_Commit(filter->source.pAllocator)))
-        ERR("Failed to commit allocator, hr %#lx.\n", hr);
+        ERR("Failed to commit allocator, hr %#x.\n", hr);
 
     EnterCriticalSection(&filter->state_cs);
     filter->state = State_Paused;
@@ -218,9 +215,6 @@ static HRESULT vfw_capture_start_stream(struct strmbase_filter *iface, REFERENCE
 {
     struct vfw_capture *filter = impl_from_strmbase_filter(iface);
 
-    if (!filter->source.pin.peer)
-        return S_OK;
-
     EnterCriticalSection(&filter->state_cs);
     filter->state = State_Running;
     LeaveCriticalSection(&filter->state_cs);
@@ -232,9 +226,6 @@ static HRESULT vfw_capture_stop_stream(struct strmbase_filter *iface)
 {
     struct vfw_capture *filter = impl_from_strmbase_filter(iface);
 
-    if (!filter->source.pin.peer)
-        return S_OK;
-
     EnterCriticalSection(&filter->state_cs);
     filter->state = State_Paused;
     LeaveCriticalSection(&filter->state_cs);
@@ -246,9 +237,6 @@ static HRESULT vfw_capture_cleanup_stream(struct strmbase_filter *iface)
     struct vfw_capture *filter = impl_from_strmbase_filter(iface);
     HRESULT hr;
 
-    if (!filter->source.pin.peer)
-        return S_OK;
-
     EnterCriticalSection(&filter->state_cs);
     filter->state = State_Stopped;
     LeaveCriticalSection(&filter->state_cs);
@@ -260,18 +248,14 @@ static HRESULT vfw_capture_cleanup_stream(struct strmbase_filter *iface)
 
     hr = IMemAllocator_Decommit(filter->source.pAllocator);
     if (hr != S_OK && hr != VFW_E_NOT_COMMITTED)
-        ERR("Failed to decommit allocator, hr %#lx.\n", hr);
+        ERR("Failed to decommit allocator, hr %#x.\n", hr);
 
     return S_OK;
 }
 
 static HRESULT vfw_capture_wait_state(struct strmbase_filter *iface, DWORD timeout)
 {
-    struct vfw_capture *filter = impl_from_strmbase_filter(iface);
-
-    if (filter->source.pin.peer && filter->filter.state == State_Paused)
-        return VFW_S_CANT_CUE;
-    return S_OK;
+    return iface->state == State_Paused ? VFW_S_CANT_CUE : S_OK;
 }
 
 static const struct strmbase_filter_ops filter_ops =
@@ -332,7 +316,7 @@ AMStreamConfig_SetFormat(IAMStreamConfig *iface, AM_MEDIA_TYPE *pmt)
     if (This->source.pin.peer)
     {
         hr = IPin_QueryAccept(This->source.pin.peer, pmt);
-        TRACE("QueryAccept() returned %#lx.\n", hr);
+        TRACE("Would accept: %d\n", hr);
         if (hr == S_FALSE)
             return VFW_E_INVALIDMEDIATYPE;
     }
@@ -346,7 +330,7 @@ AMStreamConfig_SetFormat(IAMStreamConfig *iface, AM_MEDIA_TYPE *pmt)
         if (SUCCEEDED(hr))
             TRACE("Reconnection completed, with new media format..\n");
     }
-    TRACE("Returning %#lx.\n", hr);
+    TRACE("Returning: %d\n", hr);
     return hr;
 }
 
@@ -481,7 +465,7 @@ static HRESULT WINAPI AMVideoProcAmp_GetRange(IAMVideoProcAmp *iface, LONG prope
     struct vfw_capture *filter = impl_from_IAMVideoProcAmp(iface);
     struct get_prop_range_params params = { filter->device, property, min, max, step, default_value, flags };
 
-    TRACE("filter %p, property %#lx, min %p, max %p, step %p, default_value %p, flags %p.\n",
+    TRACE("filter %p, property %#x, min %p, max %p, step %p, default_value %p, flags %p.\n",
             filter, property, min, max, step, default_value, flags);
 
     return V4L_CALL( get_prop_range, &params );
@@ -493,7 +477,7 @@ static HRESULT WINAPI AMVideoProcAmp_Set(IAMVideoProcAmp *iface, LONG property,
     struct vfw_capture *filter = impl_from_IAMVideoProcAmp(iface);
     struct set_prop_params params = { filter->device, property, value, flags };
 
-    TRACE("filter %p, property %#lx, value %ld, flags %#lx.\n", filter, property, value, flags);
+    TRACE("filter %p, property %#x, value %d, flags %#x.\n", filter, property, value, flags);
 
     return V4L_CALL( set_prop, &params );
 }
@@ -504,7 +488,7 @@ static HRESULT WINAPI AMVideoProcAmp_Get(IAMVideoProcAmp *iface, LONG property,
     struct vfw_capture *filter = impl_from_IAMVideoProcAmp(iface);
     struct get_prop_params params = { filter->device, property, value, flags };
 
-    TRACE("filter %p, property %#lx, value %p, flags %p.\n", filter, property, value, flags);
+    TRACE("filter %p, property %#x, value %p, flags %p.\n", filter, property, value, flags);
 
     return V4L_CALL( get_prop, &params );
 }
@@ -815,7 +799,7 @@ static HRESULT WINAPI video_control_SetMode(IAMVideoControl *iface, IPin *pin, L
 {
     struct vfw_capture *filter = impl_from_IAMVideoControl(iface);
 
-    FIXME("filter %p, pin %p, mode %ld, stub.\n", filter, pin, mode);
+    FIXME("filter %p, pin %p, mode %d: stub.\n", filter, pin, mode);
 
     return E_NOTIMPL;
 }
@@ -844,7 +828,7 @@ static HRESULT WINAPI video_control_GetMaxAvailableFrameRate(IAMVideoControl *if
 {
     struct vfw_capture *filter = impl_from_IAMVideoControl(iface);
 
-    FIXME("filter %p, pin %p, index %ld, dimensions (%ldx%ld), frame rate %p, stub.\n",
+    FIXME("filter %p, pin %p, index %d, dimensions (%dx%d), frame rate %p: stub.\n",
             filter, pin, index, dimensions.cx, dimensions.cy, frame_rate);
 
     return E_NOTIMPL;
@@ -855,7 +839,7 @@ static HRESULT WINAPI video_control_GetFrameRateList(IAMVideoControl *iface, IPi
 {
     struct vfw_capture *filter = impl_from_IAMVideoControl(iface);
 
-    FIXME("filter %p, pin %p, index %ld, dimensions (%ldx%ld), list size %p, frame rate %p, stub.\n",
+    FIXME("filter %p, pin %p, index %d, dimensions (%dx%d), list size %p, frame rate: %p: stub.\n",
             filter, pin, index, dimensions.cx, dimensions.cy, list_size, frame_rate);
 
     return E_NOTIMPL;
diff --git a/dlls/quartz/Makefile.in b/dlls/quartz/Makefile.in
index e7e1b43da79..81db98e639d 100644
--- wine/dlls/quartz/Makefile.in
+++ wine/dlls/quartz/Makefile.in
@@ -1,3 +1,4 @@
+EXTRADEFS = -DWINE_NO_LONG_TYPES
 MODULE    = quartz.dll
 IMPORTLIB = quartz
 IMPORTS   = strmiids dxguid strmbase uuid dsound msacm32 msvfw32 ole32 oleaut32 rpcrt4 user32 gdi32 advapi32
diff --git a/dlls/quartz/acmwrapper.c b/dlls/quartz/acmwrapper.c
index 8e1b5e6b773..a07bdfef0ca 100644
--- wine/dlls/quartz/acmwrapper.c
+++ wine/dlls/quartz/acmwrapper.c
@@ -110,7 +110,7 @@ static HRESULT WINAPI acm_wrapper_sink_Receive(struct strmbase_sink *iface, IMed
     hr = IMediaSample_GetPointer(pSample, &pbSrcStream);
     if (FAILED(hr))
     {
-        ERR("Failed to get input buffer pointer, hr %#lx.\n", hr);
+        ERR("Cannot get pointer to sample data (%x)\n", hr);
         return hr;
     }
 
@@ -135,14 +135,17 @@ static HRESULT WINAPI acm_wrapper_sink_Receive(struct strmbase_sink *iface, IMed
     tMed = tStart;
     mtMed = mtStart;
 
+    TRACE("Sample data ptr = %p, size = %d\n", pbSrcStream, cbSrcStream);
+
     ash.pbSrc = pbSrcStream;
     ash.cbSrcLength = cbSrcStream;
 
     while(hr == S_OK && ash.cbSrcLength)
     {
-        if (FAILED(hr = IMemAllocator_GetBuffer(This->source.pAllocator, &pOutSample, NULL, NULL, 0)))
+        hr = BaseOutputPinImpl_GetDeliveryBuffer(&This->source, &pOutSample, NULL, NULL, 0);
+        if (FAILED(hr))
         {
-            ERR("Failed to get sample, hr %#lx.\n", hr);
+            ERR("Unable to get delivery buffer (%x)\n", hr);
             return hr;
         }
         IMediaSample_SetPreroll(pOutSample, preroll);
@@ -152,7 +155,7 @@ static HRESULT WINAPI acm_wrapper_sink_Receive(struct strmbase_sink *iface, IMed
 
 	hr = IMediaSample_GetPointer(pOutSample, &pbDstStream);
 	if (FAILED(hr)) {
-            ERR("Failed to get output buffer pointer, hr %#lx.\n", hr);
+	    ERR("Unable to get pointer to buffer (%x)\n", hr);
 	    goto error;
 	}
 	cbDstStream = IMediaSample_GetSize(pOutSample);
@@ -189,7 +192,7 @@ static HRESULT WINAPI acm_wrapper_sink_Receive(struct strmbase_sink *iface, IMed
             goto error;
         }
 
-        TRACE("used in %lu/%lu, used out %lu/%lu\n", ash.cbSrcLengthUsed, ash.cbSrcLength, ash.cbDstLengthUsed, ash.cbDstLength);
+        TRACE("used in %u/%u, used out %u/%u\n", ash.cbSrcLengthUsed, ash.cbSrcLength, ash.cbDstLengthUsed, ash.cbDstLength);
 
         hr = IMediaSample_SetActualDataLength(pOutSample, ash.cbDstLengthUsed);
         assert(hr == S_OK);
@@ -197,7 +200,7 @@ static HRESULT WINAPI acm_wrapper_sink_Receive(struct strmbase_sink *iface, IMed
         /* Bug in acm codecs? It apparently uses the input, but doesn't necessarily output immediately */
         if (!ash.cbSrcLengthUsed)
         {
-            WARN("Sample was skipped? Outputted: %lu\n", ash.cbDstLengthUsed);
+            WARN("Sample was skipped? Outputted: %u\n", ash.cbDstLengthUsed);
             ash.cbSrcLength = 0;
             goto error;
         }
@@ -240,7 +243,7 @@ static HRESULT WINAPI acm_wrapper_sink_Receive(struct strmbase_sink *iface, IMed
         hr = IMemInputPin_Receive(This->source.pMemInputPin, pOutSample);
         if (hr != S_OK && hr != VFW_E_NOT_CONNECTED) {
             if (FAILED(hr))
-                ERR("Failed to send sample, hr %#lx.\n", hr);
+                ERR("Error sending sample (%x)\n", hr);
             goto error;
         }
 
@@ -416,7 +419,7 @@ static HRESULT WINAPI acm_wrapper_source_qc_Notify(IQualityControl *iface,
     IQualityControl *peer;
     HRESULT hr = S_OK;
 
-    TRACE("filter %p, sender %p, type %#x, proportion %ld, late %s, timestamp %s.\n",
+    TRACE("filter %p, sender %p, type %#x, proportion %u, late %s, timestamp %s.\n",
             filter, sender, q.Type, q.Proportion, debugstr_time(q.Late), debugstr_time(q.TimeStamp));
 
     if (filter->source_qc_sink)
@@ -489,7 +492,7 @@ static HRESULT acm_wrapper_init_stream(struct strmbase_filter *iface)
     HRESULT hr;
 
     if (filter->source.pin.peer && FAILED(hr = IMemAllocator_Commit(filter->source.pAllocator)))
-        ERR("Failed to commit allocator, hr %#lx.\n", hr);
+        ERR("Failed to commit allocator, hr %#x.\n", hr);
     return S_OK;
 }
 
@@ -520,11 +523,8 @@ HRESULT acm_wrapper_create(IUnknown *outer, IUnknown **out)
     strmbase_filter_init(&object->filter, outer, &CLSID_ACMWrapper, &filter_ops);
 
     strmbase_sink_init(&object->sink, &object->filter, L"In", &sink_ops, NULL);
-    wcscpy(object->sink.pin.name, L"Input");
 
     strmbase_source_init(&object->source, &object->filter, L"Out", &source_ops);
-    wcscpy(object->source.pin.name, L"Output");
-
     object->source_IQualityControl_iface.lpVtbl = &source_qc_vtbl;
     strmbase_passthrough_init(&object->passthrough, (IUnknown *)&object->source.pin.IPin_iface);
     ISeekingPassThru_Init(&object->passthrough.ISeekingPassThru_iface, FALSE,
diff --git a/dlls/quartz/avidec.c b/dlls/quartz/avidec.c
index 8cc729748c1..3d947e1b1bf 100644
--- wine/dlls/quartz/avidec.c
+++ wine/dlls/quartz/avidec.c
@@ -101,13 +101,14 @@ static HRESULT WINAPI avi_decompressor_sink_Receive(struct strmbase_sink *iface,
     struct avi_decompressor *This = impl_from_strmbase_filter(iface->pin.filter);
     VIDEOINFOHEADER *source_format;
     HRESULT hr;
+    DWORD res;
     IMediaSample* pOutSample = NULL;
-    LONG cbDstStream, cbSrcStream;
+    DWORD cbDstStream;
     LPBYTE pbDstStream;
+    DWORD cbSrcStream;
     LPBYTE pbSrcStream;
     LONGLONG tStart, tStop;
     DWORD flags = 0;
-    LRESULT res;
 
     /* We do not expect pin connection state to change while the filter is
      * running. This guarantee is necessary, since otherwise we would have to
@@ -130,18 +131,20 @@ static HRESULT WINAPI avi_decompressor_sink_Receive(struct strmbase_sink *iface,
     hr = IMediaSample_GetPointer(pSample, &pbSrcStream);
     if (FAILED(hr))
     {
-        ERR("Failed to get input buffer pointer, hr %#lx.\n", hr);
+        ERR("Cannot get pointer to sample data (%x)\n", hr);
         return hr;
     }
 
     cbSrcStream = IMediaSample_GetActualDataLength(pSample);
 
+    TRACE("Sample data ptr = %p, size = %d\n", pbSrcStream, cbSrcStream);
+
     /* Update input size to match sample size */
     This->pBihIn->biSizeImage = cbSrcStream;
 
-    if (FAILED(hr = IMemAllocator_GetBuffer(This->source.pAllocator, &pOutSample, NULL, NULL, 0)))
-    {
-        ERR("Failed to get sample, hr %#lx.\n", hr);
+    hr = BaseOutputPinImpl_GetDeliveryBuffer(&This->source, &pOutSample, NULL, NULL, 0);
+    if (FAILED(hr)) {
+        ERR("Unable to get delivery buffer (%x)\n", hr);
         return hr;
     }
 
@@ -150,14 +153,14 @@ static HRESULT WINAPI avi_decompressor_sink_Receive(struct strmbase_sink *iface,
 
     hr = IMediaSample_GetPointer(pOutSample, &pbDstStream);
     if (FAILED(hr)) {
-        ERR("Failed to get output buffer pointer, hr %#lx.\n", hr);
+	ERR("Unable to get pointer to buffer (%x)\n", hr);
         IMediaSample_Release(pOutSample);
         return hr;
     }
     cbDstStream = IMediaSample_GetSize(pOutSample);
     if (cbDstStream < source_format->bmiHeader.biSizeImage)
     {
-        ERR("Sample size is too small (%ld < %lu).\n", cbDstStream, source_format->bmiHeader.biSizeImage);
+        ERR("Sample size is too small (%u < %u).\n", cbDstStream, source_format->bmiHeader.biSizeImage);
         IMediaSample_Release(pOutSample);
         return E_FAIL;
     }
@@ -172,7 +175,7 @@ static HRESULT WINAPI avi_decompressor_sink_Receive(struct strmbase_sink *iface,
 
     res = ICDecompress(This->hvid, flags, This->pBihIn, pbSrcStream, &source_format->bmiHeader, pbDstStream);
     if (res != ICERR_OK)
-        ERR("Failed to decompress, error %Id.\n", res);
+        ERR("Error occurred during the decompression (%x)\n", res);
 
     /* Drop sample if it's intended to be dropped */
     if (flags & ICDECOMPRESS_HURRYUP) {
@@ -195,7 +198,7 @@ static HRESULT WINAPI avi_decompressor_sink_Receive(struct strmbase_sink *iface,
 
     hr = IMemInputPin_Receive(This->source.pMemInputPin, pOutSample);
     if (hr != S_OK && hr != VFW_E_NOT_CONNECTED)
-        ERR("Failed to send sample, hr %#lx.\n", hr);
+        ERR("Error sending sample (%x)\n", hr);
 
     IMediaSample_Release(pOutSample);
     return hr;
@@ -225,7 +228,7 @@ static HRESULT avi_decompressor_sink_connect(struct strmbase_sink *iface, IPin *
         if (This->hvid)
         {
             DWORD bih_size;
-            LRESULT result;
+            DWORD result;
 
             /* Copy bitmap header from media type to 1 for input and 1 for output */
             bih_size = bmi->biSize + bmi->biClrUsed * 4;
@@ -239,7 +242,7 @@ static HRESULT avi_decompressor_sink_connect(struct strmbase_sink *iface, IPin *
 
             if ((result = ICDecompressQuery(This->hvid, This->pBihIn, NULL)))
             {
-                WARN("No decompressor found, error %Id.\n", result);
+                WARN("No decompressor found, error %d.\n", result);
                 return VFW_E_TYPE_NOT_ACCEPTED;
             }
 
@@ -342,12 +345,9 @@ static HRESULT avi_decompressor_source_get_media_type(struct strmbase_pin *iface
 
     if (index < ARRAY_SIZE(formats))
     {
-        /* In theory we could allocate less than this, but gcc generates
-         * -Warray-bounds warnings if we access the structure through a
-         * VIDEOINFO pointer, even if we only access valid fields. */
-        if (!(format = CoTaskMemAlloc(sizeof(*format))))
+        if (!(format = CoTaskMemAlloc(offsetof(VIDEOINFO, dwBitMasks[3]))))
             return E_OUTOFMEMORY;
-        memset(format, 0, sizeof(*format));
+        memset(format, 0, offsetof(VIDEOINFO, dwBitMasks[3]));
 
         format->rcSource = sink_format->rcSource;
         format->rcTarget = sink_format->rcTarget;
@@ -479,7 +479,7 @@ static HRESULT WINAPI avi_decompressor_source_qc_Notify(IQualityControl *iface,
 {
     struct avi_decompressor *filter = impl_from_source_IQualityControl(iface);
 
-    TRACE("filter %p, sender %p, type %#x, proportion %ld, late %s, timestamp %s.\n",
+    TRACE("filter %p, sender %p, type %#x, proportion %u, late %s, timestamp %s.\n",
             filter, sender, q.Type, q.Proportion, debugstr_time(q.Late), debugstr_time(q.TimeStamp));
 
     EnterCriticalSection(&filter->filter.stream_cs);
@@ -555,12 +555,12 @@ static HRESULT avi_decompressor_init_stream(struct strmbase_filter *iface)
     source_format = (VIDEOINFOHEADER *)filter->sink.pin.mt.pbFormat;
     if ((res = ICDecompressBegin(filter->hvid, filter->pBihIn, &source_format->bmiHeader)))
     {
-        ERR("ICDecompressBegin() failed, error %Id.\n", res);
+        ERR("ICDecompressBegin() failed, error %ld.\n", res);
         return E_FAIL;
     }
 
     if (FAILED(hr = IMemAllocator_Commit(filter->source.pAllocator)))
-        ERR("Failed to commit allocator, hr %#lx.\n", hr);
+        ERR("Failed to commit allocator, hr %#x.\n", hr);
 
     return S_OK;
 }
@@ -575,7 +575,7 @@ static HRESULT avi_decompressor_cleanup_stream(struct strmbase_filter *iface)
 
     if (filter->hvid && (res = ICDecompressEnd(filter->hvid)))
     {
-        ERR("ICDecompressEnd() failed, error %Id.\n", res);
+        ERR("ICDecompressEnd() failed, error %ld.\n", res);
         return E_FAIL;
     }
 
@@ -602,11 +602,8 @@ HRESULT avi_dec_create(IUnknown *outer, IUnknown **out)
     strmbase_filter_init(&object->filter, outer, &CLSID_AVIDec, &filter_ops);
 
     strmbase_sink_init(&object->sink, &object->filter, L"In", &sink_ops, NULL);
-    wcscpy(object->sink.pin.name, L"XForm In");
 
     strmbase_source_init(&object->source, &object->filter, L"Out", &source_ops);
-    wcscpy(object->source.pin.name, L"XForm Out");
-
     object->source_IQualityControl_iface.lpVtbl = &source_qc_vtbl;
     strmbase_passthrough_init(&object->passthrough, (IUnknown *)&object->source.pin.IPin_iface);
     ISeekingPassThru_Init(&object->passthrough.ISeekingPassThru_iface, FALSE,
diff --git a/dlls/quartz/dsoundrender.c b/dlls/quartz/dsoundrender.c
index 1abd4bdbcec..df40d1254ee 100644
--- wine/dlls/quartz/dsoundrender.c
+++ wine/dlls/quartz/dsoundrender.c
@@ -126,7 +126,7 @@ static void DSoundRender_UpdatePositions(struct dsound_render *This, DWORD *seqw
         adv = playpos - old_playpos;
     This->last_playpos = playpos;
     if (adv) {
-        TRACE("Moving from %lu to %lu: clearing %lu bytes.\n", old_playpos, playpos, adv);
+        TRACE("Moving from %u to %u: clearing %u bytes\n", old_playpos, playpos, adv);
         IDirectSoundBuffer_Lock(This->dsbuffer, old_playpos, adv, (void**)&buf1, &size1, (void**)&buf2, &size2, 0);
         memset(buf1, wfx->wBitsPerSample == 8 ? 128  : 0, size1);
         memset(buf2, wfx->wBitsPerSample == 8 ? 128  : 0, size2);
@@ -190,19 +190,19 @@ static HRESULT DSoundRender_GetWritePos(struct dsound_render *This,
         past = min_writepos_t - write_at;
         if (past >= 0) {
             DWORD skipbytes = pos_from_time(This, past);
-            WARN("Skipping %lu bytes.\n", skipbytes);
+            WARN("Skipping %u bytes\n", skipbytes);
             *skip = skipbytes;
             *ret_writepos = min_writepos;
         } else {
             DWORD aheadbytes = pos_from_time(This, -past);
-            WARN("Advancing %lu bytes.\n", aheadbytes);
+            WARN("Advancing %u bytes\n", aheadbytes);
             *ret_writepos = (min_writepos + aheadbytes) % This->buf_size;
         }
     } else /* delta_t > 0 */ {
         DWORD aheadbytes;
         WARN("Delta too big %s/%s, too far ahead\n", debugstr_time(delta_t), debugstr_time(max_lag));
         aheadbytes = pos_from_time(This, delta_t);
-        WARN("Advancing %lu bytes.\n", aheadbytes);
+        WARN("Advancing %u bytes\n", aheadbytes);
         if (delta_t >= DSoundRenderer_Max_Fill)
             return S_FALSE;
         *ret_writepos = (min_writepos + aheadbytes) % This->buf_size;
@@ -254,13 +254,13 @@ static HRESULT DSoundRender_SendSampleData(struct dsound_render *This,
             if (This->sink.flushing || This->filter.state == State_Stopped)
                 return This->filter.state == State_Paused ? S_OK : VFW_E_WRONG_STATE;
             if (ret != WAIT_TIMEOUT)
-                ERR("WaitForSingleObject() returned %ld.\n", ret);
+                ERR("%x\n", ret);
             continue;
         }
         tStart = -1;
 
         if (skip)
-            FIXME("Sample dropped %lu of %lu bytes.\n", skip, size);
+            FIXME("Sample dropped %u of %u bytes\n", skip, size);
         if (skip >= size)
             return S_OK;
         data += skip;
@@ -268,7 +268,7 @@ static HRESULT DSoundRender_SendSampleData(struct dsound_render *This,
 
         hr = IDirectSoundBuffer_Lock(This->dsbuffer, writepos, min(free, size), (void**)&buf1, &size1, (void**)&buf2, &size2, 0);
         if (hr != DS_OK) {
-            ERR("Failed to lock sound buffer, hr %#lx.\n", hr);
+            ERR("Unable to lock sound buffer! (%x)\n", hr);
             break;
         }
         memcpy(buf1, data, size1);
@@ -276,7 +276,7 @@ static HRESULT DSoundRender_SendSampleData(struct dsound_render *This,
             memcpy(buf2, data+size1, size2);
         IDirectSoundBuffer_Unlock(This->dsbuffer, buf1, size1, buf2, size2);
         This->writepos = (writepos + size1 + size2) % This->buf_size;
-        TRACE("Wrote %lu bytes at %lu, next at %lu - (%lu/%lu)\n", size1+size2, writepos, This->writepos, free, size);
+        TRACE("Wrote %u bytes at %u, next at %u - (%u/%u)\n", size1+size2, writepos, This->writepos, free, size);
         data += size1 + size2;
         size -= size1 + size2;
     }
@@ -330,13 +330,13 @@ static HRESULT DSoundRender_DoRenderSample(struct dsound_render *This, IMediaSam
     hr = IMediaSample_GetPointer(pSample, &pbSrcStream);
     if (FAILED(hr))
     {
-        ERR("Failed to get buffer pointer, hr %#lx.\n", hr);
+        ERR("Cannot get pointer to sample data (%x)\n", hr);
         return hr;
     }
 
     hr = IMediaSample_GetTime(pSample, &tStart, &tStop);
     if (FAILED(hr)) {
-        ERR("Failed to get sample time, hr %#lx.\n", hr);
+        ERR("Cannot get sample time (%x)\n", hr);
         tStart = tStop = -1;
     }
 
@@ -347,6 +347,8 @@ static HRESULT DSoundRender_DoRenderSample(struct dsound_render *This, IMediaSam
     }
 
     cbSrcStream = IMediaSample_GetActualDataLength(pSample);
+    TRACE("Sample data ptr = %p, size = %d\n", pbSrcStream, cbSrcStream);
+
     return DSoundRender_SendSampleData(This, tStart, tStop, pbSrcStream, cbSrcStream);
 }
 
@@ -414,17 +416,17 @@ static HRESULT dsound_render_sink_connect(struct strmbase_sink *iface, IPin *pee
     hr = IDirectSound8_CreateSoundBuffer(This->dsound, &buf_desc, &This->dsbuffer, NULL);
     This->writepos = This->buf_size;
     if (FAILED(hr))
-        ERR("Failed to create sound buffer, hr %#lx.\n", hr);
+        ERR("Can't create sound buffer (%x)\n", hr);
 
     if (SUCCEEDED(hr))
     {
         hr = IDirectSoundBuffer_SetVolume(This->dsbuffer, This->volume);
         if (FAILED(hr))
-            ERR("Failed to set volume to %ld, hr %#lx.\n", This->volume, hr);
+            ERR("Can't set volume to %d (%x)\n", This->volume, hr);
 
         hr = IDirectSoundBuffer_SetPan(This->dsbuffer, This->pan);
         if (FAILED(hr))
-            ERR("Failed to set pan to %ld, hr %#lx.\n", This->pan, hr);
+            ERR("Can't set pan to %d (%x)\n", This->pan, hr);
         hr = S_OK;
     }
 
@@ -699,7 +701,7 @@ HRESULT WINAPI basic_audio_GetTypeInfoCount(IBasicAudio *iface, UINT *count)
 HRESULT WINAPI basic_audio_GetTypeInfo(IBasicAudio *iface, UINT index,
         LCID lcid, ITypeInfo **typeinfo)
 {
-    TRACE("iface %p, index %u, lcid %#lx, typeinfo %p.\n", iface, index, lcid, typeinfo);
+    TRACE("iface %p, index %u, lcid %#x, typeinfo %p.\n", iface, index, lcid, typeinfo);
     return strmbase_get_typeinfo(IBasicAudio_tid, typeinfo);
 }
 
@@ -709,7 +711,7 @@ HRESULT WINAPI basic_audio_GetIDsOfNames(IBasicAudio *iface, REFIID iid,
     ITypeInfo *typeinfo;
     HRESULT hr;
 
-    TRACE("iface %p, iid %s, names %p, count %u, lcid %#lx, ids %p.\n",
+    TRACE("iface %p, iid %s, names %p, count %u, lcid %#x, ids %p.\n",
             iface, debugstr_guid(iid), names, count, lcid, ids);
 
     if (SUCCEEDED(hr = strmbase_get_typeinfo(IBasicAudio_tid, &typeinfo)))
@@ -726,7 +728,7 @@ static HRESULT WINAPI basic_audio_Invoke(IBasicAudio *iface, DISPID id, REFIID i
     ITypeInfo *typeinfo;
     HRESULT hr;
 
-    TRACE("iface %p, id %ld, iid %s, lcid %#lx, flags %#x, params %p, result %p, excepinfo %p, error_arg %p.\n",
+    TRACE("iface %p, id %d, iid %s, lcid %#x, flags %#x, params %p, result %p, excepinfo %p, error_arg %p.\n",
             iface, id, debugstr_guid(iid), lcid, flags, params, result, excepinfo, error_arg);
 
     if (SUCCEEDED(hr = strmbase_get_typeinfo(IBasicAudio_tid, &typeinfo)))
@@ -741,7 +743,7 @@ static HRESULT WINAPI Basicaudio_put_Volume(IBasicAudio *iface,
                                             LONG lVolume) {
     struct dsound_render *This = impl_from_IBasicAudio(iface);
 
-    TRACE("filter %p, volume %ld.\n", This, lVolume);
+    TRACE("(%p/%p)->(%d)\n", This, iface, lVolume);
 
     if (lVolume > DSBVOLUME_MAX || lVolume < DSBVOLUME_MIN)
         return E_INVALIDARG;
@@ -772,7 +774,7 @@ static HRESULT WINAPI Basicaudio_put_Balance(IBasicAudio *iface,
                                              LONG lBalance) {
     struct dsound_render *This = impl_from_IBasicAudio(iface);
 
-    TRACE("filter %p, balance %ld.\n", This, lBalance);
+    TRACE("(%p/%p)->(%d)\n", This, iface, lBalance);
 
     if (lBalance < DSBPAN_LEFT || lBalance > DSBPAN_RIGHT)
         return E_INVALIDARG;
@@ -961,7 +963,7 @@ static HRESULT WINAPI dsound_render_qc_Notify(IQualityControl *iface,
 {
     struct dsound_render *filter = impl_from_IQualityControl(iface);
 
-    FIXME("filter %p, sender %p, type %#x, proportion %ld, late %s, timestamp %s, stub!\n",
+    FIXME("filter %p, sender %p, type %#x, proportion %u, late %s, timestamp %s, stub!\n",
             filter, sender, q.Type, q.Proportion, debugstr_time(q.Late), debugstr_time(q.TimeStamp));
 
     return E_NOTIMPL;
diff --git a/dlls/quartz/filesource.c b/dlls/quartz/filesource.c
index 6ffae606df4..e5e7b482984 100644
--- wine/dlls/quartz/filesource.c
+++ wine/dlls/quartz/filesource.c
@@ -217,7 +217,7 @@ BOOL get_media_type(const WCHAR *filename, GUID *majortype, GUID *subtype, GUID
     if ((file = CreateFileW(filename, GENERIC_READ, FILE_SHARE_READ, NULL,
             OPEN_EXISTING, 0, NULL)) == INVALID_HANDLE_VALUE)
     {
-        WARN("Failed to open file %s, error %lu.\n", debugstr_w(filename), GetLastError());
+        WARN("Failed to open file %s, error %u.\n", debugstr_w(filename), GetLastError());
         return FALSE;
     }
 
@@ -393,14 +393,14 @@ static DWORD CALLBACK io_thread(void *arg)
         EnterCriticalSection(&filter->sample_cs);
 
         req = CONTAINING_RECORD(ovl, struct request, ovl);
-        TRACE("Got sample %Iu.\n", req - filter->requests);
+        TRACE("Got sample %u.\n", req - filter->requests);
         assert(req >= filter->requests && req < filter->requests + filter->max_requests);
 
         if (ret)
             WakeConditionVariable(&filter->sample_cv);
         else
         {
-            ERR("GetQueuedCompletionStatus() returned failure, error %lu.\n", GetLastError());
+            ERR("GetQueuedCompletionStatus() returned failure, error %u.\n", GetLastError());
             req->sample = NULL;
         }
 
@@ -624,6 +624,7 @@ static HRESULT WINAPI FileAsyncReaderPin_AttemptConnection(struct strmbase_sourc
         FreeMediaType(&This->pin.mt);
     }
 
+    TRACE(" -- %x\n", hr);
     return hr;
 }
 
@@ -711,7 +712,7 @@ static HRESULT WINAPI FileAsyncReader_Request(IAsyncReader *iface, IMediaSample
     HRESULT hr;
     BYTE *data;
 
-    TRACE("filter %p, sample %p, cookie %#Ix.\n", filter, sample, cookie);
+    TRACE("filter %p, sample %p, cookie %#lx.\n", filter, sample, cookie);
 
     if (!sample)
         return E_POINTER;
@@ -764,7 +765,7 @@ static HRESULT WINAPI FileAsyncReader_WaitForNext(IAsyncReader *iface,
     struct async_reader *filter = impl_from_IAsyncReader(iface);
     unsigned int i;
 
-    TRACE("filter %p, timeout %lu, sample %p, cookie %p.\n", filter, timeout, sample, cookie);
+    TRACE("filter %p, timeout %u, sample %p, cookie %p.\n", filter, timeout, sample, cookie);
 
     *sample = NULL;
     *cookie = 0;
@@ -823,7 +824,7 @@ static BOOL sync_read(HANDLE file, LONGLONG offset, LONG length, BYTE *buffer, D
     if (ret || GetLastError() == ERROR_IO_PENDING)
         ret = GetOverlappedResult(file, &ovl, read_len, TRUE);
 
-    TRACE("Returning %lu bytes.\n", *read_len);
+    TRACE("Returning %u bytes.\n", *read_len);
 
     CloseHandle(ovl.hEvent);
     return ret;
@@ -872,7 +873,7 @@ static HRESULT WINAPI FileAsyncReader_SyncRead(IAsyncReader *iface,
     HRESULT hr;
     BOOL ret;
 
-    TRACE("filter %p, offset %s, length %ld, buffer %p.\n",
+    TRACE("filter %p, offset %s, length %d, buffer %p.\n",
             filter, wine_dbgstr_longlong(offset), length, buffer);
 
     ret = sync_read(filter->file, offset, length, buffer, &read_len);
diff --git a/dlls/quartz/filtergraph.c b/dlls/quartz/filtergraph.c
index a99fdc80ba6..5f1b80d12cf 100644
--- wine/dlls/quartz/filtergraph.c
+++ wine/dlls/quartz/filtergraph.c
@@ -61,6 +61,7 @@ struct filter
     struct list entry;
     IBaseFilter *filter;
     IMediaSeeking *seeking;
+    IMediaPosition *position;
     WCHAR *name;
     BOOL sorting;
 };
@@ -98,7 +99,7 @@ struct filter_graph
     struct list filters;
     unsigned int name_index;
 
-    FILTER_STATE state;
+    OAFilterState state;
     TP_WORK *async_run_work;
 
     IReferenceClock *refClock;
@@ -181,7 +182,7 @@ static ULONG WINAPI EnumFilters_AddRef(IEnumFilters *iface)
     struct enum_filters *enum_filters = impl_from_IEnumFilters(iface);
     ULONG ref = InterlockedIncrement(&enum_filters->ref);
 
-    TRACE("%p increasing refcount to %lu.\n", enum_filters, ref);
+    TRACE("%p increasing refcount to %u.\n", enum_filters, ref);
 
     return ref;
 }
@@ -191,7 +192,7 @@ static ULONG WINAPI EnumFilters_Release(IEnumFilters *iface)
     struct enum_filters *enum_filters = impl_from_IEnumFilters(iface);
     ULONG ref = InterlockedDecrement(&enum_filters->ref);
 
-    TRACE("%p decreasing refcount to %lu.\n", enum_filters, ref);
+    TRACE("%p decreasing refcount to %u.\n", enum_filters, ref);
 
     if (!ref)
     {
@@ -208,7 +209,7 @@ static HRESULT WINAPI EnumFilters_Next(IEnumFilters *iface, ULONG count,
     struct enum_filters *enum_filters = impl_from_IEnumFilters(iface);
     unsigned int i = 0;
 
-    TRACE("enum_filters %p, count %lu, filters %p, fetched %p.\n",
+    TRACE("enum_filters %p, count %u, filters %p, fetched %p.\n",
             enum_filters, count, filters, fetched);
 
     if (enum_filters->version != enum_filters->graph->version)
@@ -238,7 +239,7 @@ static HRESULT WINAPI EnumFilters_Skip(IEnumFilters *iface, ULONG count)
 {
     struct enum_filters *enum_filters = impl_from_IEnumFilters(iface);
 
-    TRACE("enum_filters %p, count %lu.\n", enum_filters, count);
+    TRACE("enum_filters %p, count %u.\n", enum_filters, count);
 
     if (enum_filters->version != enum_filters->graph->version)
         return VFW_E_ENUM_OUT_OF_SYNC;
@@ -418,24 +419,23 @@ static HRESULT WINAPI FilterGraphInner_QueryInterface(IUnknown *iface, REFIID ri
 
 static ULONG WINAPI FilterGraphInner_AddRef(IUnknown *iface)
 {
-    struct filter_graph *graph = impl_from_IUnknown(iface);
-    ULONG refcount = InterlockedIncrement(&graph->ref);
+    struct filter_graph *This = impl_from_IUnknown(iface);
+    ULONG ref = InterlockedIncrement(&This->ref);
 
-    TRACE("%p increasing refcount to %lu.\n", graph, refcount);
+    TRACE("(%p)->(): new ref = %d\n", This, ref);
 
-    return refcount;
+    return ref;
 }
 
 static ULONG WINAPI FilterGraphInner_Release(IUnknown *iface)
 {
     struct filter_graph *This = impl_from_IUnknown(iface);
-    ULONG refcount = InterlockedDecrement(&This->ref);
+    ULONG ref = InterlockedDecrement(&This->ref);
     struct list *cursor;
 
-    TRACE("%p decreasing refcount to %lu.\n", This, refcount);
+    TRACE("(%p)->(): new ref = %d\n", This, ref);
 
-    if (!refcount)
-    {
+    if (ref == 0) {
         int i;
 
         This->ref = 1; /* guard against reentrancy (aggregation). */
@@ -477,7 +477,7 @@ static ULONG WINAPI FilterGraphInner_Release(IUnknown *iface)
 	DeleteCriticalSection(&This->cs);
         free(This);
     }
-    return refcount;
+    return ref;
 }
 
 static struct filter_graph *impl_from_IFilterGraph2(IFilterGraph2 *iface)
@@ -507,6 +507,13 @@ static IBaseFilter *find_filter_by_name(struct filter_graph *graph, const WCHAR
 {
     struct filter *filter;
 
+    /* King of Fighters XIII requests the WMV decoder filter by name to
+     * connect it to a Sample Grabber filter, return our custom decoder
+     * filter instance instead.
+     */
+    if (!wcscmp(name, L"WMVideo Decoder DMO"))
+        name = L"GStreamer splitter filter";
+
     LIST_FOR_EACH_ENTRY(filter, &graph->filters, struct filter, entry)
     {
         if (!wcscmp(filter->name, name))
@@ -542,6 +549,7 @@ static BOOL has_output_pins(IBaseFilter *filter)
 
 static void update_seeking(struct filter *filter)
 {
+    IMediaPosition *position;
     IMediaSeeking *seeking;
 
     if (!filter->seeking)
@@ -560,11 +568,19 @@ static void update_seeking(struct filter *filter)
                 IMediaSeeking_Release(seeking);
         }
     }
+
+    if (!filter->position)
+    {
+        /* Tokyo Xanadu eX+, same as above, same developer, destroys its filter when
+         * its IMediaPosition interface is released, so cache the interface instead
+         * of querying for it every time. */
+        if (SUCCEEDED(IBaseFilter_QueryInterface(filter->filter, &IID_IMediaPosition, (void **)&position)))
+            filter->position = position;
+    }
 }
 
 static BOOL is_renderer(struct filter *filter)
 {
-    IMediaPosition *media_position;
     IAMFilterMiscFlags *flags;
     BOOL ret = FALSE;
 
@@ -574,16 +590,11 @@ static BOOL is_renderer(struct filter *filter)
             ret = TRUE;
         IAMFilterMiscFlags_Release(flags);
     }
-    else if (SUCCEEDED(IBaseFilter_QueryInterface(filter->filter, &IID_IMediaPosition, (void **)&media_position)))
-    {
-        if (!has_output_pins(filter->filter))
-            ret = TRUE;
-        IMediaPosition_Release(media_position);
-    }
     else
     {
         update_seeking(filter);
-        if (filter->seeking && !has_output_pins(filter->filter))
+        if ((filter->seeking || filter->position) &&
+            !has_output_pins(filter->filter))
             ret = TRUE;
     }
     return ret;
@@ -654,6 +665,7 @@ static HRESULT WINAPI FilterGraph2_AddFilter(IFilterGraph2 *iface,
     list_add_head(&graph->filters, &entry->entry);
     entry->sorting = FALSE;
     entry->seeking = NULL;
+    entry->position = NULL;
     ++graph->version;
 
     return duplicate_name ? VFW_S_DUPLICATE_NAME : hr;
@@ -695,7 +707,7 @@ static HRESULT WINAPI FilterGraph2_RemoveFilter(IFilterGraph2 *iface, IBaseFilte
                     {
                         if (FAILED(hr = IPin_Disconnect(peer)))
                         {
-                            WARN("Failed to disconnect peer %p, hr %#lx.\n", peer, hr);
+                            WARN("Failed to disconnect peer %p, hr %#x.\n", peer, hr);
                             IPin_Release(peer);
                             IPin_Release(ppin);
                             IEnumPins_Release(penumpins);
@@ -705,7 +717,7 @@ static HRESULT WINAPI FilterGraph2_RemoveFilter(IFilterGraph2 *iface, IBaseFilte
 
                         if (FAILED(hr = IPin_Disconnect(ppin)))
                         {
-                            WARN("Failed to disconnect pin %p, hr %#lx.\n", ppin, hr);
+                            WARN("Failed to disconnect pin %p, hr %#x.\n", ppin, hr);
                             IPin_Release(ppin);
                             IEnumPins_Release(penumpins);
                             return hr;
@@ -721,6 +733,8 @@ static HRESULT WINAPI FilterGraph2_RemoveFilter(IFilterGraph2 *iface, IBaseFilte
             {
                 IBaseFilter_SetSyncSource(pFilter, NULL);
                 IBaseFilter_Release(pFilter);
+                if (entry->position)
+                    IMediaPosition_Release(entry->position);
                 if (entry->seeking)
                     IMediaSeeking_Release(entry->seeking);
                 list_remove(&entry->entry);
@@ -772,66 +786,80 @@ static HRESULT WINAPI FilterGraph2_FindFilterByName(IFilterGraph2 *iface,
     return VFW_E_NOT_FOUND;
 }
 
-static HRESULT check_cyclic_connection(IPin *source, IPin *sink)
+/* Don't allow a circular connection to form, return VFW_E_CIRCULAR_GRAPH if this would be the case.
+ * A circular connection will be formed if from the filter of the output pin, the input pin can be reached
+ */
+static HRESULT CheckCircularConnection(struct filter_graph *This, IPin *out, IPin *in)
 {
-    IPin *upstream_source, *upstream_sink;
-    PIN_INFO source_info, sink_info;
-    IEnumPins *enumpins;
+#if 1
     HRESULT hr;
+    PIN_INFO info_out, info_in;
 
-    hr = IPin_QueryPinInfo(sink, &sink_info);
+    hr = IPin_QueryPinInfo(out, &info_out);
     if (FAILED(hr))
-    {
-        ERR("Failed to query pin, hr %#lx.\n", hr);
         return hr;
-    }
-    IBaseFilter_Release(sink_info.pFilter);
-
-    hr = IPin_QueryPinInfo(source, &source_info);
-    if (FAILED(hr))
+    if (info_out.dir != PINDIR_OUTPUT)
     {
-        ERR("Failed to query pin, hr %#lx.\n", hr);
-        return hr;
-    }
-
-    if (sink_info.pFilter == source_info.pFilter)
-    {
-        WARN("Cyclic connection detected; returning VFW_E_CIRCULAR_GRAPH.\n");
-        IBaseFilter_Release(source_info.pFilter);
-        return VFW_E_CIRCULAR_GRAPH;
+        IBaseFilter_Release(info_out.pFilter);
+        return VFW_E_CANNOT_CONNECT;
     }
 
-    hr = IBaseFilter_EnumPins(source_info.pFilter, &enumpins);
+    hr = IPin_QueryPinInfo(in, &info_in);
+    if (SUCCEEDED(hr))
+        IBaseFilter_Release(info_in.pFilter);
     if (FAILED(hr))
+        goto out;
+    if (info_in.dir != PINDIR_INPUT)
     {
-        ERR("Failed to enumerate pins, hr %#lx.\n", hr);
-        IBaseFilter_Release(source_info.pFilter);
-        return hr;
+        hr = VFW_E_CANNOT_CONNECT;
+        goto out;
     }
 
-    while ((hr = IEnumPins_Next(enumpins, 1, &upstream_sink, NULL)) == S_OK)
+    if (info_out.pFilter == info_in.pFilter)
+        hr = VFW_E_CIRCULAR_GRAPH;
+    else
     {
-        PIN_DIRECTION dir = PINDIR_OUTPUT;
+        IEnumPins *enumpins;
+        IPin *test;
 
-        IPin_QueryDirection(upstream_sink, &dir);
-        if (dir == PINDIR_INPUT && IPin_ConnectedTo(upstream_sink, &upstream_source) == S_OK)
+        hr = IBaseFilter_EnumPins(info_out.pFilter, &enumpins);
+        if (FAILED(hr))
+            goto out;
+
+        IEnumPins_Reset(enumpins);
+        while ((hr = IEnumPins_Next(enumpins, 1, &test, NULL)) == S_OK)
         {
-            hr = check_cyclic_connection(upstream_source, sink);
-            IPin_Release(upstream_source);
-            if (FAILED(hr))
+            PIN_DIRECTION dir = PINDIR_OUTPUT;
+            IPin_QueryDirection(test, &dir);
+            if (dir == PINDIR_INPUT)
             {
-                IPin_Release(upstream_sink);
-                IEnumPins_Release(enumpins);
-                IBaseFilter_Release(source_info.pFilter);
-                return hr;
+                IPin *victim = NULL;
+                IPin_ConnectedTo(test, &victim);
+                if (victim)
+                {
+                    hr = CheckCircularConnection(This, victim, in);
+                    IPin_Release(victim);
+                    if (FAILED(hr))
+                    {
+                        IPin_Release(test);
+                        break;
+                    }
+                }
             }
+            IPin_Release(test);
         }
-        IPin_Release(upstream_sink);
+        IEnumPins_Release(enumpins);
     }
-    IEnumPins_Release(enumpins);
 
-    IBaseFilter_Release(source_info.pFilter);
+out:
+    IBaseFilter_Release(info_out.pFilter);
+    if (FAILED(hr))
+        ERR("Checking filtergraph returned %08x, something's not right!\n", hr);
+    return hr;
+#else
+    /* Debugging filtergraphs not enabled */
     return S_OK;
+#endif
 }
 
 static struct filter *find_sorted_filter(struct filter_graph *graph, IBaseFilter *iface)
@@ -857,7 +885,7 @@ static void sort_filter_recurse(struct filter_graph *graph, struct filter *filte
 
     TRACE("Sorting filter %p.\n", filter->filter);
 
-    /* Cyclic connections should be caught by check_cyclic_connection(). */
+    /* Cyclic connections should be caught by CheckCircularConnection(). */
     assert(!filter->sorting);
 
     filter->sorting = TRUE;
@@ -937,13 +965,13 @@ static HRESULT WINAPI FilterGraph2_ConnectDirect(IFilterGraph2 *iface, IPin *ppi
     {
         if (dir == PINDIR_INPUT)
         {
-            hr = check_cyclic_connection(ppinOut, ppinIn);
+            hr = CheckCircularConnection(This, ppinOut, ppinIn);
             if (SUCCEEDED(hr))
                 hr = IPin_Connect(ppinOut, ppinIn, pmt);
         }
         else
         {
-            hr = check_cyclic_connection(ppinIn, ppinOut);
+            hr = CheckCircularConnection(This, ppinIn, ppinOut);
             if (SUCCEEDED(hr))
                 hr = IPin_Connect(ppinIn, ppinOut, pmt);
         }
@@ -1265,7 +1293,7 @@ static HRESULT autoplug(struct filter_graph *graph, IPin *source, IPin *sink,
 
             if (callback && FAILED(hr = IAMGraphBuilderCallback_SelectedFilter(callback, moniker)))
             {
-                TRACE("Filter rejected by IAMGraphBuilderCallback::SelectedFilter(), hr %#lx.\n", hr);
+                TRACE("Filter rejected by IAMGraphBuilderCallback::SelectedFilter(), hr %#x.\n", hr);
                 IMoniker_Release(moniker);
                 continue;
             }
@@ -1274,14 +1302,14 @@ static HRESULT autoplug(struct filter_graph *graph, IPin *source, IPin *sink,
             IMoniker_Release(moniker);
             if (FAILED(hr))
             {
-                ERR("Failed to create filter for %s, hr %#lx.\n", debugstr_w(V_BSTR(&var)), hr);
+                ERR("Failed to create filter for %s, hr %#x.\n", debugstr_w(V_BSTR(&var)), hr);
                 VariantClear(&var);
                 continue;
             }
 
             if (callback && FAILED(hr = IAMGraphBuilderCallback_CreatedFilter(callback, filter)))
             {
-                TRACE("Filter rejected by IAMGraphBuilderCallback::CreatedFilter(), hr %#lx.\n", hr);
+                TRACE("Filter rejected by IAMGraphBuilderCallback::CreatedFilter(), hr %#x.\n", hr);
                 IBaseFilter_Release(filter);
                 continue;
             }
@@ -1290,7 +1318,7 @@ static HRESULT autoplug(struct filter_graph *graph, IPin *source, IPin *sink,
             VariantClear(&var);
             if (FAILED(hr))
             {
-                ERR("Failed to add filter, hr %#lx.\n", hr);
+                ERR("Failed to add filter, hr %#x.\n", hr);
                 IBaseFilter_Release(filter);
                 continue;
             }
@@ -1348,89 +1376,10 @@ static HRESULT WINAPI FilterGraph2_Connect(IFilterGraph2 *iface, IPin *source, I
 
     LeaveCriticalSection(&graph->cs);
 
-    TRACE("Returning %#lx.\n", hr);
+    TRACE("Returning %#x.\n", hr);
     return hr;
 }
 
-/* CW HACK 19248 */
-static BOOL is_bethesda_game(void)
-{
-    static const WCHAR *exe_names[] = { L"oblivion.exe", L"fallout3.exe", L"morrowind.exe" };
-    WCHAR name[MAX_PATH], *module_exe;
-    int i;
-
-    if (!GetModuleFileNameW(NULL, name, sizeof(name)))
-        return FALSE;
-
-    module_exe = wcsrchr(name, '\\');
-    module_exe = module_exe ? module_exe + 1 : name;
-
-    for (i = 0; i < ARRAY_SIZE(exe_names); i++) {
-        if (!_wcsicmp(module_exe, exe_names[i]))
-            return TRUE;
-    }
-
-    return FALSE;
-}
-
-static BOOL is_mac_os(void)
-{
-    const char *sysname;
-    void (CDECL *my_wine_get_host_version)(const char **sysname, const char **release);
-
-    my_wine_get_host_version = (void *)GetProcAddress(GetModuleHandleW(L"ntdll.dll"), "wine_get_host_version");
-    if (!my_wine_get_host_version)
-        return FALSE;
-
-    my_wine_get_host_version(&sysname, NULL);
-
-    return !strcmp(sysname, "Darwin");
-}
-
-static BOOL needs_mp3_hack(void)
-{
-    static BOOL needs_hack, did_check = FALSE;
-
-    if (!did_check) {
-        needs_hack = is_mac_os() && is_bethesda_game();
-        did_check = TRUE;
-    }
-
-    return needs_hack;
-}
-
-static BOOL is_mp3_file(LPCWSTR filename)
-{
-    LPCWSTR ext = wcsrchr(filename, '.');
-    if (!ext)
-        return FALSE;
-
-    return !_wcsicmp(ext, L".mp3");
-}
-
-static BOOL is_fallout3_mp3_source(IPin *source)
-{
-    static const CLSID fallout_source_clsid = { 0xc553f2c0, 0x1529, 0x11d0, { 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea } };
-    PIN_INFO pin_info;
-    CLSID clsid;
-    HRESULT hr;
-
-    if (!source)
-        return FALSE;
-
-    hr = IPin_QueryPinInfo(source, &pin_info);
-    if (FAILED(hr))
-        return FALSE;
-
-    hr = IBaseFilter_GetClassID(pin_info.pFilter, &clsid);
-    IBaseFilter_Release(pin_info.pFilter);
-    if (FAILED(hr))
-        return FALSE;
-
-    return IsEqualGUID(&clsid, &fallout_source_clsid);
-}
-/* End hack */
-
 static HRESULT WINAPI FilterGraph2_Render(IFilterGraph2 *iface, IPin *source)
 {
     struct filter_graph *graph = impl_from_IFilterGraph2(iface);
@@ -1444,11 +1393,7 @@ static HRESULT WINAPI FilterGraph2_Render(IFilterGraph2 *iface, IPin *source)
     if (hr == VFW_E_CANNOT_CONNECT)
         hr = VFW_E_CANNOT_RENDER;
 
-    /* CW HACK 19248 */
-    if (FAILED(hr) && needs_mp3_hack() && is_fallout3_mp3_source(source))
-        hr = S_OK;
-
-    TRACE("Returning %#lx.\n", hr);
+    TRACE("Returning %#x.\n", hr);
     return hr;
 }
 
@@ -1501,13 +1446,8 @@ static HRESULT WINAPI FilterGraph2_RenderFile(IFilterGraph2 *iface, LPCWSTR lpcw
         if (!any)
         {
             if (FAILED(hr = IFilterGraph2_RemoveFilter(iface, preader)))
-                ERR("Failed to remove source filter, hr %#lx.\n", hr);
-
-            /* CW HACK 19248 */
-            if (needs_mp3_hack() && is_mp3_file(lpcwstrFile))
-                hr = S_OK;
-            else
-                hr = VFW_E_CANNOT_RENDER;
+                ERR("Failed to remove source filter, hr %#x.\n", hr);
+            hr = VFW_E_CANNOT_RENDER;
         }
         else if (partial)
         {
@@ -1520,7 +1460,7 @@ static HRESULT WINAPI FilterGraph2_RenderFile(IFilterGraph2 *iface, LPCWSTR lpcw
     }
     IBaseFilter_Release(preader);
 
-    TRACE("Returning %#lx.\n", hr);
+    TRACE("--> %08x\n", hr);
     return hr;
 }
 
@@ -1543,13 +1483,13 @@ static HRESULT WINAPI FilterGraph2_AddSourceFilter(IFilterGraph2 *iface,
     if (FAILED(hr = CoCreateInstance(&clsid, NULL, CLSCTX_INPROC_SERVER,
             &IID_IBaseFilter, (void **)&filter)))
     {
-        WARN("Failed to create filter, hr %#lx.\n", hr);
+        WARN("Failed to create filter, hr %#x.\n", hr);
         return hr;
     }
 
     if (FAILED(hr = IBaseFilter_QueryInterface(filter, &IID_IFileSourceFilter, (void **)&filesource)))
     {
-        WARN("Failed to get IFileSourceFilter, hr %#lx.\n", hr);
+        WARN("Failed to get IFileSourceFilter, hr %#x.\n", hr);
         IBaseFilter_Release(filter);
         return hr;
     }
@@ -1558,7 +1498,7 @@ static HRESULT WINAPI FilterGraph2_AddSourceFilter(IFilterGraph2 *iface,
     IFileSourceFilter_Release(filesource);
     if (FAILED(hr))
     {
-        WARN("Failed to load file, hr %#lx.\n", hr);
+        WARN("Failed to load file, hr %#x.\n", hr);
         return hr;
     }
 
@@ -1573,11 +1513,11 @@ static HRESULT WINAPI FilterGraph2_AddSourceFilter(IFilterGraph2 *iface,
     return S_OK;
 }
 
-static HRESULT WINAPI FilterGraph2_SetLogFile(IFilterGraph2 *iface, DWORD_PTR file)
+static HRESULT WINAPI FilterGraph2_SetLogFile(IFilterGraph2 *iface, DWORD_PTR hFile)
 {
-    struct filter_graph *graph = impl_from_IFilterGraph2(iface);
+    struct filter_graph *This = impl_from_IFilterGraph2(iface);
 
-    TRACE("graph %p, file %#Ix.\n", graph, file);
+    TRACE("(%p/%p)->(%08x): stub !!!\n", This, iface, (DWORD) hFile);
 
     return S_OK;
 }
@@ -1612,13 +1552,13 @@ static HRESULT WINAPI FilterGraph2_AddSourceFilterForMoniker(IFilterGraph2 *ifac
 
     hr = IMoniker_BindToObject(pMoniker, pCtx, NULL, &IID_IBaseFilter, (void**)&pfilter);
     if(FAILED(hr)) {
-        WARN("Failed to bind moniker, hr %#lx.\n", hr);
+        WARN("Unable to bind moniker to filter object (%x)\n", hr);
         return hr;
     }
 
     hr = IFilterGraph2_AddFilter(iface, pfilter, lpcwstrFilterName);
     if (FAILED(hr)) {
-        WARN("Failed to add filter, hr %#lx.\n", hr);
+        WARN("Unable to add filter (%x)\n", hr);
         IBaseFilter_Release(pfilter);
         return hr;
     }
@@ -1660,10 +1600,10 @@ static HRESULT WINAPI FilterGraph2_RenderEx(IFilterGraph2 *iface, IPin *source,
     struct filter_graph *graph = impl_from_IFilterGraph2(iface);
     HRESULT hr;
 
-    TRACE("graph %p, source %p, flags %#lx, context %p.\n", graph, source, flags, context);
+    TRACE("graph %p, source %p, flags %#x, context %p.\n", graph, source, flags, context);
 
     if (flags & ~AM_RENDEREX_RENDERTOEXISTINGRENDERERS)
-        FIXME("Unknown flags %#lx.\n", flags);
+        FIXME("Unknown flags %#x.\n", flags);
 
     EnterCriticalSection(&graph->cs);
     hr = autoplug(graph, source, NULL, !!(flags & AM_RENDEREX_RENDERTOEXISTINGRENDERERS), 0);
@@ -1671,7 +1611,7 @@ static HRESULT WINAPI FilterGraph2_RenderEx(IFilterGraph2 *iface, IPin *source,
     if (hr == VFW_E_CANNOT_CONNECT)
         hr = VFW_E_CANNOT_RENDER;
 
-    TRACE("Returning %#lx.\n", hr);
+    TRACE("Returning %#x.\n", hr);
     return hr;
 }
 
@@ -1725,52 +1665,47 @@ static ULONG WINAPI MediaControl_Release(IMediaControl *iface)
 
 }
 
-static HRESULT WINAPI MediaControl_GetTypeInfoCount(IMediaControl *iface, UINT *count)
+/*** IDispatch methods ***/
+static HRESULT WINAPI MediaControl_GetTypeInfoCount(IMediaControl *iface, UINT *pctinfo)
 {
-    TRACE("iface %p, count %p.\n", iface, count);
-    *count = 1;
+    struct filter_graph *This = impl_from_IMediaControl(iface);
+
+    TRACE("(%p/%p)->(%p): stub !!!\n", This, iface, pctinfo);
+
     return S_OK;
 }
 
-static HRESULT WINAPI MediaControl_GetTypeInfo(IMediaControl *iface, UINT index,
-        LCID lcid, ITypeInfo **typeinfo)
+static HRESULT WINAPI MediaControl_GetTypeInfo(IMediaControl *iface, UINT iTInfo, LCID lcid,
+        ITypeInfo **ppTInfo)
 {
-    TRACE("iface %p, index %u, lcid %#lx, typeinfo %p.\n", iface, index, lcid, typeinfo);
-    return strmbase_get_typeinfo(IMediaControl_tid, typeinfo);
+    struct filter_graph *This = impl_from_IMediaControl(iface);
+
+    TRACE("(%p/%p)->(%d, %d, %p): stub !!!\n", This, iface, iTInfo, lcid, ppTInfo);
+
+    return S_OK;
 }
 
-static HRESULT WINAPI MediaControl_GetIDsOfNames(IMediaControl *iface, REFIID iid,
-        LPOLESTR *names, UINT count, LCID lcid, DISPID *ids)
+static HRESULT WINAPI MediaControl_GetIDsOfNames(IMediaControl *iface, REFIID riid,
+        LPOLESTR *rgszNames, UINT cNames, LCID lcid, DISPID *rgDispId)
 {
-    ITypeInfo *typeinfo;
-    HRESULT hr;
+    struct filter_graph *This = impl_from_IMediaControl(iface);
 
-    TRACE("iface %p, iid %s, names %p, count %u, lcid %#lx, ids %p.\n",
-            iface, debugstr_guid(iid), names, count, lcid, ids);
+    TRACE("(%p/%p)->(%s, %p, %d, %d, %p): stub !!!\n", This, iface, debugstr_guid(riid), rgszNames,
+            cNames, lcid, rgDispId);
 
-    if (SUCCEEDED(hr = strmbase_get_typeinfo(IMediaControl_tid, &typeinfo)))
-    {
-        hr = ITypeInfo_GetIDsOfNames(typeinfo, names, count, ids);
-        ITypeInfo_Release(typeinfo);
-    }
-    return hr;
+    return S_OK;
 }
 
-static HRESULT WINAPI MediaControl_Invoke(IMediaControl *iface, DISPID id, REFIID iid, LCID lcid,
-        WORD flags, DISPPARAMS *params, VARIANT *result, EXCEPINFO *excepinfo, UINT *error_arg)
+static HRESULT WINAPI MediaControl_Invoke(IMediaControl *iface, DISPID dispIdMember, REFIID riid,
+        LCID lcid, WORD wFlags, DISPPARAMS *pDispParams, VARIANT *pVarResult, EXCEPINFO *pExepInfo,
+        UINT *puArgErr)
 {
-    ITypeInfo *typeinfo;
-    HRESULT hr;
+    struct filter_graph *This = impl_from_IMediaControl(iface);
 
-    TRACE("iface %p, id %ld, iid %s, lcid %#lx, flags %#x, params %p, result %p, excepinfo %p, error_arg %p.\n",
-            iface, id, debugstr_guid(iid), lcid, flags, params, result, excepinfo, error_arg);
+    TRACE("(%p/%p)->(%d, %s, %d, %04x, %p, %p, %p, %p): stub !!!\n", This, iface, dispIdMember,
+            debugstr_guid(riid), lcid, wFlags, pDispParams, pVarResult, pExepInfo, puArgErr);
 
-    if (SUCCEEDED(hr = strmbase_get_typeinfo(IMediaControl_tid, &typeinfo)))
-    {
-        hr = ITypeInfo_Invoke(typeinfo, iface, id, flags, params, result, excepinfo, error_arg);
-        ITypeInfo_Release(typeinfo);
-    }
-    return hr;
+    return S_OK;
 }
 
 static void update_render_count(struct filter_graph *graph)
@@ -1830,11 +1765,11 @@ static HRESULT graph_start(struct filter_graph *graph, REFERENCE_TIME stream_sta
         HRESULT filter_hr = IBaseFilter_Run(filter->filter, stream_start);
         if (hr == S_OK)
             hr = filter_hr;
-        TRACE("Filter %p returned %#lx.\n", filter->filter, filter_hr);
+        TRACE("Filter %p returned %#x.\n", filter->filter, filter_hr);
     }
 
     if (FAILED(hr))
-        WARN("Failed to start stream, hr %#lx.\n", hr);
+        WARN("Failed to start stream, hr %#x.\n", hr);
 
     return hr;
 }
@@ -1929,7 +1864,7 @@ static HRESULT WINAPI MediaControl_Run(IMediaControl *iface)
             HRESULT filter_hr = IBaseFilter_Pause(filter->filter);
             if (hr == S_OK)
                 hr = filter_hr;
-            TRACE("Filter %p returned %#lx.\n", filter->filter, filter_hr);
+            TRACE("Filter %p returned %#x.\n", filter->filter, filter_hr);
 
             /* If a filter returns VFW_S_CANT_CUE, we shouldn't wait for a
              * paused state. */
@@ -1941,7 +1876,7 @@ static HRESULT WINAPI MediaControl_Run(IMediaControl *iface)
         if (FAILED(hr))
         {
             LeaveCriticalSection(&graph->cs);
-            WARN("Failed to pause, hr %#lx.\n", hr);
+            WARN("Failed to pause, hr %#x.\n", hr);
             return hr;
         }
     }
@@ -1989,7 +1924,7 @@ static HRESULT WINAPI MediaControl_GetState(IMediaControl *iface, LONG timeout,
 {
     struct filter_graph *graph = impl_from_IMediaControl(iface);
 
-    TRACE("graph %p, timeout %ld, state %p.\n", graph, timeout, state);
+    TRACE("graph %p, timeout %u, state %p.\n", graph, timeout, state);
 
     if (timeout < 0) timeout = INFINITE;
 
@@ -2040,13 +1975,13 @@ static void CALLBACK wait_pause_cb(TP_CALLBACK_INSTANCE *instance, void *context
     HRESULT hr;
 
     if ((hr = IMediaControl_GetState(control, INFINITE, &state)) != S_OK)
-        ERR("Failed to get paused state, hr %#lx.\n", hr);
+        ERR("Failed to get paused state, hr %#x.\n", hr);
 
     if (FAILED(hr = IMediaControl_Stop(control)))
-        ERR("Failed to stop, hr %#lx.\n", hr);
+        ERR("Failed to stop, hr %#x.\n", hr);
 
     if ((hr = IMediaControl_GetState(control, INFINITE, &state)) != S_OK)
-        ERR("Failed to get paused state, hr %#lx.\n", hr);
+        ERR("Failed to get paused state, hr %#x.\n", hr);
 
     IMediaControl_Release(control);
 }
@@ -2058,7 +1993,7 @@ static void CALLBACK wait_stop_cb(TP_CALLBACK_INSTANCE *instance, void *context)
     HRESULT hr;
 
     if ((hr = IMediaControl_GetState(control, INFINITE, &state)) != S_OK)
-        ERR("Failed to get state, hr %#lx.\n", hr);
+        ERR("Failed to get state, hr %#x.\n", hr);
 
     IMediaControl_Release(control);
 }
@@ -2145,6 +2080,9 @@ static HRESULT all_renderers_seek(struct filter_graph *This, fnFoundSeek FoundSe
     HRESULT hr, hr_return = S_OK;
     struct filter *filter;
 
+    TRACE("(%p)->(%p %08lx)\n", This, FoundSeek, arg);
+    /* Send a message to all renderers, they are responsible for broadcasting it further */
+
     LIST_FOR_EACH_ENTRY(filter, &This->filters, struct filter, entry)
     {
         update_seeking(filter);
@@ -2336,7 +2274,7 @@ static HRESULT WINAPI MediaSeeking_GetDuration(IMediaSeeking *iface, LONGLONG *d
 
     LeaveCriticalSection(&graph->cs);
 
-    TRACE("Returning hr %#lx, duration %s (%s seconds).\n", hr,
+    TRACE("Returning hr %#x, duration %s (%s seconds).\n", hr,
             wine_dbgstr_longlong(*duration), debugstr_time(*duration));
     return hr;
 }
@@ -2444,7 +2382,7 @@ static HRESULT WINAPI MediaSeeking_SetPositions(IMediaSeeking *iface, LONGLONG *
     struct filter *filter;
     FILTER_STATE state;
 
-    TRACE("graph %p, current %s, current_flags %#lx, stop %s, stop_flags %#lx.\n", graph,
+    TRACE("graph %p, current %s, current_flags %#x, stop %s, stop_flags %#x.\n", graph,
             current_ptr ? wine_dbgstr_longlong(*current_ptr) : "<null>", current_flags,
             stop_ptr ? wine_dbgstr_longlong(*stop_ptr): "<null>", stop_flags);
     if (current_ptr)
@@ -2456,11 +2394,11 @@ static HRESULT WINAPI MediaSeeking_SetPositions(IMediaSeeking *iface, LONGLONG *
 
     if ((current_flags & 0x7) != AM_SEEKING_AbsolutePositioning
             && (current_flags & 0x7) != AM_SEEKING_NoPositioning)
-        FIXME("Unhandled current_flags %#lx.\n", current_flags & 0x7);
+        FIXME("Unhandled current_flags %#x.\n", current_flags & 0x7);
 
     if ((stop_flags & 0x7) != AM_SEEKING_NoPositioning
             && (stop_flags & 0x7) != AM_SEEKING_AbsolutePositioning)
-        FIXME("Unhandled stop_flags %#lx.\n", stop_flags & 0x7);
+        FIXME("Unhandled stop_flags %#x.\n", stop_flags & 0x7);
 
     EnterCriticalSection(&graph->cs);
 
@@ -2615,52 +2553,29 @@ static ULONG WINAPI MediaPosition_Release(IMediaPosition *iface)
     return IUnknown_Release(graph->outer_unk);
 }
 
-static HRESULT WINAPI MediaPosition_GetTypeInfoCount(IMediaPosition *iface, UINT *count)
+/*** IDispatch methods ***/
+static HRESULT WINAPI MediaPosition_GetTypeInfoCount(IMediaPosition *iface, UINT* pctinfo)
 {
-    TRACE("iface %p, count %p.\n", iface, count);
-    *count = 1;
-    return S_OK;
+    FIXME("(%p) stub!\n", iface);
+    return E_NOTIMPL;
 }
 
-static HRESULT WINAPI MediaPosition_GetTypeInfo(IMediaPosition *iface, UINT index,
-        LCID lcid, ITypeInfo **typeinfo)
+static HRESULT WINAPI MediaPosition_GetTypeInfo(IMediaPosition *iface, UINT iTInfo, LCID lcid, ITypeInfo** ppTInfo)
 {
-    TRACE("iface %p, index %u, lcid %#lx, typeinfo %p.\n", iface, index, lcid, typeinfo);
-    return strmbase_get_typeinfo(IMediaPosition_tid, typeinfo);
+    FIXME("(%p) stub!\n", iface);
+    return E_NOTIMPL;
 }
 
-static HRESULT WINAPI MediaPosition_GetIDsOfNames(IMediaPosition *iface, REFIID iid,
-        LPOLESTR *names, UINT count, LCID lcid, DISPID *ids)
+static HRESULT WINAPI MediaPosition_GetIDsOfNames(IMediaPosition* iface, REFIID riid, LPOLESTR* rgszNames, UINT cNames, LCID lcid, DISPID* rgDispId)
 {
-    ITypeInfo *typeinfo;
-    HRESULT hr;
-
-    TRACE("iface %p, iid %s, names %p, count %u, lcid %#lx, ids %p.\n",
-            iface, debugstr_guid(iid), names, count, lcid, ids);
-
-    if (SUCCEEDED(hr = strmbase_get_typeinfo(IMediaPosition_tid, &typeinfo)))
-    {
-        hr = ITypeInfo_GetIDsOfNames(typeinfo, names, count, ids);
-        ITypeInfo_Release(typeinfo);
-    }
-    return hr;
+    FIXME("(%p) stub!\n", iface);
+    return E_NOTIMPL;
 }
 
-static HRESULT WINAPI MediaPosition_Invoke(IMediaPosition *iface, DISPID id, REFIID iid, LCID lcid,
-        WORD flags, DISPPARAMS *params, VARIANT *result, EXCEPINFO *excepinfo, UINT *error_arg)
+static HRESULT WINAPI MediaPosition_Invoke(IMediaPosition* iface, DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS* pDispParams, VARIANT* pVarResult, EXCEPINFO* pExcepInfo, UINT* puArgErr)
 {
-    ITypeInfo *typeinfo;
-    HRESULT hr;
-
-    TRACE("iface %p, id %ld, iid %s, lcid %#lx, flags %#x, params %p, result %p, excepinfo %p, error_arg %p.\n",
-            iface, id, debugstr_guid(iid), lcid, flags, params, result, excepinfo, error_arg);
-
-    if (SUCCEEDED(hr = strmbase_get_typeinfo(IMediaPosition_tid, &typeinfo)))
-    {
-        hr = ITypeInfo_Invoke(typeinfo, iface, id, flags, params, result, excepinfo, error_arg);
-        ITypeInfo_Release(typeinfo);
-    }
-    return hr;
+    FIXME("(%p) stub!\n", iface);
+    return E_NOTIMPL;
 }
 
 static HRESULT ConvertFromREFTIME(IMediaSeeking *seek, REFTIME time_in, LONGLONG *time_out)
@@ -2954,7 +2869,7 @@ static HRESULT WINAPI BasicAudio_GetTypeInfoCount(IBasicAudio *iface, UINT *coun
 static HRESULT WINAPI BasicAudio_GetTypeInfo(IBasicAudio *iface, UINT index,
         LCID lcid, ITypeInfo **typeinfo)
 {
-    TRACE("iface %p, index %u, lcid %#lx, typeinfo %p.\n", iface, index, lcid, typeinfo);
+    TRACE("iface %p, index %u, lcid %#x, typeinfo %p.\n", iface, index, lcid, typeinfo);
     return strmbase_get_typeinfo(IBasicAudio_tid, typeinfo);
 }
 
@@ -2964,7 +2879,7 @@ static HRESULT WINAPI BasicAudio_GetIDsOfNames(IBasicAudio *iface, REFIID iid,
     ITypeInfo *typeinfo;
     HRESULT hr;
 
-    TRACE("iface %p, iid %s, names %p, count %u, lcid %#lx, ids %p.\n",
+    TRACE("iface %p, iid %s, names %p, count %u, lcid %#x, ids %p.\n",
             iface, debugstr_guid(iid), names, count, lcid, ids);
 
     if (SUCCEEDED(hr = strmbase_get_typeinfo(IBasicAudio_tid, &typeinfo)))
@@ -2981,7 +2896,7 @@ static HRESULT WINAPI BasicAudio_Invoke(IBasicAudio *iface, DISPID id, REFIID ii
     ITypeInfo *typeinfo;
     HRESULT hr;
 
-    TRACE("iface %p, id %ld, iid %s, lcid %#lx, flags %#x, params %p, result %p, excepinfo %p, error_arg %p.\n",
+    TRACE("iface %p, id %d, iid %s, lcid %#x, flags %#x, params %p, result %p, excepinfo %p, error_arg %p.\n",
             iface, id, debugstr_guid(iid), lcid, flags, params, result, excepinfo, error_arg);
 
     if (SUCCEEDED(hr = strmbase_get_typeinfo(IBasicAudio_tid, &typeinfo)))
@@ -2999,7 +2914,7 @@ static HRESULT WINAPI BasicAudio_put_Volume(IBasicAudio *iface, LONG lVolume)
     IBasicAudio* pBasicAudio;
     HRESULT hr;
 
-    TRACE("graph %p, volume %ld.\n", This, lVolume);
+    TRACE("(%p/%p)->(%d)\n", This, iface, lVolume);
 
     EnterCriticalSection(&This->cs);
 
@@ -3039,7 +2954,7 @@ static HRESULT WINAPI BasicAudio_put_Balance(IBasicAudio *iface, LONG lBalance)
     IBasicAudio* pBasicAudio;
     HRESULT hr;
 
-    TRACE("graph %p, balance %ld.\n", This, lBalance);
+    TRACE("(%p/%p)->(%d)\n", This, iface, lBalance);
 
     EnterCriticalSection(&This->cs);
 
@@ -3121,7 +3036,7 @@ static HRESULT WINAPI BasicVideo_GetTypeInfoCount(IBasicVideo2 *iface, UINT *cou
 static HRESULT WINAPI BasicVideo_GetTypeInfo(IBasicVideo2 *iface, UINT index,
         LCID lcid, ITypeInfo **typeinfo)
 {
-    TRACE("iface %p, index %u, lcid %#lx, typeinfo %p.\n", iface, index, lcid, typeinfo);
+    TRACE("iface %p, index %u, lcid %#x, typeinfo %p.\n", iface, index, lcid, typeinfo);
     return strmbase_get_typeinfo(IBasicVideo_tid, typeinfo);
 }
 
@@ -3131,7 +3046,7 @@ static HRESULT WINAPI BasicVideo_GetIDsOfNames(IBasicVideo2 *iface, REFIID iid,
     ITypeInfo *typeinfo;
     HRESULT hr;
 
-    TRACE("iface %p, iid %s, names %p, count %u, lcid %#lx, ids %p.\n",
+    TRACE("iface %p, iid %s, names %p, count %u, lcid %#x, ids %p.\n",
             iface, debugstr_guid(iid), names, count, lcid, ids);
 
     if (SUCCEEDED(hr = strmbase_get_typeinfo(IBasicVideo_tid, &typeinfo)))
@@ -3148,7 +3063,7 @@ static HRESULT WINAPI BasicVideo_Invoke(IBasicVideo2 *iface, DISPID id, REFIID i
     ITypeInfo *typeinfo;
     HRESULT hr;
 
-    TRACE("iface %p, id %ld, iid %s, lcid %#lx, flags %#x, params %p, result %p, excepinfo %p, error_arg %p.\n",
+    TRACE("iface %p, id %d, iid %s, lcid %#x, flags %#x, params %p, result %p, excepinfo %p, error_arg %p.\n",
             iface, id, debugstr_guid(iid), lcid, flags, params, result, excepinfo, error_arg);
 
     if (SUCCEEDED(hr = strmbase_get_typeinfo(IBasicVideo_tid, &typeinfo)))
@@ -3266,7 +3181,7 @@ static HRESULT WINAPI BasicVideo_put_SourceLeft(IBasicVideo2 *iface, LONG Source
     IBasicVideo *pBasicVideo;
     HRESULT hr;
 
-    TRACE("graph %p, left %ld.\n", This, SourceLeft);
+    TRACE("(%p/%p)->(%d)\n", This, iface, SourceLeft);
 
     EnterCriticalSection(&This->cs);
 
@@ -3306,7 +3221,7 @@ static HRESULT WINAPI BasicVideo_put_SourceWidth(IBasicVideo2 *iface, LONG Sourc
     IBasicVideo *pBasicVideo;
     HRESULT hr;
 
-    TRACE("graph %p, width %ld.\n", This, SourceWidth);
+    TRACE("(%p/%p)->(%d)\n", This, iface, SourceWidth);
 
     EnterCriticalSection(&This->cs);
 
@@ -3346,7 +3261,7 @@ static HRESULT WINAPI BasicVideo_put_SourceTop(IBasicVideo2 *iface, LONG SourceT
     IBasicVideo *pBasicVideo;
     HRESULT hr;
 
-    TRACE("graph %p, top %ld.\n", This, SourceTop);
+    TRACE("(%p/%p)->(%d)\n", This, iface, SourceTop);
 
     EnterCriticalSection(&This->cs);
 
@@ -3386,7 +3301,7 @@ static HRESULT WINAPI BasicVideo_put_SourceHeight(IBasicVideo2 *iface, LONG Sour
     IBasicVideo *pBasicVideo;
     HRESULT hr;
 
-    TRACE("graph %p, height %ld.\n", This, SourceHeight);
+    TRACE("(%p/%p)->(%d)\n", This, iface, SourceHeight);
 
     EnterCriticalSection(&This->cs);
 
@@ -3426,7 +3341,7 @@ static HRESULT WINAPI BasicVideo_put_DestinationLeft(IBasicVideo2 *iface, LONG D
     IBasicVideo *pBasicVideo;
     HRESULT hr;
 
-    TRACE("graph %p, left %ld.\n", This, DestinationLeft);
+    TRACE("(%p/%p)->(%d)\n", This, iface, DestinationLeft);
 
     EnterCriticalSection(&This->cs);
 
@@ -3466,7 +3381,7 @@ static HRESULT WINAPI BasicVideo_put_DestinationWidth(IBasicVideo2 *iface, LONG
     IBasicVideo *pBasicVideo;
     HRESULT hr;
 
-    TRACE("graph %p, width %ld.\n", This, DestinationWidth);
+    TRACE("(%p/%p)->(%d)\n", This, iface, DestinationWidth);
 
     EnterCriticalSection(&This->cs);
 
@@ -3506,7 +3421,7 @@ static HRESULT WINAPI BasicVideo_put_DestinationTop(IBasicVideo2 *iface, LONG De
     IBasicVideo *pBasicVideo;
     HRESULT hr;
 
-    TRACE("graph %p, top %ld.\n", This, DestinationTop);
+    TRACE("(%p/%p)->(%d)\n", This, iface, DestinationTop);
 
     EnterCriticalSection(&This->cs);
 
@@ -3546,7 +3461,7 @@ static HRESULT WINAPI BasicVideo_put_DestinationHeight(IBasicVideo2 *iface, LONG
     IBasicVideo *pBasicVideo;
     HRESULT hr;
 
-    TRACE("graph %p, height %ld.\n", This, DestinationHeight);
+    TRACE("(%p/%p)->(%d)\n", This, iface, DestinationHeight);
 
     EnterCriticalSection(&This->cs);
 
@@ -3588,7 +3503,7 @@ static HRESULT WINAPI BasicVideo_SetSourcePosition(IBasicVideo2 *iface, LONG Lef
     IBasicVideo *pBasicVideo;
     HRESULT hr;
 
-    TRACE("graph %p, left %ld, top %ld, width %ld, height %ld.\n", This, Left, Top, Width, Height);
+    TRACE("(%p/%p)->(%d, %d, %d, %d)\n", This, iface, Left, Top, Width, Height);
 
     EnterCriticalSection(&This->cs);
 
@@ -3650,7 +3565,7 @@ static HRESULT WINAPI BasicVideo_SetDestinationPosition(IBasicVideo2 *iface, LON
     IBasicVideo *pBasicVideo;
     HRESULT hr;
 
-    TRACE("graph %p, left %ld, top %ld, width %ld, height %ld.\n", This, Left, Top, Width, Height);
+    TRACE("(%p/%p)->(%d, %d, %d, %d)\n", This, iface, Left, Top, Width, Height);
 
     EnterCriticalSection(&This->cs);
 
@@ -3732,8 +3647,7 @@ static HRESULT WINAPI BasicVideo_GetVideoPaletteEntries(IBasicVideo2 *iface, LON
     IBasicVideo *pBasicVideo;
     HRESULT hr;
 
-    TRACE("graph %p, start_index %ld, count %ld, ret_count %p, entries %p.\n",
-            This, StartIndex, Entries, pRetrieved, pPalette);
+    TRACE("(%p/%p)->(%d, %d, %p, %p)\n", This, iface, StartIndex, Entries, pRetrieved, pPalette);
 
     EnterCriticalSection(&This->cs);
 
@@ -3906,7 +3820,7 @@ HRESULT WINAPI VideoWindow_GetTypeInfoCount(IVideoWindow *iface, UINT *count)
 HRESULT WINAPI VideoWindow_GetTypeInfo(IVideoWindow *iface, UINT index,
         LCID lcid, ITypeInfo **typeinfo)
 {
-    TRACE("iface %p, index %u, lcid %#lx, typeinfo %p.\n", iface, index, lcid, typeinfo);
+    TRACE("iface %p, index %u, lcid %#x, typeinfo %p.\n", iface, index, lcid, typeinfo);
     return strmbase_get_typeinfo(IVideoWindow_tid, typeinfo);
 }
 
@@ -3916,7 +3830,7 @@ HRESULT WINAPI VideoWindow_GetIDsOfNames(IVideoWindow *iface, REFIID iid,
     ITypeInfo *typeinfo;
     HRESULT hr;
 
-    TRACE("iface %p, iid %s, names %p, count %u, lcid %#lx, ids %p.\n",
+    TRACE("iface %p, iid %s, names %p, count %u, lcid %#x, ids %p.\n",
             iface, debugstr_guid(iid), names, count, lcid, ids);
 
     if (SUCCEEDED(hr = strmbase_get_typeinfo(IVideoWindow_tid, &typeinfo)))
@@ -3933,7 +3847,7 @@ static HRESULT WINAPI VideoWindow_Invoke(IVideoWindow *iface, DISPID id, REFIID
     ITypeInfo *typeinfo;
     HRESULT hr;
 
-    TRACE("iface %p, id %ld, iid %s, lcid %#lx, flags %#x, params %p, result %p, excepinfo %p, error_arg %p.\n",
+    TRACE("iface %p, id %d, iid %s, lcid %#x, flags %#x, params %p, result %p, excepinfo %p, error_arg %p.\n",
             iface, id, debugstr_guid(iid), lcid, flags, params, result, excepinfo, error_arg);
 
     if (SUCCEEDED(hr = strmbase_get_typeinfo(IVideoWindow_tid, &typeinfo)))
@@ -3991,7 +3905,7 @@ static HRESULT WINAPI VideoWindow_put_WindowStyle(IVideoWindow *iface, LONG Wind
     IVideoWindow *pVideoWindow;
     HRESULT hr;
 
-    TRACE("graph %p, style %#lx.\n", This, WindowStyle);
+    TRACE("(%p/%p)->(%d)\n", This, iface, WindowStyle);
 
     EnterCriticalSection(&This->cs);
 
@@ -4031,7 +3945,7 @@ static HRESULT WINAPI VideoWindow_put_WindowStyleEx(IVideoWindow *iface, LONG Wi
     IVideoWindow *pVideoWindow;
     HRESULT hr;
 
-    TRACE("graph %p, style %#lx.\n", This, WindowStyleEx);
+    TRACE("(%p/%p)->(%d)\n", This, iface, WindowStyleEx);
 
     EnterCriticalSection(&This->cs);
 
@@ -4071,7 +3985,7 @@ static HRESULT WINAPI VideoWindow_put_AutoShow(IVideoWindow *iface, LONG AutoSho
     IVideoWindow *pVideoWindow;
     HRESULT hr;
 
-    TRACE("graph %p, show %#lx.\n", This, AutoShow);
+    TRACE("(%p/%p)->(%d)\n", This, iface, AutoShow);
 
     EnterCriticalSection(&This->cs);
 
@@ -4111,7 +4025,7 @@ static HRESULT WINAPI VideoWindow_put_WindowState(IVideoWindow *iface, LONG Wind
     IVideoWindow *pVideoWindow;
     HRESULT hr;
 
-    TRACE("graph %p, state %ld.\n", This, WindowState);
+    TRACE("(%p/%p)->(%d)\n", This, iface, WindowState);
 
     EnterCriticalSection(&This->cs);
 
@@ -4151,7 +4065,7 @@ static HRESULT WINAPI VideoWindow_put_BackgroundPalette(IVideoWindow *iface, LON
     IVideoWindow *pVideoWindow;
     HRESULT hr;
 
-    TRACE("graph %p, palette %ld.\n", This, BackgroundPalette);
+    TRACE("(%p/%p)->(%d)\n", This, iface, BackgroundPalette);
 
     EnterCriticalSection(&This->cs);
 
@@ -4192,7 +4106,7 @@ static HRESULT WINAPI VideoWindow_put_Visible(IVideoWindow *iface, LONG Visible)
     IVideoWindow *pVideoWindow;
     HRESULT hr;
 
-    TRACE("graph %p, visible %ld.\n", This, Visible);
+    TRACE("(%p/%p)->(%d)\n", This, iface, Visible);
 
     EnterCriticalSection(&This->cs);
 
@@ -4232,7 +4146,7 @@ static HRESULT WINAPI VideoWindow_put_Left(IVideoWindow *iface, LONG Left)
     IVideoWindow *pVideoWindow;
     HRESULT hr;
 
-    TRACE("graph %p, left %ld.\n", This, Left);
+    TRACE("(%p/%p)->(%d)\n", This, iface, Left);
 
     EnterCriticalSection(&This->cs);
 
@@ -4272,7 +4186,7 @@ static HRESULT WINAPI VideoWindow_put_Width(IVideoWindow *iface, LONG Width)
     IVideoWindow *pVideoWindow;
     HRESULT hr;
 
-    TRACE("graph %p, width %ld.\n", This, Width);
+    TRACE("(%p/%p)->(%d)\n", This, iface, Width);
 
     EnterCriticalSection(&This->cs);
 
@@ -4312,7 +4226,7 @@ static HRESULT WINAPI VideoWindow_put_Top(IVideoWindow *iface, LONG Top)
     IVideoWindow *pVideoWindow;
     HRESULT hr;
 
-    TRACE("graph %p, top %ld.\n", This, Top);
+    TRACE("(%p/%p)->(%d)\n", This, iface, Top);
 
     EnterCriticalSection(&This->cs);
 
@@ -4352,7 +4266,7 @@ static HRESULT WINAPI VideoWindow_put_Height(IVideoWindow *iface, LONG Height)
     IVideoWindow *pVideoWindow;
     HRESULT hr;
 
-    TRACE("graph %p, height %ld.\n", This, Height);
+    TRACE("(%p/%p)->(%d)\n", This, iface, Height);
 
     EnterCriticalSection(&This->cs);
 
@@ -4392,7 +4306,7 @@ static HRESULT WINAPI VideoWindow_put_Owner(IVideoWindow *iface, OAHWND Owner)
     IVideoWindow *pVideoWindow;
     HRESULT hr;
 
-    TRACE("graph %p, owner %#Ix.\n", This, Owner);
+    TRACE("(%p/%p)->(%08x)\n", This, iface, (DWORD) Owner);
 
     EnterCriticalSection(&This->cs);
 
@@ -4432,7 +4346,7 @@ static HRESULT WINAPI VideoWindow_put_MessageDrain(IVideoWindow *iface, OAHWND D
     IVideoWindow *pVideoWindow;
     HRESULT hr;
 
-    TRACE("graph %p, drain %#Ix.\n", This, Drain);
+    TRACE("(%p/%p)->(%08x)\n", This, iface, (DWORD) Drain);
 
     EnterCriticalSection(&This->cs);
 
@@ -4492,7 +4406,7 @@ static HRESULT WINAPI VideoWindow_put_BorderColor(IVideoWindow *iface, LONG Colo
     IVideoWindow *pVideoWindow;
     HRESULT hr;
 
-    TRACE("graph %p, colour %#lx.\n", This, Color);
+    TRACE("(%p/%p)->(%d)\n", This, iface, Color);
 
     EnterCriticalSection(&This->cs);
 
@@ -4532,7 +4446,7 @@ static HRESULT WINAPI VideoWindow_put_FullScreenMode(IVideoWindow *iface, LONG F
     IVideoWindow *pVideoWindow;
     HRESULT hr;
 
-    TRACE("graph %p, fullscreen %ld.\n", This, FullScreenMode);
+    TRACE("(%p/%p)->(%d)\n", This, iface, FullScreenMode);
 
     EnterCriticalSection(&This->cs);
 
@@ -4552,7 +4466,7 @@ static HRESULT WINAPI VideoWindow_SetWindowForeground(IVideoWindow *iface, LONG
     IVideoWindow *pVideoWindow;
     HRESULT hr;
 
-    TRACE("graph %p, focus %ld.\n", This, Focus);
+    TRACE("(%p/%p)->(%d)\n", This, iface, Focus);
 
     EnterCriticalSection(&This->cs);
 
@@ -4573,7 +4487,7 @@ static HRESULT WINAPI VideoWindow_NotifyOwnerMessage(IVideoWindow *iface, OAHWND
     IVideoWindow *pVideoWindow;
     HRESULT hr;
 
-    TRACE("graph %p, hwnd %#Ix, message %#lx, wparam %#Ix, lparam %#Ix.\n", This, hwnd, uMsg, wParam, lParam);
+    TRACE("(%p/%p)->(%08lx, %d, %08lx, %08lx)\n", This, iface, hwnd, uMsg, wParam, lParam);
 
     EnterCriticalSection(&This->cs);
 
@@ -4594,7 +4508,7 @@ static HRESULT WINAPI VideoWindow_SetWindowPosition(IVideoWindow *iface, LONG Le
     IVideoWindow *pVideoWindow;
     HRESULT hr;
 
-    TRACE("graph %p, left %ld, top %ld, width %ld, height %ld.\n", This, Left, Top, Width, Height);
+    TRACE("(%p/%p)->(%d, %d, %d, %d)\n", This, iface, Left, Top, Width, Height);
 
     EnterCriticalSection(&This->cs);
 
@@ -4698,7 +4612,7 @@ static HRESULT WINAPI VideoWindow_HideCursor(IVideoWindow *iface, LONG HideCurso
     IVideoWindow *pVideoWindow;
     HRESULT hr;
 
-    TRACE("graph %p, hide %ld.\n", This, HideCursor);
+    TRACE("(%p/%p)->(%d)\n", This, iface, HideCursor);
 
     EnterCriticalSection(&This->cs);
 
@@ -4806,54 +4720,50 @@ static ULONG WINAPI MediaEvent_Release(IMediaEventEx *iface)
     return IUnknown_Release(graph->outer_unk);
 }
 
-static HRESULT WINAPI MediaEvent_GetTypeInfoCount(IMediaEventEx *iface, UINT *count)
+/*** IDispatch methods ***/
+static HRESULT WINAPI MediaEvent_GetTypeInfoCount(IMediaEventEx *iface, UINT *pctinfo)
 {
-    TRACE("iface %p, count %p.\n", iface, count);
-    *count = 1;
+    struct filter_graph *This = impl_from_IMediaEventEx(iface);
+
+    TRACE("(%p/%p)->(%p): stub !!!\n", This, iface, pctinfo);
+
     return S_OK;
 }
 
-static HRESULT WINAPI MediaEvent_GetTypeInfo(IMediaEventEx *iface, UINT index,
-        LCID lcid, ITypeInfo **typeinfo)
+static HRESULT WINAPI MediaEvent_GetTypeInfo(IMediaEventEx *iface, UINT iTInfo, LCID lcid,
+        ITypeInfo **ppTInfo)
 {
-    TRACE("iface %p, index %u, lcid %#lx, typeinfo %p.\n", iface, index, lcid, typeinfo);
-    return strmbase_get_typeinfo(IMediaEvent_tid, typeinfo);
+    struct filter_graph *This = impl_from_IMediaEventEx(iface);
+
+    TRACE("(%p/%p)->(%d, %d, %p): stub !!!\n", This, iface, iTInfo, lcid, ppTInfo);
+
+    return S_OK;
 }
 
-static HRESULT WINAPI MediaEvent_GetIDsOfNames(IMediaEventEx *iface, REFIID iid,
-        LPOLESTR *names, UINT count, LCID lcid, DISPID *ids)
+static HRESULT WINAPI MediaEvent_GetIDsOfNames(IMediaEventEx *iface, REFIID riid,
+        LPOLESTR *rgszNames, UINT cNames, LCID lcid, DISPID *rgDispId)
 {
-    ITypeInfo *typeinfo;
-    HRESULT hr;
+    struct filter_graph *This = impl_from_IMediaEventEx(iface);
 
-    TRACE("iface %p, iid %s, names %p, count %u, lcid %#lx, ids %p.\n",
-            iface, debugstr_guid(iid), names, count, lcid, ids);
+    TRACE("(%p/%p)->(%s, %p, %d, %d, %p): stub !!!\n", This, iface, debugstr_guid(riid), rgszNames,
+            cNames, lcid, rgDispId);
 
-    if (SUCCEEDED(hr = strmbase_get_typeinfo(IMediaEvent_tid, &typeinfo)))
-    {
-        hr = ITypeInfo_GetIDsOfNames(typeinfo, names, count, ids);
-        ITypeInfo_Release(typeinfo);
-    }
-    return hr;
+    return S_OK;
 }
 
-static HRESULT WINAPI MediaEvent_Invoke(IMediaEventEx *iface, DISPID id, REFIID iid, LCID lcid,
-        WORD flags, DISPPARAMS *params, VARIANT *result, EXCEPINFO *excepinfo, UINT *error_arg)
+static HRESULT WINAPI MediaEvent_Invoke(IMediaEventEx *iface, DISPID dispIdMember, REFIID riid,
+        LCID lcid, WORD wFlags, DISPPARAMS *pDispParams, VARIANT *pVarResult, EXCEPINFO *pExepInfo,
+        UINT *puArgErr)
 {
-    ITypeInfo *typeinfo;
-    HRESULT hr;
+    struct filter_graph *This = impl_from_IMediaEventEx(iface);
 
-    TRACE("iface %p, id %ld, iid %s, lcid %#lx, flags %#x, params %p, result %p, excepinfo %p, error_arg %p.\n",
-            iface, id, debugstr_guid(iid), lcid, flags, params, result, excepinfo, error_arg);
+    TRACE("(%p/%p)->(%d, %s, %d, %04x, %p, %p, %p, %p): stub !!!\n", This, iface, dispIdMember,
+            debugstr_guid(riid), lcid, wFlags, pDispParams, pVarResult, pExepInfo, puArgErr);
 
-    if (SUCCEEDED(hr = strmbase_get_typeinfo(IMediaEvent_tid, &typeinfo)))
-    {
-        hr = ITypeInfo_Invoke(typeinfo, iface, id, flags, params, result, excepinfo, error_arg);
-        ITypeInfo_Release(typeinfo);
-    }
-    return hr;
+    return S_OK;
 }
 
+/*** IMediaEvent methods ***/
 static HRESULT WINAPI MediaEvent_GetEventHandle(IMediaEventEx *iface, OAEVENT *event)
 {
     struct filter_graph *graph = impl_from_IMediaEventEx(iface);
@@ -4871,7 +4781,7 @@ static HRESULT WINAPI MediaEvent_GetEvent(IMediaEventEx *iface, LONG *code,
     struct media_event *event;
     struct list *entry;
 
-    TRACE("graph %p, code %p, param1 %p, param2 %p, timeout %ld.\n", graph, code, param1, param2, timeout);
+    TRACE("graph %p, code %p, param1 %p, param2 %p, timeout %d.\n", graph, code, param1, param2, timeout);
 
     *code = 0;
 
@@ -4902,7 +4812,7 @@ static HRESULT WINAPI MediaEvent_WaitForCompletion(IMediaEventEx *iface, LONG ms
 {
     struct filter_graph *This = impl_from_IMediaEventEx(iface);
 
-    TRACE("graph %p, timeout %ld, code %p.\n", This, msTimeout, pEvCode);
+    TRACE("(%p/%p)->(%d, %p)\n", This, iface, msTimeout, pEvCode);
 
     if (This->state != State_Running)
         return VFW_E_WRONG_STATE;
@@ -4921,7 +4831,7 @@ static HRESULT WINAPI MediaEvent_CancelDefaultHandling(IMediaEventEx *iface, LON
 {
     struct filter_graph *This = impl_from_IMediaEventEx(iface);
 
-    TRACE("graph %p, code %#lx.\n", This, lEvCode);
+    TRACE("(%p/%p)->(%d)\n", This, iface, lEvCode);
 
     if (lEvCode == EC_COMPLETE)
 	This->HandleEcComplete = FALSE;
@@ -4939,7 +4849,7 @@ static HRESULT WINAPI MediaEvent_RestoreDefaultHandling(IMediaEventEx *iface, LO
 {
     struct filter_graph *This = impl_from_IMediaEventEx(iface);
 
-    TRACE("graph %p, code %#lx.\n", This, lEvCode);
+    TRACE("(%p/%p)->(%d)\n", This, iface, lEvCode);
 
     if (lEvCode == EC_COMPLETE)
 	This->HandleEcComplete = TRUE;
@@ -4953,12 +4863,12 @@ static HRESULT WINAPI MediaEvent_RestoreDefaultHandling(IMediaEventEx *iface, LO
     return S_OK;
 }
 
-static HRESULT WINAPI MediaEvent_FreeEventParams(IMediaEventEx *iface, LONG code,
-        LONG_PTR param1, LONG_PTR param2)
+static HRESULT WINAPI MediaEvent_FreeEventParams(IMediaEventEx *iface, LONG lEvCode,
+        LONG_PTR lParam1, LONG_PTR lParam2)
 {
-    struct filter_graph *graph = impl_from_IMediaEventEx(iface);
+    struct filter_graph *This = impl_from_IMediaEventEx(iface);
 
-    WARN("graph %p, code %#lx, param1 %Id, param2 %Id, stub!\n", graph, code, param1, param2);
+    TRACE("(%p/%p)->(%d, %08lx, %08lx): stub !!!\n", This, iface, lEvCode, lParam1, lParam2);
 
     return S_OK;
 }
@@ -4969,7 +4879,7 @@ static HRESULT WINAPI MediaEvent_SetNotifyWindow(IMediaEventEx *iface,
 {
     struct filter_graph *graph = impl_from_IMediaEventEx(iface);
 
-    TRACE("graph %p, window %#Ix, message %#lx, lparam %#Ix.\n", graph, window, message, lparam);
+    TRACE("graph %p, window %#Ix, message %#x, lparam %#Ix.\n", graph, window, message, lparam);
 
     graph->media_event_window = (HWND)window;
     graph->media_event_message = message;
@@ -4982,11 +4892,11 @@ static HRESULT WINAPI MediaEvent_SetNotifyFlags(IMediaEventEx *iface, LONG flags
 {
     struct filter_graph *graph = impl_from_IMediaEventEx(iface);
 
-    TRACE("graph %p, flags %#lx.\n", graph, flags);
+    TRACE("graph %p, flags %#x.\n", graph, flags);
 
     if (flags & ~AM_MEDIAEVENT_NONOTIFY)
     {
-        WARN("Invalid flags %#lx, returning E_INVALIDARG.\n", flags);
+        WARN("Invalid flags %#x, returning E_INVALIDARG.\n", flags);
         return E_INVALIDARG;
     }
 
@@ -5208,7 +5118,7 @@ static HRESULT WINAPI MediaFilter_GetState(IMediaFilter *iface, DWORD timeout, F
     DWORD end = GetTickCount() + timeout;
     HRESULT hr;
 
-    TRACE("graph %p, timeout %lu, state %p.\n", graph, timeout, state);
+    TRACE("graph %p, timeout %u, state %p.\n", graph, timeout, state);
 
     if (!state)
         return E_POINTER;
@@ -5234,7 +5144,7 @@ static HRESULT WINAPI MediaFilter_GetState(IMediaFilter *iface, DWORD timeout, F
         {
             HRESULT filter_hr = IBaseFilter_GetState(filter->filter, 0, &filter_state);
 
-            TRACE("Filter %p returned hr %#lx, state %u.\n", filter->filter, filter_hr, filter_state);
+            TRACE("Filter %p returned hr %#x, state %u.\n", filter->filter, filter_hr, filter_state);
 
             if (filter_hr == VFW_S_STATE_INTERMEDIATE)
                 async_filter = filter->filter;
@@ -5276,7 +5186,7 @@ static HRESULT WINAPI MediaFilter_GetState(IMediaFilter *iface, DWORD timeout, F
         EnterCriticalSection(&graph->cs);
     }
 
-    TRACE("Returning %#lx, state %u.\n", hr, *state);
+    TRACE("Returning %#x, state %u.\n", hr, *state);
     return hr;
 }
 
@@ -5395,7 +5305,7 @@ static HRESULT WINAPI MediaEventSink_Notify(IMediaEventSink *iface, LONG code,
 {
     struct filter_graph *graph = impl_from_IMediaEventSink(iface);
 
-    TRACE("graph %p, code %#lx, param1 %#Ix, param2 %#Ix.\n", graph, code, param1, param2);
+    TRACE("graph %p, code %#x, param1 %#Ix, param2 %#Ix.\n", graph, code, param1, param2);
 
     EnterCriticalSection(&graph->event_cs);
 
@@ -5459,35 +5369,34 @@ static ULONG WINAPI GraphConfig_Release(IGraphConfig *iface)
     return IUnknown_Release(graph->outer_unk);
 }
 
-static HRESULT WINAPI GraphConfig_Reconnect(IGraphConfig *iface, IPin *source, IPin *sink,
-        const AM_MEDIA_TYPE *mt, IBaseFilter *filter, HANDLE abort_event, DWORD flags)
+static HRESULT WINAPI GraphConfig_Reconnect(IGraphConfig *iface, IPin *pOutputPin, IPin *pInputPin,
+        const AM_MEDIA_TYPE *pmtFirstConnection, IBaseFilter *pUsingFilter, HANDLE hAbortEvent,
+        DWORD dwFlags)
 {
-    struct filter_graph *graph = impl_from_IGraphConfig(iface);
-
-    FIXME("graph %p, source %p, sink %p, mt %p, filter %p, abort_event %p, flags %#lx, stub!\n",
-            graph, source, sink, mt, filter, abort_event, flags);
-    strmbase_dump_media_type(mt);
+    struct filter_graph *This = impl_from_IGraphConfig(iface);
 
+    FIXME("(%p)->(%p, %p, %p, %p, %p, %x): stub!\n", This, pOutputPin, pInputPin, pmtFirstConnection, pUsingFilter, hAbortEvent, dwFlags);
+    strmbase_dump_media_type(pmtFirstConnection);
+    
     return E_NOTIMPL;
 }
 
-static HRESULT WINAPI GraphConfig_Reconfigure(IGraphConfig *iface,
-        IGraphConfigCallback *callback, void *context, DWORD flags, HANDLE abort_event)
+static HRESULT WINAPI GraphConfig_Reconfigure(IGraphConfig *iface, IGraphConfigCallback *pCallback,
+        void *pvContext, DWORD dwFlags, HANDLE hAbortEvent)
 {
-    struct filter_graph *graph = impl_from_IGraphConfig(iface);
+    struct filter_graph *This = impl_from_IGraphConfig(iface);
     HRESULT hr;
 
-    TRACE("graph %p, callback %p, context %p, flags %#lx, abort_event %p.\n",
-            graph, callback, context, flags, abort_event);
+    WARN("(%p)->(%p, %p, %x, %p): partial stub!\n", This, pCallback, pvContext, dwFlags, hAbortEvent);
 
-    if (abort_event)
+    if (hAbortEvent)
         FIXME("The parameter hAbortEvent is not handled!\n");
 
-    EnterCriticalSection(&graph->cs);
+    EnterCriticalSection(&This->cs);
 
-    hr = IGraphConfigCallback_Reconfigure(callback, context, flags);
+    hr = IGraphConfigCallback_Reconfigure(pCallback, pvContext, dwFlags);
 
-    LeaveCriticalSection(&graph->cs);
+    LeaveCriticalSection(&This->cs);
 
     return hr;
 }
@@ -5538,11 +5447,12 @@ static HRESULT WINAPI GraphConfig_PushThroughData(IGraphConfig *iface, IPin *pOu
     return E_NOTIMPL;
 }
 
-static HRESULT WINAPI GraphConfig_SetFilterFlags(IGraphConfig *iface, IBaseFilter *filter, DWORD flags)
+static HRESULT WINAPI GraphConfig_SetFilterFlags(IGraphConfig *iface, IBaseFilter *pFilter,
+        DWORD dwFlags)
 {
-    struct filter_graph *graph = impl_from_IGraphConfig(iface);
+    struct filter_graph *This = impl_from_IGraphConfig(iface);
 
-    FIXME("graph %p, filter %p, flags %#lx, stub!\n", graph, filter, flags);
+    FIXME("(%p)->(%p, %x): stub!\n", This, pFilter, dwFlags);
 
     return E_NOTIMPL;
 }
@@ -5557,11 +5467,12 @@ static HRESULT WINAPI GraphConfig_GetFilterFlags(IGraphConfig *iface, IBaseFilte
     return E_NOTIMPL;
 }
 
-static HRESULT WINAPI GraphConfig_RemoveFilterEx(IGraphConfig *iface, IBaseFilter *filter, DWORD flags)
+static HRESULT WINAPI GraphConfig_RemoveFilterEx(IGraphConfig *iface, IBaseFilter *pFilter,
+        DWORD dwFlags)
 {
-    struct filter_graph *graph = impl_from_IGraphConfig(iface);
+    struct filter_graph *This = impl_from_IGraphConfig(iface);
 
-    FIXME("graph %p, filter %p, flags %#lx, stub!\n", graph, filter, flags);
+    FIXME("(%p)->(%p, %x): stub!\n", This, pFilter, dwFlags);
 
     return E_NOTIMPL;
 }
@@ -5609,16 +5520,16 @@ static ULONG WINAPI GraphVersion_Release(IGraphVersion *iface)
     return IUnknown_Release(graph->outer_unk);
 }
 
-static HRESULT WINAPI GraphVersion_QueryVersion(IGraphVersion *iface, LONG *version)
+static HRESULT WINAPI GraphVersion_QueryVersion(IGraphVersion *iface, LONG *pVersion)
 {
-    struct filter_graph *graph = impl_from_IGraphVersion(iface);
+    struct filter_graph *This = impl_from_IGraphVersion(iface);
 
-    TRACE("graph %p, version %p, returning %ld.\n", graph, version, graph->version);
-
-    if (!version)
+    if(!pVersion)
         return E_POINTER;
 
-    *version = graph->version;
+    TRACE("(%p)->(%p): current version %i\n", This, pVersion, This->version);
+
+    *pVersion = This->version;
     return S_OK;
 }
 
@@ -5655,13 +5566,13 @@ static ULONG WINAPI VideoFrameStep_Release(IVideoFrameStep *iface)
 
 static HRESULT WINAPI VideoFrameStep_Step(IVideoFrameStep *iface, DWORD frame_count, IUnknown *filter)
 {
-    FIXME("iface %p, frame_count %lu, filter %p, stub!\n", iface, frame_count, filter);
+    FIXME("iface %p, frame_count %u, filter %p, stub!\n", iface, frame_count, filter);
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI VideoFrameStep_CanStep(IVideoFrameStep *iface, LONG multiple, IUnknown *filter)
 {
-    FIXME("iface %p, multiple %ld, filter %p, stub!\n", iface, multiple, filter);
+    FIXME("iface %p, multiple %d, filter %p, stub!\n", iface, multiple, filter);
     return E_NOTIMPL;
 }
 
@@ -5688,11 +5599,28 @@ static const IUnknownVtbl IInner_VTable =
     FilterGraphInner_Release
 };
 
+static BOOL CALLBACK register_winegstreamer_proc(INIT_ONCE *once, void *param, void **ctx)
+{
+    HMODULE mod = LoadLibraryW(L"winegstreamer.dll");
+    if (mod)
+    {
+        HRESULT (WINAPI *proc)(void) = (void *)GetProcAddress(mod, "DllRegisterServer");
+        proc();
+        FreeLibrary(mod);
+    }
+    return TRUE;
+}
+
 static HRESULT filter_graph_common_create(IUnknown *outer, IUnknown **out, BOOL threaded)
 {
+    static INIT_ONCE once = INIT_ONCE_STATIC_INIT;
     struct filter_graph *object;
     HRESULT hr;
 
+    /* HACK: our build system makes it difficult to load gstreamer on prefix
+     * creation, so it won't get registered. Do that here instead. */
+    InitOnceExecuteOnce(&once, register_winegstreamer_proc, NULL, NULL);
+
     *out = NULL;
 
     if (!(object = calloc(1, sizeof(*object))))
@@ -5719,7 +5647,7 @@ static HRESULT filter_graph_common_create(IUnknown *outer, IUnknown **out, BOOL
     if (FAILED(hr = CoCreateInstance(&CLSID_FilterMapper2, object->outer_unk,
             CLSCTX_INPROC_SERVER, &IID_IUnknown, (void **)&object->punkFilterMapper2)))
     {
-        ERR("Failed to create filter mapper, hr %#lx.\n", hr);
+        ERR("Failed to create filter mapper, hr %#x.\n", hr);
         free(object);
         return hr;
     }
diff --git a/dlls/quartz/filtermapper.c b/dlls/quartz/filtermapper.c
index 149bc8d1716..a95f0ca7832 100644
--- wine/dlls/quartz/filtermapper.c
+++ wine/dlls/quartz/filtermapper.c
@@ -76,7 +76,7 @@ static ULONG WINAPI enum_reg_filters_AddRef(IEnumRegFilters *iface)
 {
     struct enum_reg_filters *enumerator = impl_from_IEnumRegFilters(iface);
     ULONG refcount = InterlockedIncrement(&enumerator->refcount);
-    TRACE("%p increasing refcount to %lu.\n", enumerator, refcount);
+    TRACE("%p increasing refcount to %u.\n", enumerator, refcount);
     return refcount;
 }
 
@@ -86,7 +86,7 @@ static ULONG WINAPI enum_reg_filters_Release(IEnumRegFilters *iface)
     ULONG refcount = InterlockedDecrement(&enumerator->refcount);
     unsigned int i;
 
-    TRACE("%p decreasing refcount to %lu.\n", enumerator, refcount);
+    TRACE("%p decreasing refcount to %u.\n", enumerator, refcount);
     if (!refcount)
     {
         for (i = 0; i < enumerator->count; ++i)
@@ -103,7 +103,7 @@ static HRESULT WINAPI enum_reg_filters_Next(IEnumRegFilters *iface, ULONG count,
     struct enum_reg_filters *enumerator = impl_from_IEnumRegFilters(iface);
     unsigned int i;
 
-    TRACE("iface %p, count %lu, filters %p, ret_count %p.\n", iface, count, filters, ret_count);
+    TRACE("iface %p, count %u, filters %p, ret_count %p.\n", iface, count, filters, ret_count);
 
     for (i = 0; i < count && enumerator->index + i < enumerator->count; ++i)
     {
@@ -131,7 +131,7 @@ static HRESULT WINAPI enum_reg_filters_Next(IEnumRegFilters *iface, ULONG count,
 
 static HRESULT WINAPI enum_reg_filters_Skip(IEnumRegFilters *iface, ULONG count)
 {
-    TRACE("iface %p, count %lu, unimplemented.\n", iface, count);
+    TRACE("iface %p, count %u, unimplemented.\n", iface, count);
     return E_NOTIMPL;
 }
 
@@ -234,7 +234,7 @@ static ULONG WINAPI enum_moniker_AddRef(IEnumMoniker *iface)
 {
     struct enum_moniker *enumerator = impl_from_IEnumMoniker(iface);
     ULONG refcount = InterlockedIncrement(&enumerator->refcount);
-    TRACE("%p increasing refcount to %lu.\n", enumerator, refcount);
+    TRACE("%p increasing refcount to %u.\n", enumerator, refcount);
     return refcount;
 }
 
@@ -244,7 +244,7 @@ static ULONG WINAPI enum_moniker_Release(IEnumMoniker *iface)
     ULONG refcount = InterlockedDecrement(&enumerator->refcount);
     unsigned int i;
 
-    TRACE("%p decreasing refcount to %lu.\n", enumerator, refcount);
+    TRACE("%p decreasing refcount to %u.\n", enumerator, refcount);
     if (!refcount)
     {
         for (i = 0; i < enumerator->count; ++i)
@@ -261,7 +261,7 @@ static HRESULT WINAPI enum_moniker_Next(IEnumMoniker *iface, ULONG count,
     struct enum_moniker *enumerator = impl_from_IEnumMoniker(iface);
     unsigned int i;
 
-    TRACE("iface %p, count %lu, filters %p, ret_count %p.\n", iface, count, filters, ret_count);
+    TRACE("iface %p, count %u, filters %p, ret_count %p.\n", iface, count, filters, ret_count);
 
     for (i = 0; i < count && enumerator->index + i < enumerator->count; ++i)
         IMoniker_AddRef(filters[i] = enumerator->filters[enumerator->index + i]);
@@ -276,7 +276,7 @@ static HRESULT WINAPI enum_moniker_Skip(IEnumMoniker *iface, ULONG count)
 {
     struct enum_moniker *enumerator = impl_from_IEnumMoniker(iface);
 
-    TRACE("iface %p, count %lu.\n", iface, count);
+    TRACE("iface %p, count %u.\n", iface, count);
 
     enumerator->index += count;
     return S_OK;
@@ -469,27 +469,27 @@ static HRESULT WINAPI Inner_QueryInterface(IUnknown *iface, REFIID riid, void **
 
 static ULONG WINAPI Inner_AddRef(IUnknown *iface)
 {
-    FilterMapper3Impl *mapper = impl_from_IUnknown(iface);
-    ULONG refcount = InterlockedIncrement(&mapper->ref);
+    FilterMapper3Impl *This = impl_from_IUnknown(iface);
+    ULONG ref = InterlockedIncrement(&This->ref);
 
-    TRACE("%p increasing refcount to %lu.\n", mapper, refcount);
+    TRACE("(%p)->(): new ref = %d\n", This, ref);
 
-    return refcount;
+    return ref;
 }
 
 static ULONG WINAPI Inner_Release(IUnknown *iface)
 {
-    FilterMapper3Impl *mapper = impl_from_IUnknown(iface);
-    ULONG refcount = InterlockedDecrement(&mapper->ref);
+    FilterMapper3Impl *This = impl_from_IUnknown(iface);
+    ULONG ref = InterlockedDecrement(&This->ref);
 
-    TRACE("%p decreasing refcount to %lu.\n", mapper, refcount);
+    TRACE("(%p)->(): new ref = %d\n", This, ref);
 
-    if (!refcount)
+    if (ref == 0)
     {
-        CoTaskMemFree(mapper);
+        CoTaskMemFree(This);
     }
 
-    return refcount;
+    return ref;
 }
 
 static const IUnknownVtbl IInner_VTable =
@@ -529,7 +529,7 @@ static HRESULT WINAPI FilterMapper3_CreateCategory(IFilterMapper3 *iface,
     HKEY key;
     LONG ret;
 
-    TRACE("iface %p, category %s, merit %#lx, description %s.\n", iface,
+    TRACE("iface %p, category %s, merit %#x, description %s.\n", iface,
             debugstr_guid(category), merit, debugstr_w(description));
 
     StringFromGUID2(category, guidstr, ARRAY_SIZE(guidstr));
@@ -702,14 +702,14 @@ static HRESULT FM2_ReadFilterData(BYTE *pData, REGFILTER2 * prf2)
 
     if (prrf->dwVersion != 2)
     {
-        FIXME("Filter registry version %lu is not supported.\n", prrf->dwVersion);
+        FIXME("Filter registry version %d not supported\n", prrf->dwVersion);
         ZeroMemory(prf2, sizeof(*prf2));
         hr = E_FAIL;
     }
 
     if (SUCCEEDED(hr))
     {
-        TRACE("dwVersion %lu, dwMerit %#lx, dwPins %lu, dwUnused %#lx.\n",
+        TRACE("version = %d, merit = %x, #pins = %d, unused = %x\n",
             prrf->dwVersion, prrf->dwMerit, prrf->dwPins, prrf->dwUnused);
 
         prf2->dwVersion = prrf->dwVersion;
@@ -730,7 +730,7 @@ static HRESULT FM2_ReadFilterData(BYTE *pData, REGFILTER2 * prf2)
 
             TRACE("\tsignature = %s\n", debugstr_an((const char*)prrfp->signature, 4));
 
-            TRACE("\tPin %lu: dwFlags %#lx, dwInstances %lu, dwMediaTypes %lu, dwMediums %lu.\n",
+            TRACE("\tpin[%d]: flags = %x, instances = %d, media types = %d, mediums = %d\n",
                 i, prrfp->dwFlags, prrfp->dwInstances, prrfp->dwMediaTypes, prrfp->dwMediums);
 
             rgPins2[i].dwFlags = prrfp->dwFlags;
@@ -901,7 +901,7 @@ static HRESULT WINAPI FilterMapper3_RegisterFilter(IFilterMapper3 *iface,
 
     if (FAILED(hr = IParseDisplayName_ParseDisplayName(parser, NULL, display_name, &eaten, &moniker)))
     {
-        ERR("Failed to parse display name, hr %#lx.\n", hr);
+        ERR("Failed to parse display name, hr %#x.\n", hr);
         IParseDisplayName_Release(parser);
         free(display_name);
         return hr;
@@ -911,7 +911,7 @@ static HRESULT WINAPI FilterMapper3_RegisterFilter(IFilterMapper3 *iface,
 
     if (FAILED(hr = IMoniker_BindToStorage(moniker, NULL, NULL, &IID_IPropertyBag, (void **)&prop_bag)))
     {
-        ERR("Failed to get property bag, hr %#lx.\n", hr);
+        ERR("Failed to get property bag, hr %#x.\n", hr);
         IMoniker_Release(moniker);
         free(display_name);
         return hr;
@@ -920,13 +920,13 @@ static HRESULT WINAPI FilterMapper3_RegisterFilter(IFilterMapper3 *iface,
     V_VT(&var) = VT_BSTR;
     V_BSTR(&var) = SysAllocString(name);
     if (FAILED(hr = IPropertyBag_Write(prop_bag, L"FriendlyName", &var)))
-        ERR("Failed to write friendly name, hr %#lx.\n", hr);
+        ERR("Failed to write friendly name, hr %#x.\n", hr);
     VariantClear(&var);
 
     V_VT(&var) = VT_BSTR;
     V_BSTR(&var) = SysAllocString(clsid_string);
     if (FAILED(hr = IPropertyBag_Write(prop_bag, L"CLSID", &var)))
-        ERR("Failed to write class ID, hr %#lx.\n", hr);
+        ERR("Failed to write class ID, hr %#x.\n", hr);
     VariantClear(&var);
 
     if (SUCCEEDED(FM2_WriteFilterData(&regfilter2, &filter_data, &filter_data_len)))
@@ -936,7 +936,7 @@ static HRESULT WINAPI FilterMapper3_RegisterFilter(IFilterMapper3 *iface,
         {
             memcpy(V_ARRAY(&var)->pvData, filter_data, filter_data_len);
             if (FAILED(hr = IPropertyBag_Write(prop_bag, L"FilterData", &var)))
-                ERR("Failed to write filter data, hr %#lx.\n", hr);
+                ERR("Failed to write filter data, hr %#x.\n", hr);
             VariantClear(&var);
         }
 
@@ -1030,7 +1030,7 @@ static HRESULT WINAPI FilterMapper3_EnumMatchingFilters(
     HRESULT hr;
     struct Vector monikers = {NULL, 0, 0};
 
-    TRACE("(%p, %#lx, %s, %#lx, %s, %lu, %p, %p, %p, %s, %s, %p, %p, %p)\n",
+    TRACE("(%p, %x, %s, %x, %s, %d, %p, %p, %p, %s, %s, %p, %p, %p)\n",
         ppEnum,
         dwFlags,
         bExactMatch ? "true" : "false",
@@ -1047,7 +1047,9 @@ static HRESULT WINAPI FilterMapper3_EnumMatchingFilters(
         pPinCategoryOut);
 
     if (dwFlags != 0)
-        FIXME("Ignoring flags %#lx.\n", dwFlags);
+    {
+        FIXME("dwFlags = %x not implemented\n", dwFlags);
+    }
 
     *ppEnum = NULL;
 
@@ -1287,7 +1289,7 @@ static HRESULT WINAPI FilterMapper_EnumMatchingFilters(
     REGFILTER* regfilters;
     HRESULT hr;
 
-    TRACE("(%p/%p)->(%p, %#lx, %s, %s, %s, %s, %s, %s, %s)\n",
+    TRACE("(%p/%p)->(%p, %x, %s, %s, %s, %s, %s, %s, %s)\n",
         This,
         iface,
         ppEnum,
@@ -1399,7 +1401,7 @@ static HRESULT WINAPI FilterMapper_RegisterFilter(IFilterMapper * iface,
     HKEY key;
     LONG ret;
 
-    TRACE("iface %p, clsid %s, name %s, merit %#lx.\n",
+    TRACE("iface %p, clsid %s, name %s, merit %#x.\n",
             iface, debugstr_guid(&clsid), debugstr_w(name), merit);
 
     StringFromGUID2(&clsid, guidstr, ARRAY_SIZE(guidstr));
@@ -1410,7 +1412,7 @@ static HRESULT WINAPI FilterMapper_RegisterFilter(IFilterMapper * iface,
         return HRESULT_FROM_WIN32(ret);
 
     if ((ret = RegSetValueExW(key, NULL, 0, REG_SZ, (const BYTE *)name, (wcslen(name) + 1) * sizeof(WCHAR))))
-        ERR("Failed to set filter name, error %lu.\n", ret);
+        ERR("Failed to set filter name, error %u.\n", ret);
     RegCloseKey(key);
 
     wcscpy(keypath, L"CLSID\\");
@@ -1418,11 +1420,11 @@ static HRESULT WINAPI FilterMapper_RegisterFilter(IFilterMapper * iface,
     if (!(ret = RegCreateKeyExW(HKEY_CLASSES_ROOT, keypath, 0, NULL, 0, KEY_WRITE, NULL, &key, NULL)))
     {
         if ((ret = RegSetValueExW(key, L"Merit", 0, REG_DWORD, (const BYTE *)&merit, sizeof(DWORD))))
-            ERR("Failed to set merit, error %lu.\n", ret);
+            ERR("Failed to set merit, error %u.\n", ret);
         RegCloseKey(key);
     }
     else
-        ERR("Failed to create CLSID key, error %lu.\n", ret);
+        ERR("Failed to create CLSID key, error %u.\n", ret);
 
     return S_OK;
 }
@@ -1464,7 +1466,7 @@ static HRESULT WINAPI FilterMapper_RegisterPin(IFilterMapper *iface, CLSID clsid
 
     if ((ret = RegCreateKeyExW(key, pin_keypath, 0, NULL, 0, KEY_WRITE, NULL, &pin_key, NULL)))
     {
-        ERR("Failed to open pin key, error %lu.\n", ret);
+        ERR("Failed to open pin key, error %u.\n", ret);
         free(pin_keypath);
         RegCloseKey(key);
         return HRESULT_FROM_WIN32(ret);
@@ -1472,18 +1474,18 @@ static HRESULT WINAPI FilterMapper_RegisterPin(IFilterMapper *iface, CLSID clsid
     free(pin_keypath);
 
     if ((ret = RegSetValueExW(pin_key, L"AllowedMany", 0, REG_DWORD, (const BYTE *)&many, sizeof(DWORD))))
-        ERR("Failed to set AllowedMany value, error %lu.\n", ret);
+        ERR("Failed to set AllowedMany value, error %u.\n", ret);
     if ((ret = RegSetValueExW(pin_key, L"AllowedZero", 0, REG_DWORD, (const BYTE *)&zero, sizeof(DWORD))))
-        ERR("Failed to set AllowedZero value, error %lu.\n", ret);
+        ERR("Failed to set AllowedZero value, error %u.\n", ret);
     if ((ret = RegSetValueExW(pin_key, L"Direction", 0, REG_DWORD, (const BYTE *)&output, sizeof(DWORD))))
-        ERR("Failed to set Direction value, error %lu.\n", ret);
+        ERR("Failed to set Direction value, error %u.\n", ret);
     if ((ret = RegSetValueExW(pin_key, L"IsRendered", 0, REG_DWORD, (const BYTE *)&rendered, sizeof(DWORD))))
-        ERR("Failed to set IsRendered value, error %lu.\n", ret);
+        ERR("Failed to set IsRendered value, error %u.\n", ret);
 
     if (!(ret = RegCreateKeyExW(pin_key, L"Types", 0, NULL, 0, 0, NULL, &type_key, NULL)))
         RegCloseKey(type_key);
     else
-        ERR("Failed to create Types subkey, error %lu.\n", ret);
+        ERR("Failed to create Types subkey, error %u.\n", ret);
 
     RegCloseKey(pin_key);
     RegCloseKey(key);
@@ -1525,7 +1527,7 @@ static HRESULT WINAPI FilterMapper_RegisterPinType(IFilterMapper *iface,
     if (!(ret = RegCreateKeyExW(key, type_keypath, 0, NULL, 0, 0, NULL, &type_key, NULL)))
         RegCloseKey(type_key);
     else
-        ERR("Failed to create type key, error %lu.\n", ret);
+        ERR("Failed to create type key, error %u.\n", ret);
 
     RegCloseKey(key);
     return HRESULT_FROM_WIN32(ret);
@@ -1544,7 +1546,7 @@ static HRESULT WINAPI FilterMapper_UnregisterFilter(IFilterMapper *iface, CLSID
     if ((ret = RegOpenKeyExW(HKEY_CLASSES_ROOT, L"Filter", 0, 0, &key)))
         return HRESULT_FROM_WIN32(ret);
     if ((ret = RegDeleteKeyW(key, guidstr)))
-        ERR("Failed to delete filter key, error %lu.\n", ret);
+        ERR("Failed to delete filter key, error %u.\n", ret);
     RegCloseKey(key);
 
     wcscpy(keypath, L"CLSID\\");
@@ -1552,13 +1554,13 @@ static HRESULT WINAPI FilterMapper_UnregisterFilter(IFilterMapper *iface, CLSID
     if (!(ret = RegOpenKeyExW(HKEY_CLASSES_ROOT, keypath, 0, KEY_WRITE, &key)))
     {
         if ((ret = RegDeleteValueW(key, L"Merit")))
-            ERR("Failed to delete Merit value, error %lu.\n", ret);
+            ERR("Failed to delete Merit value, error %u.\n", ret);
         if ((ret = RegDeleteTreeW(key, L"Pins")))
-            ERR("Failed to delete Pins key, error %lu.\n", ret);
+            ERR("Failed to delete Pins key, error %u.\n", ret);
         RegCloseKey(key);
     }
     else
-        ERR("Failed to open CLSID key, error %lu.\n", ret);
+        ERR("Failed to open CLSID key, error %u.\n", ret);
 
     return S_OK;
 }
@@ -1590,7 +1592,7 @@ static HRESULT WINAPI FilterMapper_UnregisterPin(IFilterMapper * iface, CLSID cl
         return HRESULT_FROM_WIN32(ret);
 
     if ((ret = RegDeleteTreeW(key, name)))
-        ERR("Failed to delete subkey, error %lu.\n", ret);
+        ERR("Failed to delete subkey, error %u.\n", ret);
 
     RegCloseKey(key);
 
@@ -1646,7 +1648,7 @@ static HRESULT WINAPI AMFilterData_ParseFilterData(IAMFilterData* iface,
     HRESULT hr = S_OK;
     static REGFILTER2 *prf2;
 
-    TRACE("mapper %p, data %p, size %lu, parsed_data %p.\n", This, pData, cb, ppRegFilter2);
+    TRACE("(%p/%p)->(%p, %d, %p)\n", This, iface, pData, cb, ppRegFilter2);
 
     prf2 = CoTaskMemAlloc(sizeof(*prf2));
     if (!prf2)
diff --git a/dlls/quartz/main.c b/dlls/quartz/main.c
index c5302db6ced..ed7080b76b9 100644
--- wine/dlls/quartz/main.c
+++ wine/dlls/quartz/main.c
@@ -260,13 +260,13 @@ const char * qzdebugstr_guid( const GUID * id )
     return debugstr_guid(id);
 }
 
-int WINAPI AmpFactorToDB(int ampfactor)
+LONG WINAPI AmpFactorToDB(LONG ampfactor)
 {
     FIXME("(%d) Stub!\n", ampfactor);
     return 0;
 }
 
-int WINAPI DBToAmpFactor(int db)
+LONG WINAPI DBToAmpFactor(LONG db)
 {
     FIXME("(%d) Stub!\n", db);
     /* Avoid divide by zero (probably during range computation) in Windows Media Player 6.4 */
@@ -283,8 +283,7 @@ DWORD WINAPI AMGetErrorTextA(HRESULT hr, LPSTR buffer, DWORD maxlen)
     DWORD res;
     WCHAR errorW[MAX_ERROR_TEXT_LEN];
 
-    TRACE("hr %#lx, buffer %p, maxlen %lu.\n", hr, buffer, maxlen);
-
+    TRACE("(%x,%p,%d)\n", hr, buffer, maxlen);
     if (!buffer)
         return 0;
 
@@ -306,7 +305,7 @@ DWORD WINAPI AMGetErrorTextW(HRESULT hr, LPWSTR buffer, DWORD maxlen)
     unsigned int len;
     WCHAR error[MAX_ERROR_TEXT_LEN];
 
-    TRACE("hr %#lx, buffer %p, maxlen %lu.\n", hr, buffer, maxlen);
+    FIXME("(%x,%p,%d) stub\n", hr, buffer, maxlen);
 
     if (!buffer) return 0;
     swprintf(error, ARRAY_SIZE(error), L"Error: 0x%lx", hr);
diff --git a/dlls/quartz/memallocator.c b/dlls/quartz/memallocator.c
index 87869b4d6b2..531fbe874cf 100644
--- wine/dlls/quartz/memallocator.c
+++ wine/dlls/quartz/memallocator.c
@@ -135,7 +135,7 @@ static ULONG WINAPI BaseMemAllocator_AddRef(IMemAllocator * iface)
     BaseMemAllocator *This = impl_from_IMemAllocator(iface);
     ULONG ref = InterlockedIncrement(&This->ref);
 
-    TRACE("%p increasing refcount to %lu.\n", This, ref);
+    TRACE("(%p)->() AddRef from %d\n", iface, ref - 1);
 
     return ref;
 }
@@ -145,7 +145,7 @@ static ULONG WINAPI BaseMemAllocator_Release(IMemAllocator * iface)
     BaseMemAllocator *This = impl_from_IMemAllocator(iface);
     ULONG ref = InterlockedDecrement(&This->ref);
 
-    TRACE("%p decreasing refcount to %lu.\n", This, ref);
+    TRACE("(%p)->() Release from %d\n", iface, ref + 1);
 
     if (!ref)
     {
@@ -166,7 +166,7 @@ static HRESULT WINAPI BaseMemAllocator_SetProperties(IMemAllocator * iface, ALLO
 
     TRACE("(%p)->(%p, %p)\n", This, pRequest, pActual);
 
-    TRACE("Requested %ld buffers, size %ld, alignment %ld, prefix %ld.\n",
+    TRACE("Requested %d buffers, size %d, alignment %d, prefix %d.\n",
             pRequest->cBuffers, pRequest->cbBuffer, pRequest->cbAlign, pRequest->cbPrefix);
 
     EnterCriticalSection(This->pCritSect);
@@ -236,7 +236,7 @@ static HRESULT WINAPI BaseMemAllocator_Commit(IMemAllocator * iface)
         {
             if (!(This->hSemWaiting = CreateSemaphoreW(NULL, This->props.cBuffers, This->props.cBuffers, NULL)))
             {
-                ERR("Failed to create semaphore, error %lu.\n", GetLastError());
+                ERR("Couldn't create semaphore (error was %u)\n", GetLastError());
                 hr = HRESULT_FROM_WIN32(GetLastError());
             }
             else
@@ -245,7 +245,7 @@ static HRESULT WINAPI BaseMemAllocator_Commit(IMemAllocator * iface)
                 if (SUCCEEDED(hr))
                     This->bCommitted = TRUE;
                 else
-                    ERR("Failed to allocate, hr %#lx.\n", hr);
+                    ERR("fnAlloc failed with error 0x%x\n", hr);
             }
         }
     }
@@ -278,13 +278,15 @@ static HRESULT WINAPI BaseMemAllocator_Decommit(IMemAllocator * iface)
             else
             {
                 if (This->lWaiting != 0)
-                    ERR("Waiting: %ld\n", This->lWaiting);
+                    ERR("Waiting: %d\n", This->lWaiting);
 
                 This->bCommitted = FALSE;
                 CloseHandle(This->hSemWaiting);
                 This->hSemWaiting = NULL;
 
                 hr = This->fnFree(iface);
+                if (FAILED(hr))
+                    ERR("fnFree failed with error 0x%x\n", hr);
             }
         }
     }
@@ -300,9 +302,8 @@ static HRESULT WINAPI BaseMemAllocator_GetBuffer(IMemAllocator * iface, IMediaSa
 
     /* NOTE: The pStartTime and pEndTime parameters are not applied to the sample. 
      * The allocator might use these values to determine which buffer it retrieves */
-
-    TRACE("allocator %p, sample %p, start_time %p, end_time %p, flags %#lx.\n",
-            This, pSample, pStartTime, pEndTime, dwFlags);
+    
+    TRACE("(%p)->(%p, %p, %p, %x)\n", This, pSample, pStartTime, pEndTime, dwFlags);
 
     *pSample = NULL;
 
@@ -350,7 +351,7 @@ static HRESULT WINAPI BaseMemAllocator_GetBuffer(IMemAllocator * iface, IMediaSa
     LeaveCriticalSection(This->pCritSect);
 
     if (hr != S_OK)
-        WARN("Returning hr %#lx.\n", hr);
+        WARN("%08x\n", hr);
     return hr;
 }
 
@@ -378,8 +379,10 @@ static HRESULT WINAPI BaseMemAllocator_ReleaseBuffer(IMemAllocator * iface, IMed
 
         if (list_empty(&This->used_list) && This->bDecommitQueued && This->bCommitted)
         {
+            HRESULT hrfree;
+
             if (This->lWaiting != 0)
-                ERR("Waiting: %ld\n", This->lWaiting);
+                ERR("Waiting: %d\n", This->lWaiting);
 
             This->bCommitted = FALSE;
             This->bDecommitQueued = FALSE;
@@ -387,7 +390,8 @@ static HRESULT WINAPI BaseMemAllocator_ReleaseBuffer(IMemAllocator * iface, IMed
             CloseHandle(This->hSemWaiting);
             This->hSemWaiting = NULL;
             
-            This->fnFree(iface);
+            if (FAILED(hrfree = This->fnFree(iface)))
+                ERR("fnFree failed with error 0x%x\n", hrfree);
         }
     }
     LeaveCriticalSection(This->pCritSect);
@@ -395,7 +399,7 @@ static HRESULT WINAPI BaseMemAllocator_ReleaseBuffer(IMemAllocator * iface, IMed
     /* notify a waiting thread that there is now a free buffer */
     if (This->hSemWaiting && !ReleaseSemaphore(This->hSemWaiting, 1, NULL))
     {
-        ERR("Failed to release semaphore, error %lu.\n", GetLastError());
+        ERR("ReleaseSemaphore failed with error %u\n", GetLastError());
         hr = HRESULT_FROM_WIN32(GetLastError());
     }
 
@@ -475,7 +479,7 @@ static ULONG WINAPI StdMediaSample2_AddRef(IMediaSample2 * iface)
     StdMediaSample2 *This = impl_from_IMediaSample2(iface);
     ULONG ref = InterlockedIncrement(&This->ref);
 
-    TRACE("%p increasing refcount to %lu.\n", This, ref);
+    TRACE("(%p)->(): new ref = %d\n", This, ref);
 
     return ref;
 }
@@ -485,7 +489,7 @@ static ULONG WINAPI StdMediaSample2_Release(IMediaSample2 * iface)
     StdMediaSample2 *This = impl_from_IMediaSample2(iface);
     ULONG ref = InterlockedDecrement(&This->ref);
 
-    TRACE("%p decreasing refcount to %lu.\n", This, ref);
+    TRACE("(%p)->(): new ref = %d\n", This, ref);
 
     if (!ref)
     {
@@ -641,11 +645,11 @@ static HRESULT WINAPI StdMediaSample2_SetActualDataLength(IMediaSample2 * iface,
 {
     StdMediaSample2 *This = impl_from_IMediaSample2(iface);
 
-    TRACE("sample %p, len %ld.\n", This, len);
+    TRACE("(%p)->(%d)\n", iface, len);
 
     if ((len > This->props.cbBuffer) || (len < 0))
     {
-        ERR("Length %ld exceeds maximum %ld.\n", len, This->props.cbBuffer);
+        WARN("Tried to set length to %d, while max is %d\n", len, This->props.cbBuffer);
         return VFW_E_BUFFER_OVERFLOW;
     }
     else
@@ -762,7 +766,7 @@ static HRESULT WINAPI StdMediaSample2_GetProperties(IMediaSample2 * iface, DWORD
 {
     StdMediaSample2 *This = impl_from_IMediaSample2(iface);
 
-    TRACE("sample %p, size %lu, properties %p.\n", This, cbProperties, pbProperties);
+    TRACE("(%p)->(%d, %p)\n", iface, cbProperties, pbProperties);
 
     memcpy(pbProperties, &This->props, min(cbProperties, sizeof(This->props)));
 
@@ -773,7 +777,7 @@ static HRESULT WINAPI StdMediaSample2_SetProperties(IMediaSample2 * iface, DWORD
 {
     StdMediaSample2 *This = impl_from_IMediaSample2(iface);
 
-    TRACE("sample %p, size %lu, properties %p.\n", This, cbProperties, pbProperties);
+    TRACE("(%p)->(%d, %p)\n", iface, cbProperties, pbProperties);
 
     /* NOTE: pbBuffer and cbBuffer are read-only */
     memcpy(&This->props, pbProperties, min(cbProperties, AM_SAMPLE2_PROP_SIZE_WRITABLE));
@@ -892,7 +896,7 @@ static HRESULT StdMemAllocator_Free(IMemAllocator * iface)
     /* free memory */
     if (!VirtualFree(This->pMemory, 0, MEM_RELEASE))
     {
-        ERR("Failed to free memory, error %lu.\n", GetLastError());
+        ERR("Couldn't free memory. Error: %u\n", GetLastError());
         return HRESULT_FROM_WIN32(GetLastError());
     }
 
diff --git a/dlls/quartz/passthrough.c b/dlls/quartz/passthrough.c
index 4627b2d26f8..2f8fe9dc370 100644
--- wine/dlls/quartz/passthrough.c
+++ wine/dlls/quartz/passthrough.c
@@ -66,7 +66,7 @@ static ULONG WINAPI seeking_passthrough_AddRef(IUnknown *iface)
     struct seeking_passthrough *passthrough = impl_from_IUnknown(iface);
     ULONG refcount = InterlockedIncrement(&passthrough->refcount);
 
-    TRACE("%p increasing refcount to %lu.\n", passthrough, refcount);
+    TRACE("%p increasing refcount to %u.\n", passthrough, refcount);
     return refcount;
 }
 
@@ -75,7 +75,7 @@ static ULONG WINAPI seeking_passthrough_Release(IUnknown *iface)
     struct seeking_passthrough *passthrough = impl_from_IUnknown(iface);
     ULONG refcount = InterlockedDecrement(&passthrough->refcount);
 
-    TRACE("%p decreasing refcount to %lu.\n", passthrough, refcount);
+    TRACE("%p decreasing refcount to %u.\n", passthrough, refcount);
     if (!refcount)
     {
         strmbase_passthrough_cleanup(&passthrough->passthrough);
diff --git a/dlls/quartz/regsvr.c b/dlls/quartz/regsvr.c
index d035f8673fb..649e25e7327 100644
--- wine/dlls/quartz/regsvr.c
+++ wine/dlls/quartz/regsvr.c
@@ -127,7 +127,7 @@ static HRESULT register_filters(struct regsvr_filter const *list)
 	    }
 
 	    if (FAILED(hr)) {
-		ERR("failed to register with hresult %#lx\n", hr);
+		ERR("failed to register with hresult 0x%x\n", hr);
 		CoTaskMemFree(prfp2);
 		break;
 	    }
diff --git a/dlls/quartz/systemclock.c b/dlls/quartz/systemclock.c
index 729122fec46..f579ae754ea 100644
--- wine/dlls/quartz/systemclock.c
+++ wine/dlls/quartz/systemclock.c
@@ -25,7 +25,7 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(quartz);
 
-static LONG cookie_counter;
+static int cookie_counter;
 
 struct advise_sink
 {
@@ -42,8 +42,7 @@ struct system_clock
     IUnknown *outer_unk;
     LONG refcount;
 
-    LONG thread_created;
-    BOOL thread_stopped;
+    BOOL thread_created, thread_stopped;
     HANDLE thread;
     LARGE_INTEGER frequency;
     REFERENCE_TIME last_time;
@@ -91,7 +90,7 @@ static ULONG WINAPI system_clock_inner_AddRef(IUnknown *iface)
     struct system_clock *clock = impl_from_IUnknown(iface);
     ULONG refcount = InterlockedIncrement(&clock->refcount);
 
-    TRACE("%p increasing refcount to %lu.\n", clock, refcount);
+    TRACE("%p increasing refcount to %u.\n", clock, refcount);
 
     return refcount;
 }
@@ -102,7 +101,7 @@ static ULONG WINAPI system_clock_inner_Release(IUnknown *iface)
     ULONG refcount = InterlockedDecrement(&clock->refcount);
     struct advise_sink *sink, *cursor;
 
-    TRACE("%p decreasing refcount to %lu.\n", clock, refcount);
+    TRACE("%p decreasing refcount to %u.\n", clock, refcount);
 
     if (!refcount)
     {
@@ -268,7 +267,7 @@ static HRESULT WINAPI SystemClockImpl_AdviseTime(IReferenceClock *iface,
 {
     struct system_clock *clock = impl_from_IReferenceClock(iface);
 
-    TRACE("clock %p, base %s, offset %s, event %#Ix, cookie %p.\n",
+    TRACE("clock %p, base %s, offset %s, event %#lx, cookie %p.\n",
             clock, debugstr_time(base), debugstr_time(offset), event, cookie);
 
     if (base + offset <= 0)
@@ -282,7 +281,7 @@ static HRESULT WINAPI SystemClockImpl_AdvisePeriodic(IReferenceClock* iface,
 {
     struct system_clock *clock = impl_from_IReferenceClock(iface);
 
-    TRACE("clock %p, start %s, period %s, semaphore %#Ix, cookie %p.\n",
+    TRACE("clock %p, start %s, period %s, semaphore %#lx, cookie %p.\n",
             clock, debugstr_time(start), debugstr_time(period), semaphore, cookie);
 
     if (start <= 0 || period <= 0)
@@ -296,7 +295,7 @@ static HRESULT WINAPI SystemClockImpl_Unadvise(IReferenceClock *iface, DWORD_PTR
     struct system_clock *clock = impl_from_IReferenceClock(iface);
     struct advise_sink *sink;
 
-    TRACE("clock %p, cookie %#Ix.\n", clock, cookie);
+    TRACE("clock %p, cookie %#lx.\n", clock, cookie);
 
     EnterCriticalSection(&clock->cs);
 
diff --git a/dlls/quartz/tests/Makefile.in b/dlls/quartz/tests/Makefile.in
index 423abc78ef6..a47eec8bfd2 100644
--- wine/dlls/quartz/tests/Makefile.in
+++ wine/dlls/quartz/tests/Makefile.in
@@ -1,3 +1,4 @@
+EXTRADEFS = -DWINE_NO_LONG_TYPES
 TESTDLL   = quartz.dll
 IMPORTS   = strmbase advapi32 d3d9 dsound msdmo msvfw32 ole32 oleaut32 user32 uuid winmm
 
diff --git a/dlls/quartz/tests/acmwrapper.c b/dlls/quartz/tests/acmwrapper.c
index caeca61ae50..31b32b53ac9 100644
--- wine/dlls/quartz/tests/acmwrapper.c
+++ wine/dlls/quartz/tests/acmwrapper.c
@@ -27,7 +27,7 @@ static IBaseFilter *create_acm_wrapper(void)
     IBaseFilter *filter = NULL;
     HRESULT hr = CoCreateInstance(&CLSID_ACMWrapper, NULL, CLSCTX_INPROC_SERVER,
             &IID_IBaseFilter, (void **)&filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     return filter;
 }
 
@@ -48,7 +48,7 @@ static void check_interface_(unsigned int line, void *iface_ptr, REFIID iid, BOO
     expected_hr = supported ? S_OK : E_NOINTERFACE;
 
     hr = IUnknown_QueryInterface(iface, iid, (void **)&unk);
-    ok_(__FILE__, line)(hr == expected_hr, "Got hr %#lx, expected %#lx.\n", hr, expected_hr);
+    ok_(__FILE__, line)(hr == expected_hr, "Got hr %#x, expected %#x.\n", hr, expected_hr);
     if (SUCCEEDED(hr))
         IUnknown_Release(unk);
 }
@@ -148,53 +148,53 @@ static void test_aggregation(void)
     filter = (IBaseFilter *)0xdeadbeef;
     hr = CoCreateInstance(&CLSID_ACMWrapper, &test_outer, CLSCTX_INPROC_SERVER,
             &IID_IBaseFilter, (void **)&filter);
-    ok(hr == E_NOINTERFACE, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOINTERFACE, "Got hr %#x.\n", hr);
     ok(!filter, "Got interface %p.\n", filter);
 
     hr = CoCreateInstance(&CLSID_ACMWrapper, &test_outer, CLSCTX_INPROC_SERVER,
             &IID_IUnknown, (void **)&unk);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(outer_ref == 1, "Got unexpected refcount %ld.\n", outer_ref);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
     ok(unk != &test_outer, "Returned IUnknown should not be outer IUnknown.\n");
     ref = get_refcount(unk);
-    ok(ref == 1, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
 
     ref = IUnknown_AddRef(unk);
-    ok(ref == 2, "Got unexpected refcount %ld.\n", ref);
-    ok(outer_ref == 1, "Got unexpected refcount %ld.\n", outer_ref);
+    ok(ref == 2, "Got unexpected refcount %d.\n", ref);
+    ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
 
     ref = IUnknown_Release(unk);
-    ok(ref == 1, "Got unexpected refcount %ld.\n", ref);
-    ok(outer_ref == 1, "Got unexpected refcount %ld.\n", outer_ref);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
+    ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
 
     hr = IUnknown_QueryInterface(unk, &IID_IUnknown, (void **)&unk2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(unk2 == unk, "Got unexpected IUnknown %p.\n", unk2);
     IUnknown_Release(unk2);
 
     hr = IUnknown_QueryInterface(unk, &IID_IBaseFilter, (void **)&filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_QueryInterface(filter, &IID_IUnknown, (void **)&unk2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(unk2 == (IUnknown *)0xdeadbeef, "Got unexpected IUnknown %p.\n", unk2);
 
     hr = IBaseFilter_QueryInterface(filter, &IID_IBaseFilter, (void **)&filter2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(filter2 == (IBaseFilter *)0xdeadbeef, "Got unexpected IBaseFilter %p.\n", filter2);
 
     hr = IUnknown_QueryInterface(unk, &test_iid, (void **)&unk2);
-    ok(hr == E_NOINTERFACE, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOINTERFACE, "Got hr %#x.\n", hr);
     ok(!unk2, "Got unexpected IUnknown %p.\n", unk2);
 
     hr = IBaseFilter_QueryInterface(filter, &test_iid, (void **)&unk2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(unk2 == (IUnknown *)0xdeadbeef, "Got unexpected IUnknown %p.\n", unk2);
 
     IBaseFilter_Release(filter);
     ref = IUnknown_Release(unk);
-    ok(!ref, "Got unexpected refcount %ld.\n", ref);
-    ok(outer_ref == 1, "Got unexpected refcount %ld.\n", outer_ref);
+    ok(!ref, "Got unexpected refcount %d.\n", ref);
+    ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
 }
 
 static void test_enum_pins(void)
@@ -206,116 +206,116 @@ static void test_enum_pins(void)
     HRESULT hr;
 
     ref = get_refcount(filter);
-    ok(ref == 1, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
 
     hr = IBaseFilter_EnumPins(filter, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_EnumPins(filter, &enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ref = get_refcount(filter);
-    ok(ref == 2, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 2, "Got unexpected refcount %d.\n", ref);
     ref = get_refcount(enum1);
-    ok(ref == 1, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
 
     hr = IEnumPins_Next(enum1, 1, NULL, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum1, 1, pins, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ref = get_refcount(filter);
-    ok(ref == 3, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 3, "Got unexpected refcount %d.\n", ref);
     ref = get_refcount(pins[0]);
-    ok(ref == 3, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 3, "Got unexpected refcount %d.\n", ref);
     ref = get_refcount(enum1);
-    ok(ref == 1, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
     IPin_Release(pins[0]);
     ref = get_refcount(filter);
-    ok(ref == 2, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 2, "Got unexpected refcount %d.\n", ref);
 
     hr = IEnumPins_Next(enum1, 1, pins, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ref = get_refcount(filter);
-    ok(ref == 3, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 3, "Got unexpected refcount %d.\n", ref);
     ref = get_refcount(pins[0]);
-    ok(ref == 3, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 3, "Got unexpected refcount %d.\n", ref);
     ref = get_refcount(enum1);
-    ok(ref == 1, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
     IPin_Release(pins[0]);
     ref = get_refcount(filter);
-    ok(ref == 2, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 2, "Got unexpected refcount %d.\n", ref);
 
     hr = IEnumPins_Next(enum1, 1, pins, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum1, 1, pins, &count);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(count == 1, "Got count %lu.\n", count);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(count == 1, "Got count %u.\n", count);
     IPin_Release(pins[0]);
 
     hr = IEnumPins_Next(enum1, 1, pins, &count);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(count == 1, "Got count %lu.\n", count);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(count == 1, "Got count %u.\n", count);
     IPin_Release(pins[0]);
 
     hr = IEnumPins_Next(enum1, 1, pins, &count);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
-    ok(!count, "Got count %lu.\n", count);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    ok(!count, "Got count %u.\n", count);
 
     hr = IEnumPins_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum1, 2, pins, NULL);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum1, 2, pins, &count);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(count == 2, "Got count %lu.\n", count);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(count == 2, "Got count %u.\n", count);
     IPin_Release(pins[0]);
     IPin_Release(pins[1]);
 
     hr = IEnumPins_Next(enum1, 2, pins, &count);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
-    ok(!count, "Got count %lu.\n", count);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    ok(!count, "Got count %u.\n", count);
 
     hr = IEnumPins_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum1, 3, pins, &count);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
-    ok(count == 2, "Got count %lu.\n", count);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    ok(count == 2, "Got count %u.\n", count);
     IPin_Release(pins[0]);
     IPin_Release(pins[1]);
 
     hr = IEnumPins_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Clone(enum1, &enum2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Skip(enum1, 3);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Skip(enum1, 2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Skip(enum1, 1);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum1, 1, pins, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum2, 1, pins, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     IPin_Release(pins[0]);
 
     IEnumPins_Release(enum2);
     IEnumPins_Release(enum1);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 static void test_find_pin(void)
@@ -327,36 +327,36 @@ static void test_find_pin(void)
     ULONG ref;
 
     hr = IBaseFilter_EnumPins(filter, &enum_pins);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_FindPin(filter, L"In", &pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IEnumPins_Next(enum_pins, 1, &pin2, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(pin == pin2, "Pins didn't match.\n");
     IPin_Release(pin);
     IPin_Release(pin2);
 
     hr = IBaseFilter_FindPin(filter, L"Out", &pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IEnumPins_Next(enum_pins, 1, &pin2, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(pin == pin2, "Pins didn't match.\n");
     IPin_Release(pin);
     IPin_Release(pin2);
 
     hr = IBaseFilter_FindPin(filter, L"Input", &pin);
-    ok(hr == VFW_E_NOT_FOUND, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_FOUND, "Got hr %#x.\n", hr);
     hr = IBaseFilter_FindPin(filter, L"Output", &pin);
-    ok(hr == VFW_E_NOT_FOUND, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_FOUND, "Got hr %#x.\n", hr);
     hr = IBaseFilter_FindPin(filter, L"input pin", &pin);
-    ok(hr == VFW_E_NOT_FOUND, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_FOUND, "Got hr %#x.\n", hr);
     hr = IBaseFilter_FindPin(filter, L"output pin", &pin);
-    ok(hr == VFW_E_NOT_FOUND, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_FOUND, "Got hr %#x.\n", hr);
 
     IEnumPins_Release(enum_pins);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 static void test_pin_info(void)
@@ -370,66 +370,68 @@ static void test_pin_info(void)
     IPin *pin;
 
     hr = IBaseFilter_FindPin(filter, L"In", &pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ref = get_refcount(filter);
-    ok(ref == 2, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 2, "Got unexpected refcount %d.\n", ref);
     ref = get_refcount(pin);
-    ok(ref == 2, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 2, "Got unexpected refcount %d.\n", ref);
 
     hr = IPin_QueryPinInfo(pin, &info);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(info.pFilter == filter, "Expected filter %p, got %p.\n", filter, info.pFilter);
     ok(info.dir == PINDIR_INPUT, "Got direction %d.\n", info.dir);
-    ok(!wcscmp(info.achName, L"Input"), "Got name %s.\n", debugstr_w(info.achName));
+todo_wine
+    ok(!wcscmp(info.achName, L"Input"), "Got name %s.\n", wine_dbgstr_w(info.achName));
     ref = get_refcount(filter);
-    ok(ref == 3, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 3, "Got unexpected refcount %d.\n", ref);
     ref = get_refcount(pin);
-    ok(ref == 3, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 3, "Got unexpected refcount %d.\n", ref);
     IBaseFilter_Release(info.pFilter);
 
     hr = IPin_QueryDirection(pin, &dir);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(dir == PINDIR_INPUT, "Got direction %d.\n", dir);
 
     hr = IPin_QueryId(pin, &id);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(!wcscmp(id, L"In"), "Got id %s.\n", wine_dbgstr_w(id));
     CoTaskMemFree(id);
 
     hr = IPin_QueryInternalConnections(pin, NULL, NULL);
-    ok(hr == E_NOTIMPL, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOTIMPL, "Got hr %#x.\n", hr);
 
     IPin_Release(pin);
 
     hr = IBaseFilter_FindPin(filter, L"Out", &pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     check_interface(pin, &IID_IPin, TRUE);
     check_interface(pin, &IID_IMediaSeeking, TRUE);
 
     hr = IPin_QueryPinInfo(pin, &info);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(info.pFilter == filter, "Expected filter %p, got %p.\n", filter, info.pFilter);
     ok(info.dir == PINDIR_OUTPUT, "Got direction %d.\n", info.dir);
-    ok(!wcscmp(info.achName, L"Output"), "Got name %s.\n", debugstr_w(info.achName));
+todo_wine
+    ok(!wcscmp(info.achName, L"Output"), "Got name %s.\n", wine_dbgstr_w(info.achName));
     IBaseFilter_Release(info.pFilter);
 
     hr = IPin_QueryDirection(pin, &dir);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(dir == PINDIR_OUTPUT, "Got direction %d.\n", dir);
 
     hr = IPin_QueryId(pin, &id);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(!wcscmp(id, L"Out"), "Got id %s.\n", wine_dbgstr_w(id));
     CoTaskMemFree(id);
 
     hr = IPin_QueryInternalConnections(pin, NULL, NULL);
-    ok(hr == E_NOTIMPL, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOTIMPL, "Got hr %#x.\n", hr);
 
     IPin_Release(pin);
 
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 static void test_unconnected_filter_state(void)
@@ -440,53 +442,53 @@ static void test_unconnected_filter_state(void)
     ULONG ref;
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(state == State_Stopped, "Got state %u.\n", state);
 
     hr = IBaseFilter_Pause(filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(state == State_Paused, "Got state %u.\n", state);
 
     hr = IBaseFilter_Run(filter, 0);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(state == State_Running, "Got state %u.\n", state);
 
     hr = IBaseFilter_Pause(filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(state == State_Paused, "Got state %u.\n", state);
 
     hr = IBaseFilter_Stop(filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(state == State_Stopped, "Got state %u.\n", state);
 
     hr = IBaseFilter_Run(filter, 0);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(state == State_Running, "Got state %u.\n", state);
 
     hr = IBaseFilter_Stop(filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(state == State_Stopped, "Got state %u.\n", state);
 
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 START_TEST(acmwrapper)
diff --git a/dlls/quartz/tests/avidec.c b/dlls/quartz/tests/avidec.c
index 46ce5d9eeda..ac1078bf59b 100644
--- wine/dlls/quartz/tests/avidec.c
+++ wine/dlls/quartz/tests/avidec.c
@@ -35,7 +35,7 @@ static IBaseFilter *create_avi_dec(void)
     IBaseFilter *filter = NULL;
     HRESULT hr = CoCreateInstance(&CLSID_AVIDec, NULL, CLSCTX_INPROC_SERVER,
             &IID_IBaseFilter, (void **)&filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     return filter;
 }
 
@@ -60,7 +60,7 @@ static LRESULT CALLBACK vfw_driver_proc(DWORD_PTR id, HDRVR driver, UINT msg,
     static int in_begin;
 
     if (winetest_debug > 1)
-        trace("id %#Ix, driver %p, msg %#x, lparam1 %#Ix, lparam2 %#Ix.\n",
+        trace("id %#lx, driver %p, msg %#x, lparam1 %#lx, lparam2 %#lx.\n",
                 id, driver, msg, lparam1, lparam2);
 
     switch (msg)
@@ -143,18 +143,18 @@ static LRESULT CALLBACK vfw_driver_proc(DWORD_PTR id, HDRVR driver, UINT msg,
         ok(lparam2 == sizeof(ICDECOMPRESS), "Got size %Iu.\n", lparam2);
 
         if (testmode == 5 || testmode == 6)
-            ok(params->dwFlags == ICDECOMPRESS_NOTKEYFRAME, "Got flags %#lx.\n", params->dwFlags);
+            ok(params->dwFlags == ICDECOMPRESS_NOTKEYFRAME, "Got flags %#x.\n", params->dwFlags);
         else if (testmode == 3)
-            ok(params->dwFlags == ICDECOMPRESS_PREROLL, "Got flags %#lx.\n", params->dwFlags);
+            ok(params->dwFlags == ICDECOMPRESS_PREROLL, "Got flags %#x.\n", params->dwFlags);
         else
-            ok(params->dwFlags == 0, "Got flags %#lx.\n", params->dwFlags);
+            ok(params->dwFlags == 0, "Got flags %#x.\n", params->dwFlags);
 
         expect_sink_format.biSizeImage = 200;
         ok(!memcmp(params->lpbiInput, &expect_sink_format, sizeof(BITMAPINFOHEADER)),
                 "Input types didn't match.\n");
         ok(!memcmp(params->lpbiOutput, &source_bitmap_info, sizeof(BITMAPINFOHEADER)),
                 "Output types didn't match.\n");
-        ok(!params->ckid, "Got chunk id %#lx.\n", params->ckid);
+        ok(!params->ckid, "Got chunk id %#x.\n", params->ckid);
 
         for (i = 0; i < 200; ++i)
             expect[i] = i;
@@ -189,7 +189,7 @@ static void check_interface_(unsigned int line, void *iface_ptr, REFIID iid, BOO
     expected_hr = supported ? S_OK : E_NOINTERFACE;
 
     hr = IUnknown_QueryInterface(iface, iid, (void **)&unk);
-    ok_(__FILE__, line)(hr == expected_hr, "Got hr %#lx, expected %#lx.\n", hr, expected_hr);
+    ok_(__FILE__, line)(hr == expected_hr, "Got hr %#x, expected %#x.\n", hr, expected_hr);
     if (SUCCEEDED(hr))
         IUnknown_Release(unk);
 }
@@ -289,53 +289,53 @@ static void test_aggregation(void)
     filter = (IBaseFilter *)0xdeadbeef;
     hr = CoCreateInstance(&CLSID_AVIDec, &test_outer, CLSCTX_INPROC_SERVER,
             &IID_IBaseFilter, (void **)&filter);
-    ok(hr == E_NOINTERFACE, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOINTERFACE, "Got hr %#x.\n", hr);
     ok(!filter, "Got interface %p.\n", filter);
 
     hr = CoCreateInstance(&CLSID_AVIDec, &test_outer, CLSCTX_INPROC_SERVER,
             &IID_IUnknown, (void **)&unk);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(outer_ref == 1, "Got unexpected refcount %ld.\n", outer_ref);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
     ok(unk != &test_outer, "Returned IUnknown should not be outer IUnknown.\n");
     ref = get_refcount(unk);
-    ok(ref == 1, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
 
     ref = IUnknown_AddRef(unk);
-    ok(ref == 2, "Got unexpected refcount %ld.\n", ref);
-    ok(outer_ref == 1, "Got unexpected refcount %ld.\n", outer_ref);
+    ok(ref == 2, "Got unexpected refcount %d.\n", ref);
+    ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
 
     ref = IUnknown_Release(unk);
-    ok(ref == 1, "Got unexpected refcount %ld.\n", ref);
-    ok(outer_ref == 1, "Got unexpected refcount %ld.\n", outer_ref);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
+    ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
 
     hr = IUnknown_QueryInterface(unk, &IID_IUnknown, (void **)&unk2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(unk2 == unk, "Got unexpected IUnknown %p.\n", unk2);
     IUnknown_Release(unk2);
 
     hr = IUnknown_QueryInterface(unk, &IID_IBaseFilter, (void **)&filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_QueryInterface(filter, &IID_IUnknown, (void **)&unk2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(unk2 == (IUnknown *)0xdeadbeef, "Got unexpected IUnknown %p.\n", unk2);
 
     hr = IBaseFilter_QueryInterface(filter, &IID_IBaseFilter, (void **)&filter2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(filter2 == (IBaseFilter *)0xdeadbeef, "Got unexpected IBaseFilter %p.\n", filter2);
 
     hr = IUnknown_QueryInterface(unk, &test_iid, (void **)&unk2);
-    ok(hr == E_NOINTERFACE, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOINTERFACE, "Got hr %#x.\n", hr);
     ok(!unk2, "Got unexpected IUnknown %p.\n", unk2);
 
     hr = IBaseFilter_QueryInterface(filter, &test_iid, (void **)&unk2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(unk2 == (IUnknown *)0xdeadbeef, "Got unexpected IUnknown %p.\n", unk2);
 
     IBaseFilter_Release(filter);
     ref = IUnknown_Release(unk);
-    ok(!ref, "Got unexpected refcount %ld.\n", ref);
-    ok(outer_ref == 1, "Got unexpected refcount %ld.\n", outer_ref);
+    ok(!ref, "Got unexpected refcount %d.\n", ref);
+    ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
 }
 
 static void test_enum_pins(void)
@@ -347,116 +347,116 @@ static void test_enum_pins(void)
     HRESULT hr;
 
     ref = get_refcount(filter);
-    ok(ref == 1, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
 
     hr = IBaseFilter_EnumPins(filter, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_EnumPins(filter, &enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ref = get_refcount(filter);
-    ok(ref == 2, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 2, "Got unexpected refcount %d.\n", ref);
     ref = get_refcount(enum1);
-    ok(ref == 1, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
 
     hr = IEnumPins_Next(enum1, 1, NULL, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum1, 1, pins, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ref = get_refcount(filter);
-    ok(ref == 3, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 3, "Got unexpected refcount %d.\n", ref);
     ref = get_refcount(pins[0]);
-    ok(ref == 3, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 3, "Got unexpected refcount %d.\n", ref);
     ref = get_refcount(enum1);
-    ok(ref == 1, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
     IPin_Release(pins[0]);
     ref = get_refcount(filter);
-    ok(ref == 2, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 2, "Got unexpected refcount %d.\n", ref);
 
     hr = IEnumPins_Next(enum1, 1, pins, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ref = get_refcount(filter);
-    ok(ref == 3, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 3, "Got unexpected refcount %d.\n", ref);
     ref = get_refcount(pins[0]);
-    ok(ref == 3, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 3, "Got unexpected refcount %d.\n", ref);
     ref = get_refcount(enum1);
-    ok(ref == 1, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
     IPin_Release(pins[0]);
     ref = get_refcount(filter);
-    ok(ref == 2, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 2, "Got unexpected refcount %d.\n", ref);
 
     hr = IEnumPins_Next(enum1, 1, pins, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum1, 1, pins, &count);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(count == 1, "Got count %lu.\n", count);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(count == 1, "Got count %u.\n", count);
     IPin_Release(pins[0]);
 
     hr = IEnumPins_Next(enum1, 1, pins, &count);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(count == 1, "Got count %lu.\n", count);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(count == 1, "Got count %u.\n", count);
     IPin_Release(pins[0]);
 
     hr = IEnumPins_Next(enum1, 1, pins, &count);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
-    ok(!count, "Got count %lu.\n", count);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    ok(!count, "Got count %u.\n", count);
 
     hr = IEnumPins_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum1, 2, pins, NULL);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum1, 2, pins, &count);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(count == 2, "Got count %lu.\n", count);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(count == 2, "Got count %u.\n", count);
     IPin_Release(pins[0]);
     IPin_Release(pins[1]);
 
     hr = IEnumPins_Next(enum1, 2, pins, &count);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
-    ok(!count, "Got count %lu.\n", count);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    ok(!count, "Got count %u.\n", count);
 
     hr = IEnumPins_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum1, 3, pins, &count);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
-    ok(count == 2, "Got count %lu.\n", count);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    ok(count == 2, "Got count %u.\n", count);
     IPin_Release(pins[0]);
     IPin_Release(pins[1]);
 
     hr = IEnumPins_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Clone(enum1, &enum2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Skip(enum1, 3);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Skip(enum1, 2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Skip(enum1, 1);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum1, 1, pins, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum2, 1, pins, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     IPin_Release(pins[0]);
 
     IEnumPins_Release(enum2);
     IEnumPins_Release(enum1);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 static void test_find_pin(void)
@@ -468,36 +468,36 @@ static void test_find_pin(void)
     ULONG ref;
 
     hr = IBaseFilter_EnumPins(filter, &enum_pins);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_FindPin(filter, L"In", &pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IEnumPins_Next(enum_pins, 1, &pin2, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(pin == pin2, "Pins didn't match.\n");
     IPin_Release(pin);
     IPin_Release(pin2);
 
     hr = IBaseFilter_FindPin(filter, L"Out", &pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IEnumPins_Next(enum_pins, 1, &pin2, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(pin == pin2, "Pins didn't match.\n");
     IPin_Release(pin);
     IPin_Release(pin2);
 
     hr = IBaseFilter_FindPin(filter, L"XForm In", &pin);
-    ok(hr == VFW_E_NOT_FOUND, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_FOUND, "Got hr %#x.\n", hr);
     hr = IBaseFilter_FindPin(filter, L"XForm Out", &pin);
-    ok(hr == VFW_E_NOT_FOUND, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_FOUND, "Got hr %#x.\n", hr);
     hr = IBaseFilter_FindPin(filter, L"input pin", &pin);
-    ok(hr == VFW_E_NOT_FOUND, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_FOUND, "Got hr %#x.\n", hr);
     hr = IBaseFilter_FindPin(filter, L"output pin", &pin);
-    ok(hr == VFW_E_NOT_FOUND, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_FOUND, "Got hr %#x.\n", hr);
 
     IEnumPins_Release(enum_pins);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 static void test_pin_info(void)
@@ -511,66 +511,66 @@ static void test_pin_info(void)
     IPin *pin;
 
     hr = IBaseFilter_FindPin(filter, L"In", &pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ref = get_refcount(filter);
-    ok(ref == 2, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 2, "Got unexpected refcount %d.\n", ref);
     ref = get_refcount(pin);
-    ok(ref == 2, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 2, "Got unexpected refcount %d.\n", ref);
 
     hr = IPin_QueryPinInfo(pin, &info);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(info.pFilter == filter, "Expected filter %p, got %p.\n", filter, info.pFilter);
     ok(info.dir == PINDIR_INPUT, "Got direction %d.\n", info.dir);
-    ok(!wcscmp(info.achName, L"XForm In"), "Got name %s.\n", wine_dbgstr_w(info.achName));
+    todo_wine ok(!wcscmp(info.achName, L"XForm In"), "Got name %s.\n", wine_dbgstr_w(info.achName));
     ref = get_refcount(filter);
-    ok(ref == 3, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 3, "Got unexpected refcount %d.\n", ref);
     ref = get_refcount(pin);
-    ok(ref == 3, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 3, "Got unexpected refcount %d.\n", ref);
     IBaseFilter_Release(info.pFilter);
 
     hr = IPin_QueryDirection(pin, &dir);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(dir == PINDIR_INPUT, "Got direction %d.\n", dir);
 
     hr = IPin_QueryId(pin, &id);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(!wcscmp(id, L"In"), "Got id %s.\n", wine_dbgstr_w(id));
     CoTaskMemFree(id);
 
     hr = IPin_QueryInternalConnections(pin, NULL, NULL);
-    ok(hr == E_NOTIMPL, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOTIMPL, "Got hr %#x.\n", hr);
 
     IPin_Release(pin);
 
     hr = IBaseFilter_FindPin(filter, L"Out", &pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     check_interface(pin, &IID_IPin, TRUE);
     check_interface(pin, &IID_IMediaSeeking, TRUE);
 
     hr = IPin_QueryPinInfo(pin, &info);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(info.pFilter == filter, "Expected filter %p, got %p.\n", filter, info.pFilter);
     ok(info.dir == PINDIR_OUTPUT, "Got direction %d.\n", info.dir);
-    ok(!wcscmp(info.achName, L"XForm Out"), "Got name %s.\n", wine_dbgstr_w(info.achName));
+    todo_wine ok(!wcscmp(info.achName, L"XForm Out"), "Got name %s.\n", wine_dbgstr_w(info.achName));
     IBaseFilter_Release(info.pFilter);
 
     hr = IPin_QueryDirection(pin, &dir);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(dir == PINDIR_OUTPUT, "Got direction %d.\n", dir);
 
     hr = IPin_QueryId(pin, &id);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(!wcscmp(id, L"Out"), "Got id %s.\n", wine_dbgstr_w(id));
     CoTaskMemFree(id);
 
     hr = IPin_QueryInternalConnections(pin, NULL, NULL);
-    ok(hr == E_NOTIMPL, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOTIMPL, "Got hr %#x.\n", hr);
 
     IPin_Release(pin);
 
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 static void test_media_types(void)
@@ -586,10 +586,10 @@ static void test_media_types(void)
     IBaseFilter_FindPin(filter, L"In", &pin);
 
     hr = IPin_EnumMediaTypes(pin, &enummt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enummt, 1, &pmt, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     IEnumMediaTypes_Release(enummt);
 
@@ -604,35 +604,35 @@ static void test_media_types(void)
     vih.bmiHeader.biHeight = 24;
     vih.bmiHeader.biBitCount = 16;
     hr = IPin_QueryAccept(pin, &mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     vih.bmiHeader.biBitCount = 32;
     hr = IPin_QueryAccept(pin, &mt);
-    todo_wine ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     vih.bmiHeader.biBitCount = 16;
 
     mt.bFixedSizeSamples = TRUE;
     mt.bTemporalCompression = TRUE;
     mt.lSampleSize = 123;
     hr = IPin_QueryAccept(pin, &mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     /* Some versions of quartz check the major type; some do not. */
 
     mt.subtype = MEDIASUBTYPE_NULL;
     hr = IPin_QueryAccept(pin, &mt);
-    todo_wine ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     mt.subtype = MEDIASUBTYPE_RGB24;
     hr = IPin_QueryAccept(pin, &mt);
-    todo_wine ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     mt.subtype = test_subtype;
 
     mt.formattype = GUID_NULL;
     hr = IPin_QueryAccept(pin, &mt);
-    todo_wine ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     mt.formattype = FORMAT_None;
     hr = IPin_QueryAccept(pin, &mt);
-    todo_wine ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     mt.formattype = FORMAT_VideoInfo;
 
     IPin_Release(pin);
@@ -640,23 +640,23 @@ static void test_media_types(void)
     IBaseFilter_FindPin(filter, L"Out", &pin);
 
     hr = IPin_EnumMediaTypes(pin, &enummt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enummt, 1, &pmt, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     mt.subtype = MEDIASUBTYPE_RGB24;
     vih.bmiHeader.biCompression = BI_RGB;
     vih.bmiHeader.biBitCount = 24;
     vih.bmiHeader.biSizeImage= 32 * 24 * 3;
     hr = IPin_QueryAccept(pin, &mt);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     IEnumMediaTypes_Release(enummt);
     IPin_Release(pin);
 
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 static void test_enum_media_types(void)
@@ -671,29 +671,29 @@ static void test_enum_media_types(void)
     IBaseFilter_FindPin(filter, L"In", &pin);
 
     hr = IPin_EnumMediaTypes(pin, &enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enum1, 1, mts, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enum1, 1, mts, &count);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
-    ok(!count, "Got count %lu.\n", count);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    ok(!count, "Got count %u.\n", count);
 
     hr = IEnumMediaTypes_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enum1, 1, mts, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Clone(enum1, &enum2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Skip(enum1, 1);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enum2, 1, mts, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     IEnumMediaTypes_Release(enum1);
     IEnumMediaTypes_Release(enum2);
@@ -702,36 +702,36 @@ static void test_enum_media_types(void)
     IBaseFilter_FindPin(filter, L"Out", &pin);
 
     hr = IPin_EnumMediaTypes(pin, &enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enum1, 1, mts, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enum1, 1, mts, &count);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
-    ok(!count, "Got count %lu.\n", count);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    ok(!count, "Got count %u.\n", count);
 
     hr = IEnumMediaTypes_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enum1, 1, mts, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Clone(enum1, &enum2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Skip(enum1, 1);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enum2, 1, mts, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     IEnumMediaTypes_Release(enum1);
     IEnumMediaTypes_Release(enum2);
     IPin_Release(pin);
 
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 static void test_unconnected_filter_state(void)
@@ -742,53 +742,53 @@ static void test_unconnected_filter_state(void)
     ULONG ref;
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(state == State_Stopped, "Got state %u.\n", state);
 
     hr = IBaseFilter_Pause(filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(state == State_Paused, "Got state %u.\n", state);
 
     hr = IBaseFilter_Run(filter, 0);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(state == State_Running, "Got state %u.\n", state);
 
     hr = IBaseFilter_Pause(filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(state == State_Paused, "Got state %u.\n", state);
 
     hr = IBaseFilter_Stop(filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(state == State_Stopped, "Got state %u.\n", state);
 
     hr = IBaseFilter_Run(filter, 0);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(state == State_Running, "Got state %u.\n", state);
 
     hr = IBaseFilter_Stop(filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(state == State_Stopped, "Got state %u.\n", state);
 
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 struct testfilter
@@ -884,12 +884,12 @@ static HRESULT WINAPI testsink_Receive(struct strmbase_sink *iface, IMediaSample
     ++filter->got_sample;
 
     size = IMediaSample_GetSize(sample);
-    ok(size == 32 * 24 * 12 / 8, "Got size %lu.\n", size);
+    ok(size == 32 * 24 * 12 / 8, "Got size %u.\n", size);
     size = IMediaSample_GetActualDataLength(sample);
-    ok(size == 32 * 24 * 12 / 8, "Got valid size %lu.\n", size);
+    ok(size == 32 * 24 * 12 / 8, "Got valid size %u.\n", size);
 
     hr = IMediaSample_GetPointer(sample, &data);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     for (i = 0; i < size; ++i)
         expect[i] = 111 - i;
     ok(!memcmp(data, expect, size), "Data didn't match.\n");
@@ -897,28 +897,28 @@ static HRESULT WINAPI testsink_Receive(struct strmbase_sink *iface, IMediaSample
     hr = IMediaSample_GetTime(sample, &start, &stop);
     if (testmode == 0)
     {
-        ok(hr == VFW_E_SAMPLE_TIME_NOT_SET, "Got hr %#lx.\n", hr);
+        ok(hr == VFW_E_SAMPLE_TIME_NOT_SET, "Got hr %#x.\n", hr);
     }
     else if (testmode == 1)
     {
-        ok(hr == VFW_S_NO_STOP_TIME, "Got hr %#lx.\n", hr);
+        ok(hr == VFW_S_NO_STOP_TIME, "Got hr %#x.\n", hr);
         ok(start == 20000, "Got start time %s.\n", wine_dbgstr_longlong(start));
     }
     else
     {
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
         ok(start == 20000, "Got start time %s.\n", wine_dbgstr_longlong(start));
         ok(stop == 30000, "Got stop time %s.\n", wine_dbgstr_longlong(stop));
     }
 
     hr = IMediaSample_GetMediaTime(sample, &start, &stop);
-    ok(hr == VFW_E_MEDIA_TIME_NOT_SET, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_MEDIA_TIME_NOT_SET, "Got hr %#x.\n", hr);
     hr = IMediaSample_IsDiscontinuity(sample);
-    todo_wine_if (testmode == 5) ok(hr == (testmode == 4) ? S_OK : S_FALSE, "Got hr %#lx.\n", hr);
+    todo_wine_if (testmode == 5) ok(hr == (testmode == 4) ? S_OK : S_FALSE, "Got hr %#x.\n", hr);
     hr = IMediaSample_IsPreroll(sample);
-    todo_wine_if (testmode == 3) ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    todo_wine_if (testmode == 3) ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     hr = IMediaSample_IsSyncPoint(sample);
-    todo_wine_if (testmode == 5 || testmode == 6) ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine_if (testmode == 5 || testmode == 6) ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     return S_OK;
 }
@@ -983,27 +983,27 @@ static void test_sink_allocator(IMemInputPin *input)
     HRESULT hr;
 
     hr = IMemInputPin_GetAllocatorRequirements(input, &props);
-    ok(hr == E_NOTIMPL, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOTIMPL, "Got hr %#x.\n", hr);
 
     hr = IMemInputPin_GetAllocator(input, &ret_allocator);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     if (hr == S_OK)
     {
         hr = IMemAllocator_GetProperties(ret_allocator, &props);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
-        ok(!props.cBuffers, "Got %ld buffers.\n", props.cBuffers);
-        ok(!props.cbBuffer, "Got size %ld.\n", props.cbBuffer);
-        ok(!props.cbAlign, "Got alignment %ld.\n", props.cbAlign);
-        ok(!props.cbPrefix, "Got prefix %ld.\n", props.cbPrefix);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
+        ok(!props.cBuffers, "Got %d buffers.\n", props.cBuffers);
+        ok(!props.cbBuffer, "Got size %d.\n", props.cbBuffer);
+        ok(!props.cbAlign, "Got alignment %d.\n", props.cbAlign);
+        ok(!props.cbPrefix, "Got prefix %d.\n", props.cbPrefix);
 
         hr = IMemInputPin_NotifyAllocator(input, ret_allocator, TRUE);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
         IMemAllocator_Release(ret_allocator);
     }
 
     hr = IMemInputPin_NotifyAllocator(input, NULL, TRUE);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
 
     CoCreateInstance(&CLSID_MemoryAllocator, NULL, CLSCTX_INPROC_SERVER,
             &IID_IMemAllocator, (void **)&req_allocator);
@@ -1013,13 +1013,13 @@ static void test_sink_allocator(IMemInputPin *input)
     props.cbAlign = 1;
     props.cbPrefix = 0;
     hr = IMemAllocator_SetProperties(req_allocator, &props, &ret_props);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMemInputPin_NotifyAllocator(input, req_allocator, TRUE);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMemInputPin_GetAllocator(input, &ret_allocator);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(ret_allocator == req_allocator, "Allocators didn't match.\n");
 
     IMemAllocator_Release(req_allocator);
@@ -1036,104 +1036,104 @@ static void test_sample_processing(IMediaControl *control, IMemInputPin *input,
     BYTE *data;
 
     hr = IMemInputPin_ReceiveCanBlock(input);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMemInputPin_GetAllocator(input, &allocator);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_Pause(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMemAllocator_GetBuffer(allocator, &sample, NULL, NULL, 0);
-    ok(hr == VFW_E_NOT_COMMITTED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_COMMITTED, "Got hr %#x.\n", hr);
 
     hr = IMemAllocator_Commit(allocator);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMemAllocator_GetBuffer(allocator, &sample, NULL, NULL, 0);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaSample_GetPointer(sample, &data);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     size = IMediaSample_GetSize(sample);
-    ok(size == 256, "Got size %ld.\n", size);
+    ok(size == 256, "Got size %d.\n", size);
     for (i = 0; i < 200; ++i)
         data[i] = i;
     hr = IMediaSample_SetActualDataLength(sample, 200);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     start = 10000;
     stop = 20000;
     hr = IMediaSample_SetMediaTime(sample, &start, &stop);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMediaSample_SetSyncPoint(sample, TRUE);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     testmode = 0;
     hr = IMemInputPin_Receive(input, sample);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(sink->got_sample == 1, "Got %u calls to Receive().\n", sink->got_sample);
     sink->got_sample = 0;
 
     start = 20000;
     hr = IMediaSample_SetTime(sample, &start, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     testmode = 1;
     hr = IMemInputPin_Receive(input, sample);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(sink->got_sample == 1, "Got %u calls to Receive().\n", sink->got_sample);
     sink->got_sample = 0;
 
     stop = 30000;
     hr = IMediaSample_SetTime(sample, &start, &stop);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     testmode = 2;
     hr = IMemInputPin_Receive(input, sample);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(sink->got_sample == 1, "Got %u calls to Receive().\n", sink->got_sample);
     sink->got_sample = 0;
 
     hr = IMediaSample_SetPreroll(sample, TRUE);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     testmode = 3;
     hr = IMemInputPin_Receive(input, sample);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     todo_wine ok(!sink->got_sample, "Got %u calls to Receive().\n", sink->got_sample);
 
     hr = IMediaSample_SetPreroll(sample, FALSE);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMediaSample_SetDiscontinuity(sample, TRUE);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     testmode = 4;
     hr = IMemInputPin_Receive(input, sample);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     todo_wine ok(sink->got_sample == 1, "Got %u calls to Receive().\n", sink->got_sample);
     sink->got_sample = 0;
 
     hr = IMediaSample_SetSyncPoint(sample, FALSE);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     testmode = 5;
     hr = IMemInputPin_Receive(input, sample);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     todo_wine ok(!sink->got_sample, "Got %u calls to Receive().\n", sink->got_sample);
 
     hr = IMediaSample_SetDiscontinuity(sample, FALSE);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     testmode = 6;
     hr = IMemInputPin_Receive(input, sample);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     todo_wine ok(!sink->got_sample, "Got %u calls to Receive().\n", sink->got_sample);
 
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMemInputPin_Receive(input, sample);
-    ok(hr == VFW_E_WRONG_STATE, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_WRONG_STATE, "Got hr %#x.\n", hr);
 
     IMediaSample_Release(sample);
     IMemAllocator_Release(allocator);
@@ -1149,68 +1149,68 @@ static void test_streaming_events(IMediaControl *control, IPin *sink,
     LONG i;
 
     hr = IMediaControl_Pause(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMemInputPin_GetAllocator(input, &allocator);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMemAllocator_Commit(allocator);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMemAllocator_GetBuffer(allocator, &sample, NULL, NULL, 0);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMediaSample_GetPointer(sample, &data);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     for (i = 0; i < 200; ++i)
         data[i] = i;
     hr = IMediaSample_SetActualDataLength(sample, 200);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMediaSample_SetSyncPoint(sample, TRUE);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     ok(!testsink->got_new_segment, "Got %u calls to IPin::NewSegment().\n", testsink->got_new_segment);
     hr = IPin_NewSegment(sink, 10000, 20000, 1.0);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(testsink->got_new_segment == 1, "Got %u calls to IPin::NewSegment().\n", testsink->got_new_segment);
 
     ok(!testsink->got_eos, "Got %u calls to IPin::EndOfStream().\n", testsink->got_eos);
     hr = IPin_EndOfStream(sink);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     todo_wine ok(!testsink->got_sample, "Got %u calls to Receive().\n", testsink->got_sample);
     ok(testsink->got_eos == 1, "Got %u calls to IPin::EndOfStream().\n", testsink->got_eos);
     testsink->got_eos = 0;
 
     hr = IPin_EndOfStream(sink);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(testsink->got_eos == 1, "Got %u calls to IPin::EndOfStream().\n", testsink->got_eos);
 
     testmode = 0;
     hr = IMemInputPin_Receive(input, sample);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     todo_wine ok(testsink->got_sample == 1, "Got %u calls to Receive().\n", testsink->got_sample);
     testsink->got_sample = 0;
 
     ok(!testsink->got_begin_flush, "Got %u calls to IPin::BeginFlush().\n", testsink->got_begin_flush);
     hr = IPin_BeginFlush(sink);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(testsink->got_begin_flush == 1, "Got %u calls to IPin::BeginFlush().\n", testsink->got_begin_flush);
 
     hr = IMemInputPin_Receive(input, sample);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IPin_EndOfStream(sink);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     ok(!testsink->got_end_flush, "Got %u calls to IPin::EndFlush().\n", testsink->got_end_flush);
     hr = IPin_EndFlush(sink);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(testsink->got_end_flush == 1, "Got %u calls to IPin::EndFlush().\n", testsink->got_end_flush);
 
     hr = IMemInputPin_Receive(input, sample);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(testsink->got_sample == 1, "Got %u calls to Receive().\n", testsink->got_sample);
     testsink->got_sample = 0;
 
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     IMediaSample_Release(sample);
     IMemAllocator_Release(allocator);
 }
@@ -1262,49 +1262,49 @@ static void test_connect_pin(void)
 
     peer = (IPin *)0xdeadbeef;
     hr = IPin_ConnectedTo(sink, &peer);
-    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#x.\n", hr);
     ok(!peer, "Got peer %p.\n", peer);
 
     hr = IPin_ConnectionMediaType(sink, &mt);
-    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_Pause(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IFilterGraph2_ConnectDirect(graph, &testsource.source.pin.IPin_iface, sink, &req_mt);
-    ok(hr == VFW_E_NOT_STOPPED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_STOPPED, "Got hr %#x.\n", hr);
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     req_mt.subtype = MEDIASUBTYPE_RGB24;
     hr = IFilterGraph2_ConnectDirect(graph, &testsource.source.pin.IPin_iface, sink, &req_mt);
-    ok(hr == VFW_E_TYPE_NOT_ACCEPTED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_TYPE_NOT_ACCEPTED, "Got hr %#x.\n", hr);
     req_mt.subtype = test_subtype;
 
     hr = IFilterGraph2_ConnectDirect(graph, &testsource.source.pin.IPin_iface, sink, &req_mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IPin_ConnectedTo(sink, &peer);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(peer == &testsource.source.pin.IPin_iface, "Got peer %p.\n", peer);
     IPin_Release(peer);
 
     hr = IPin_ConnectionMediaType(sink, &mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(compare_media_types(&mt, &req_mt), "Media types didn't match.\n");
     ok(compare_media_types(&testsource.source.pin.mt, &req_mt), "Media types didn't match.\n");
     FreeMediaType(&mt);
 
     hr = IMediaControl_Pause(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IFilterGraph2_Disconnect(graph, sink);
-    ok(hr == VFW_E_NOT_STOPPED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_STOPPED, "Got hr %#x.\n", hr);
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     sink_bitmap_info = req_format.bmiHeader;
 
     hr = IPin_EnumMediaTypes(source, &enummt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     for (i = 0; i < 9; ++i)
     {
@@ -1349,7 +1349,7 @@ static void test_connect_pin(void)
         };
 
         hr = IEnumMediaTypes_Next(enummt, 1, &pmt, NULL);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
         ok(!memcmp(pmt, &expect_mt, offsetof(AM_MEDIA_TYPE, cbFormat)),
                 "%u: Media types didn't match.\n", i);
         ok(!memcmp(pmt->pbFormat, &expect_format, sizeof(VIDEOINFOHEADER)),
@@ -1358,14 +1358,14 @@ static void test_connect_pin(void)
         {
             const VIDEOINFO *format = (VIDEOINFO *)pmt->pbFormat;
 
-            ok(pmt->cbFormat == offsetof(VIDEOINFO, dwBitMasks[3]), "Got format size %lu.\n", pmt->cbFormat);
-            ok(format->dwBitMasks[iRED] == 0xf800, "Got red bit mask %#lx.\n", format->dwBitMasks[iRED]);
-            ok(format->dwBitMasks[iGREEN] == 0x07e0, "Got green bit mask %#lx.\n", format->dwBitMasks[iGREEN]);
-            ok(format->dwBitMasks[iBLUE] == 0x001f, "Got blue bit mask %#lx.\n", format->dwBitMasks[iBLUE]);
+            ok(pmt->cbFormat == offsetof(VIDEOINFO, dwBitMasks[3]), "Got format size %u.\n", pmt->cbFormat);
+            ok(format->dwBitMasks[iRED] == 0xf800, "Got red bit mask %#x.\n", format->dwBitMasks[iRED]);
+            ok(format->dwBitMasks[iGREEN] == 0x07e0, "Got green bit mask %#x.\n", format->dwBitMasks[iGREEN]);
+            ok(format->dwBitMasks[iBLUE] == 0x001f, "Got blue bit mask %#x.\n", format->dwBitMasks[iBLUE]);
         }
 
         hr = IPin_QueryAccept(source, pmt);
-        ok(hr == (i == 8 ? S_OK : S_FALSE), "Got hr %#lx.\n", hr);
+        ok(hr == (i == 8 ? S_OK : S_FALSE), "Got hr %#x.\n", hr);
 
         if (i == 8)
             CopyMediaType(&source_mt, pmt);
@@ -1374,7 +1374,7 @@ static void test_connect_pin(void)
     }
 
     hr = IEnumMediaTypes_Next(enummt, 1, &pmt, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     IEnumMediaTypes_Release(enummt);
 
@@ -1384,33 +1384,33 @@ static void test_connect_pin(void)
 
     peer = (IPin *)0xdeadbeef;
     hr = IPin_ConnectedTo(source, &peer);
-    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#x.\n", hr);
     ok(!peer, "Got peer %p.\n", peer);
 
     hr = IPin_ConnectionMediaType(source, &mt);
-    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#x.\n", hr);
 
     /* Exact connection. */
 
     CopyMediaType(&req_mt, &source_mt);
 
     hr = IMediaControl_Pause(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IFilterGraph2_ConnectDirect(graph, source, &testsink.sink.pin.IPin_iface, &req_mt);
-    ok(hr == VFW_E_NOT_STOPPED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_STOPPED, "Got hr %#x.\n", hr);
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IFilterGraph2_ConnectDirect(graph, source, &testsink.sink.pin.IPin_iface, &req_mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IPin_ConnectedTo(source, &peer);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(peer == &testsink.sink.pin.IPin_iface, "Got peer %p.\n", peer);
     IPin_Release(peer);
 
     hr = IPin_ConnectionMediaType(source, &mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(compare_media_types(&mt, &req_mt), "Media types didn't match.\n");
     ok(compare_media_types(&testsink.sink.pin.mt, &req_mt), "Media types didn't match.\n");
     FreeMediaType(&mt);
@@ -1418,88 +1418,88 @@ static void test_connect_pin(void)
     source_bitmap_info = ((VIDEOINFOHEADER *)req_mt.pbFormat)->bmiHeader;
 
     hr = IMediaControl_Pause(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IFilterGraph2_Disconnect(graph, source);
-    ok(hr == VFW_E_NOT_STOPPED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_STOPPED, "Got hr %#x.\n", hr);
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     test_sample_processing(control, meminput, &testsink);
     test_streaming_events(control, sink, meminput, &testsink);
 
     hr = IFilterGraph2_Disconnect(graph, source);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IFilterGraph2_Disconnect(graph, source);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     ok(testsink.sink.pin.peer == source, "Got peer %p.\n", testsink.sink.pin.peer);
     IFilterGraph2_Disconnect(graph, &testsink.sink.pin.IPin_iface);
 
     req_mt.lSampleSize = 999;
     req_mt.bTemporalCompression = req_mt.bFixedSizeSamples = TRUE;
     hr = IFilterGraph2_ConnectDirect(graph, source, &testsink.sink.pin.IPin_iface, &req_mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(compare_media_types(&testsink.sink.pin.mt, &req_mt), "Media types didn't match.\n");
     IFilterGraph2_Disconnect(graph, source);
     IFilterGraph2_Disconnect(graph, &testsink.sink.pin.IPin_iface);
 
     req_mt.formattype = FORMAT_None;
     hr = IFilterGraph2_ConnectDirect(graph, source, &testsink.sink.pin.IPin_iface, &req_mt);
-    ok(hr == VFW_E_TYPE_NOT_ACCEPTED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_TYPE_NOT_ACCEPTED, "Got hr %#x.\n", hr);
     req_mt.formattype = FORMAT_VideoInfo;
 
     /* Connection with wildcards. */
 
     hr = IFilterGraph2_ConnectDirect(graph, source, &testsink.sink.pin.IPin_iface, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(compare_media_types(&testsink.sink.pin.mt, &source_mt), "Media types didn't match.\n");
     IFilterGraph2_Disconnect(graph, source);
     IFilterGraph2_Disconnect(graph, &testsink.sink.pin.IPin_iface);
 
     req_mt.majortype = GUID_NULL;
     hr = IFilterGraph2_ConnectDirect(graph, source, &testsink.sink.pin.IPin_iface, &req_mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(compare_media_types(&testsink.sink.pin.mt, &source_mt), "Media types didn't match.\n");
     IFilterGraph2_Disconnect(graph, source);
     IFilterGraph2_Disconnect(graph, &testsink.sink.pin.IPin_iface);
 
     req_mt.subtype = MEDIASUBTYPE_RGB32;
     hr = IFilterGraph2_ConnectDirect(graph, source, &testsink.sink.pin.IPin_iface, &req_mt);
-    ok(hr == VFW_E_NO_ACCEPTABLE_TYPES, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NO_ACCEPTABLE_TYPES, "Got hr %#x.\n", hr);
 
     req_mt.subtype = GUID_NULL;
     hr = IFilterGraph2_ConnectDirect(graph, source, &testsink.sink.pin.IPin_iface, &req_mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(compare_media_types(&testsink.sink.pin.mt, &source_mt), "Media types didn't match.\n");
     IFilterGraph2_Disconnect(graph, source);
     IFilterGraph2_Disconnect(graph, &testsink.sink.pin.IPin_iface);
 
     req_mt.formattype = FORMAT_None;
     hr = IFilterGraph2_ConnectDirect(graph, source, &testsink.sink.pin.IPin_iface, &req_mt);
-    ok(hr == VFW_E_NO_ACCEPTABLE_TYPES, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NO_ACCEPTABLE_TYPES, "Got hr %#x.\n", hr);
 
     req_mt.majortype = MEDIATYPE_Video;
     req_mt.subtype = MEDIASUBTYPE_I420;
     req_mt.formattype = GUID_NULL;
     hr = IFilterGraph2_ConnectDirect(graph, source, &testsink.sink.pin.IPin_iface, &req_mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(compare_media_types(&testsink.sink.pin.mt, &source_mt), "Media types didn't match.\n");
     IFilterGraph2_Disconnect(graph, source);
     IFilterGraph2_Disconnect(graph, &testsink.sink.pin.IPin_iface);
 
     req_mt.subtype = MEDIASUBTYPE_RGB32;
     hr = IFilterGraph2_ConnectDirect(graph, source, &testsink.sink.pin.IPin_iface, &req_mt);
-    ok(hr == VFW_E_NO_ACCEPTABLE_TYPES, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NO_ACCEPTABLE_TYPES, "Got hr %#x.\n", hr);
 
     req_mt.subtype = GUID_NULL;
     hr = IFilterGraph2_ConnectDirect(graph, source, &testsink.sink.pin.IPin_iface, &req_mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(compare_media_types(&testsink.sink.pin.mt, &source_mt), "Media types didn't match.\n");
     IFilterGraph2_Disconnect(graph, source);
     IFilterGraph2_Disconnect(graph, &testsink.sink.pin.IPin_iface);
 
     req_mt.majortype = MEDIATYPE_Audio;
     hr = IFilterGraph2_ConnectDirect(graph, source, &testsink.sink.pin.IPin_iface, &req_mt);
-    ok(hr == VFW_E_NO_ACCEPTABLE_TYPES, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NO_ACCEPTABLE_TYPES, "Got hr %#x.\n", hr);
 
     /* Test enumeration of sink media types. */
 
@@ -1508,20 +1508,20 @@ static void test_connect_pin(void)
     testsink.mt = &req_mt;
     hr = IFilterGraph2_ConnectDirect(graph, source, &testsink.sink.pin.IPin_iface, NULL);
     ok(hr == VFW_E_NO_ACCEPTABLE_TYPES
-            || broken(hr == VFW_E_INVALIDMEDIATYPE) /* Win8+ */, "Got hr %#lx.\n", hr);
+            || broken(hr == VFW_E_INVALIDMEDIATYPE) /* Win8+ */, "Got hr %#x.\n", hr);
 
     req_mt.majortype = MEDIATYPE_Video;
     req_mt.subtype = MEDIASUBTYPE_I420;
     req_mt.formattype = FORMAT_VideoInfo;
     req_mt.lSampleSize = 444;
     hr = IFilterGraph2_ConnectDirect(graph, source, &testsink.sink.pin.IPin_iface, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(compare_media_types(&testsink.sink.pin.mt, &req_mt), "Media types didn't match.\n");
 
     hr = IFilterGraph2_Disconnect(graph, sink);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IFilterGraph2_Disconnect(graph, sink);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     ok(testsource.source.pin.peer == sink, "Got peer %p.\n", testsource.source.pin.peer);
     IFilterGraph2_Disconnect(graph, &testsource.source.pin.IPin_iface);
 
@@ -1530,13 +1530,13 @@ static void test_connect_pin(void)
     IPin_Release(source);
     IMediaControl_Release(control);
     ref = IFilterGraph2_Release(graph);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ref = IBaseFilter_Release(&testsource.filter.IBaseFilter_iface);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ref = IBaseFilter_Release(&testsink.filter.IBaseFilter_iface);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 START_TEST(avidec)
diff --git a/dlls/quartz/tests/avisplit.c b/dlls/quartz/tests/avisplit.c
index 8b7e8a222b0..06c2f5fed3c 100644
--- wine/dlls/quartz/tests/avisplit.c
+++ wine/dlls/quartz/tests/avisplit.c
@@ -32,7 +32,7 @@ static IBaseFilter *create_avi_splitter(void)
     IBaseFilter *filter = NULL;
     HRESULT hr = CoCreateInstance(&CLSID_AviSplitter, NULL, CLSCTX_INPROC_SERVER,
         &IID_IBaseFilter, (void **)&filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     return filter;
 }
 
@@ -54,11 +54,11 @@ static WCHAR *load_resource(const WCHAR *name)
     wcscat(pathW, name);
 
     file = CreateFileW(pathW, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, 0);
-    ok(file != INVALID_HANDLE_VALUE, "Failed to create file %s, error %lu.\n",
+    ok(file != INVALID_HANDLE_VALUE, "Failed to create file %s, error %u.\n",
             wine_dbgstr_w(pathW), GetLastError());
 
     res = FindResourceW(NULL, name, (LPCWSTR)RT_RCDATA);
-    ok(!!res, "Failed to load resource, error %lu.\n", GetLastError());
+    ok(!!res, "Failed to load resource, error %u.\n", GetLastError());
     ptr = LockResource(LoadResource(GetModuleHandleA(NULL), res));
     WriteFile(file, ptr, SizeofResource( GetModuleHandleA(NULL), res), &written, NULL);
     ok(written == SizeofResource(GetModuleHandleA(NULL), res), "Failed to write resource.\n");
@@ -96,7 +96,7 @@ static IFilterGraph2 *connect_input(IBaseFilter *splitter, const WCHAR *filename
     IBaseFilter_FindPin(reader, L"Output", &source);
 
     hr = IFilterGraph2_ConnectDirect(graph, source, sink, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     IPin_Release(source);
     IPin_Release(sink);
@@ -115,7 +115,7 @@ static void check_interface_(unsigned int line, void *iface_ptr, REFIID iid, BOO
     expected_hr = supported ? S_OK : E_NOINTERFACE;
 
     hr = IUnknown_QueryInterface(iface, iid, (void **)&unk);
-    ok_(__FILE__, line)(hr == expected_hr, "Got hr %#lx, expected %#lx.\n", hr, expected_hr);
+    ok_(__FILE__, line)(hr == expected_hr, "Got hr %#x, expected %#x.\n", hr, expected_hr);
     if (SUCCEEDED(hr))
         IUnknown_Release(unk);
 }
@@ -220,53 +220,53 @@ static void test_aggregation(void)
     filter = (IBaseFilter *)0xdeadbeef;
     hr = CoCreateInstance(&CLSID_AviSplitter, &test_outer, CLSCTX_INPROC_SERVER,
             &IID_IBaseFilter, (void **)&filter);
-    ok(hr == E_NOINTERFACE, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOINTERFACE, "Got hr %#x.\n", hr);
     ok(!filter, "Got interface %p.\n", filter);
 
     hr = CoCreateInstance(&CLSID_AviSplitter, &test_outer, CLSCTX_INPROC_SERVER,
             &IID_IUnknown, (void **)&unk);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(outer_ref == 1, "Got unexpected refcount %ld.\n", outer_ref);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
     ok(unk != &test_outer, "Returned IUnknown should not be outer IUnknown.\n");
     ref = get_refcount(unk);
-    ok(ref == 1, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
 
     ref = IUnknown_AddRef(unk);
-    ok(ref == 2, "Got unexpected refcount %ld.\n", ref);
-    ok(outer_ref == 1, "Got unexpected refcount %ld.\n", outer_ref);
+    ok(ref == 2, "Got unexpected refcount %d.\n", ref);
+    ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
 
     ref = IUnknown_Release(unk);
-    ok(ref == 1, "Got unexpected refcount %ld.\n", ref);
-    ok(outer_ref == 1, "Got unexpected refcount %ld.\n", outer_ref);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
+    ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
 
     hr = IUnknown_QueryInterface(unk, &IID_IUnknown, (void **)&unk2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(unk2 == unk, "Got unexpected IUnknown %p.\n", unk2);
     IUnknown_Release(unk2);
 
     hr = IUnknown_QueryInterface(unk, &IID_IBaseFilter, (void **)&filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_QueryInterface(filter, &IID_IUnknown, (void **)&unk2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(unk2 == (IUnknown *)0xdeadbeef, "Got unexpected IUnknown %p.\n", unk2);
 
     hr = IBaseFilter_QueryInterface(filter, &IID_IBaseFilter, (void **)&filter2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(filter2 == (IBaseFilter *)0xdeadbeef, "Got unexpected IBaseFilter %p.\n", filter2);
 
     hr = IUnknown_QueryInterface(unk, &test_iid, (void **)&unk2);
-    ok(hr == E_NOINTERFACE, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOINTERFACE, "Got hr %#x.\n", hr);
     ok(!unk2, "Got unexpected IUnknown %p.\n", unk2);
 
     hr = IBaseFilter_QueryInterface(filter, &test_iid, (void **)&unk2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(unk2 == (IUnknown *)0xdeadbeef, "Got unexpected IUnknown %p.\n", unk2);
 
     IBaseFilter_Release(filter);
     ref = IUnknown_Release(unk);
-    ok(!ref, "Got unexpected refcount %ld.\n", ref);
-    ok(outer_ref == 1, "Got unexpected refcount %ld.\n", outer_ref);
+    ok(!ref, "Got unexpected refcount %d.\n", ref);
+    ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
 }
 
 static void test_enum_pins(void)
@@ -281,79 +281,79 @@ static void test_enum_pins(void)
     BOOL ret;
 
     ref = get_refcount(filter);
-    ok(ref == 1, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
 
     hr = IBaseFilter_EnumPins(filter, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_EnumPins(filter, &enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ref = get_refcount(filter);
-    ok(ref == 2, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 2, "Got unexpected refcount %d.\n", ref);
     ref = get_refcount(enum1);
-    ok(ref == 1, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
 
     hr = IEnumPins_Next(enum1, 1, NULL, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum1, 1, pins, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ref = get_refcount(filter);
-    ok(ref == 3, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 3, "Got unexpected refcount %d.\n", ref);
     ref = get_refcount(pins[0]);
-    ok(ref == 3, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 3, "Got unexpected refcount %d.\n", ref);
     ref = get_refcount(enum1);
-    ok(ref == 1, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
     IPin_Release(pins[0]);
     ref = get_refcount(filter);
-    ok(ref == 2, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 2, "Got unexpected refcount %d.\n", ref);
 
     hr = IEnumPins_Next(enum1, 1, pins, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum1, 1, pins, &count);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(count == 1, "Got count %lu.\n", count);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(count == 1, "Got count %u.\n", count);
     IPin_Release(pins[0]);
 
     hr = IEnumPins_Next(enum1, 1, pins, &count);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
-    ok(!count, "Got count %lu.\n", count);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    ok(!count, "Got count %u.\n", count);
 
     hr = IEnumPins_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum1, 2, pins, NULL);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum1, 2, pins, &count);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
-    ok(count == 1, "Got count %lu.\n", count);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    ok(count == 1, "Got count %u.\n", count);
     IPin_Release(pins[0]);
 
     hr = IEnumPins_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Clone(enum1, &enum2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Skip(enum1, 2);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Skip(enum1, 1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Skip(enum1, 1);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum1, 1, pins, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum2, 1, pins, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     IPin_Release(pins[0]);
 
     IEnumPins_Release(enum2);
@@ -361,46 +361,46 @@ static void test_enum_pins(void)
     graph = connect_input(filter, filename);
 
     hr = IEnumPins_Next(enum1, 1, pins, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum1, 1, pins, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     IPin_Release(pins[0]);
 
     hr = IEnumPins_Next(enum1, 1, pins, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     IPin_Release(pins[0]);
 
     hr = IEnumPins_Next(enum1, 1, pins, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum1, 2, pins, &count);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(count == 2, "Got count %lu.\n", count);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(count == 2, "Got count %u.\n", count);
     IPin_Release(pins[0]);
     IPin_Release(pins[1]);
 
     hr = IEnumPins_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum1, 3, pins, &count);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
-    ok(count == 2, "Got count %lu.\n", count);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    ok(count == 2, "Got count %u.\n", count);
     IPin_Release(pins[0]);
     IPin_Release(pins[1]);
 
     IEnumPins_Release(enum1);
     IFilterGraph2_Release(graph);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ret = DeleteFileW(filename);
-    ok(ret, "Failed to delete file, error %lu.\n", GetLastError());
+    ok(ret, "Failed to delete file, error %u.\n", GetLastError());
 }
 
 static void test_find_pin(void)
@@ -415,34 +415,34 @@ static void test_find_pin(void)
     BOOL ret;
 
     hr = IBaseFilter_FindPin(filter, L"input pin", &pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     IPin_Release(pin);
 
     hr = IBaseFilter_FindPin(filter, L"Stream 00", &pin);
-    ok(hr == VFW_E_NOT_FOUND, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_FOUND, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_FindPin(filter, L"Input", &pin);
-    ok(hr == VFW_E_NOT_FOUND, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_FOUND, "Got hr %#x.\n", hr);
 
     graph = connect_input(filter, filename);
 
     hr = IBaseFilter_EnumPins(filter, &enum_pins);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum_pins, 1, &pin2, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_FindPin(filter, L"Stream 00", &pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(pin == pin2, "Expected pin %p, got %p.\n", pin2, pin);
     IPin_Release(pin);
     IPin_Release(pin2);
 
     hr = IEnumPins_Next(enum_pins, 1, &pin2, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_FindPin(filter, L"input pin", &pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(pin == pin2, "Expected pin %p, got %p.\n", pin2, pin);
     IPin_Release(pin);
     IPin_Release(pin2);
@@ -450,9 +450,9 @@ static void test_find_pin(void)
     IEnumPins_Release(enum_pins);
     IFilterGraph2_Release(graph);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ret = DeleteFileW(filename);
-    ok(ret, "Failed to delete file, error %lu.\n", GetLastError());
+    ok(ret, "Failed to delete file, error %u.\n", GetLastError());
 }
 
 static void test_pin_info(void)
@@ -471,52 +471,52 @@ static void test_pin_info(void)
     graph = connect_input(filter, filename);
 
     hr = IBaseFilter_FindPin(filter, L"input pin", &pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     expect_ref = get_refcount(filter);
     ref = get_refcount(pin);
-    ok(ref == expect_ref, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == expect_ref, "Got unexpected refcount %d.\n", ref);
 
     hr = IPin_QueryPinInfo(pin, &info);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(info.pFilter == filter, "Expected filter %p, got %p.\n", filter, info.pFilter);
     ok(info.dir == PINDIR_INPUT, "Got direction %d.\n", info.dir);
     ok(!wcscmp(info.achName, L"input pin"), "Got name %s.\n", wine_dbgstr_w(info.achName));
     ref = get_refcount(filter);
-    ok(ref == expect_ref + 1, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == expect_ref + 1, "Got unexpected refcount %d.\n", ref);
     ref = get_refcount(pin);
-    ok(ref == expect_ref + 1, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == expect_ref + 1, "Got unexpected refcount %d.\n", ref);
     IBaseFilter_Release(info.pFilter);
 
     hr = IPin_QueryDirection(pin, &dir);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(dir == PINDIR_INPUT, "Got direction %d.\n", dir);
 
     hr = IPin_QueryId(pin, &id);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(!wcscmp(id, L"input pin"), "Got id %s.\n", wine_dbgstr_w(id));
     CoTaskMemFree(id);
 
     IPin_Release(pin);
 
     hr = IBaseFilter_FindPin(filter, L"Stream 00", &pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     check_interface(pin, &IID_IPin, TRUE);
     check_interface(pin, &IID_IMediaSeeking, TRUE);
 
     hr = IPin_QueryPinInfo(pin, &info);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(info.pFilter == filter, "Expected filter %p, got %p.\n", filter, info.pFilter);
     ok(info.dir == PINDIR_OUTPUT, "Got direction %d.\n", info.dir);
     ok(!wcscmp(info.achName, L"Stream 00"), "Got name %s.\n", wine_dbgstr_w(info.achName));
     IBaseFilter_Release(info.pFilter);
 
     hr = IPin_QueryDirection(pin, &dir);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(dir == PINDIR_OUTPUT, "Got direction %d.\n", dir);
 
     hr = IPin_QueryId(pin, &id);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(!wcscmp(id, L"Stream 00"), "Got id %s.\n", wine_dbgstr_w(id));
     CoTaskMemFree(id);
 
@@ -524,9 +524,9 @@ static void test_pin_info(void)
 
     IFilterGraph2_Release(graph);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ret = DeleteFileW(filename);
-    ok(ret, "Failed to delete file, error %lu.\n", GetLastError());
+    ok(ret, "Failed to delete file, error %u.\n", GetLastError());
 }
 
 static void test_media_types(void)
@@ -557,42 +557,42 @@ static void test_media_types(void)
     IBaseFilter_FindPin(filter, L"input pin", &pin);
 
     hr = IPin_EnumMediaTypes(pin, &enummt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enummt, 1, &pmt, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     IEnumMediaTypes_Release(enummt);
 
     mt.majortype = MEDIATYPE_Stream;
     mt.subtype = MEDIASUBTYPE_Avi;
     hr = IPin_QueryAccept(pin, &mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     mt.bFixedSizeSamples = TRUE;
     mt.bTemporalCompression = TRUE;
     mt.lSampleSize = 123;
     mt.formattype = FORMAT_WaveFormatEx;
     hr = IPin_QueryAccept(pin, &mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     mt.majortype = GUID_NULL;
     hr = IPin_QueryAccept(pin, &mt);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     mt.majortype = MEDIATYPE_Stream;
 
     mt.subtype = GUID_NULL;
     hr = IPin_QueryAccept(pin, &mt);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     mt.subtype = MEDIASUBTYPE_Avi;
 
     graph = connect_input(filter, filename);
 
     hr = IPin_EnumMediaTypes(pin, &enummt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enummt, 1, &pmt, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     IEnumMediaTypes_Release(enummt);
     IPin_Release(pin);
@@ -600,86 +600,86 @@ static void test_media_types(void)
     IBaseFilter_FindPin(filter, L"Stream 00", &pin);
 
     hr = IPin_EnumMediaTypes(pin, &enummt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enummt, 1, &pmt, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(IsEqualGUID(&pmt->majortype, &MEDIATYPE_Video), "Got major type %s\n",
             wine_dbgstr_guid(&pmt->majortype));
     ok(IsEqualGUID(&pmt->subtype, &MEDIASUBTYPE_I420), "Got subtype %s\n",
             wine_dbgstr_guid(&pmt->subtype));
     ok(!pmt->bFixedSizeSamples, "Got fixed size %d.\n", pmt->bFixedSizeSamples);
     todo_wine ok(!pmt->bTemporalCompression, "Got temporal compression %d.\n", pmt->bTemporalCompression);
-    ok(pmt->lSampleSize == 1, "Got sample size %lu.\n", pmt->lSampleSize);
+    ok(pmt->lSampleSize == 1, "Got sample size %u.\n", pmt->lSampleSize);
     ok(IsEqualGUID(&pmt->formattype, &FORMAT_VideoInfo), "Got format type %s.\n",
             wine_dbgstr_guid(&pmt->formattype));
     ok(!pmt->pUnk, "Got pUnk %p.\n", pmt->pUnk);
-    ok(pmt->cbFormat == sizeof(VIDEOINFOHEADER), "Got format size %lu.\n", pmt->cbFormat);
+    ok(pmt->cbFormat == sizeof(VIDEOINFOHEADER), "Got format size %u.\n", pmt->cbFormat);
     ok(!memcmp(pmt->pbFormat, &expect_vih, sizeof(VIDEOINFOHEADER)), "Format blocks didn't match.\n");
 
     hr = IPin_QueryAccept(pin, pmt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     pmt->bFixedSizeSamples = TRUE;
     pmt->bTemporalCompression = TRUE;
     pmt->lSampleSize = 123;
     hr = IPin_QueryAccept(pin, pmt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     pmt->majortype = GUID_NULL;
     hr = IPin_QueryAccept(pin, pmt);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     pmt->majortype = MEDIATYPE_Video;
 
     pmt->subtype = GUID_NULL;
     hr = IPin_QueryAccept(pin, pmt);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     pmt->subtype = MEDIASUBTYPE_I420;
 
     pmt->formattype = GUID_NULL;
     hr = IPin_QueryAccept(pin, pmt);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     pmt->formattype = FORMAT_None;
     hr = IPin_QueryAccept(pin, pmt);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     pmt->formattype = FORMAT_VideoInfo;
 
     vih = (VIDEOINFOHEADER *)pmt->pbFormat;
 
     vih->AvgTimePerFrame = 10000;
     hr = IPin_QueryAccept(pin, pmt);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     vih->AvgTimePerFrame = 1000 * 10000;
 
     vih->dwBitRate = 1000000;
     hr = IPin_QueryAccept(pin, pmt);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     vih->dwBitRate = 0;
 
     SetRect(&vih->rcSource, 0, 0, 32, 24);
     hr = IPin_QueryAccept(pin, pmt);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     SetRect(&vih->rcSource, 0, 0, 0, 0);
 
     vih->bmiHeader.biCompression = BI_RGB;
     hr = IPin_QueryAccept(pin, pmt);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     vih->bmiHeader.biCompression = mmioFOURCC('I','4','2','0');
 
     CoTaskMemFree(pmt->pbFormat);
     CoTaskMemFree(pmt);
 
     hr = IEnumMediaTypes_Next(enummt, 1, &pmt, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     IEnumMediaTypes_Release(enummt);
     IPin_Release(pin);
 
     IFilterGraph2_Release(graph);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ret = DeleteFileW(filename);
-    ok(ret, "Failed to delete file, error %lu.\n", GetLastError());
+    ok(ret, "Failed to delete file, error %u.\n", GetLastError());
 }
 
 static void test_enum_media_types(void)
@@ -697,29 +697,29 @@ static void test_enum_media_types(void)
     IBaseFilter_FindPin(filter, L"input pin", &pin);
 
     hr = IPin_EnumMediaTypes(pin, &enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enum1, 1, mts, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enum1, 1, mts, &count);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
-    ok(!count, "Got count %lu.\n", count);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    ok(!count, "Got count %u.\n", count);
 
     hr = IEnumMediaTypes_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enum1, 1, mts, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Clone(enum1, &enum2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Skip(enum1, 1);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enum2, 1, mts, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     IEnumMediaTypes_Release(enum1);
     IEnumMediaTypes_Release(enum2);
@@ -728,64 +728,64 @@ static void test_enum_media_types(void)
     IBaseFilter_FindPin(filter, L"Stream 00", &pin);
 
     hr = IPin_EnumMediaTypes(pin, &enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enum1, 1, mts, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     CoTaskMemFree(mts[0]->pbFormat);
     CoTaskMemFree(mts[0]);
 
     hr = IEnumMediaTypes_Next(enum1, 1, mts, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enum1, 1, mts, &count);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(count == 1, "Got count %lu.\n", count);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(count == 1, "Got count %u.\n", count);
     CoTaskMemFree(mts[0]->pbFormat);
     CoTaskMemFree(mts[0]);
 
     hr = IEnumMediaTypes_Next(enum1, 1, mts, &count);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
-    ok(!count, "Got count %lu.\n", count);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    ok(!count, "Got count %u.\n", count);
 
     hr = IEnumMediaTypes_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enum1, 2, mts, &count);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
-    ok(count == 1, "Got count %lu.\n", count);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    ok(count == 1, "Got count %u.\n", count);
     CoTaskMemFree(mts[0]->pbFormat);
     CoTaskMemFree(mts[0]);
 
     hr = IEnumMediaTypes_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Clone(enum1, &enum2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Skip(enum1, 2);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Skip(enum1, 1);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Skip(enum1, 1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Skip(enum1, 1);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enum1, 1, mts, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enum2, 1, mts, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     CoTaskMemFree(mts[0]->pbFormat);
     CoTaskMemFree(mts[0]);
 
@@ -795,9 +795,9 @@ static void test_enum_media_types(void)
 
     IFilterGraph2_Release(graph);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ret = DeleteFileW(filename);
-    ok(ret, "Failed to delete file, error %lu.\n", GetLastError());
+    ok(ret, "Failed to delete file, error %u.\n", GetLastError());
 }
 
 struct testfilter
@@ -809,7 +809,7 @@ struct testfilter
     const AM_MEDIA_TYPE *mt;
     HANDLE eos_event;
     unsigned int sample_count, eos_count, new_segment_count;
-    REFERENCE_TIME segment_start, segment_end, seek_start, seek_end;
+    REFERENCE_TIME seek_start, seek_end;
 };
 
 static inline struct testfilter *impl_from_strmbase_filter(struct strmbase_filter *iface)
@@ -836,21 +836,10 @@ static void testfilter_destroy(struct strmbase_filter *iface)
     strmbase_filter_cleanup(&filter->filter);
 }
 
-static HRESULT testfilter_init_stream(struct strmbase_filter *iface)
-{
-    struct testfilter *filter = impl_from_strmbase_filter(iface);
-
-    filter->new_segment_count = 0;
-    filter->eos_count = 0;
-    filter->sample_count = 0;
-    return S_OK;
-}
-
 static const struct strmbase_filter_ops testfilter_ops =
 {
     .filter_get_pin = testfilter_get_pin,
     .filter_destroy = testfilter_destroy,
-    .filter_init_stream = testfilter_init_stream,
 };
 
 static HRESULT testsource_query_interface(struct strmbase_pin *iface, REFIID iid, void **out)
@@ -877,7 +866,7 @@ static HRESULT WINAPI testsource_AttemptConnection(struct strmbase_source *iface
 
     if (FAILED(hr = IPin_ReceiveConnection(peer, &iface->pin.IPin_iface, mt)))
     {
-        ok(hr == VFW_E_TYPE_NOT_ACCEPTED, "Got hr %#lx.\n", hr);
+        ok(hr == VFW_E_TYPE_NOT_ACCEPTED, "Got hr %#x.\n", hr);
         IPin_Release(peer);
         iface->pin.peer = NULL;
         FreeMediaType(&iface->pin.mt);
@@ -924,12 +913,12 @@ static HRESULT testsink_connect(struct strmbase_sink *iface, IPin *peer, const A
     HRESULT hr;
 
     hr = IPin_ConnectedTo(peer, &peer2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(peer2 == &iface->pin.IPin_iface, "Peer didn't match.\n");
     IPin_Release(peer2);
 
     hr = IPin_ConnectionMediaType(peer, &mt2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(compare_media_types(mt, &mt2), "Media types didn't match.\n");
     FreeMediaType(&mt2);
 
@@ -946,16 +935,16 @@ static HRESULT WINAPI testsink_Receive(struct strmbase_sink *iface, IMediaSample
     HRESULT hr;
 
     hr = IMediaSample_GetTime(sample, &start, &end);
-    todo_wine_if (hr == VFW_S_NO_STOP_TIME) ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine_if (hr == VFW_S_NO_STOP_TIME) ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     if (winetest_debug > 1)
-        trace("%04lx: Got sample with timestamps %I64d-%I64d.\n", GetCurrentThreadId(), start, end);
+        trace("%04x: Got sample with timestamps %I64d-%I64d.\n", GetCurrentThreadId(), start, end);
 
     ok(filter->new_segment_count, "Expected NewSegment() before Receive().\n");
 
     IPin_QueryInterface(iface->pin.peer, &IID_IMediaSeeking, (void **)&seeking);
     hr = IMediaSeeking_GetPositions(seeking, &start, &end);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(start == filter->seek_start, "Expected start position %I64u, got %I64u.\n", filter->seek_start, start);
     ok(end == filter->seek_end, "Expected end position %I64u, got %I64u.\n", filter->seek_end, end);
     IMediaSeeking_Release(seeking);
@@ -970,7 +959,7 @@ static HRESULT testsink_eos(struct strmbase_sink *iface)
     struct testfilter *filter = impl_from_strmbase_filter(iface->pin.filter);
 
     if (winetest_debug > 1)
-        trace("%04lx: Got EOS.\n", GetCurrentThreadId());
+        trace("%04x: Got EOS.\n", GetCurrentThreadId());
 
     ok(!filter->eos_count, "Got %u EOS events.\n", filter->eos_count + 1);
     ++filter->eos_count;
@@ -985,19 +974,13 @@ static HRESULT testsink_new_segment(struct strmbase_sink *iface,
     IMediaSeeking *seeking;
     HRESULT hr;
 
-    if (winetest_debug > 1)
-        trace("%04lx: Got segment with timestamps %I64d-%I64d.\n", GetCurrentThreadId(), start, end);
-
     ++filter->new_segment_count;
 
     IPin_QueryInterface(iface->pin.peer, &IID_IMediaSeeking, (void **)&seeking);
     hr = IMediaSeeking_GetPositions(seeking, &filter->seek_start, &filter->seek_end);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    IMediaSeeking_Release(seeking);
-
-    ok(start == filter->segment_start, "Expected start %I64d, got %I64d.\n", filter->segment_start, start);
-    ok(end == filter->segment_end, "Expected end %I64d, got %I64d.\n", filter->segment_end, end);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(rate == 1.0, "Got rate %.16e.\n", rate);
+    IMediaSeeking_Release(seeking);
 
     return S_OK;
 }
@@ -1098,7 +1081,6 @@ static void testfilter_init(struct testfilter *filter)
     strmbase_sink_init(&filter->sink, &filter->filter, L"sink", &testsink_ops, NULL);
     filter->IAsyncReader_iface.lpVtbl = &async_reader_vtbl;
     filter->eos_event = CreateEventW(NULL, FALSE, FALSE, NULL);
-    filter->segment_end = 50000000;
 }
 
 static void test_filter_state(IMediaControl *control)
@@ -1107,50 +1089,50 @@ static void test_filter_state(IMediaControl *control)
     HRESULT hr;
 
     hr = IMediaControl_GetState(control, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(state == State_Stopped, "Got state %lu.\n", state);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(state == State_Stopped, "Got state %u.\n", state);
 
     hr = IMediaControl_Pause(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_GetState(control, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(state == State_Paused, "Got state %lu.\n", state);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(state == State_Paused, "Got state %u.\n", state);
 
     hr = IMediaControl_Run(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_GetState(control, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(state == State_Running, "Got state %lu.\n", state);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(state == State_Running, "Got state %u.\n", state);
 
     hr = IMediaControl_Pause(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_GetState(control, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(state == State_Paused, "Got state %lu.\n", state);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(state == State_Paused, "Got state %u.\n", state);
 
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_GetState(control, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(state == State_Stopped, "Got state %lu.\n", state);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(state == State_Stopped, "Got state %u.\n", state);
 
     hr = IMediaControl_Run(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_GetState(control, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(state == State_Running, "Got state %lu.\n", state);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(state == State_Running, "Got state %u.\n", state);
 
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_GetState(control, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(state == State_Stopped, "Got state %lu.\n", state);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(state == State_Stopped, "Got state %u.\n", state);
 }
 
 static void test_connect_pin(void)
@@ -1198,48 +1180,48 @@ static void test_connect_pin(void)
 
     peer = (IPin *)0xdeadbeef;
     hr = IPin_ConnectedTo(sink, &peer);
-    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#x.\n", hr);
     ok(!peer, "Got peer %p.\n", peer);
 
     hr = IPin_ConnectionMediaType(sink, &mt);
-    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_Pause(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IFilterGraph2_ConnectDirect(graph, &testsource.source.pin.IPin_iface, sink, &req_mt);
-    ok(hr == VFW_E_NOT_STOPPED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_STOPPED, "Got hr %#x.\n", hr);
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     req_mt.majortype = MEDIATYPE_Video;
     hr = IFilterGraph2_ConnectDirect(graph, &testsource.source.pin.IPin_iface, sink, &req_mt);
-    ok(hr == VFW_E_TYPE_NOT_ACCEPTED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_TYPE_NOT_ACCEPTED, "Got hr %#x.\n", hr);
     req_mt.majortype = MEDIATYPE_Stream;
 
     req_mt.subtype = MEDIASUBTYPE_RGB8;
     hr = IFilterGraph2_ConnectDirect(graph, &testsource.source.pin.IPin_iface, sink, &req_mt);
-    ok(hr == VFW_E_TYPE_NOT_ACCEPTED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_TYPE_NOT_ACCEPTED, "Got hr %#x.\n", hr);
     req_mt.subtype = MEDIASUBTYPE_Avi;
 
     hr = IFilterGraph2_ConnectDirect(graph, &testsource.source.pin.IPin_iface, sink, &req_mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IPin_ConnectedTo(sink, &peer);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(peer == &testsource.source.pin.IPin_iface, "Got peer %p.\n", peer);
     IPin_Release(peer);
 
     hr = IPin_ConnectionMediaType(sink, &mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(compare_media_types(&mt, &req_mt), "Media types didn't match.\n");
     ok(compare_media_types(&testsource.source.pin.mt, &req_mt), "Media types didn't match.\n");
 
     hr = IMediaControl_Pause(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IFilterGraph2_Disconnect(graph, sink);
-    ok(hr == VFW_E_NOT_STOPPED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_STOPPED, "Got hr %#x.\n", hr);
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     /* Test source connection. */
 
@@ -1247,11 +1229,11 @@ static void test_connect_pin(void)
 
     peer = (IPin *)0xdeadbeef;
     hr = IPin_ConnectedTo(source, &peer);
-    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#x.\n", hr);
     ok(!peer, "Got peer %p.\n", peer);
 
     hr = IPin_ConnectionMediaType(source, &mt);
-    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#x.\n", hr);
 
     /* Exact connection. */
 
@@ -1261,135 +1243,135 @@ static void test_connect_pin(void)
     CopyMediaType(&req_mt, source_mt);
 
     hr = IMediaControl_Pause(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IFilterGraph2_ConnectDirect(graph, source, &testsink.sink.pin.IPin_iface, &req_mt);
-    ok(hr == VFW_E_NOT_STOPPED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_STOPPED, "Got hr %#x.\n", hr);
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IFilterGraph2_ConnectDirect(graph, source, &testsink.sink.pin.IPin_iface, &req_mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     test_filter_state(control);
 
     hr = IPin_ConnectedTo(source, &peer);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(peer == &testsink.sink.pin.IPin_iface, "Got peer %p.\n", peer);
     IPin_Release(peer);
 
     hr = IPin_ConnectionMediaType(source, &mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(compare_media_types(&mt, &req_mt), "Media types didn't match.\n");
     ok(compare_media_types(&testsink.sink.pin.mt, &req_mt), "Media types didn't match.\n");
 
     hr = IMediaControl_Pause(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IFilterGraph2_Disconnect(graph, source);
-    ok(hr == VFW_E_NOT_STOPPED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_STOPPED, "Got hr %#x.\n", hr);
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IFilterGraph2_Disconnect(graph, source);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IFilterGraph2_Disconnect(graph, source);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     ok(testsink.sink.pin.peer == source, "Got peer %p.\n", testsink.sink.pin.peer);
     IFilterGraph2_Disconnect(graph, &testsink.sink.pin.IPin_iface);
 
     req_mt.lSampleSize = 999;
     req_mt.bTemporalCompression = req_mt.bFixedSizeSamples = TRUE;
     hr = IFilterGraph2_ConnectDirect(graph, source, &testsink.sink.pin.IPin_iface, &req_mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(compare_media_types(&testsink.sink.pin.mt, &req_mt), "Media types didn't match.\n");
     IFilterGraph2_Disconnect(graph, source);
     IFilterGraph2_Disconnect(graph, &testsink.sink.pin.IPin_iface);
 
     req_mt.majortype = MEDIATYPE_Stream;
     hr = IFilterGraph2_ConnectDirect(graph, source, &testsink.sink.pin.IPin_iface, &req_mt);
-    ok(hr == VFW_E_TYPE_NOT_ACCEPTED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_TYPE_NOT_ACCEPTED, "Got hr %#x.\n", hr);
     req_mt.majortype = MEDIATYPE_Video;
 
     req_mt.subtype = MEDIASUBTYPE_RGB32;
     hr = IFilterGraph2_ConnectDirect(graph, source, &testsink.sink.pin.IPin_iface, &req_mt);
-    ok(hr == VFW_E_TYPE_NOT_ACCEPTED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_TYPE_NOT_ACCEPTED, "Got hr %#x.\n", hr);
     req_mt.subtype = GUID_NULL;
     hr = IFilterGraph2_ConnectDirect(graph, source, &testsink.sink.pin.IPin_iface, &req_mt);
-    ok(hr == VFW_E_TYPE_NOT_ACCEPTED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_TYPE_NOT_ACCEPTED, "Got hr %#x.\n", hr);
     req_mt.subtype = MEDIASUBTYPE_I420;
 
     /* Connection with wildcards. */
 
     hr = IFilterGraph2_ConnectDirect(graph, source, &testsink.sink.pin.IPin_iface, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(compare_media_types(&testsink.sink.pin.mt, source_mt), "Media types didn't match.\n");
     IFilterGraph2_Disconnect(graph, source);
     IFilterGraph2_Disconnect(graph, &testsink.sink.pin.IPin_iface);
 
     req_mt.majortype = GUID_NULL;
     hr = IFilterGraph2_ConnectDirect(graph, source, &testsink.sink.pin.IPin_iface, &req_mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(compare_media_types(&testsink.sink.pin.mt, source_mt), "Media types didn't match.\n");
     IFilterGraph2_Disconnect(graph, source);
     IFilterGraph2_Disconnect(graph, &testsink.sink.pin.IPin_iface);
 
     req_mt.subtype = MEDIASUBTYPE_RGB32;
     hr = IFilterGraph2_ConnectDirect(graph, source, &testsink.sink.pin.IPin_iface, &req_mt);
-    ok(hr == VFW_E_NO_ACCEPTABLE_TYPES, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NO_ACCEPTABLE_TYPES, "Got hr %#x.\n", hr);
 
     req_mt.subtype = GUID_NULL;
     hr = IFilterGraph2_ConnectDirect(graph, source, &testsink.sink.pin.IPin_iface, &req_mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(compare_media_types(&testsink.sink.pin.mt, source_mt), "Media types didn't match.\n");
     IFilterGraph2_Disconnect(graph, source);
     IFilterGraph2_Disconnect(graph, &testsink.sink.pin.IPin_iface);
 
     req_mt.formattype = FORMAT_None;
     hr = IFilterGraph2_ConnectDirect(graph, source, &testsink.sink.pin.IPin_iface, &req_mt);
-    ok(hr == VFW_E_NO_ACCEPTABLE_TYPES, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NO_ACCEPTABLE_TYPES, "Got hr %#x.\n", hr);
 
     req_mt.majortype = MEDIATYPE_Video;
     req_mt.subtype = MEDIASUBTYPE_I420;
     req_mt.formattype = GUID_NULL;
     hr = IFilterGraph2_ConnectDirect(graph, source, &testsink.sink.pin.IPin_iface, &req_mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(compare_media_types(&testsink.sink.pin.mt, source_mt), "Media types didn't match.\n");
     IFilterGraph2_Disconnect(graph, source);
     IFilterGraph2_Disconnect(graph, &testsink.sink.pin.IPin_iface);
 
     req_mt.subtype = MEDIASUBTYPE_RGB32;
     hr = IFilterGraph2_ConnectDirect(graph, source, &testsink.sink.pin.IPin_iface, &req_mt);
-    ok(hr == VFW_E_NO_ACCEPTABLE_TYPES, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NO_ACCEPTABLE_TYPES, "Got hr %#x.\n", hr);
 
     req_mt.subtype = GUID_NULL;
     hr = IFilterGraph2_ConnectDirect(graph, source, &testsink.sink.pin.IPin_iface, &req_mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(compare_media_types(&testsink.sink.pin.mt, source_mt), "Media types didn't match.\n");
     IFilterGraph2_Disconnect(graph, source);
     IFilterGraph2_Disconnect(graph, &testsink.sink.pin.IPin_iface);
 
     req_mt.majortype = MEDIATYPE_Audio;
     hr = IFilterGraph2_ConnectDirect(graph, source, &testsink.sink.pin.IPin_iface, &req_mt);
-    ok(hr == VFW_E_NO_ACCEPTABLE_TYPES, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NO_ACCEPTABLE_TYPES, "Got hr %#x.\n", hr);
 
     /* Test enumeration of sink media types. */
 
     testsink.mt = &req_mt;
     hr = IFilterGraph2_ConnectDirect(graph, source, &testsink.sink.pin.IPin_iface, NULL);
-    ok(hr == VFW_E_NO_ACCEPTABLE_TYPES, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NO_ACCEPTABLE_TYPES, "Got hr %#x.\n", hr);
 
     req_mt.majortype = MEDIATYPE_Video;
     req_mt.subtype = MEDIASUBTYPE_I420;
     req_mt.formattype = FORMAT_VideoInfo;
     req_mt.lSampleSize = 444;
     hr = IFilterGraph2_ConnectDirect(graph, source, &testsink.sink.pin.IPin_iface, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(compare_media_types(&testsink.sink.pin.mt, &req_mt), "Media types didn't match.\n");
 
     IPin_Release(source);
     hr = IFilterGraph2_Disconnect(graph, sink);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IFilterGraph2_Disconnect(graph, sink);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     ok(testsource.source.pin.peer == sink, "Got peer %p.\n", testsource.source.pin.peer);
     IFilterGraph2_Disconnect(graph, &testsource.source.pin.IPin_iface);
 
@@ -1401,17 +1383,17 @@ static void test_connect_pin(void)
     IPin_Release(sink);
     IMediaControl_Release(control);
     ref = IFilterGraph2_Release(graph);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ref = IBaseFilter_Release(reader);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ref = IBaseFilter_Release(&testsource.filter.IBaseFilter_iface);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ref = IBaseFilter_Release(&testsink.filter.IBaseFilter_iface);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ret = DeleteFileW(filename);
-    ok(ret, "Failed to delete file, error %lu.\n", GetLastError());
+    ok(ret, "Failed to delete file, error %u.\n", GetLastError());
 }
 
 static void test_unconnected_filter_state(void)
@@ -1422,53 +1404,53 @@ static void test_unconnected_filter_state(void)
     ULONG ref;
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(state == State_Stopped, "Got state %u.\n", state);
 
     hr = IBaseFilter_Pause(filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(state == State_Paused, "Got state %u.\n", state);
 
     hr = IBaseFilter_Run(filter, 0);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(state == State_Running, "Got state %u.\n", state);
 
     hr = IBaseFilter_Pause(filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(state == State_Paused, "Got state %u.\n", state);
 
     hr = IBaseFilter_Stop(filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(state == State_Stopped, "Got state %u.\n", state);
 
     hr = IBaseFilter_Run(filter, 0);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(state == State_Running, "Got state %u.\n", state);
 
     hr = IBaseFilter_Stop(filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(state == State_Stopped, "Got state %u.\n", state);
 
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 static void test_seeking(void)
@@ -1508,137 +1490,137 @@ static void test_seeking(void)
     IPin_QueryInterface(pin, &IID_IMediaSeeking, (void **)&seeking);
 
     hr = IMediaSeeking_GetCapabilities(seeking, &caps);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(caps == (AM_SEEKING_CanSeekAbsolute | AM_SEEKING_CanSeekForwards
             | AM_SEEKING_CanSeekBackwards | AM_SEEKING_CanGetStopPos
-            | AM_SEEKING_CanGetDuration), "Got caps %#lx.\n", caps);
+            | AM_SEEKING_CanGetDuration), "Got caps %#x.\n", caps);
 
     caps = AM_SEEKING_CanSeekAbsolute | AM_SEEKING_CanSeekForwards;
     hr = IMediaSeeking_CheckCapabilities(seeking, &caps);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(caps == (AM_SEEKING_CanSeekAbsolute | AM_SEEKING_CanSeekForwards), "Got caps %#lx.\n", caps);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(caps == (AM_SEEKING_CanSeekAbsolute | AM_SEEKING_CanSeekForwards), "Got caps %#x.\n", caps);
 
     caps = AM_SEEKING_CanSeekAbsolute | AM_SEEKING_CanGetCurrentPos;
     hr = IMediaSeeking_CheckCapabilities(seeking, &caps);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
-    ok(caps == AM_SEEKING_CanSeekAbsolute, "Got caps %#lx.\n", caps);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    ok(caps == AM_SEEKING_CanSeekAbsolute, "Got caps %#x.\n", caps);
 
     caps = AM_SEEKING_CanGetCurrentPos;
     hr = IMediaSeeking_CheckCapabilities(seeking, &caps);
-    ok(hr == E_FAIL, "Got hr %#lx.\n", hr);
-    ok(!caps, "Got caps %#lx.\n", caps);
+    ok(hr == E_FAIL, "Got hr %#x.\n", hr);
+    ok(!caps, "Got caps %#x.\n", caps);
 
     caps = 0;
     hr = IMediaSeeking_CheckCapabilities(seeking, &caps);
-    ok(hr == E_FAIL, "Got hr %#lx.\n", hr);
-    ok(!caps, "Got caps %#lx.\n", caps);
+    ok(hr == E_FAIL, "Got hr %#x.\n", hr);
+    ok(!caps, "Got caps %#x.\n", caps);
 
     for (i = 0; i < ARRAY_SIZE(format_tests); ++i)
     {
         hr = IMediaSeeking_IsFormatSupported(seeking, format_tests[i].guid);
-        todo_wine_if(i == 1) ok(hr == format_tests[i].hr, "Got hr %#lx for format %s.\n",
+        todo_wine_if(i == 1) ok(hr == format_tests[i].hr, "Got hr %#x for format %s.\n",
                 hr, wine_dbgstr_guid(format_tests[i].guid));
     }
 
     hr = IMediaSeeking_QueryPreferredFormat(seeking, &format);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(IsEqualGUID(&format, &TIME_FORMAT_MEDIA_TIME), "Got format %s.\n", wine_dbgstr_guid(&format));
 
     hr = IMediaSeeking_GetTimeFormat(seeking, &format);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(IsEqualGUID(&format, &TIME_FORMAT_MEDIA_TIME), "Got format %s.\n", wine_dbgstr_guid(&format));
 
     hr = IMediaSeeking_IsUsingTimeFormat(seeking, &TIME_FORMAT_MEDIA_TIME);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMediaSeeking_IsUsingTimeFormat(seeking, &TIME_FORMAT_FRAME);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IMediaSeeking_SetTimeFormat(seeking, &TIME_FORMAT_SAMPLE);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
     hr = IMediaSeeking_SetTimeFormat(seeking, &TIME_FORMAT_FRAME);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaSeeking_GetTimeFormat(seeking, &format);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     todo_wine ok(IsEqualGUID(&format, &TIME_FORMAT_FRAME), "Got format %s.\n", wine_dbgstr_guid(&format));
 
     hr = IMediaSeeking_IsUsingTimeFormat(seeking, &TIME_FORMAT_MEDIA_TIME);
-    todo_wine ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     hr = IMediaSeeking_IsUsingTimeFormat(seeking, &TIME_FORMAT_FRAME);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaSeeking_SetTimeFormat(seeking, &TIME_FORMAT_MEDIA_TIME);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     duration = 0;
     hr = IMediaSeeking_GetDuration(seeking, &duration);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(duration == 50000000, "Got duration %I64d.\n", duration);
 
     stop = current = 0xdeadbeef;
     hr = IMediaSeeking_GetStopPosition(seeking, &stop);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(stop == duration, "Expected time %s, got %s.\n",
             wine_dbgstr_longlong(duration), wine_dbgstr_longlong(stop));
     hr = IMediaSeeking_GetCurrentPosition(seeking, &current);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(!current, "Got time %s.\n", wine_dbgstr_longlong(current));
     stop = current = 0xdeadbeef;
     hr = IMediaSeeking_GetPositions(seeking, &current, &stop);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(!current, "Got time %s.\n", wine_dbgstr_longlong(current));
     ok(stop == duration, "Expected time %s, got %s.\n",
             wine_dbgstr_longlong(duration), wine_dbgstr_longlong(stop));
 
     time = 0xdeadbeef;
     hr = IMediaSeeking_ConvertTimeFormat(seeking, &time, &TIME_FORMAT_MEDIA_TIME, 0x123456789a, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(time == 0x123456789a, "Got time %s.\n", wine_dbgstr_longlong(time));
     time = 0xdeadbeef;
     hr = IMediaSeeking_ConvertTimeFormat(seeking, &time, NULL, 0x123456789a, &TIME_FORMAT_MEDIA_TIME);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(time == 0x123456789a, "Got time %s.\n", wine_dbgstr_longlong(time));
     time = 0xdeadbeef;
     hr = IMediaSeeking_ConvertTimeFormat(seeking, &time, NULL, 123, &TIME_FORMAT_FRAME);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
     todo_wine ok(time == 123 * 10000000, "Got time %s.\n", wine_dbgstr_longlong(time));
 
     earliest = latest = 0xdeadbeef;
     hr = IMediaSeeking_GetAvailable(seeking, &earliest, &latest);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(!earliest, "Got time %s.\n", wine_dbgstr_longlong(earliest));
     ok(latest == duration, "Expected time %s, got %s.\n",
             wine_dbgstr_longlong(duration), wine_dbgstr_longlong(latest));
 
     rate = 0;
     hr = IMediaSeeking_GetRate(seeking, &rate);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(rate == 1.0, "Got rate %.16e.\n", rate);
 
     hr = IMediaSeeking_SetRate(seeking, 200.0);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
     rate = 0;
     hr = IMediaSeeking_GetRate(seeking, &rate);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     todo_wine ok(rate == 200.0, "Got rate %.16e.\n", rate);
 
     hr = IMediaSeeking_SetRate(seeking, -1.0);
-    todo_wine ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
 
     hr = IMediaSeeking_GetPreroll(seeking, &time);
-    todo_wine ok(hr == E_NOTIMPL, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == E_NOTIMPL, "Got hr %#x.\n", hr);
 
     current = 1500 * 10000;
     stop = 3500 * 10000;
     hr = IMediaSeeking_SetPositions(seeking, &current, AM_SEEKING_AbsolutePositioning,
             &stop, AM_SEEKING_AbsolutePositioning);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(current == 1500 * 10000, "Got time %s.\n", wine_dbgstr_longlong(current));
     ok(stop == 3500 * 10000, "Got time %s.\n", wine_dbgstr_longlong(stop));
 
     stop = current = 0xdeadbeef;
     hr = IMediaSeeking_GetPositions(seeking, &current, &stop);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     /* Native snaps to the nearest frame. */
     ok(current > 0 && current < duration, "Got time %s.\n", wine_dbgstr_longlong(current));
     ok(stop > 0 && stop < duration && stop > current, "Got time %s.\n", wine_dbgstr_longlong(stop));
@@ -1647,21 +1629,21 @@ static void test_seeking(void)
     stop = 3500 * 10000;
     hr = IMediaSeeking_SetPositions(seeking, &current, AM_SEEKING_AbsolutePositioning | AM_SEEKING_ReturnTime,
             &stop, AM_SEEKING_AbsolutePositioning | AM_SEEKING_ReturnTime);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(current > 0 && current < duration, "Got time %s.\n", wine_dbgstr_longlong(current));
     ok(stop > 0 && stop < duration && stop > current, "Got time %s.\n", wine_dbgstr_longlong(stop));
 
     hr = IMediaSeeking_GetStopPosition(seeking, &prev_stop);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     current = 0;
     hr = IMediaSeeking_SetPositions(seeking, &current, AM_SEEKING_AbsolutePositioning,
             NULL, AM_SEEKING_NoPositioning);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     stop = current = 0xdeadbeef;
     hr = IMediaSeeking_GetPositions(seeking, &current, &stop);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(!current, "Got time %s.\n", wine_dbgstr_longlong(current));
     ok(stop == prev_stop, "Expected time %s, got %s.\n",
             wine_dbgstr_longlong(prev_stop), wine_dbgstr_longlong(stop));
@@ -1670,9 +1652,9 @@ static void test_seeking(void)
     IPin_Release(pin);
     IFilterGraph2_Release(graph);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ret = DeleteFileW(filename);
-    ok(ret, "Failed to delete file, error %lu.\n", GetLastError());
+    ok(ret, "Failed to delete file, error %u.\n", GetLastError());
 }
 
 static void test_streaming(void)
@@ -1696,32 +1678,33 @@ static void test_streaming(void)
     IPin_QueryInterface(source, &IID_IMediaSeeking, (void **)&seeking);
 
     hr = IFilterGraph2_ConnectDirect(graph, source, &testsink.sink.pin.IPin_iface, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     ok(WaitForSingleObject(testsink.eos_event, 100) == WAIT_TIMEOUT, "Expected timeout.\n");
 
     hr = IMediaControl_Pause(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     ok(!WaitForSingleObject(testsink.eos_event, 1000), "Did not receive EOS.\n");
     ok(WaitForSingleObject(testsink.eos_event, 100) == WAIT_TIMEOUT, "Got more than one EOS.\n");
     ok(testsink.sample_count, "Expected at least one sample.\n");
 
+    testsink.sample_count = testsink.eos_count = 0;
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMediaControl_Pause(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     ok(!WaitForSingleObject(testsink.eos_event, 1000), "Did not receive EOS.\n");
     ok(WaitForSingleObject(testsink.eos_event, 100) == WAIT_TIMEOUT, "Got more than one EOS.\n");
     ok(testsink.sample_count, "Expected at least one sample.\n");
 
-    testsink.new_segment_count = testsink.sample_count = testsink.eos_count = 0;
-    testsink.segment_start = 1500 * 10000;
-    testsink.segment_end = 3500 * 10000;
-    hr = IMediaSeeking_SetPositions(seeking, &testsink.segment_start, AM_SEEKING_AbsolutePositioning,
-            &testsink.segment_end, AM_SEEKING_AbsolutePositioning);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    testsink.sample_count = testsink.eos_count = 0;
+    start = 1500 * 10000;
+    end = 3500 * 10000;
+    hr = IMediaSeeking_SetPositions(seeking, &start, AM_SEEKING_AbsolutePositioning,
+            &end, AM_SEEKING_AbsolutePositioning);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     ok(!WaitForSingleObject(testsink.eos_event, 1000), "Did not receive EOS.\n");
     ok(WaitForSingleObject(testsink.eos_event, 100) == WAIT_TIMEOUT, "Got more than one EOS.\n");
@@ -1729,14 +1712,15 @@ static void test_streaming(void)
 
     start = end = 0xdeadbeef;
     hr = IMediaSeeking_GetPositions(seeking, &start, &end);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(start == testsink.seek_start, "Expected start position %I64u, got %I64u.\n", testsink.seek_start, start);
     ok(end == testsink.seek_end, "Expected end position %I64u, got %I64u.\n", testsink.seek_end, end);
 
+    testsink.sample_count = testsink.eos_count = 0;
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMediaControl_Pause(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     ok(!WaitForSingleObject(testsink.eos_event, 1000), "Did not receive EOS.\n");
     ok(WaitForSingleObject(testsink.eos_event, 100) == WAIT_TIMEOUT, "Got more than one EOS.\n");
@@ -1744,7 +1728,7 @@ static void test_streaming(void)
 
     start = end = 0xdeadbeef;
     hr = IMediaSeeking_GetPositions(seeking, &start, &end);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(start == testsink.seek_start, "Expected start position %I64u, got %I64u.\n", testsink.seek_start, start);
     ok(end == testsink.seek_end, "Expected end position %I64u, got %I64u.\n", testsink.seek_end, end);
 
@@ -1752,13 +1736,13 @@ static void test_streaming(void)
     IPin_Release(source);
     IMediaControl_Release(control);
     ref = IFilterGraph2_Release(graph);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ref = IBaseFilter_Release(&testsink.filter.IBaseFilter_iface);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ret = DeleteFileW(filename);
-    ok(ret, "Failed to delete file, error %lu.\n", GetLastError());
+    ok(ret, "Failed to delete file, error %u.\n", GetLastError());
 }
 
 START_TEST(avisplit)
diff --git a/dlls/quartz/tests/dsoundrender.c b/dlls/quartz/tests/dsoundrender.c
index 269c590f8ee..03e6b8413d5 100644
--- wine/dlls/quartz/tests/dsoundrender.c
+++ wine/dlls/quartz/tests/dsoundrender.c
@@ -36,7 +36,7 @@ static IBaseFilter *create_dsound_render(void)
     IBaseFilter *filter = NULL;
     HRESULT hr = CoCreateInstance(&CLSID_DSoundRender, NULL, CLSCTX_INPROC_SERVER,
             &IID_IBaseFilter, (void **)&filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     return filter;
 }
 
@@ -45,7 +45,7 @@ static IFilterGraph2 *create_graph(void)
     IFilterGraph2 *ret;
     HRESULT hr;
     hr = CoCreateInstance(&CLSID_FilterGraph, NULL, CLSCTX_INPROC_SERVER, &IID_IFilterGraph2, (void **)&ret);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to create FilterGraph: %#x\n", hr);
     return ret;
 }
 
@@ -115,17 +115,17 @@ static void test_property_bag(void)
 
     hr = CoCreateInstance(&CLSID_DSoundRender, NULL, CLSCTX_INPROC_SERVER,
             &IID_IPersistPropertyBag, (void **)&ppb);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
     if (hr != S_OK) return;
 
     hr = IPersistPropertyBag_InitNew(ppb);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IPersistPropertyBag_Load(ppb, &property_bag, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     ref = IPersistPropertyBag_Release(ppb);
-    ok(!ref, "Got unexpected refcount %ld.\n", ref);
+    ok(!ref, "Got unexpected refcount %d.\n", ref);
 }
 
 #define check_interface(a, b, c) check_interface_(__LINE__, a, b, c)
@@ -138,7 +138,7 @@ static void check_interface_(unsigned int line, void *iface_ptr, REFIID iid, BOO
     expected_hr = supported ? S_OK : E_NOINTERFACE;
 
     hr = IUnknown_QueryInterface(iface, iid, (void **)&unk);
-    ok_(__FILE__, line)(hr == expected_hr, "Got hr %#lx, expected %#lx.\n", hr, expected_hr);
+    ok_(__FILE__, line)(hr == expected_hr, "Got hr %#x, expected %#x.\n", hr, expected_hr);
     if (SUCCEEDED(hr))
         IUnknown_Release(unk);
 }
@@ -229,53 +229,53 @@ static void test_aggregation(void)
     filter = (IBaseFilter *)0xdeadbeef;
     hr = CoCreateInstance(&CLSID_DSoundRender, &test_outer, CLSCTX_INPROC_SERVER,
             &IID_IBaseFilter, (void **)&filter);
-    ok(hr == E_NOINTERFACE, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOINTERFACE, "Got hr %#x.\n", hr);
     ok(!filter, "Got interface %p.\n", filter);
 
     hr = CoCreateInstance(&CLSID_DSoundRender, &test_outer, CLSCTX_INPROC_SERVER,
             &IID_IUnknown, (void **)&unk);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(outer_ref == 1, "Got unexpected refcount %ld.\n", outer_ref);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
     ok(unk != &test_outer, "Returned IUnknown should not be outer IUnknown.\n");
     ref = get_refcount(unk);
-    ok(ref == 1, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
 
     ref = IUnknown_AddRef(unk);
-    ok(ref == 2, "Got unexpected refcount %ld.\n", ref);
-    ok(outer_ref == 1, "Got unexpected refcount %ld.\n", outer_ref);
+    ok(ref == 2, "Got unexpected refcount %d.\n", ref);
+    ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
 
     ref = IUnknown_Release(unk);
-    ok(ref == 1, "Got unexpected refcount %ld.\n", ref);
-    ok(outer_ref == 1, "Got unexpected refcount %ld.\n", outer_ref);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
+    ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
 
     hr = IUnknown_QueryInterface(unk, &IID_IUnknown, (void **)&unk2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(unk2 == unk, "Got unexpected IUnknown %p.\n", unk2);
     IUnknown_Release(unk2);
 
     hr = IUnknown_QueryInterface(unk, &IID_IBaseFilter, (void **)&filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_QueryInterface(filter, &IID_IUnknown, (void **)&unk2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(unk2 == (IUnknown *)0xdeadbeef, "Got unexpected IUnknown %p.\n", unk2);
 
     hr = IBaseFilter_QueryInterface(filter, &IID_IBaseFilter, (void **)&filter2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(filter2 == (IBaseFilter *)0xdeadbeef, "Got unexpected IBaseFilter %p.\n", filter2);
 
     hr = IUnknown_QueryInterface(unk, &test_iid, (void **)&unk2);
-    ok(hr == E_NOINTERFACE, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOINTERFACE, "Got hr %#x.\n", hr);
     ok(!unk2, "Got unexpected IUnknown %p.\n", unk2);
 
     hr = IBaseFilter_QueryInterface(filter, &test_iid, (void **)&unk2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(unk2 == (IUnknown *)0xdeadbeef, "Got unexpected IUnknown %p.\n", unk2);
 
     IBaseFilter_Release(filter);
     ref = IUnknown_Release(unk);
-    ok(!ref, "Got unexpected refcount %ld.\n", ref);
-    ok(outer_ref == 1, "Got unexpected refcount %ld.\n", outer_ref);
+    ok(!ref, "Got unexpected refcount %d.\n", ref);
+    ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
 }
 
 static void test_enum_pins(void)
@@ -287,85 +287,85 @@ static void test_enum_pins(void)
     HRESULT hr;
 
     ref = get_refcount(filter);
-    ok(ref == 1, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
 
     hr = IBaseFilter_EnumPins(filter, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_EnumPins(filter, &enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ref = get_refcount(filter);
-    ok(ref == 2, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 2, "Got unexpected refcount %d.\n", ref);
     ref = get_refcount(enum1);
-    ok(ref == 1, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
 
     hr = IEnumPins_Next(enum1, 1, NULL, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum1, 1, pins, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ref = get_refcount(filter);
-    ok(ref == 3, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 3, "Got unexpected refcount %d.\n", ref);
     ref = get_refcount(pins[0]);
-    ok(ref == 3, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 3, "Got unexpected refcount %d.\n", ref);
     ref = get_refcount(enum1);
-    ok(ref == 1, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
     IPin_Release(pins[0]);
     ref = get_refcount(filter);
-    ok(ref == 2, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 2, "Got unexpected refcount %d.\n", ref);
 
     hr = IEnumPins_Next(enum1, 1, pins, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum1, 1, pins, &count);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(count == 1, "Got count %lu.\n", count);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(count == 1, "Got count %u.\n", count);
     IPin_Release(pins[0]);
 
     hr = IEnumPins_Next(enum1, 1, pins, &count);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
-    ok(!count, "Got count %lu.\n", count);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    ok(!count, "Got count %u.\n", count);
 
     hr = IEnumPins_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum1, 2, pins, NULL);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum1, 2, pins, &count);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
-    ok(count == 1, "Got count %lu.\n", count);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    ok(count == 1, "Got count %u.\n", count);
     IPin_Release(pins[0]);
 
     hr = IEnumPins_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Clone(enum1, &enum2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Skip(enum1, 2);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Skip(enum1, 1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Skip(enum1, 1);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum1, 1, pins, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum2, 1, pins, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     IPin_Release(pins[0]);
 
     IEnumPins_Release(enum2);
     IEnumPins_Release(enum1);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 static void test_find_pin(void)
@@ -377,26 +377,26 @@ static void test_find_pin(void)
     ULONG ref;
 
     hr = IBaseFilter_FindPin(filter, L"In", &pin);
-    ok(hr == VFW_E_NOT_FOUND, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_FOUND, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_FindPin(filter, L"input pin", &pin);
-    ok(hr == VFW_E_NOT_FOUND, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_FOUND, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_FindPin(filter, sink_id, &pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_EnumPins(filter, &enum_pins);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum_pins, 1, &pin2, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(pin == pin2, "Expected pin %p, got %p.\n", pin2, pin);
     IPin_Release(pin);
     IPin_Release(pin2);
 
     IEnumPins_Release(enum_pins);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 static void test_pin_info(void)
@@ -410,38 +410,38 @@ static void test_pin_info(void)
     IPin *pin;
 
     hr = IBaseFilter_FindPin(filter, sink_id, &pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ref = get_refcount(filter);
-    ok(ref == 2, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 2, "Got unexpected refcount %d.\n", ref);
     ref = get_refcount(pin);
-    ok(ref == 2, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 2, "Got unexpected refcount %d.\n", ref);
 
     hr = IPin_QueryPinInfo(pin, &info);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(info.pFilter == filter, "Expected filter %p, got %p.\n", filter, info.pFilter);
     ok(info.dir == PINDIR_INPUT, "Got direction %d.\n", info.dir);
     ok(!wcscmp(info.achName, sink_id), "Got name %s.\n", wine_dbgstr_w(info.achName));
     ref = get_refcount(filter);
-    ok(ref == 3, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 3, "Got unexpected refcount %d.\n", ref);
     ref = get_refcount(pin);
-    ok(ref == 3, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 3, "Got unexpected refcount %d.\n", ref);
     IBaseFilter_Release(info.pFilter);
 
     hr = IPin_QueryDirection(pin, &dir);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(dir == PINDIR_INPUT, "Got direction %d.\n", dir);
 
     hr = IPin_QueryId(pin, &id);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(!wcscmp(id, sink_id), "Got id %s.\n", wine_dbgstr_w(id));
     CoTaskMemFree(id);
 
     hr = IPin_QueryInternalConnections(pin, NULL, NULL);
-    ok(hr == E_NOTIMPL, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOTIMPL, "Got hr %#x.\n", hr);
 
     IPin_Release(pin);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 static void test_basic_audio(void)
@@ -449,57 +449,56 @@ static void test_basic_audio(void)
     IBaseFilter *filter = create_dsound_render();
     LONG balance, volume;
     ITypeInfo *typeinfo;
-    unsigned int count;
     IBasicAudio *audio;
     TYPEATTR *typeattr;
+    ULONG ref, count;
     HRESULT hr;
-    ULONG ref;
 
     hr = IBaseFilter_QueryInterface(filter, &IID_IBasicAudio, (void **)&audio);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBasicAudio_get_Balance(audio, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
 
     hr = IBasicAudio_get_Balance(audio, &balance);
     if (hr != VFW_E_MONO_AUDIO_HW)
     {
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
-        ok(balance == 0, "Got balance %ld.\n", balance);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
+        ok(balance == 0, "Got balance %d.\n", balance);
 
         hr = IBasicAudio_put_Balance(audio, DSBPAN_LEFT - 1);
-        ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+        ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
 
         hr = IBasicAudio_put_Balance(audio, DSBPAN_LEFT);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
 
         hr = IBasicAudio_get_Balance(audio, &balance);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
-        ok(balance == DSBPAN_LEFT, "Got balance %ld.\n", balance);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
+        ok(balance == DSBPAN_LEFT, "Got balance %d.\n", balance);
     }
 
     hr = IBasicAudio_get_Volume(audio, &volume);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(volume == 0, "Got volume %ld.\n", volume);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(volume == 0, "Got volume %d.\n", volume);
 
     hr = IBasicAudio_put_Volume(audio, DSBVOLUME_MIN - 1);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
 
     hr = IBasicAudio_put_Volume(audio, DSBVOLUME_MIN);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBasicAudio_get_Volume(audio, &volume);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(volume == DSBVOLUME_MIN, "Got volume %ld.\n", volume);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(volume == DSBVOLUME_MIN, "Got volume %d.\n", volume);
 
     hr = IBasicAudio_GetTypeInfoCount(audio, &count);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(count == 1, "Got count %u.\n", count);
 
     hr = IBasicAudio_GetTypeInfo(audio, 0, 0, &typeinfo);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = ITypeInfo_GetTypeAttr(typeinfo, &typeattr);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(typeattr->typekind == TKIND_DISPATCH, "Got kind %u.\n", typeattr->typekind);
     ok(IsEqualGUID(&typeattr->guid, &IID_IBasicAudio), "Got IID %s.\n", wine_dbgstr_guid(&typeattr->guid));
     ITypeInfo_ReleaseTypeAttr(typeinfo, typeattr);
@@ -507,7 +506,7 @@ static void test_basic_audio(void)
 
     IBasicAudio_Release(audio);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 static void test_enum_media_types(void)
@@ -522,64 +521,64 @@ static void test_enum_media_types(void)
     IBaseFilter_FindPin(filter, sink_id, &pin);
 
     hr = IPin_EnumMediaTypes(pin, &enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enum1, 1, mts, NULL);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
     if (hr == S_OK) CoTaskMemFree(mts[0]->pbFormat);
     if (hr == S_OK) CoTaskMemFree(mts[0]);
 
     hr = IEnumMediaTypes_Next(enum1, 1, mts, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enum1, 1, mts, &count);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    todo_wine ok(count == 1, "Got count %lu.\n", count);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
+    todo_wine ok(count == 1, "Got count %u.\n", count);
     if (hr == S_OK) CoTaskMemFree(mts[0]->pbFormat);
     if (hr == S_OK) CoTaskMemFree(mts[0]);
 
     hr = IEnumMediaTypes_Next(enum1, 1, mts, &count);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
-    ok(!count, "Got count %lu.\n", count);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    ok(!count, "Got count %u.\n", count);
 
     hr = IEnumMediaTypes_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enum1, 2, mts, &count);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
-    todo_wine ok(count == 1, "Got count %lu.\n", count);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    todo_wine ok(count == 1, "Got count %u.\n", count);
     if (count > 0) CoTaskMemFree(mts[0]->pbFormat);
     if (count > 0) CoTaskMemFree(mts[0]);
 
     hr = IEnumMediaTypes_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Clone(enum1, &enum2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Skip(enum1, 2);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Skip(enum1, 1);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Skip(enum1, 1);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Skip(enum1, 1);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enum1, 1, mts, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enum2, 1, mts, NULL);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
     if (hr == S_OK) CoTaskMemFree(mts[0]->pbFormat);
     if (hr == S_OK) CoTaskMemFree(mts[0]);
 
@@ -588,7 +587,7 @@ static void test_enum_media_types(void)
     IPin_Release(pin);
 
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 struct testfilter
@@ -656,36 +655,36 @@ static void test_allocator(IMemInputPin *input)
     HRESULT hr;
 
     hr = IMemInputPin_GetAllocatorRequirements(input, &props);
-    ok(hr == E_NOTIMPL, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOTIMPL, "Got hr %#x.\n", hr);
 
     hr = IMemInputPin_GetAllocator(input, &ret_allocator);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     if (hr == S_OK)
     {
         hr = IMemAllocator_GetProperties(ret_allocator, &props);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
-        ok(!props.cBuffers, "Got %ld buffers.\n", props.cBuffers);
-        ok(!props.cbBuffer, "Got size %ld.\n", props.cbBuffer);
-        ok(!props.cbAlign, "Got alignment %ld.\n", props.cbAlign);
-        ok(!props.cbPrefix, "Got prefix %ld.\n", props.cbPrefix);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
+        ok(!props.cBuffers, "Got %d buffers.\n", props.cBuffers);
+        ok(!props.cbBuffer, "Got size %d.\n", props.cbBuffer);
+        ok(!props.cbAlign, "Got alignment %d.\n", props.cbAlign);
+        ok(!props.cbPrefix, "Got prefix %d.\n", props.cbPrefix);
 
         hr = IMemInputPin_NotifyAllocator(input, ret_allocator, TRUE);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
         IMemAllocator_Release(ret_allocator);
     }
 
     hr = IMemInputPin_NotifyAllocator(input, NULL, TRUE);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
 
     CoCreateInstance(&CLSID_MemoryAllocator, NULL, CLSCTX_INPROC_SERVER,
             &IID_IMemAllocator, (void **)&req_allocator);
 
     hr = IMemInputPin_NotifyAllocator(input, req_allocator, TRUE);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMemInputPin_GetAllocator(input, &ret_allocator);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(ret_allocator == req_allocator, "Allocators didn't match.\n");
 
     IMemAllocator_Release(req_allocator);
@@ -703,9 +702,9 @@ static DWORD WINAPI frame_thread(void *arg)
     struct frame_thread_params *params = arg;
     HRESULT hr;
 
-    if (winetest_debug > 1) trace("%04lx: Sending frame.\n", GetCurrentThreadId());
+    if (winetest_debug > 1) trace("%04x: Sending frame.\n", GetCurrentThreadId());
     hr = IMemInputPin_Receive(params->sink, params->sample);
-    if (winetest_debug > 1) trace("%04lx: Returned %#lx.\n", GetCurrentThreadId(), hr);
+    if (winetest_debug > 1) trace("%04x: Returned %#x.\n", GetCurrentThreadId(), hr);
     IMediaSample_Release(params->sample);
     free(params);
     return hr;
@@ -725,24 +724,24 @@ static HRESULT send_frame(IMemInputPin *sink)
     DWORD ret;
 
     hr = IMemInputPin_GetAllocator(sink, &allocator);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMemAllocator_GetBuffer(allocator, &sample, NULL, NULL, 0);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaSample_GetPointer(sample, &data);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     words = (unsigned short *)data;
     for (i = 0; i < 44100 * 2; i += 2)
         words[i] = words[i+1] = sinf(i / 20.0f) * 0x7fff;
 
     hr = IMediaSample_SetActualDataLength(sample, 44100 * 4);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     start_time = 0;
     end_time = start_time + 10000000;
     hr = IMediaSample_SetTime(sample, &start_time, &end_time);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     params->sink = sink;
     params->sample = sample;
@@ -762,7 +761,7 @@ static void test_filter_state(IMemInputPin *input, IMediaControl *control)
     HRESULT hr;
 
     hr = send_frame(input);
-    ok(hr == VFW_E_WRONG_STATE, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_WRONG_STATE, "Got hr %#x.\n", hr);
 
     /* The renderer is not fully paused until it receives a sample. The
      * DirectSound renderer never blocks in Receive(), despite returning S_OK
@@ -771,71 +770,71 @@ static void test_filter_state(IMemInputPin *input, IMediaControl *control)
      * than it's worth to emulate, so for now, we'll ignore this behaviour. */
 
     hr = IMediaControl_Pause(control);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     /* It's possible to queue multiple samples while paused. The number of
      * samples that can be queued depends on the length of each sample, but
      * it's not particularly clear how. */
 
     hr = IMediaControl_GetState(control, 0, &state);
-    ok(hr == VFW_S_STATE_INTERMEDIATE, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_S_STATE_INTERMEDIATE, "Got hr %#x.\n", hr);
 
     hr = send_frame(input);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_GetState(control, 1000, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = send_frame(input);
-    ok(hr == VFW_E_WRONG_STATE, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_WRONG_STATE, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_Pause(control);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_GetState(control, 0, &state);
-    ok(hr == VFW_S_STATE_INTERMEDIATE, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_S_STATE_INTERMEDIATE, "Got hr %#x.\n", hr);
 
     hr = send_frame(input);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_GetState(control, 1000, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_Run(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_GetState(control, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = send_frame(input);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = send_frame(input);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_GetState(control, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_Run(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_GetState(control, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_Pause(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_GetState(control, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_GetState(control, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     /* The DirectSound renderer will silently refuse to transition to running
      * if it hasn't finished pausing yet. Once it does it reports itself as
@@ -848,43 +847,43 @@ static void test_flushing(IPin *pin, IMemInputPin *input, IMediaControl *control
     HRESULT hr;
 
     hr = IMediaControl_Pause(control);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = send_frame(input);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_GetState(control, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IPin_BeginFlush(pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = send_frame(input);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IPin_EndFlush(pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_GetState(control, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_Run(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IPin_BeginFlush(pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = send_frame(input);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IPin_EndFlush(pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = send_frame(input);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 }
 
 static unsigned int check_ec_complete(IMediaEvent *eventsrc, DWORD timeout)
@@ -898,14 +897,14 @@ static unsigned int check_ec_complete(IMediaEvent *eventsrc, DWORD timeout)
     {
         if (code == EC_COMPLETE)
         {
-            ok(param1 == S_OK, "Got param1 %#Ix.\n", param1);
-            ok(!param2, "Got param2 %#Ix.\n", param2);
+            ok(param1 == S_OK, "Got param1 %#lx.\n", param1);
+            ok(!param2, "Got param2 %#lx.\n", param2);
             ret++;
         }
         IMediaEvent_FreeEventParams(eventsrc, code, param1, param2);
         timeout = 0;
     }
-    ok(hr == E_ABORT, "Got hr %#lx.\n", hr);
+    ok(hr == E_ABORT, "Got hr %#x.\n", hr);
 
     return ret;
 }
@@ -920,28 +919,28 @@ static void test_eos(IPin *pin, IMemInputPin *input, IMediaControl *control)
     IMediaControl_QueryInterface(control, &IID_IMediaEvent, (void **)&eventsrc);
 
     hr = IMediaControl_Pause(control);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     ret = check_ec_complete(eventsrc, 0);
     ok(!ret, "Got unexpected EC_COMPLETE.\n");
 
     hr = IPin_EndOfStream(pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_GetState(control, 1000, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ret = check_ec_complete(eventsrc, 0);
     ok(!ret, "Got unexpected EC_COMPLETE.\n");
 
     hr = send_frame(input);
-    todo_wine ok(hr == VFW_E_SAMPLE_REJECTED_EOS, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == VFW_E_SAMPLE_REJECTED_EOS, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_Run(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ret = check_ec_complete(eventsrc, 0);
     ok(ret == 1, "Expected EC_COMPLETE.\n");
 
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ret = check_ec_complete(eventsrc, 0);
     ok(!ret, "Got unexpected EC_COMPLETE.\n");
 
@@ -949,79 +948,79 @@ static void test_eos(IPin *pin, IMemInputPin *input, IMediaControl *control)
      * done rendering. */
 
     hr = IMediaControl_Pause(control);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     hr = send_frame(input);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMediaControl_GetState(control, 1000, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMediaControl_Run(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ret = check_ec_complete(eventsrc, 0);
     ok(!ret, "Got unexpected EC_COMPLETE.\n");
 
     hr = IPin_EndOfStream(pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ret = check_ec_complete(eventsrc, 0);
     todo_wine ok(!ret, "Got unexpected EC_COMPLETE.\n");
     ret = check_ec_complete(eventsrc, 2000);
     todo_wine ok(ret == 1, "Expected EC_COMPLETE.\n");
 
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ret = check_ec_complete(eventsrc, 0);
     ok(!ret, "Got unexpected EC_COMPLETE.\n");
 
     /* Test sending EOS while flushing. */
 
     hr = IMediaControl_Run(control);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     hr = send_frame(input);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IPin_BeginFlush(pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IPin_EndOfStream(pin);
-    todo_wine ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     hr = IPin_EndFlush(pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ret = check_ec_complete(eventsrc, 0);
     todo_wine ok(!ret, "Got unexpected EC_COMPLETE.\n");
 
     /* Test sending EOS and then flushing or stopping. */
 
     hr = IMediaControl_Pause(control);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     hr = send_frame(input);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMediaControl_GetState(control, 1000, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMediaControl_Run(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ret = check_ec_complete(eventsrc, 0);
     ok(!ret, "Got unexpected EC_COMPLETE.\n");
 
     hr = IPin_EndOfStream(pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ret = check_ec_complete(eventsrc, 0);
     todo_wine ok(!ret, "Got unexpected EC_COMPLETE.\n");
 
     hr = IPin_BeginFlush(pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IPin_EndFlush(pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = send_frame(input);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IPin_EndOfStream(pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ret = check_ec_complete(eventsrc, 0);
     ok(!ret, "Got unexpected EC_COMPLETE.\n");
 
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ret = check_ec_complete(eventsrc, 0);
     ok(!ret, "Got unexpected EC_COMPLETE.\n");
 
@@ -1070,37 +1069,37 @@ static void test_connect_pin(void)
 
     peer = (IPin *)0xdeadbeef;
     hr = IPin_ConnectedTo(pin, &peer);
-    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#x.\n", hr);
     ok(!peer, "Got peer %p.\n", peer);
 
     hr = IPin_ConnectionMediaType(pin, &mt);
-    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_Pause(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IFilterGraph2_ConnectDirect(graph, &source.source.pin.IPin_iface, pin, &req_mt);
-    ok(hr == VFW_E_NOT_STOPPED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_STOPPED, "Got hr %#x.\n", hr);
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IFilterGraph2_ConnectDirect(graph, &source.source.pin.IPin_iface, pin, &req_mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IPin_ConnectedTo(pin, &peer);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(peer == &source.source.pin.IPin_iface, "Got peer %p.\n", peer);
     IPin_Release(peer);
 
     hr = IPin_ConnectionMediaType(pin, &mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(compare_media_types(&mt, &req_mt), "Media types didn't match.\n");
 
     hr = IMediaControl_Pause(control);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     hr = IFilterGraph2_Disconnect(graph, pin);
-    ok(hr == VFW_E_NOT_STOPPED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_STOPPED, "Got hr %#x.\n", hr);
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     IPin_QueryInterface(pin, &IID_IMemInputPin, (void **)&input);
 
@@ -1108,48 +1107,48 @@ static void test_connect_pin(void)
 
     hr = CoCreateInstance(&CLSID_MemoryAllocator, NULL, CLSCTX_INPROC_SERVER,
             &IID_IMemAllocator, (void **)&allocator);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMemAllocator_SetProperties(allocator, &req_props, &ret_props);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(!memcmp(&ret_props, &req_props, sizeof(req_props)), "Properties did not match.\n");
     hr = IMemInputPin_NotifyAllocator(input, allocator, TRUE);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMemAllocator_Commit(allocator);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMemInputPin_ReceiveCanBlock(input);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     test_filter_state(input, control);
     test_flushing(pin, input, control);
     test_eos(pin, input, control);
 
     hr = IFilterGraph2_Disconnect(graph, pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IFilterGraph2_Disconnect(graph, pin);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     ok(source.source.pin.peer == pin, "Got peer %p.\n", source.source.pin.peer);
     IFilterGraph2_Disconnect(graph, &source.source.pin.IPin_iface);
 
     peer = (IPin *)0xdeadbeef;
     hr = IPin_ConnectedTo(pin, &peer);
-    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#x.\n", hr);
     ok(!peer, "Got peer %p.\n", peer);
 
     hr = IPin_ConnectionMediaType(pin, &mt);
-    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#x.\n", hr);
 
     ref = IMemAllocator_Release(allocator);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     IMemInputPin_Release(input);
     IPin_Release(pin);
     IMediaControl_Release(control);
     ref = IFilterGraph2_Release(graph);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ref = IBaseFilter_Release(&source.filter.IBaseFilter_iface);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 static void test_unconnected_filter_state(void)
@@ -1160,53 +1159,53 @@ static void test_unconnected_filter_state(void)
     ULONG ref;
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(state == State_Stopped, "Got state %u.\n", state);
 
     hr = IBaseFilter_Pause(filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(state == State_Paused, "Got state %u.\n", state);
 
     hr = IBaseFilter_Run(filter, 0);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(state == State_Running, "Got state %u.\n", state);
 
     hr = IBaseFilter_Pause(filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(state == State_Paused, "Got state %u.\n", state);
 
     hr = IBaseFilter_Stop(filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(state == State_Stopped, "Got state %u.\n", state);
 
     hr = IBaseFilter_Run(filter, 0);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(state == State_Running, "Got state %u.\n", state);
 
     hr = IBaseFilter_Stop(filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(state == State_Stopped, "Got state %u.\n", state);
 
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 static HRESULT does_dsound_support_format(WAVEFORMATEX *format)
@@ -1222,7 +1221,7 @@ static HRESULT does_dsound_support_format(WAVEFORMATEX *format)
     HRESULT hr;
 
     hr = DirectSoundCreate(NULL, &dsound, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IDirectSound_CreateSoundBuffer(dsound, &desc, &buffer, NULL);
     if (hr == S_OK)
@@ -1263,30 +1262,30 @@ static void test_media_types(void)
     IBaseFilter_FindPin(filter, sink_id, &pin);
 
     hr = IPin_EnumMediaTypes(pin, &enummt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enummt, 1, &mt, NULL);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
     if (hr == S_OK)
     {
         ok(IsEqualGUID(&mt->majortype, &MEDIATYPE_Audio), "Got major type %s.\n", wine_dbgstr_guid(&mt->majortype));
         ok(IsEqualGUID(&mt->subtype, &GUID_NULL), "Got subtype %s.\n", wine_dbgstr_guid(&mt->subtype));
         ok(mt->bFixedSizeSamples == TRUE, "Got fixed size %d.\n", mt->bFixedSizeSamples);
         ok(!mt->bTemporalCompression, "Got temporal compression %d.\n", mt->bTemporalCompression);
-        ok(mt->lSampleSize == 1, "Got sample size %lu.\n", mt->lSampleSize);
+        ok(mt->lSampleSize == 1, "Got sample size %u.\n", mt->lSampleSize);
         ok(IsEqualGUID(&mt->formattype, &GUID_NULL), "Got format type %s.\n", wine_dbgstr_guid(&mt->formattype));
         ok(!mt->pUnk, "Got pUnk %p.\n", mt->pUnk);
-        ok(!mt->cbFormat, "Got format size %lu.\n", mt->cbFormat);
+        ok(!mt->cbFormat, "Got format size %u.\n", mt->cbFormat);
         ok(!mt->pbFormat, "Got unexpected format block.\n");
 
         hr = IPin_QueryAccept(pin, mt);
-        ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+        ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
         CoTaskMemFree(mt);
     }
 
     hr = IEnumMediaTypes_Next(enummt, 1, &mt, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     req_mt.majortype = MEDIATYPE_Audio;
     req_mt.formattype = FORMAT_WaveFormatEx;
@@ -1312,7 +1311,7 @@ static void test_media_types(void)
                 expect_hr = does_dsound_support_format(&wfx);
 
                 hr = IPin_QueryAccept(pin, &req_mt);
-                ok(hr == expect_hr, "Expected hr %#lx, got %#lx, for %d channels, %d-bit %s, %ld Hz.\n",
+                ok(hr == expect_hr, "Expected hr %#x, got %#x, for %d channels, %d-bit %s, %d Hz.\n",
                         expect_hr, hr, channels, formats[i].depth,
                         formats[i].tag == WAVE_FORMAT_PCM ? "integer" : "float", sample_rates[j]);
             }
@@ -1321,7 +1320,7 @@ static void test_media_types(void)
 
     IPin_Release(pin);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 static void test_unconnected_eos(void)
@@ -1335,49 +1334,49 @@ static void test_unconnected_eos(void)
     ULONG ref;
 
     hr = IFilterGraph2_AddFilter(graph, filter, L"renderer");
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IFilterGraph2_QueryInterface(graph, &IID_IMediaControl, (void **)&control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IFilterGraph2_QueryInterface(graph, &IID_IMediaEvent, (void **)&eventsrc);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     ret = check_ec_complete(eventsrc, 0);
     ok(!ret, "Got %u EC_COMPLETE events.\n", ret);
 
     hr = IMediaControl_Pause(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     ret = check_ec_complete(eventsrc, 0);
     ok(!ret, "Got %u EC_COMPLETE events.\n", ret);
 
     hr = IMediaControl_Run(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     ret = check_ec_complete(eventsrc, 0);
     ok(ret == 1, "Got %u EC_COMPLETE events.\n", ret);
 
     hr = IMediaControl_Pause(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     ret = check_ec_complete(eventsrc, 0);
     ok(!ret, "Got %u EC_COMPLETE events.\n", ret);
 
     hr = IMediaControl_Run(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     ret = check_ec_complete(eventsrc, 0);
     ok(ret == 1, "Got %u EC_COMPLETE events.\n", ret);
 
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     ret = check_ec_complete(eventsrc, 0);
     ok(!ret, "Got %u EC_COMPLETE events.\n", ret);
 
     hr = IMediaControl_Run(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     ret = check_ec_complete(eventsrc, 0);
     ok(ret == 1, "Got %u EC_COMPLETE events.\n", ret);
@@ -1385,9 +1384,9 @@ static void test_unconnected_eos(void)
     IMediaControl_Release(control);
     IMediaEvent_Release(eventsrc);
     ref = IFilterGraph2_Release(graph);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 START_TEST(dsoundrender)
@@ -1405,7 +1404,7 @@ START_TEST(dsoundrender)
         CoUninitialize();
         return;
     }
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     IBaseFilter_Release(filter);
 
     test_property_bag();
diff --git a/dlls/quartz/tests/filesource.c b/dlls/quartz/tests/filesource.c
index c383d9f6579..4162e248937 100644
--- wine/dlls/quartz/tests/filesource.c
+++ wine/dlls/quartz/tests/filesource.c
@@ -29,7 +29,7 @@ static IBaseFilter *create_file_source(void)
     IBaseFilter *filter = NULL;
     HRESULT hr = CoCreateInstance(&CLSID_AsyncReader, NULL, CLSCTX_INPROC_SERVER,
         &IID_IBaseFilter, (void **)&filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     return filter;
 }
 
@@ -51,11 +51,11 @@ static WCHAR *load_resource(const WCHAR *name)
     wcscat(pathW, name);
 
     file = CreateFileW(pathW, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, 0);
-    ok(file != INVALID_HANDLE_VALUE, "Failed to create file %s, error %lu.\n",
+    ok(file != INVALID_HANDLE_VALUE, "Failed to create file %s, error %u.\n",
             wine_dbgstr_w(pathW), GetLastError());
 
     res = FindResourceW(NULL, name, (LPCWSTR)RT_RCDATA);
-    ok(!!res, "Failed to load resource, error %lu.\n", GetLastError());
+    ok(!!res, "Failed to load resource, error %u.\n", GetLastError());
     ptr = LockResource(LoadResource(GetModuleHandleA(NULL), res));
     WriteFile(file, ptr, SizeofResource( GetModuleHandleA(NULL), res), &written, NULL);
     ok(written == SizeofResource(GetModuleHandleA(NULL), res), "Failed to write resource.\n");
@@ -70,9 +70,9 @@ static void load_file(IBaseFilter *filter, const WCHAR *filename)
     HRESULT hr;
 
     hr = IBaseFilter_QueryInterface(filter, &IID_IFileSourceFilter, (void **)&filesource);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IFileSourceFilter_Load(filesource, filename, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     IFileSourceFilter_Release(filesource);
 }
 
@@ -93,7 +93,7 @@ static void check_interface_(unsigned int line, void *iface_ptr, REFIID iid, BOO
     expected_hr = supported ? S_OK : E_NOINTERFACE;
 
     hr = IUnknown_QueryInterface(iface, iid, (void **)&unk);
-    ok_(__FILE__, line)(hr == expected_hr, "Got hr %#lx, expected %#lx.\n", hr, expected_hr);
+    ok_(__FILE__, line)(hr == expected_hr, "Got hr %#x, expected %#x.\n", hr, expected_hr);
     if (SUCCEEDED(hr))
         IUnknown_Release(unk);
 }
@@ -181,53 +181,53 @@ static void test_aggregation(void)
     filter = (IBaseFilter *)0xdeadbeef;
     hr = CoCreateInstance(&CLSID_AsyncReader, &test_outer, CLSCTX_INPROC_SERVER,
             &IID_IBaseFilter, (void **)&filter);
-    ok(hr == E_NOINTERFACE, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOINTERFACE, "Got hr %#x.\n", hr);
     ok(!filter, "Got interface %p.\n", filter);
 
     hr = CoCreateInstance(&CLSID_AsyncReader, &test_outer, CLSCTX_INPROC_SERVER,
             &IID_IUnknown, (void **)&unk);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(outer_ref == 1, "Got unexpected refcount %ld.\n", outer_ref);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
     ok(unk != &test_outer, "Returned IUnknown should not be outer IUnknown.\n");
     ref = get_refcount(unk);
-    ok(ref == 1, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
 
     ref = IUnknown_AddRef(unk);
-    ok(ref == 2, "Got unexpected refcount %ld.\n", ref);
-    ok(outer_ref == 1, "Got unexpected refcount %ld.\n", outer_ref);
+    ok(ref == 2, "Got unexpected refcount %d.\n", ref);
+    ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
 
     ref = IUnknown_Release(unk);
-    ok(ref == 1, "Got unexpected refcount %ld.\n", ref);
-    ok(outer_ref == 1, "Got unexpected refcount %ld.\n", outer_ref);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
+    ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
 
     hr = IUnknown_QueryInterface(unk, &IID_IUnknown, (void **)&unk2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(unk2 == unk, "Got unexpected IUnknown %p.\n", unk2);
     IUnknown_Release(unk2);
 
     hr = IUnknown_QueryInterface(unk, &IID_IBaseFilter, (void **)&filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_QueryInterface(filter, &IID_IUnknown, (void **)&unk2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(unk2 == (IUnknown *)0xdeadbeef, "Got unexpected IUnknown %p.\n", unk2);
 
     hr = IBaseFilter_QueryInterface(filter, &IID_IBaseFilter, (void **)&filter2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(filter2 == (IBaseFilter *)0xdeadbeef, "Got unexpected IBaseFilter %p.\n", filter2);
 
     hr = IUnknown_QueryInterface(unk, &test_iid, (void **)&unk2);
-    ok(hr == E_NOINTERFACE, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOINTERFACE, "Got hr %#x.\n", hr);
     ok(!unk2, "Got unexpected IUnknown %p.\n", unk2);
 
     hr = IBaseFilter_QueryInterface(filter, &test_iid, (void **)&unk2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(unk2 == (IUnknown *)0xdeadbeef, "Got unexpected IUnknown %p.\n", unk2);
 
     IBaseFilter_Release(filter);
     ref = IUnknown_Release(unk);
-    ok(!ref, "Got unexpected refcount %ld.\n", ref);
-    ok(outer_ref == 1, "Got unexpected refcount %ld.\n", outer_ref);
+    ok(!ref, "Got unexpected refcount %d.\n", ref);
+    ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
 }
 
 static void test_file_source_filter(void)
@@ -306,9 +306,9 @@ static void test_file_source_filter(void)
         trace("Running test for %s.\n", tests[i].label);
 
         file = CreateFileW(path, GENERIC_READ | GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
-        ok(file != INVALID_HANDLE_VALUE, "Failed to create file, error %lu.\n", GetLastError());
+        ok(file != INVALID_HANDLE_VALUE, "Failed to create file, error %u.\n", GetLastError());
         ret = WriteFile(file, tests[i].data, tests[i].size, &written, NULL);
-        ok(ret, "Failed to write file, error %lu.\n", GetLastError());
+        ok(ret, "Failed to write file, error %u.\n", GetLastError());
         CloseHandle(file);
 
         filter = create_file_source();
@@ -316,27 +316,27 @@ static void test_file_source_filter(void)
 
         olepath = (void *)0xdeadbeef;
         hr = IFileSourceFilter_GetCurFile(filesource, &olepath, NULL);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
         ok(!olepath, "Got path %s.\n", wine_dbgstr_w(olepath));
 
         hr = IFileSourceFilter_Load(filesource, NULL, NULL);
-        ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+        ok(hr == E_POINTER, "Got hr %#x.\n", hr);
 
         hr = IFileSourceFilter_Load(filesource, path, NULL);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
 
         hr = IFileSourceFilter_GetCurFile(filesource, NULL, &mt);
-        ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+        ok(hr == E_POINTER, "Got hr %#x.\n", hr);
 
         olepath = NULL;
         hr = IFileSourceFilter_GetCurFile(filesource, &olepath, NULL);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
         CoTaskMemFree(olepath);
 
         olepath = NULL;
         memset(&file_mt, 0x11, sizeof(file_mt));
         hr = IFileSourceFilter_GetCurFile(filesource, &olepath, &file_mt);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
         ok(!wcscmp(olepath, path), "Expected path %s, got %s.\n",
                 wine_dbgstr_w(path), wine_dbgstr_w(olepath));
         ok(IsEqualGUID(&file_mt.majortype, &MEDIATYPE_Stream), "Got major type %s.\n",
@@ -348,40 +348,40 @@ static void test_file_source_filter(void)
         ok(file_mt.bFixedSizeSamples == TRUE, "Got fixed size %d.\n", file_mt.bFixedSizeSamples);
         ok(file_mt.bTemporalCompression == FALSE, "Got temporal compression %d.\n",
                 file_mt.bTemporalCompression);
-        ok(file_mt.lSampleSize == 1, "Got sample size %lu.\n", file_mt.lSampleSize);
+        ok(file_mt.lSampleSize == 1, "Got sample size %u.\n", file_mt.lSampleSize);
         ok(IsEqualGUID(&file_mt.formattype, &GUID_NULL), "Got format type %s.\n",
                 wine_dbgstr_guid(&file_mt.formattype));
         ok(!file_mt.pUnk, "Got pUnk %p.\n", file_mt.pUnk);
-        ok(!file_mt.cbFormat, "Got format size %#lx.\n", file_mt.cbFormat);
+        ok(!file_mt.cbFormat, "Got format size %#x.\n", file_mt.cbFormat);
         ok(!file_mt.pbFormat, "Got format %p.\n", file_mt.pbFormat);
         CoTaskMemFree(olepath);
 
         hr = IBaseFilter_FindPin(filter, L"Output", &pin);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
 
         hr = IPin_EnumMediaTypes(pin, &enum_mt);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
 
         hr = IEnumMediaTypes_Next(enum_mt, 1, &pmt, NULL);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
         ok(!memcmp(pmt, &file_mt, sizeof(*pmt)), "Media types did not match.\n");
         CoTaskMemFree(pmt);
 
         hr = IEnumMediaTypes_Next(enum_mt, 1, &pmt, NULL);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
         mt = file_mt;
         mt.subtype = GUID_NULL;
         ok(!memcmp(pmt, &mt, sizeof(*pmt)), "Media types did not match.\n");
         CoTaskMemFree(pmt);
 
         hr = IEnumMediaTypes_Next(enum_mt, 1, &pmt, NULL);
-        ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+        ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
         IEnumMediaTypes_Release(enum_mt);
 
         mt = file_mt;
         hr = IPin_QueryAccept(pin, &mt);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
 
         mt.bFixedSizeSamples = FALSE;
         mt.bTemporalCompression = TRUE;
@@ -389,33 +389,33 @@ static void test_file_source_filter(void)
         mt.formattype = FORMAT_VideoInfo;
         mt.subtype = MEDIASUBTYPE_RGB32;
         hr = IPin_QueryAccept(pin, &mt);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
 
         mt.majortype = MEDIATYPE_Video;
         hr = IPin_QueryAccept(pin, &mt);
-        ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+        ok(hr == S_FALSE, "Got hr %#x.\n", hr);
         mt.majortype = MEDIATYPE_Stream;
 
         if (!IsEqualGUID(tests[i].subtype, &GUID_NULL))
         {
             mt.subtype = GUID_NULL;
             hr = IPin_QueryAccept(pin, &mt);
-            ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+            ok(hr == S_FALSE, "Got hr %#x.\n", hr);
         }
 
         IPin_Release(pin);
         IFileSourceFilter_Release(filesource);
         ref = IBaseFilter_Release(filter);
-        ok(!ref, "Got outstanding refcount %ld.\n", ref);
+        ok(!ref, "Got outstanding refcount %d.\n", ref);
 
         ret = DeleteFileW(path);
-        ok(ret, "Failed to delete file, error %lu\n", GetLastError());
+        ok(ret, "Failed to delete file, error %u\n", GetLastError());
     }
 
     /* test prescribed format */
     filter = create_file_source();
     hr = IBaseFilter_QueryInterface(filter, &IID_IFileSourceFilter, (void **)&filesource);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     mt.majortype = MEDIATYPE_Video;
     mt.subtype = MEDIASUBTYPE_RGB8;
@@ -428,73 +428,73 @@ static void test_file_source_filter(void)
     mt.pbFormat = NULL;
     filename = load_resource(L"test.avi");
     hr = IFileSourceFilter_Load(filesource, filename, &mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IFileSourceFilter_GetCurFile(filesource, &olepath, &file_mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(!memcmp(&file_mt, &mt, sizeof(mt)), "Media types did not match.\n");
     CoTaskMemFree(olepath);
 
     hr = IBaseFilter_FindPin(filter, L"Output", &pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IPin_EnumMediaTypes(pin, &enum_mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enum_mt, 1, &pmt, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(!memcmp(pmt, &file_mt, sizeof(*pmt)), "Media types did not match.\n");
     CoTaskMemFree(pmt);
 
     hr = IEnumMediaTypes_Next(enum_mt, 1, &pmt, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(IsEqualGUID(&pmt->majortype, &MEDIATYPE_Stream), "Got major type %s.\n",
             wine_dbgstr_guid(&pmt->majortype));
     ok(IsEqualGUID(&pmt->subtype, &GUID_NULL), "Got subtype %s.\n",
             wine_dbgstr_guid(&pmt->subtype));
     ok(pmt->bFixedSizeSamples == TRUE, "Got fixed size %d.\n", pmt->bFixedSizeSamples);
     ok(!pmt->bTemporalCompression, "Got temporal compression %d.\n", pmt->bTemporalCompression);
-    ok(pmt->lSampleSize == 1, "Got sample size %lu.\n", pmt->lSampleSize);
+    ok(pmt->lSampleSize == 1, "Got sample size %u.\n", pmt->lSampleSize);
     ok(IsEqualGUID(&pmt->formattype, &GUID_NULL), "Got format type %s.\n",
             wine_dbgstr_guid(&pmt->formattype));
     ok(!pmt->pUnk, "Got pUnk %p.\n", pmt->pUnk);
-    ok(!pmt->cbFormat, "Got format size %#lx.\n", pmt->cbFormat);
+    ok(!pmt->cbFormat, "Got format size %#x.\n", pmt->cbFormat);
     ok(!pmt->pbFormat, "Got format %p.\n", pmt->pbFormat);
 
     hr = IPin_QueryAccept(pin, pmt);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     CoTaskMemFree(pmt);
 
     hr = IEnumMediaTypes_Next(enum_mt, 1, &pmt, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     IEnumMediaTypes_Release(enum_mt);
 
     hr = IPin_QueryAccept(pin, &mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     mt.bFixedSizeSamples = TRUE;
     mt.bTemporalCompression = FALSE;
     mt.lSampleSize = 456;
     mt.formattype = FORMAT_VideoInfo;
     hr = IPin_QueryAccept(pin, &mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     mt.majortype = MEDIATYPE_Stream;
     hr = IPin_QueryAccept(pin, &mt);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     mt.majortype = MEDIATYPE_Video;
 
     mt.subtype = MEDIASUBTYPE_NULL;
     hr = IPin_QueryAccept(pin, &mt);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     IPin_Release(pin);
     IFileSourceFilter_Release(filesource);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ret = DeleteFileW(filename);
-    ok(ret, "Failed to delete file, error %lu.\n", GetLastError());
+    ok(ret, "Failed to delete file, error %u.\n", GetLastError());
 }
 
 static void test_enum_pins(void)
@@ -509,102 +509,102 @@ static void test_enum_pins(void)
     BOOL ret;
 
     ref = get_refcount(filter);
-    ok(ref == 1, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
 
     hr = IBaseFilter_EnumPins(filter, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_EnumPins(filter, &enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     ref = get_refcount(filter);
-    ok(ref == 2, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 2, "Got unexpected refcount %d.\n", ref);
     ref = get_refcount(enum1);
-    ok(ref == 1, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
 
     hr = IEnumPins_Next(enum1, 1, NULL, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum1, 1, pins, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Skip(enum1, 1);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     load_file(filter, filename);
 
     hr = IEnumPins_Next(enum1, 1, pins, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum1, 1, pins, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ref = get_refcount(filter);
-    ok(ref == 3, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 3, "Got unexpected refcount %d.\n", ref);
     ref = get_refcount(pins[0]);
-    ok(ref == 3, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 3, "Got unexpected refcount %d.\n", ref);
     ref = get_refcount(enum1);
-    ok(ref == 1, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
     IPin_Release(pins[0]);
     ref = get_refcount(filter);
-    ok(ref == 2, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 2, "Got unexpected refcount %d.\n", ref);
 
     hr = IEnumPins_Next(enum1, 1, pins, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum1, 1, pins, &count);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(count == 1, "Got count %lu.\n", count);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(count == 1, "Got count %u.\n", count);
     IPin_Release(pins[0]);
 
     hr = IEnumPins_Next(enum1, 1, pins, &count);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
-    ok(!count, "Got count %lu.\n", count);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    ok(!count, "Got count %u.\n", count);
 
     hr = IEnumPins_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum1, 2, pins, NULL);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum1, 2, pins, &count);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
-    ok(count == 1, "Got count %lu.\n", count);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    ok(count == 1, "Got count %u.\n", count);
     IPin_Release(pins[0]);
 
     hr = IEnumPins_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Clone(enum1, &enum2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Skip(enum1, 2);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Skip(enum1, 1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Skip(enum1, 1);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum1, 1, pins, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum2, 1, pins, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     IPin_Release(pins[0]);
 
     IEnumPins_Release(enum2);
     IEnumPins_Release(enum1);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ret = DeleteFileW(filename);
-    ok(ret, "Failed to delete file, error %lu.\n", GetLastError());
+    ok(ret, "Failed to delete file, error %u.\n", GetLastError());
 }
 
 static void test_find_pin(void)
@@ -618,31 +618,31 @@ static void test_find_pin(void)
     BOOL ret;
 
     hr = IBaseFilter_FindPin(filter, L"Output", &pin);
-    ok(hr == VFW_E_NOT_FOUND, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_FOUND, "Got hr %#x.\n", hr);
 
     load_file(filter, filename);
 
     hr = IBaseFilter_FindPin(filter, L"Output", &pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ref = get_refcount(filter);
-    ok(ref == 2, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 2, "Got unexpected refcount %d.\n", ref);
     ref = get_refcount(pin);
-    ok(ref == 2, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 2, "Got unexpected refcount %d.\n", ref);
 
     hr = IBaseFilter_EnumPins(filter, &enumpins);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enumpins, 1, &pin2, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(pin == pin2, "Expected pin %p, got %p.\n", pin, pin2);
 
     IPin_Release(pin2);
     IPin_Release(pin);
     IEnumPins_Release(enumpins);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ret = DeleteFileW(filename);
-    ok(ret, "Failed to delete file, error %lu.\n", GetLastError());
+    ok(ret, "Failed to delete file, error %u.\n", GetLastError());
 }
 
 static void test_pin_info(void)
@@ -660,37 +660,37 @@ static void test_pin_info(void)
     load_file(filter, filename);
 
     hr = IBaseFilter_FindPin(filter, L"Output", &pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ref = get_refcount(filter);
-    ok(ref == 2, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 2, "Got unexpected refcount %d.\n", ref);
     ref = get_refcount(pin);
-    ok(ref == 2, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 2, "Got unexpected refcount %d.\n", ref);
 
     hr = IPin_QueryPinInfo(pin, &info);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(info.pFilter == filter, "Expected filter %p, got %p.\n", filter, info.pFilter);
     ok(info.dir == PINDIR_OUTPUT, "Got direction %d.\n", info.dir);
     ok(!wcscmp(info.achName, L"Output"), "Got name %s.\n", wine_dbgstr_w(info.achName));
     ref = get_refcount(filter);
-    ok(ref == 3, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 3, "Got unexpected refcount %d.\n", ref);
     ref = get_refcount(pin);
-    ok(ref == 3, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 3, "Got unexpected refcount %d.\n", ref);
     IBaseFilter_Release(info.pFilter);
 
     hr = IPin_QueryDirection(pin, &dir);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(dir == PINDIR_OUTPUT, "Got direction %d.\n", dir);
 
     hr = IPin_QueryId(pin, &id);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(!wcscmp(id, L"Output"), "Got id %s.\n", wine_dbgstr_w(id));
     CoTaskMemFree(id);
 
     IPin_Release(pin);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ret = DeleteFileW(filename);
-    ok(ret, "Failed to delete file, error %lu.\n", GetLastError());
+    ok(ret, "Failed to delete file, error %u.\n", GetLastError());
 }
 
 static void test_unconnected_filter_state(void)
@@ -701,53 +701,53 @@ static void test_unconnected_filter_state(void)
     ULONG ref;
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(state == State_Stopped, "Got state %u.\n", state);
 
     hr = IBaseFilter_Pause(filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(state == State_Paused, "Got state %u.\n", state);
 
     hr = IBaseFilter_Run(filter, 0);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(state == State_Running, "Got state %u.\n", state);
 
     hr = IBaseFilter_Pause(filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(state == State_Paused, "Got state %u.\n", state);
 
     hr = IBaseFilter_Stop(filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(state == State_Stopped, "Got state %u.\n", state);
 
     hr = IBaseFilter_Run(filter, 0);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(state == State_Running, "Got state %u.\n", state);
 
     hr = IBaseFilter_Stop(filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(state == State_Stopped, "Got state %u.\n", state);
 
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 static void test_sync_read_aligned(IAsyncReader *reader, IMemAllocator *allocator)
@@ -765,13 +765,13 @@ static void test_sync_read_aligned(IAsyncReader *reader, IMemAllocator *allocato
     start_time = 0;
     end_time = 512 * (LONGLONG)10000000;
     hr = IMediaSample_SetTime(sample, &start_time, &end_time);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IAsyncReader_SyncReadAligned(reader, sample);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     len = IMediaSample_GetActualDataLength(sample);
-    ok(len == 512, "Got length %ld.\n", len);
+    ok(len == 512, "Got length %d.\n", len);
 
     for (i = 0; i < 512; i++)
         ok(data[i] == i % 111, "Got wrong byte %02x at %u.\n", data[i], i);
@@ -779,13 +779,13 @@ static void test_sync_read_aligned(IAsyncReader *reader, IMemAllocator *allocato
     start_time = 512 * (LONGLONG)10000000;
     end_time  = 1024 * (LONGLONG)10000000;
     hr = IMediaSample_SetTime(sample, &start_time, &end_time);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IAsyncReader_SyncReadAligned(reader, sample);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     len = IMediaSample_GetActualDataLength(sample);
-    ok(len == 88, "Got length %ld.\n", len);
+    ok(len == 88, "Got length %d.\n", len);
 
     for (i = 0; i < 88; i++)
         ok(data[i] == (512 + i) % 111, "Got wrong byte %02x at %u.\n", data[i], i);
@@ -793,13 +793,13 @@ static void test_sync_read_aligned(IAsyncReader *reader, IMemAllocator *allocato
     start_time = 1024 * (LONGLONG)10000000;
     end_time   = 1536 * (LONGLONG)10000000;
     hr = IMediaSample_SetTime(sample, &start_time, &end_time);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IAsyncReader_SyncReadAligned(reader, sample);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     len = IMediaSample_GetActualDataLength(sample);
-    ok(len == 0, "Got length %ld.\n", len);
+    ok(len == 0, "Got length %d.\n", len);
 
     IMediaSample_Release(sample);
 }
@@ -814,7 +814,7 @@ static DWORD CALLBACK request_thread(void *arg)
 {
     struct request_thread_params *params = arg;
     HRESULT hr = IAsyncReader_Request(params->reader, params->sample, 123);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     return 0;
 }
 
@@ -836,23 +836,23 @@ static void test_request(IAsyncReader *reader, IMemAllocator *allocator)
     IMediaSample_GetPointer(sample2, &data2);
 
     hr = IAsyncReader_WaitForNext(reader, 0, &ret_sample, &cookie);
-    ok(hr == VFW_E_TIMEOUT, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_TIMEOUT, "Got hr %#x.\n", hr);
 
     start_time = 0;
     end_time = 512 * (LONGLONG)10000000;
     hr = IMediaSample_SetTime(sample, &start_time, &end_time);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IAsyncReader_Request(reader, sample, 123);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IAsyncReader_WaitForNext(reader, 1000, &ret_sample, &cookie);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(ret_sample == sample, "Expected sample %p, got %p.\n", sample, ret_sample);
-    ok(cookie == 123, "Got cookie %Iu.\n", cookie);
+    ok(cookie == 123, "Got cookie %lu.\n", cookie);
 
     len = IMediaSample_GetActualDataLength(sample);
-    ok(len == 512, "Got length %ld.\n", len);
+    ok(len == 512, "Got length %d.\n", hr);
 
     for (i = 0; i < 512; i++)
         ok(data[i] == i % 111, "Got wrong byte %02x at %u.\n", data[i], i);
@@ -860,47 +860,47 @@ static void test_request(IAsyncReader *reader, IMemAllocator *allocator)
     start_time = 1024 * (LONGLONG)10000000;
     end_time   = 1536 * (LONGLONG)10000000;
     hr = IMediaSample_SetTime(sample, &start_time, &end_time);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IAsyncReader_Request(reader, sample, 123);
-    ok(hr == HRESULT_FROM_WIN32(ERROR_HANDLE_EOF), "Got hr %#lx.\n", hr);
+    ok(hr == HRESULT_FROM_WIN32(ERROR_HANDLE_EOF), "Got hr %#x.\n", hr);
 
     start_time = 0;
     end_time = 512 * (LONGLONG)10000000;
     hr = IMediaSample_SetTime(sample, &start_time, &end_time);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IAsyncReader_Request(reader, sample, 123);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     start_time = 512 * (LONGLONG)10000000;
     end_time  = 1024 * (LONGLONG)10000000;
     hr = IMediaSample_SetTime(sample2, &start_time, &end_time);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IAsyncReader_Request(reader, sample2, 456);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IAsyncReader_WaitForNext(reader, 1000, &ret_sample, &cookie);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     if (cookie == 123)
     {
         ok(ret_sample == sample, "Expected sample %p, got %p.\n", sample, ret_sample);
 
         hr = IAsyncReader_WaitForNext(reader, 1000, &ret_sample, &cookie);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
         ok(ret_sample == sample2, "Expected sample %p, got %p.\n", sample2, ret_sample);
-        ok(cookie == 456, "Got cookie %Iu.\n", cookie);
+        ok(cookie == 456, "Got cookie %lu.\n", cookie);
     }
     else
     {
-        ok(cookie == 456, "Got cookie %Iu.\n", cookie);
+        ok(cookie == 456, "Got cookie %lu.\n", cookie);
         ok(ret_sample == sample2, "Expected sample %p, got %p.\n", sample2, ret_sample);
 
         hr = IAsyncReader_WaitForNext(reader, 1000, &ret_sample, &cookie);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
         ok(ret_sample == sample, "Expected sample %p, got %p.\n", sample, ret_sample);
-        ok(cookie == 123, "Got cookie %Iu.\n", cookie);
+        ok(cookie == 123, "Got cookie %lu.\n", cookie);
     }
 
     for (i = 0; i < 512; i++)
@@ -916,9 +916,9 @@ static void test_request(IAsyncReader *reader, IMemAllocator *allocator)
     CloseHandle(thread);
 
     hr = IAsyncReader_WaitForNext(reader, 1000, &ret_sample, &cookie);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(ret_sample == sample, "Samples didn't match.\n");
-    ok(cookie == 123, "Got cookie %Iu.\n", cookie);
+    ok(cookie == 123, "Got cookie %lu.\n", cookie);
 
     IMediaSample_Release(sample);
     IMediaSample_Release(sample2);
@@ -930,7 +930,7 @@ static DWORD CALLBACK wait_thread(void *arg)
     IMediaSample *sample;
     DWORD_PTR cookie;
     HRESULT hr = IAsyncReader_WaitForNext(reader, 2000, &sample, &cookie);
-    ok(hr == VFW_E_WRONG_STATE, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_WRONG_STATE, "Got hr %#x.\n", hr);
     return 0;
 }
 
@@ -950,44 +950,44 @@ static void test_flush(IAsyncReader *reader, IMemAllocator *allocator)
     start_time = 0;
     end_time = 512 * (LONGLONG)10000000;
     hr = IMediaSample_SetTime(sample, &start_time, &end_time);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IAsyncReader_BeginFlush(reader);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IAsyncReader_SyncRead(reader, 0, 20, buffer);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     for (i = 0; i < 20; i++)
         ok(buffer[i] == i % 111, "Got wrong byte %02x at %u.\n", buffer[i], i);
 
     start_time = 0;
     end_time = 512 * (LONGLONG)10000000;
     hr = IMediaSample_SetTime(sample, &start_time, &end_time);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IAsyncReader_SyncReadAligned(reader, sample);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     for (i = 0; i < 512; i++)
         ok(data[i] == i % 111, "Got wrong byte %02x at %u.\n", data[i], i);
 
     hr = IAsyncReader_Request(reader, sample, 456);
-    ok(hr == VFW_E_WRONG_STATE, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_WRONG_STATE, "Got hr %#x.\n", hr);
 
     hr = IAsyncReader_EndFlush(reader);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IAsyncReader_WaitForNext(reader, 0, &ret_sample, &cookie);
-    ok(hr == VFW_E_TIMEOUT, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_TIMEOUT, "Got hr %#x.\n", hr);
 
     start_time = 0;
     end_time = 512 * (LONGLONG)10000000;
     hr = IAsyncReader_Request(reader, sample, 123);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IAsyncReader_WaitForNext(reader, 1000, &ret_sample, &cookie);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(ret_sample == sample, "Expected sample %p, got %p.\n", sample, ret_sample);
-    ok(cookie == 123, "Got cookie %Iu.\n", cookie);
+    ok(cookie == 123, "Got cookie %lu.\n", cookie);
 
     for (i = 0; i < 512; i++)
         ok(data[i] == i % 111, "Got wrong byte %02x at %u.\n", data[i], i);
@@ -996,12 +996,12 @@ static void test_flush(IAsyncReader *reader, IMemAllocator *allocator)
     ok(WaitForSingleObject(thread, 100) == WAIT_TIMEOUT, "Expected timeout.\n");
 
     hr = IAsyncReader_BeginFlush(reader);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(!WaitForSingleObject(thread, 1000), "Wait timed out.\n");
     CloseHandle(thread);
 
     hr = IAsyncReader_EndFlush(reader);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     IMediaSample_Release(sample);
 }
@@ -1027,7 +1027,7 @@ static void test_async_reader(void)
     GetTempPathW(ARRAY_SIZE(filename), filename);
     wcscat(filename, L"test.avi");
     file = CreateFileW(filename, GENERIC_READ | GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, 0);
-    ok(file != INVALID_HANDLE_VALUE, "Failed to create file, error %lu.\n", GetLastError());
+    ok(file != INVALID_HANDLE_VALUE, "Failed to create file, error %u.\n", GetLastError());
     for (i = 0; i < 600; i++)
     {
         BYTE b = i % 111;
@@ -1040,31 +1040,31 @@ static void test_async_reader(void)
     IBaseFilter_FindPin(filter, L"Output", &pin);
 
     hr = IPin_QueryInterface(pin, &IID_IAsyncReader, (void **)&reader);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IAsyncReader_Length(reader, &length, &available);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(length == 600, "Got length %s.\n", wine_dbgstr_longlong(length));
     ok(available == 600, "Got available length %s.\n", wine_dbgstr_longlong(available));
 
     memset(buffer, 0xcc, sizeof(buffer));
     hr = IAsyncReader_SyncRead(reader, 0, 10, buffer);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     for (i = 0; i < 10; i++)
         ok(buffer[i] == i % 111, "Got wrong byte %02x at %u.\n", buffer[i], i);
 
     hr = IAsyncReader_SyncRead(reader, 0, 10, buffer);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     for (i = 0; i < 10; i++)
         ok(buffer[i] == i % 111, "Got wrong byte %02x at %u.\n", buffer[i], i);
 
     hr = IAsyncReader_SyncRead(reader, 10, 10, buffer);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     for (i = 0; i < 10; i++)
         ok(buffer[i] == (10 + i) % 111, "Got wrong byte %02x at %u.\n", buffer[i], i);
 
     hr = IAsyncReader_SyncRead(reader, 590, 20, buffer);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     for (i = 0; i < 10; i++)
         ok(buffer[i] == (590 + i) % 111, "Got wrong byte %02x at %u.\n", buffer[i], i);
     for (; i < 20; i++)
@@ -1072,16 +1072,16 @@ static void test_async_reader(void)
 
     memset(buffer, 0xcc, sizeof(buffer));
     hr = IAsyncReader_SyncRead(reader, 600, 10, buffer);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     ok(buffer[0] == 0xcc, "Got wrong byte %02x.\n", buffer[0]);
 
     ret_props = req_props;
     hr = IAsyncReader_RequestAllocator(reader, NULL, &ret_props, &allocator);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(ret_props.cBuffers == 100, "Got %ld buffers.\n", ret_props.cBuffers);
-    ok(ret_props.cbBuffer == 1024, "Got size %ld.\n", ret_props.cbBuffer);
-    ok(ret_props.cbAlign == 512, "Got alignment %ld.\n", ret_props.cbAlign);
-    ok(ret_props.cbPrefix == 0, "Got prefix %ld.\n", ret_props.cbPrefix);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(ret_props.cBuffers == 100, "Got %d buffers.\n", ret_props.cBuffers);
+    ok(ret_props.cbBuffer == 1024, "Got size %d.\n", ret_props.cbBuffer);
+    ok(ret_props.cbAlign == 512, "Got alignment %d.\n", ret_props.cbAlign);
+    ok(ret_props.cbPrefix == 0, "Got prefix %d.\n", ret_props.cbPrefix);
 
     IMemAllocator_Commit(allocator);
 
@@ -1094,9 +1094,9 @@ static void test_async_reader(void)
     IPin_Release(pin);
     IFileSourceFilter_Release(filesource);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ret = DeleteFileW(filename);
-    ok(ret, "Failed to delete file, error %lu.\n", GetLastError());
+    ok(ret, "Failed to delete file, error %u.\n", GetLastError());
 }
 
 static void test_enum_media_types(void)
@@ -1115,84 +1115,84 @@ static void test_enum_media_types(void)
     IBaseFilter_FindPin(filter, L"Output", &pin);
 
     hr = IPin_EnumMediaTypes(pin, &enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enum1, 1, mts, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     CoTaskMemFree(mts[0]);
 
     hr = IEnumMediaTypes_Next(enum1, 1, mts, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     CoTaskMemFree(mts[0]);
 
     hr = IEnumMediaTypes_Next(enum1, 1, mts, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enum1, 1, mts, &count);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(count == 1, "Got count %lu.\n", count);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(count == 1, "Got count %u.\n", count);
     CoTaskMemFree(mts[0]);
 
     hr = IEnumMediaTypes_Next(enum1, 1, mts, &count);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(count == 1, "Got count %lu.\n", count);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(count == 1, "Got count %u.\n", count);
     CoTaskMemFree(mts[0]);
 
     hr = IEnumMediaTypes_Next(enum1, 1, mts, &count);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
-    ok(!count, "Got count %lu.\n", count);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    ok(!count, "Got count %u.\n", count);
 
     hr = IEnumMediaTypes_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enum1, 2, mts, &count);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(count == 2, "Got count %lu.\n", count);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(count == 2, "Got count %u.\n", count);
     CoTaskMemFree(mts[0]);
     CoTaskMemFree(mts[1]);
 
     hr = IEnumMediaTypes_Next(enum1, 2, mts, &count);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
-    ok(!count, "Got count %lu.\n", count);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    ok(!count, "Got count %u.\n", count);
 
     hr = IEnumMediaTypes_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enum1, 3, mts, &count);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
-    ok(count == 2, "Got count %lu.\n", count);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    ok(count == 2, "Got count %u.\n", count);
     CoTaskMemFree(mts[0]);
     CoTaskMemFree(mts[1]);
 
     hr = IEnumMediaTypes_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Clone(enum1, &enum2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Skip(enum1, 3);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Skip(enum1, 1);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Skip(enum1, 2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Skip(enum1, 1);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enum1, 1, mts, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enum2, 1, mts, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     CoTaskMemFree(mts[0]);
 
     IEnumMediaTypes_Release(enum1);
@@ -1200,9 +1200,9 @@ static void test_enum_media_types(void)
     IPin_Release(pin);
 
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ret = DeleteFileW(filename);
-    ok(ret, "Failed to delete file, error %lu.\n", GetLastError());
+    ok(ret, "Failed to delete file, error %u.\n", GetLastError());
 }
 
 struct testsink
@@ -1319,52 +1319,52 @@ static void test_connect_pin(void)
 
     peer = (IPin *)0xdeadbeef;
     hr = IPin_ConnectedTo(source, &peer);
-    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#x.\n", hr);
     ok(!peer, "Got peer %p.\n", peer);
 
     hr = IPin_ConnectionMediaType(source, &mt);
-    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#x.\n", hr);
 
     /* Test exact connection. */
 
     hr = IMediaControl_Pause(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IFilterGraph2_ConnectDirect(graph, source, &testsink.pin.pin.IPin_iface, &req_mt);
-    ok(hr == VFW_E_NOT_STOPPED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_STOPPED, "Got hr %#x.\n", hr);
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IFilterGraph2_ConnectDirect(graph, source, &testsink.pin.pin.IPin_iface, &req_mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IPin_ConnectedTo(source, &peer);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(peer == &testsink.pin.pin.IPin_iface, "Got peer %p.\n", peer);
     IPin_Release(peer);
 
     hr = IPin_ConnectionMediaType(source, &mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(compare_media_types(&mt, &req_mt), "Media types didn't match.\n");
     ok(compare_media_types(&testsink.pin.pin.mt, &req_mt), "Media types didn't match.\n");
 
     hr = IMediaControl_Pause(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IFilterGraph2_Disconnect(graph, source);
-    ok(hr == VFW_E_NOT_STOPPED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_STOPPED, "Got hr %#x.\n", hr);
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IFilterGraph2_Disconnect(graph, source);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IFilterGraph2_Disconnect(graph, source);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     ok(testsink.pin.pin.peer == source, "Got peer %p.\n", testsink.pin.pin.peer);
     IFilterGraph2_Disconnect(graph, &testsink.pin.pin.IPin_iface);
 
     req_mt.pbFormat = &my_format;
     req_mt.cbFormat = sizeof(my_format);
     hr = IFilterGraph2_ConnectDirect(graph, source, &testsink.pin.pin.IPin_iface, &req_mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(compare_media_types(&testsink.pin.pin.mt, &req_mt), "Media types didn't match.\n");
     IFilterGraph2_Disconnect(graph, source);
     IFilterGraph2_Disconnect(graph, &testsink.pin.pin.IPin_iface);
@@ -1373,31 +1373,31 @@ static void test_connect_pin(void)
 
     req_mt.majortype = MEDIATYPE_Video;
     hr = IFilterGraph2_ConnectDirect(graph, source, &testsink.pin.pin.IPin_iface, &req_mt);
-    ok(hr == VFW_E_TYPE_NOT_ACCEPTED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_TYPE_NOT_ACCEPTED, "Got hr %#x.\n", hr);
     req_mt.majortype = MEDIATYPE_Stream;
 
     req_mt.subtype = MEDIASUBTYPE_RGB8;
     hr = IFilterGraph2_ConnectDirect(graph, source, &testsink.pin.pin.IPin_iface, &req_mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(compare_media_types(&testsink.pin.pin.mt, &req_mt), "Media types didn't match.\n");
     IFilterGraph2_Disconnect(graph, source);
     IFilterGraph2_Disconnect(graph, &testsink.pin.pin.IPin_iface);
     req_mt.subtype = GUID_NULL;
     hr = IFilterGraph2_ConnectDirect(graph, source, &testsink.pin.pin.IPin_iface, &req_mt);
-    ok(hr == VFW_E_TYPE_NOT_ACCEPTED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_TYPE_NOT_ACCEPTED, "Got hr %#x.\n", hr);
     req_mt.subtype = MEDIASUBTYPE_Avi;
 
     /* Test connection with wildcards. */
 
     hr = IFilterGraph2_ConnectDirect(graph, source, &testsink.pin.pin.IPin_iface, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(compare_media_types(&testsink.pin.pin.mt, source_mt), "Media types didn't match.\n");
     IFilterGraph2_Disconnect(graph, source);
     IFilterGraph2_Disconnect(graph, &testsink.pin.pin.IPin_iface);
 
     req_mt.formattype = GUID_NULL;
     hr = IFilterGraph2_ConnectDirect(graph, source, &testsink.pin.pin.IPin_iface, &req_mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(compare_media_types(&testsink.pin.pin.mt, source_mt), "Media types didn't match.\n");
     IFilterGraph2_Disconnect(graph, source);
     IFilterGraph2_Disconnect(graph, &testsink.pin.pin.IPin_iface);
@@ -1405,22 +1405,22 @@ static void test_connect_pin(void)
     req_mt.formattype = FORMAT_None;
     req_mt.majortype = GUID_NULL;
     hr = IFilterGraph2_ConnectDirect(graph, source, &testsink.pin.pin.IPin_iface, &req_mt);
-    ok(hr == VFW_E_NO_ACCEPTABLE_TYPES, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NO_ACCEPTABLE_TYPES, "Got hr %#x.\n", hr);
 
     req_mt.formattype = GUID_NULL;
     hr = IFilterGraph2_ConnectDirect(graph, source, &testsink.pin.pin.IPin_iface, &req_mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(compare_media_types(&testsink.pin.pin.mt, source_mt), "Media types didn't match.\n");
     IFilterGraph2_Disconnect(graph, source);
     IFilterGraph2_Disconnect(graph, &testsink.pin.pin.IPin_iface);
 
     req_mt.subtype = MEDIASUBTYPE_RGB8;
     hr = IFilterGraph2_ConnectDirect(graph, source, &testsink.pin.pin.IPin_iface, &req_mt);
-    ok(hr == VFW_E_NO_ACCEPTABLE_TYPES, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NO_ACCEPTABLE_TYPES, "Got hr %#x.\n", hr);
 
     req_mt.subtype = GUID_NULL;
     hr = IFilterGraph2_ConnectDirect(graph, source, &testsink.pin.pin.IPin_iface, &req_mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(compare_media_types(&testsink.pin.pin.mt, source_mt), "Media types didn't match.\n");
     IFilterGraph2_Disconnect(graph, source);
     IFilterGraph2_Disconnect(graph, &testsink.pin.pin.IPin_iface);
@@ -1428,24 +1428,24 @@ static void test_connect_pin(void)
     req_mt.majortype = MEDIATYPE_Stream;
     req_mt.subtype = MEDIASUBTYPE_RGB8;
     hr = IFilterGraph2_ConnectDirect(graph, source, &testsink.pin.pin.IPin_iface, &req_mt);
-    ok(hr == VFW_E_NO_ACCEPTABLE_TYPES, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NO_ACCEPTABLE_TYPES, "Got hr %#x.\n", hr);
 
     req_mt.subtype = GUID_NULL;
     hr = IFilterGraph2_ConnectDirect(graph, source, &testsink.pin.pin.IPin_iface, &req_mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(compare_media_types(&testsink.pin.pin.mt, source_mt), "Media types didn't match.\n");
     IFilterGraph2_Disconnect(graph, source);
     IFilterGraph2_Disconnect(graph, &testsink.pin.pin.IPin_iface);
 
     req_mt.majortype = MEDIATYPE_Video;
     hr = IFilterGraph2_ConnectDirect(graph, source, &testsink.pin.pin.IPin_iface, &req_mt);
-    ok(hr == VFW_E_NO_ACCEPTABLE_TYPES, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NO_ACCEPTABLE_TYPES, "Got hr %#x.\n", hr);
 
     /* The second type (i.e. whose subtype is GUID_NULL) is not tried. This is
      * consistent with its being rejected by IPin::QueryAccept(). */
     testsink.reject_avi = TRUE;
     hr = IFilterGraph2_ConnectDirect(graph, source, &testsink.pin.pin.IPin_iface, NULL);
-    ok(hr == VFW_E_NO_ACCEPTABLE_TYPES, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NO_ACCEPTABLE_TYPES, "Got hr %#x.\n", hr);
 
     /* But any types we expose are tried. */
     testsink.mt = &mt;
@@ -1454,11 +1454,11 @@ static void test_connect_pin(void)
     mt.subtype = MEDIASUBTYPE_RGB8;
     mt.formattype = FORMAT_None;
     hr = IFilterGraph2_ConnectDirect(graph, source, &testsink.pin.pin.IPin_iface, NULL);
-    ok(hr == VFW_E_NO_ACCEPTABLE_TYPES, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NO_ACCEPTABLE_TYPES, "Got hr %#x.\n", hr);
 
     mt.majortype = MEDIATYPE_Stream;
     hr = IFilterGraph2_ConnectDirect(graph, source, &testsink.pin.pin.IPin_iface, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(compare_media_types(&testsink.pin.pin.mt, &mt), "Media types didn't match.\n");
     IFilterGraph2_Disconnect(graph, source);
     IFilterGraph2_Disconnect(graph, &testsink.pin.pin.IPin_iface);
@@ -1467,13 +1467,13 @@ static void test_connect_pin(void)
     IPin_Release(source);
     IMediaControl_Release(control);
     ref = IFilterGraph2_Release(graph);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ref = IBaseFilter_Release(&testsink.filter.IBaseFilter_iface);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ret = DeleteFileW(filename);
-    ok(ret, "Failed to delete file, error %lu.\n", GetLastError());
+    ok(ret, "Failed to delete file, error %u.\n", GetLastError());
 }
 
 START_TEST(filesource)
diff --git a/dlls/quartz/tests/filtergraph.c b/dlls/quartz/tests/filtergraph.c
index 0e9a398ad2c..a83bfde0806 100644
--- wine/dlls/quartz/tests/filtergraph.c
+++ wine/dlls/quartz/tests/filtergraph.c
@@ -42,10 +42,10 @@ static WCHAR *create_file(const WCHAR *name, const char *data, DWORD size)
     GetTempPathW(ARRAY_SIZE(pathW), pathW);
     wcscat(pathW, name);
     file = CreateFileW(pathW, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, 0);
-    ok(file != INVALID_HANDLE_VALUE, "Failed to create file %s, error %lu.\n",
+    ok(file != INVALID_HANDLE_VALUE, "Failed to create file %s, error %u.\n",
             wine_dbgstr_w(pathW), GetLastError());
     WriteFile(file, data, size, &written, NULL);
-    ok(written = size, "Failed to write file data, error %lu.\n", GetLastError());
+    ok(written = size, "Failed to write file data, error %u.\n", GetLastError());
     CloseHandle(file);
 
     return pathW;
@@ -57,7 +57,7 @@ static WCHAR *load_resource(const WCHAR *name)
     void *ptr;
 
     res = FindResourceW(NULL, name, (const WCHAR *)RT_RCDATA);
-    ok(!!res, "Failed to find resource %s, error %lu.\n", wine_dbgstr_w(name), GetLastError());
+    ok(!!res, "Failed to find resource %s, error %u.\n", wine_dbgstr_w(name), GetLastError());
     ptr = LockResource(LoadResource(GetModuleHandleA(NULL), res));
     return create_file(name, ptr, SizeofResource(GetModuleHandleA(NULL), res));
 }
@@ -67,7 +67,7 @@ static IFilterGraph2 *create_graph(void)
     IFilterGraph2 *ret;
     HRESULT hr;
     hr = CoCreateInstance(&CLSID_FilterGraph, NULL, CLSCTX_INPROC_SERVER, &IID_IFilterGraph2, (void **)&ret);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to create FilterGraph: %#x\n", hr);
     return ret;
 }
 
@@ -88,7 +88,7 @@ static void check_interface_(unsigned int line, void *iface_ptr, REFIID iid, BOO
     expected_hr = supported ? S_OK : E_NOINTERFACE;
 
     hr = IUnknown_QueryInterface(iface, iid, (void **)&unk);
-    ok_(__FILE__, line)(hr == expected_hr, "Got hr %#lx, expected %#lx.\n", hr, expected_hr);
+    ok_(__FILE__, line)(hr == expected_hr, "Got hr %#x, expected %#x.\n", hr, expected_hr);
     if (SUCCEEDED(hr))
         IUnknown_Release(unk);
 }
@@ -98,30 +98,23 @@ static void test_interfaces(void)
     IFilterGraph2 *graph = create_graph();
 
     check_interface(graph, &IID_IBasicAudio, TRUE);
-    check_interface(graph, &IID_IBasicVideo, TRUE);
     check_interface(graph, &IID_IBasicVideo2, TRUE);
-    check_interface(graph, &IID_IFilterGraph, TRUE);
     check_interface(graph, &IID_IFilterGraph2, TRUE);
     check_interface(graph, &IID_IFilterMapper, TRUE);
-    check_interface(graph, &IID_IFilterMapper2, TRUE);
     check_interface(graph, &IID_IFilterMapper3, TRUE);
-    check_interface(graph, &IID_IGraphBuilder, TRUE);
     check_interface(graph, &IID_IGraphConfig, TRUE);
     check_interface(graph, &IID_IGraphVersion, TRUE);
     check_interface(graph, &IID_IMediaControl, TRUE);
     check_interface(graph, &IID_IMediaEvent, TRUE);
-    check_interface(graph, &IID_IMediaEventEx, TRUE);
-    check_interface(graph, &IID_IMediaEventSink, TRUE);
     check_interface(graph, &IID_IMediaFilter, TRUE);
+    check_interface(graph, &IID_IMediaEventSink, TRUE);
     check_interface(graph, &IID_IMediaPosition, TRUE);
     check_interface(graph, &IID_IMediaSeeking, TRUE);
     check_interface(graph, &IID_IObjectWithSite, TRUE);
     check_interface(graph, &IID_IVideoFrameStep, TRUE);
     check_interface(graph, &IID_IVideoWindow, TRUE);
-    check_interface(graph, &IID_IUnknown, TRUE);
 
     check_interface(graph, &IID_IBaseFilter, FALSE);
-    check_interface(graph, &IID_IDispatch, FALSE);
 
     IFilterGraph2_Release(graph);
 }
@@ -134,202 +127,202 @@ static void test_basic_video(IFilterGraph2 *graph)
     HRESULT hr;
 
     hr = IFilterGraph2_QueryInterface(graph, &IID_IBasicVideo, (void **)&pbv);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr==S_OK, "Cannot get IBasicVideo interface returned: %x\n", hr);
 
     /* test get video size */
     hr = IBasicVideo_GetVideoSize(pbv, NULL, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr==E_POINTER, "IBasicVideo_GetVideoSize returned: %x\n", hr);
     hr = IBasicVideo_GetVideoSize(pbv, &video_width, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr==E_POINTER, "IBasicVideo_GetVideoSize returned: %x\n", hr);
     hr = IBasicVideo_GetVideoSize(pbv, NULL, &video_height);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr==E_POINTER, "IBasicVideo_GetVideoSize returned: %x\n", hr);
     hr = IBasicVideo_GetVideoSize(pbv, &video_width, &video_height);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr==S_OK, "Cannot get video size returned: %x\n", hr);
 
     /* test source position */
     hr = IBasicVideo_GetSourcePosition(pbv, NULL, NULL, NULL, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "IBasicVideo_GetSourcePosition returned: %x\n", hr);
     hr = IBasicVideo_GetSourcePosition(pbv, &left, &top, NULL, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "IBasicVideo_GetSourcePosition returned: %x\n", hr);
     hr = IBasicVideo_GetSourcePosition(pbv, NULL, NULL, &width, &height);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "IBasicVideo_GetSourcePosition returned: %x\n", hr);
     hr = IBasicVideo_GetSourcePosition(pbv, &left, &top, &width, &height);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(left == 0, "Got left %ld.\n", left);
-    ok(top == 0, "Got top %ld.\n", top);
-    ok(width == video_width, "Expected width %ld, got %ld.\n", video_width, width);
-    ok(height == video_height, "Expected height %ld, got %ld.\n", video_height, height);
+    ok(hr == S_OK, "Cannot get source position returned: %x\n", hr);
+    ok(left == 0, "expected 0, got %d\n", left);
+    ok(top == 0, "expected 0, got %d\n", top);
+    ok(width == video_width, "expected %d, got %d\n", video_width, width);
+    ok(height == video_height, "expected %d, got %d\n", video_height, height);
 
     hr = IBasicVideo_SetSourcePosition(pbv, 0, 0, 0, 0);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr==E_INVALIDARG, "IBasicVideo_SetSourcePosition returned: %x\n", hr);
     hr = IBasicVideo_SetSourcePosition(pbv, 0, 0, video_width*2, video_height*2);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr==E_INVALIDARG, "IBasicVideo_SetSourcePosition returned: %x\n", hr);
     hr = IBasicVideo_put_SourceTop(pbv, -1);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr==E_INVALIDARG, "IBasicVideo_put_SourceTop returned: %x\n", hr);
     hr = IBasicVideo_put_SourceTop(pbv, 0);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr==S_OK, "Cannot put source top returned: %x\n", hr);
     hr = IBasicVideo_put_SourceTop(pbv, 1);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr==E_INVALIDARG, "IBasicVideo_put_SourceTop returned: %x\n", hr);
 
     hr = IBasicVideo_SetSourcePosition(pbv, video_width, 0, video_width, video_height);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr==E_INVALIDARG, "IBasicVideo_SetSourcePosition returned: %x\n", hr);
     hr = IBasicVideo_SetSourcePosition(pbv, 0, video_height, video_width, video_height);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr==E_INVALIDARG, "IBasicVideo_SetSourcePosition returned: %x\n", hr);
     hr = IBasicVideo_SetSourcePosition(pbv, -1, 0, video_width, video_height);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr==E_INVALIDARG, "IBasicVideo_SetSourcePosition returned: %x\n", hr);
     hr = IBasicVideo_SetSourcePosition(pbv, 0, -1, video_width, video_height);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr==E_INVALIDARG, "IBasicVideo_SetSourcePosition returned: %x\n", hr);
     hr = IBasicVideo_SetSourcePosition(pbv, video_width/2, video_height/2, video_width, video_height);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr==E_INVALIDARG, "IBasicVideo_SetSourcePosition returned: %x\n", hr);
     hr = IBasicVideo_SetSourcePosition(pbv, video_width/2, video_height/2, video_width, video_height);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr==E_INVALIDARG, "IBasicVideo_SetSourcePosition returned: %x\n", hr);
 
     hr = IBasicVideo_SetSourcePosition(pbv, 0, 0, video_width, video_height+1);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr==E_INVALIDARG, "IBasicVideo_SetSourcePosition returned: %x\n", hr);
     hr = IBasicVideo_SetSourcePosition(pbv, 0, 0, video_width+1, video_height);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr==E_INVALIDARG, "IBasicVideo_SetSourcePosition returned: %x\n", hr);
 
     hr = IBasicVideo_SetSourcePosition(pbv, video_width/2, video_height/2, video_width/3+1, video_height/3+1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr==S_OK, "Cannot set source position returned: %x\n", hr);
 
     hr = IBasicVideo_get_SourceLeft(pbv, &left);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(left == video_width / 2, "Expected left %ld, got %ld.\n", video_width / 2, left);
+    ok(hr==S_OK, "Cannot get source left returned: %x\n", hr);
+    ok(left==video_width/2, "expected %d, got %d\n", video_width/2, left);
     hr = IBasicVideo_get_SourceTop(pbv, &top);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(top == video_height / 2, "Expected top %ld, got %ld.\n", video_height / 2, top);
+    ok(hr==S_OK, "Cannot get source top returned: %x\n", hr);
+    ok(top==video_height/2, "expected %d, got %d\n", video_height/2, top);
     hr = IBasicVideo_get_SourceWidth(pbv, &width);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(width == video_width / 3 + 1, "Expected width %ld, got %ld.\n", video_width / 3 + 1, width);
+    ok(hr==S_OK, "Cannot get source width returned: %x\n", hr);
+    ok(width==video_width/3+1, "expected %d, got %d\n", video_width/3+1, width);
     hr = IBasicVideo_get_SourceHeight(pbv, &height);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(height == video_height / 3 + 1, "Expected height %ld, got %ld.\n", video_height / 3 + 1, height);
+    ok(hr==S_OK, "Cannot get source height returned: %x\n", hr);
+    ok(height==video_height/3+1, "expected %d, got %d\n", video_height/3+1, height);
 
     hr = IBasicVideo_put_SourceLeft(pbv, video_width/3);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr==S_OK, "Cannot put source left returned: %x\n", hr);
     hr = IBasicVideo_GetSourcePosition(pbv, &left, &top, &width, &height);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(left == video_width / 3, "Expected left %ld, got %ld.\n", video_width / 3, left);
-    ok(width == video_width / 3 + 1, "Expected width %ld, got %ld.\n", video_width / 3 + 1, width);
+    ok(hr == S_OK, "Cannot get source position returned: %x\n", hr);
+    ok(left == video_width/3, "expected %d, got %d\n", video_width/3, left);
+    ok(width == video_width/3+1, "expected %d, got %d\n", video_width/3+1, width);
 
     hr = IBasicVideo_put_SourceTop(pbv, video_height/3);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr==S_OK, "Cannot put source top returned: %x\n", hr);
     hr = IBasicVideo_GetSourcePosition(pbv, &left, &top, &width, &height);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(top == video_height / 3, "Expected top %ld, got %ld.\n", video_height / 3, top);
-    ok(height == video_height / 3 + 1, "Expected height %ld, got %ld.\n", video_height / 3 + 1, height);
+    ok(hr == S_OK, "Cannot get source position returned: %x\n", hr);
+    ok(top == video_height/3, "expected %d, got %d\n", video_height/3, top);
+    ok(height == video_height/3+1, "expected %d, got %d\n", video_height/3+1, height);
 
     hr = IBasicVideo_put_SourceWidth(pbv, video_width/4+1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr==S_OK, "Cannot put source width returned: %x\n", hr);
     hr = IBasicVideo_GetSourcePosition(pbv, &left, &top, &width, &height);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(left == video_width / 3, "Expected left %ld, got %ld.\n", video_width / 3, left);
-    ok(width == video_width / 4 + 1, "Expected width %ld, got %ld.\n", video_width / 4 + 1, width);
+    ok(hr == S_OK, "Cannot get source position returned: %x\n", hr);
+    ok(left == video_width/3, "expected %d, got %d\n", video_width/3, left);
+    ok(width == video_width/4+1, "expected %d, got %d\n", video_width/4+1, width);
 
     hr = IBasicVideo_put_SourceHeight(pbv, video_height/4+1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr==S_OK, "Cannot put source height returned: %x\n", hr);
     hr = IBasicVideo_GetSourcePosition(pbv, &left, &top, &width, &height);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(top == video_height / 3, "Expected top %ld, got %ld.\n", video_height / 3, top);
-    ok(height == video_height / 4 + 1, "Expected height %ld, got %ld.\n", video_height / 4 + 1, height);
+    ok(hr == S_OK, "Cannot get source position returned: %x\n", hr);
+    ok(top == video_height/3, "expected %d, got %d\n", video_height/3, top);
+    ok(height == video_height/4+1, "expected %d, got %d\n", video_height/4+1, height);
 
     /* test destination rectangle */
     window_width = max(video_width, GetSystemMetrics(SM_CXMIN) - 2 * GetSystemMetrics(SM_CXFRAME));
 
     hr = IBasicVideo_GetDestinationPosition(pbv, NULL, NULL, NULL, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "IBasicVideo_GetDestinationPosition returned: %x\n", hr);
     hr = IBasicVideo_GetDestinationPosition(pbv, &left, &top, NULL, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "IBasicVideo_GetDestinationPosition returned: %x\n", hr);
     hr = IBasicVideo_GetDestinationPosition(pbv, NULL, NULL, &width, &height);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "IBasicVideo_GetDestinationPosition returned: %x\n", hr);
     hr = IBasicVideo_GetDestinationPosition(pbv, &left, &top, &width, &height);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(left == 0, "Got left %ld.\n", left);
-    ok(top == 0, "Got top %ld.\n", top);
-    ok(width == window_width, "Expected width %ld, got %ld.\n", window_width, width);
-    ok(height == video_height, "Expected height %ld, got %ld.\n", video_height, height);
+    ok(hr == S_OK, "Cannot get destination position returned: %x\n", hr);
+    ok(left == 0, "expected 0, got %d\n", left);
+    ok(top == 0, "expected 0, got %d\n", top);
+    ok(width == window_width, "expected %d, got %d\n", window_width, width);
+    ok(height == video_height, "expected %d, got %d\n", video_height, height);
 
     hr = IBasicVideo_SetDestinationPosition(pbv, 0, 0, 0, 0);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr==E_INVALIDARG, "IBasicVideo_SetDestinationPosition returned: %x\n", hr);
     hr = IBasicVideo_SetDestinationPosition(pbv, 0, 0, video_width*2, video_height*2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr==S_OK, "Cannot put destination position returned: %x\n", hr);
 
     hr = IBasicVideo_put_DestinationLeft(pbv, -1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr==S_OK, "Cannot put destination left returned: %x\n", hr);
     hr = IBasicVideo_put_DestinationLeft(pbv, 0);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr==S_OK, "Cannot put destination left returned: %x\n", hr);
     hr = IBasicVideo_put_DestinationLeft(pbv, 1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr==S_OK, "Cannot put destination left returned: %x\n", hr);
 
     hr = IBasicVideo_SetDestinationPosition(pbv, video_width, 0, video_width, video_height);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr==S_OK, "Cannot set destinaiton position returned: %x\n", hr);
     hr = IBasicVideo_SetDestinationPosition(pbv, 0, video_height, video_width, video_height);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr==S_OK, "Cannot set destinaiton position returned: %x\n", hr);
     hr = IBasicVideo_SetDestinationPosition(pbv, -1, 0, video_width, video_height);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr==S_OK, "Cannot set destination position returned: %x\n", hr);
     hr = IBasicVideo_SetDestinationPosition(pbv, 0, -1, video_width, video_height);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr==S_OK, "Cannot set destination position returned: %x\n", hr);
     hr = IBasicVideo_SetDestinationPosition(pbv, video_width/2, video_height/2, video_width, video_height);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr==S_OK, "Cannot set destination position returned: %x\n", hr);
     hr = IBasicVideo_SetDestinationPosition(pbv, video_width/2, video_height/2, video_width, video_height);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr==S_OK, "Cannot set destination position returned: %x\n", hr);
 
     hr = IBasicVideo_SetDestinationPosition(pbv, 0, 0, video_width, video_height+1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr==S_OK, "Cannot set destination position returned: %x\n", hr);
     hr = IBasicVideo_SetDestinationPosition(pbv, 0, 0, video_width+1, video_height);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr==S_OK, "Cannot set destination position returned: %x\n", hr);
 
     hr = IBasicVideo_SetDestinationPosition(pbv, video_width/2, video_height/2, video_width/3+1, video_height/3+1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr==S_OK, "Cannot set destination position returned: %x\n", hr);
 
     hr = IBasicVideo_get_DestinationLeft(pbv, &left);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(left == video_width / 2, "Expected left %ld, got %ld.\n", video_width / 2, left);
+    ok(hr==S_OK, "Cannot get destination left returned: %x\n", hr);
+    ok(left==video_width/2, "expected %d, got %d\n", video_width/2, left);
     hr = IBasicVideo_get_DestinationTop(pbv, &top);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(top == video_height / 2, "Expected top %ld, got %ld.\n", video_height / 2, top);
+    ok(hr==S_OK, "Cannot get destination top returned: %x\n", hr);
+    ok(top==video_height/2, "expected %d, got %d\n", video_height/2, top);
     hr = IBasicVideo_get_DestinationWidth(pbv, &width);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(width == video_width / 3 + 1, "Expected width %ld, got %ld.\n", video_width / 3 + 1, width);
+    ok(hr==S_OK, "Cannot get destination width returned: %x\n", hr);
+    ok(width==video_width/3+1, "expected %d, got %d\n", video_width/3+1, width);
     hr = IBasicVideo_get_DestinationHeight(pbv, &height);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(height == video_height / 3 + 1, "Expected height %ld, got %ld.\n", video_height / 3 + 1, height);
+    ok(hr==S_OK, "Cannot get destination height returned: %x\n", hr);
+    ok(height==video_height/3+1, "expected %d, got %d\n", video_height/3+1, height);
 
     hr = IBasicVideo_put_DestinationLeft(pbv, video_width/3);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr==S_OK, "Cannot put destination left returned: %x\n", hr);
     hr = IBasicVideo_GetDestinationPosition(pbv, &left, &top, &width, &height);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(left == video_width / 3, "Expected left %ld, got %ld.\n", video_width / 3, left);
-    ok(width == video_width / 3 + 1, "Expected width %ld, got %ld.\n", video_width / 3 + 1, width);
+    ok(hr == S_OK, "Cannot get source position returned: %x\n", hr);
+    ok(left == video_width/3, "expected %d, got %d\n", video_width/3, left);
+    ok(width == video_width/3+1, "expected %d, got %d\n", video_width/3+1, width);
 
     hr = IBasicVideo_put_DestinationTop(pbv, video_height/3);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr==S_OK, "Cannot put destination top returned: %x\n", hr);
     hr = IBasicVideo_GetDestinationPosition(pbv, &left, &top, &width, &height);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(top == video_height / 3, "Expected top %ld, got %ld.\n", video_height / 3, top);
-    ok(height == video_height / 3 + 1, "Expected height %ld, got %ld.\n", video_height / 3 + 1, height);
+    ok(hr == S_OK, "Cannot get source position returned: %x\n", hr);
+    ok(top == video_height/3, "expected %d, got %d\n", video_height/3, top);
+    ok(height == video_height/3+1, "expected %d, got %d\n", video_height/3+1, height);
 
     hr = IBasicVideo_put_DestinationWidth(pbv, video_width/4+1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr==S_OK, "Cannot put destination width returned: %x\n", hr);
     hr = IBasicVideo_GetDestinationPosition(pbv, &left, &top, &width, &height);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(left == video_width / 3, "Expected left %ld, got %ld.\n", video_width / 3, left);
-    ok(width == video_width / 4 + 1, "Expected width %ld, got %ld.\n", video_width / 4 + 1, width);
+    ok(hr == S_OK, "Cannot get source position returned: %x\n", hr);
+    ok(left == video_width/3, "expected %d, got %d\n", video_width/3, left);
+    ok(width == video_width/4+1, "expected %d, got %d\n", video_width/4+1, width);
 
     hr = IBasicVideo_put_DestinationHeight(pbv, video_height/4+1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr==S_OK, "Cannot put destination height returned: %x\n", hr);
     hr = IBasicVideo_GetDestinationPosition(pbv, &left, &top, &width, &height);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(top == video_height / 3, "Expected top %ld, got %ld.\n", video_height / 3, top);
-    ok(height == video_height / 4 + 1, "Expected height %ld, got %ld.\n", video_height / 4 + 1, height);
+    ok(hr == S_OK, "Cannot get source position returned: %x\n", hr);
+    ok(top == video_height/3, "expected %d, got %d\n", video_height/3, top);
+    ok(height == video_height/4+1, "expected %d, got %d\n", video_height/4+1, height);
 
     /* reset source rectangle */
     hr = IBasicVideo_SetDefaultSourcePosition(pbv);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr==S_OK, "IBasicVideo_SetDefaultSourcePosition returned: %x\n", hr);
 
     /* reset destination position */
     hr = IBasicVideo_SetDestinationPosition(pbv, 0, 0, video_width, video_height);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr==S_OK, "Cannot set destination position returned: %x\n", hr);
 
     IBasicVideo_Release(pbv);
 }
@@ -344,57 +337,57 @@ static void test_media_seeking(IFilterGraph2 *graph)
 
     IFilterGraph2_SetDefaultSyncSource(graph);
     hr = IFilterGraph2_QueryInterface(graph, &IID_IMediaSeeking, (void **)&seeking);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "QueryInterface(IMediaControl) failed: %08x\n", hr);
 
     hr = IFilterGraph2_QueryInterface(graph, &IID_IMediaFilter, (void **)&filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "QueryInterface(IMediaFilter) failed: %08x\n", hr);
 
     format = GUID_NULL;
     hr = IMediaSeeking_GetTimeFormat(seeking, &format);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "GetTimeFormat failed: %#x\n", hr);
     ok(IsEqualGUID(&format, &TIME_FORMAT_MEDIA_TIME), "got %s\n", wine_dbgstr_guid(&format));
 
     pos = 0xdeadbeef;
     hr = IMediaSeeking_ConvertTimeFormat(seeking, &pos, NULL, 0x123456789a, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "ConvertTimeFormat failed: %#x\n", hr);
     ok(pos == 0x123456789a, "got %s\n", wine_dbgstr_longlong(pos));
 
     pos = 0xdeadbeef;
     hr = IMediaSeeking_ConvertTimeFormat(seeking, &pos, &TIME_FORMAT_MEDIA_TIME, 0x123456789a, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "ConvertTimeFormat failed: %#x\n", hr);
     ok(pos == 0x123456789a, "got %s\n", wine_dbgstr_longlong(pos));
 
     pos = 0xdeadbeef;
     hr = IMediaSeeking_ConvertTimeFormat(seeking, &pos, NULL, 0x123456789a, &TIME_FORMAT_MEDIA_TIME);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "ConvertTimeFormat failed: %#x\n", hr);
     ok(pos == 0x123456789a, "got %s\n", wine_dbgstr_longlong(pos));
 
     hr = IMediaSeeking_GetCurrentPosition(seeking, &pos);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "GetCurrentPosition failed: %#x\n", hr);
     ok(pos == 0, "got %s\n", wine_dbgstr_longlong(pos));
 
     hr = IMediaSeeking_GetDuration(seeking, &duration);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "GetDuration failed: %#x\n", hr);
     ok(duration > 0, "got %s\n", wine_dbgstr_longlong(duration));
 
     hr = IMediaSeeking_GetStopPosition(seeking, &stop);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "GetCurrentPosition failed: %08x\n", hr);
     ok(stop == duration || stop == duration + 1, "expected %s, got %s\n",
         wine_dbgstr_longlong(duration), wine_dbgstr_longlong(stop));
 
     hr = IMediaSeeking_SetPositions(seeking, NULL, AM_SEEKING_ReturnTime, NULL, AM_SEEKING_NoPositioning);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "SetPositions failed: %#x\n", hr);
     hr = IMediaSeeking_SetPositions(seeking, NULL, AM_SEEKING_NoPositioning, NULL, AM_SEEKING_ReturnTime);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "SetPositions failed: %#x\n", hr);
 
     pos = 0;
     hr = IMediaSeeking_SetPositions(seeking, &pos, AM_SEEKING_AbsolutePositioning, NULL, AM_SEEKING_NoPositioning);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "SetPositions failed: %08x\n", hr);
 
     IMediaFilter_SetSyncSource(filter, NULL);
     pos = 0xdeadbeef;
     hr = IMediaSeeking_GetCurrentPosition(seeking, &pos);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "GetCurrentPosition failed: %08x\n", hr);
     ok(pos == 0, "Position != 0 (%s)\n", wine_dbgstr_longlong(pos));
     IFilterGraph2_SetDefaultSyncSource(graph);
 
@@ -409,47 +402,47 @@ static void test_state_change(IFilterGraph2 *graph)
     HRESULT hr;
 
     hr = IFilterGraph2_QueryInterface(graph, &IID_IMediaControl, (void **)&control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "QueryInterface(IMediaControl) failed: %x\n", hr);
 
     hr = IMediaControl_GetState(control, 1000, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(state == State_Stopped, "Got state %ld.\n", state);
+    ok(hr == S_OK, "GetState() failed: %x\n", hr);
+    ok(state == State_Stopped, "wrong state %d\n", state);
 
     hr = IMediaControl_Run(control);
-    ok(SUCCEEDED(hr), "Got hr %#lx.\n", hr);
+    ok(SUCCEEDED(hr), "Run() failed: %x\n", hr);
     hr = IMediaControl_GetState(control, INFINITE, &state);
-    ok(SUCCEEDED(hr), "Got hr %#lx.\n", hr);
-    ok(state == State_Running, "Got state %ld.\n", state);
+    ok(SUCCEEDED(hr), "GetState() failed: %x\n", hr);
+    ok(state == State_Running, "wrong state %d\n", state);
 
     hr = IMediaControl_Stop(control);
-    ok(SUCCEEDED(hr), "Got hr %#lx.\n", hr);
+    ok(SUCCEEDED(hr), "Stop() failed: %x\n", hr);
     hr = IMediaControl_GetState(control, 1000, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(state == State_Stopped, "Got state %ld.\n", state);
+    ok(hr == S_OK, "GetState() failed: %x\n", hr);
+    ok(state == State_Stopped, "wrong state %d\n", state);
 
     hr = IMediaControl_Pause(control);
-    ok(SUCCEEDED(hr), "Got hr %#lx.\n", hr);
+    ok(SUCCEEDED(hr), "Pause() failed: %x\n", hr);
     hr = IMediaControl_GetState(control, 1000, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(state == State_Paused, "Got state %ld.\n", state);
+    ok(hr == S_OK, "GetState() failed: %x\n", hr);
+    ok(state == State_Paused, "wrong state %d\n", state);
 
     hr = IMediaControl_Run(control);
-    ok(SUCCEEDED(hr), "Got hr %#lx.\n", hr);
+    ok(SUCCEEDED(hr), "Run() failed: %x\n", hr);
     hr = IMediaControl_GetState(control, 1000, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(state == State_Running, "Got state %ld.\n", state);
+    ok(hr == S_OK, "GetState() failed: %x\n", hr);
+    ok(state == State_Running, "wrong state %d\n", state);
 
     hr = IMediaControl_Pause(control);
-    ok(SUCCEEDED(hr), "Got hr %#lx.\n", hr);
+    ok(SUCCEEDED(hr), "Pause() failed: %x\n", hr);
     hr = IMediaControl_GetState(control, 1000, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(state == State_Paused, "Got state %ld.\n", state);
+    ok(hr == S_OK, "GetState() failed: %x\n", hr);
+    ok(state == State_Paused, "wrong state %d\n", state);
 
     hr = IMediaControl_Stop(control);
-    ok(SUCCEEDED(hr), "Got hr %#lx.\n", hr);
+    ok(SUCCEEDED(hr), "Stop() failed: %x\n", hr);
     hr = IMediaControl_GetState(control, 1000, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(state == State_Stopped, "Got state %ld.\n", state);
+    ok(hr == S_OK, "GetState() failed: %x\n", hr);
+    ok(state == State_Stopped, "wrong state %d\n", state);
 
     IMediaControl_Release(control);
 }
@@ -469,33 +462,33 @@ static void test_media_event(IFilterGraph2 *graph)
     LONG code;
 
     hr = IFilterGraph2_QueryInterface(graph, &IID_IMediaFilter, (void **)&filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "QueryInterface(IMediaFilter) failed: %#x\n", hr);
 
     hr = IFilterGraph2_QueryInterface(graph, &IID_IMediaControl, (void **)&control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "QueryInterface(IMediaControl) failed: %#x\n", hr);
 
     hr = IFilterGraph2_QueryInterface(graph, &IID_IMediaEvent, (void **)&media_event);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "QueryInterface(IMediaEvent) failed: %#x\n", hr);
 
     hr = IFilterGraph2_QueryInterface(graph, &IID_IMediaSeeking, (void **)&seeking);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "QueryInterface(IMediaEvent) failed: %#x\n", hr);
 
     hr = IMediaControl_Stop(control);
-    ok(SUCCEEDED(hr), "Got hr %#lx.\n", hr);
+    ok(SUCCEEDED(hr), "Stop() failed: %#x\n", hr);
     hr = IMediaControl_GetState(control, 1000, &state);
     ok(hr == S_OK, "GetState() timed out\n");
 
     hr = IMediaSeeking_GetDuration(seeking, &stop);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "GetDuration() failed: %#x\n", hr);
     current = 0;
     hr = IMediaSeeking_SetPositions(seeking, &current, AM_SEEKING_AbsolutePositioning, &stop, AM_SEEKING_AbsolutePositioning);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "SetPositions() failed: %#x\n", hr);
 
     hr = IMediaFilter_SetSyncSource(filter, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "SetSyncSource() failed: %#x\n", hr);
 
     hr = IMediaEvent_GetEventHandle(media_event, (OAEVENT *)&event);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "GetEventHandle() failed: %#x\n", hr);
 
     /* flush existing events */
     while ((hr = IMediaEvent_GetEvent(media_event, &code, &lparam1, &lparam2, 0)) == S_OK);
@@ -503,7 +496,7 @@ static void test_media_event(IFilterGraph2 *graph)
     ok(WaitForSingleObject(event, 0) == WAIT_TIMEOUT, "event should not be signaled\n");
 
     hr = IMediaControl_Run(control);
-    ok(SUCCEEDED(hr), "Got hr %#lx.\n", hr);
+    ok(SUCCEEDED(hr), "Run() failed: %#x\n", hr);
 
     while (!got_eos)
     {
@@ -522,16 +515,16 @@ static void test_media_event(IFilterGraph2 *graph)
     ok(got_eos, "didn't get EOS\n");
 
     hr = IMediaSeeking_GetCurrentPosition(seeking, &current);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "GetCurrentPosition() failed: %#x\n", hr);
     ok(current == stop, "expected %s, got %s\n", wine_dbgstr_longlong(stop), wine_dbgstr_longlong(current));
 
     hr = IMediaControl_Stop(control);
-    ok(SUCCEEDED(hr), "Got hr %#lx.\n", hr);
+    ok(SUCCEEDED(hr), "Run() failed: %#x\n", hr);
     hr = IMediaControl_GetState(control, 1000, &state);
     ok(hr == S_OK, "GetState() timed out\n");
 
     hr = IFilterGraph2_SetDefaultSyncSource(graph);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "SetDefaultSinkSource() failed: %#x\n", hr);
 
     IMediaSeeking_Release(seeking);
     IMediaEvent_Release(media_event);
@@ -564,7 +557,7 @@ static HRESULT test_graph_builder_connect_file(WCHAR *filename, BOOL audio, BOOL
                 &IID_IBaseFilter, (void **)&renderer);
     if (hr == VFW_E_NO_AUDIO_HARDWARE)
         return VFW_E_CANNOT_CONNECT;
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     graph = create_graph();
 
@@ -573,13 +566,13 @@ static HRESULT test_graph_builder_connect_file(WCHAR *filename, BOOL audio, BOOL
     IEnumPins_Release(enumpins);
 
     hr = IFilterGraph2_AddSourceFilter(graph, filename, NULL, &source_filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "AddSourceFilter failed: %#x\n", hr);
 
     hr = IFilterGraph2_AddFilter(graph, renderer, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "AddFilter failed: %#x\n", hr);
 
     hr = IBaseFilter_FindPin(source_filter, L"Output", &pin_out);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "FindPin failed: %#x\n", hr);
     hr = IFilterGraph2_Connect(graph, pin_out, pin_in);
 
     if (SUCCEEDED(hr))
@@ -620,32 +613,32 @@ static void test_render_run(const WCHAR *file, BOOL audio, BOOL video)
         skip("%s: codec not supported; skipping test\n", wine_dbgstr_w(file));
 
         refs = IFilterGraph2_Release(graph);
-        ok(!refs, "Got outsanding refcount %ld.\n", refs);
+        ok(!refs, "Graph has %u references\n", refs);
 
         hr = test_graph_builder_connect_file(filename, audio, video);
-        ok(hr == VFW_E_CANNOT_CONNECT, "Got hr %#lx.\n", hr);
+        ok(hr == VFW_E_CANNOT_CONNECT, "got %#x\n", hr);
     }
     else
     {
         if (audio)
-            ok(hr == S_OK || hr == VFW_S_AUDIO_NOT_RENDERED, "Got hr %#lx.\n", hr);
+            ok(hr == S_OK || hr == VFW_S_AUDIO_NOT_RENDERED, "Got hr %#x.\n", hr);
         else
-            ok(hr == S_OK, "Got hr %#lx.\n", hr);
+            ok(hr == S_OK, "Got hr %#x.\n", hr);
         rungraph(graph, video);
 
         refs = IFilterGraph2_Release(graph);
-        ok(!refs, "Got outsanding refcount %ld.\n", refs);
+        ok(!refs, "Graph has %u references\n", refs);
 
         hr = test_graph_builder_connect_file(filename, audio, video);
         if (audio && video)
-            todo_wine ok(hr == VFW_S_PARTIAL_RENDER, "Got hr %#lx.\n", hr);
+            todo_wine ok(hr == VFW_S_PARTIAL_RENDER, "Got hr %#x.\n", hr);
         else
-            ok(hr == S_OK, "Got hr %#lx.\n", hr);
+            ok(hr == S_OK, "Got hr %#x.\n", hr);
     }
 
     /* check reference leaks */
     h = CreateFileW(filename, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
-    ok(h != INVALID_HANDLE_VALUE, "CreateFile failed: err=%ld\n", GetLastError());
+    ok(h != INVALID_HANDLE_VALUE, "CreateFile failed: err=%d\n", GetLastError());
     CloseHandle(h);
 
     DeleteFileW(filename);
@@ -665,74 +658,74 @@ static void test_enum_filters(void)
             &IID_IBaseFilter, (void **)&filter2);
 
     hr = IFilterGraph2_EnumFilters(graph, &enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumFilters_Next(enum1, 1, filters, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumFilters_Skip(enum1, 0);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
 
     hr = IEnumFilters_Skip(enum1, 1);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
 
     IFilterGraph2_AddFilter(graph, filter1, NULL);
     IFilterGraph2_AddFilter(graph, filter2, NULL);
 
     hr = IEnumFilters_Next(enum1, 1, filters, NULL);
-    ok(hr == VFW_E_ENUM_OUT_OF_SYNC, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_ENUM_OUT_OF_SYNC, "Got hr %#x.\n", hr);
 
     hr = IEnumFilters_Skip(enum1, 1);
-    ok(hr == VFW_E_ENUM_OUT_OF_SYNC, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_ENUM_OUT_OF_SYNC, "Got hr %#x.\n", hr);
 
     hr = IEnumFilters_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumFilters_Skip(enum1, 0);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumFilters_Skip(enum1, 1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumFilters_Skip(enum1, 2);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumFilters_Skip(enum1, 1);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
 
     hr = IEnumFilters_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumFilters_Skip(enum1, 2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumFilters_Skip(enum1, 1);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
 
     hr = IEnumFilters_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumFilters_Next(enum1, 1, filters, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(filters[0] == filter2, "Got filter %p.\n", filters[0]);
     IBaseFilter_Release(filters[0]);
 
     hr = IEnumFilters_Next(enum1, 1, filters, &count);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(count == 1, "Got count %lu.\n", count);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(count == 1, "Got count %u.\n", count);
     ok(filters[0] == filter1, "Got filter %p.\n", filters[0]);
     IBaseFilter_Release(filters[0]);
 
     hr = IEnumFilters_Next(enum1, 1, filters, &count);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
-    ok(count == 0, "Got count %lu.\n", count);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    ok(count == 0, "Got count %u.\n", count);
 
     hr = IEnumFilters_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumFilters_Next(enum1, 2, filters, &count);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(count == 2, "Got count %lu.\n", count);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(count == 2, "Got count %u.\n", count);
     ok(filters[0] == filter2, "Got filter %p.\n", filters[0]);
     ok(filters[1] == filter1, "Got filter %p.\n", filters[1]);
     IBaseFilter_Release(filters[0]);
@@ -742,41 +735,41 @@ static void test_enum_filters(void)
     IFilterGraph2_AddFilter(graph, filter1, NULL);
 
     hr = IEnumFilters_Next(enum1, 2, filters, &count);
-    ok(hr == VFW_E_ENUM_OUT_OF_SYNC, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_ENUM_OUT_OF_SYNC, "Got hr %#x.\n", hr);
 
     hr = IEnumFilters_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumFilters_Next(enum1, 2, filters, &count);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(count == 2, "Got count %lu.\n", count);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(count == 2, "Got count %u.\n", count);
     ok(filters[0] == filter1, "Got filter %p.\n", filters[0]);
     ok(filters[1] == filter2, "Got filter %p.\n", filters[1]);
     IBaseFilter_Release(filters[0]);
     IBaseFilter_Release(filters[1]);
 
     hr = IEnumFilters_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumFilters_Clone(enum1, &enum2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumFilters_Skip(enum2, 1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumFilters_Next(enum2, 2, filters, &count);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
-    ok(count == 1, "Got count %lu.\n", count);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    ok(count == 1, "Got count %u.\n", count);
     ok(filters[0] == filter2, "Got filter %p.\n", filters[0]);
     IBaseFilter_Release(filters[0]);
 
     hr = IEnumFilters_Skip(enum1, 3);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     IEnumFilters_Release(enum2);
     IEnumFilters_Release(enum1);
     ref = IFilterGraph2_Release(graph);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 static DWORD WINAPI call_RenderFile_multithread(LPVOID lParam)
@@ -786,7 +779,7 @@ static DWORD WINAPI call_RenderFile_multithread(LPVOID lParam)
     HRESULT hr;
 
     hr = IFilterGraph2_RenderFile(graph, filename, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     rungraph(graph, TRUE);
 
@@ -1434,7 +1427,7 @@ static HRESULT WINAPI testfilter_Run(IBaseFilter *iface, REFERENCE_TIME start)
 static HRESULT WINAPI testfilter_GetState(IBaseFilter *iface, DWORD timeout, FILTER_STATE *state)
 {
     struct testfilter *filter = impl_from_IBaseFilter(iface);
-    if (winetest_debug > 1) trace("%p->GetState(%lu)\n", filter, timeout);
+    if (winetest_debug > 1) trace("%p->GetState(%u)\n", filter, timeout);
 
     *state = filter->state;
     return filter->GetState_hr;
@@ -1679,7 +1672,7 @@ static HRESULT WINAPI testseek_SetPositions(IMediaSeeking *iface, LONGLONG *curr
     DWORD current_flags, LONGLONG *stop, DWORD stop_flags )
 {
     struct testfilter *filter = impl_from_IMediaSeeking(iface);
-    if (winetest_debug > 1) trace("%p->SetPositions(%s, %#lx, %s, %#lx)\n",
+    if (winetest_debug > 1) trace("%p->SetPositions(%s, %#x, %s, %#x)\n",
             iface, wine_dbgstr_longlong(*current), current_flags, wine_dbgstr_longlong(*stop), stop_flags);
     ok(filter->state != State_Running, "Filter should be paused or stopped while seeking.\n");
     filter->seek_current = *current;
@@ -2093,7 +2086,7 @@ static void test_graph_builder_render(void)
     IFilterGraph2_AddFilter(graph, &sink2.IBaseFilter_iface, NULL);
 
     hr = IFilterGraph2_Render(graph, &source_pin.IPin_iface);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(source_pin.peer == &sink2_pin.IPin_iface, "Got peer %p.\n", source_pin.peer);
     IFilterGraph2_Disconnect(graph, source_pin.peer);
     IFilterGraph2_Disconnect(graph, &source_pin.IPin_iface);
@@ -2102,7 +2095,7 @@ static void test_graph_builder_render(void)
     IFilterGraph2_AddFilter(graph, &sink1.IBaseFilter_iface, NULL);
 
     hr = IFilterGraph2_Render(graph, &source_pin.IPin_iface);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(source_pin.peer == &sink1_pin.IPin_iface, "Got peer %p.\n", source_pin.peer);
 
     IFilterGraph2_Disconnect(graph, &source_pin.IPin_iface);
@@ -2113,7 +2106,7 @@ static void test_graph_builder_render(void)
     IFilterGraph2_AddFilter(graph, &parser.IBaseFilter_iface, NULL);
 
     hr = IFilterGraph2_Render(graph, &source_pin.IPin_iface);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(source_pin.peer == &parser_pins[0].IPin_iface, "Got peer %p.\n", source_pin.peer);
     ok(parser_pins[1].peer == &sink1_pin.IPin_iface, "Got peer %p.\n", parser_pins[1].peer);
     IFilterGraph2_Disconnect(graph, source_pin.peer);
@@ -2125,7 +2118,7 @@ static void test_graph_builder_render(void)
     IFilterGraph2_AddFilter(graph, &sink1.IBaseFilter_iface, NULL);
 
     hr = IFilterGraph2_Render(graph, &source_pin.IPin_iface);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(source_pin.peer == &sink1_pin.IPin_iface, "Got peer %p.\n", source_pin.peer);
     IFilterGraph2_Disconnect(graph, source_pin.peer);
     IFilterGraph2_Disconnect(graph, &source_pin.IPin_iface);
@@ -2138,7 +2131,7 @@ static void test_graph_builder_render(void)
 
     parser_pins[1].name[0] = '~';
     hr = IFilterGraph2_Render(graph, &source_pin.IPin_iface);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(source_pin.peer == &parser_pins[0].IPin_iface, "Got peer %p.\n", source_pin.peer);
     ok(!parser_pins[1].peer, "Got peer %p.\n", parser_pins[1].peer);
     ok(!sink1_pin.peer, "Got peer %p.\n", sink1_pin.peer);
@@ -2148,14 +2141,14 @@ static void test_graph_builder_render(void)
     parser_pins[1].name[0] = 0;
     parser_pins[1].id[0] = '~';
     hr = IFilterGraph2_Render(graph, &source_pin.IPin_iface);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(source_pin.peer == &parser_pins[0].IPin_iface, "Got peer %p.\n", source_pin.peer);
     ok(parser_pins[1].peer == &sink1_pin.IPin_iface, "Got peer %p.\n", parser_pins[1].peer);
     IFilterGraph2_Disconnect(graph, source_pin.peer);
     IFilterGraph2_Disconnect(graph, &source_pin.IPin_iface);
 
     ref = IFilterGraph2_Release(graph);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 
     /* Test enumeration of filters from the registry. */
 
@@ -2183,7 +2176,7 @@ static void test_graph_builder_render(void)
         skip("Not enough permission to register filters.\n");
         goto out;
     }
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     graph = create_graph();
     IFilterGraph2_AddFilter(graph, &source.IBaseFilter_iface, NULL);
@@ -2192,12 +2185,12 @@ static void test_graph_builder_render(void)
     IFilterMapper2_RegisterFilter(mapper, &sink2_clsid, L"test", NULL, NULL, NULL, &regfilter);
 
     hr = IFilterGraph2_Render(graph, &source_pin.IPin_iface);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(source_pin.peer == &sink2_pin.IPin_iface || source_pin.peer == &sink1_pin.IPin_iface,
             "Got peer %p.\n", source_pin.peer);
 
     ref = IFilterGraph2_Release(graph);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 
     /* Preference is given to filters already in the graph. */
 
@@ -2206,11 +2199,11 @@ static void test_graph_builder_render(void)
     IFilterGraph2_AddFilter(graph, &sink2.IBaseFilter_iface, NULL);
 
     hr = IFilterGraph2_Render(graph, &source_pin.IPin_iface);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(source_pin.peer == &sink2_pin.IPin_iface, "Got peer %p.\n", source_pin.peer);
 
     ref = IFilterGraph2_Release(graph);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 
     /* No preference is given to renderer filters. */
 
@@ -2225,12 +2218,12 @@ static void test_graph_builder_render(void)
     IFilterMapper2_RegisterFilter(mapper, &sink2_clsid, L"test", NULL, NULL, NULL, &regfilter);
 
     hr = IFilterGraph2_Render(graph, &source_pin.IPin_iface);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(source_pin.peer == &sink2_pin.IPin_iface || source_pin.peer == &sink1_pin.IPin_iface,
             "Got peer %p.\n", source_pin.peer);
 
     ref = IFilterGraph2_Release(graph);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 
     /* Preference is given to filters with higher merit. */
 
@@ -2246,11 +2239,11 @@ static void test_graph_builder_render(void)
     IFilterMapper2_RegisterFilter(mapper, &sink2_clsid, L"test", NULL, NULL, NULL, &regfilter);
 
     hr = IFilterGraph2_Render(graph, &source_pin.IPin_iface);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(source_pin.peer == &sink2_pin.IPin_iface, "Got peer %p.\n", source_pin.peer);
 
     ref = IFilterGraph2_Release(graph);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 
     graph = create_graph();
     IFilterGraph2_AddFilter(graph, &source.IBaseFilter_iface, NULL);
@@ -2264,11 +2257,11 @@ static void test_graph_builder_render(void)
     IFilterMapper2_RegisterFilter(mapper, &sink2_clsid, L"test", NULL, NULL, NULL, &regfilter);
 
     hr = IFilterGraph2_Render(graph, &source_pin.IPin_iface);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(source_pin.peer == &sink1_pin.IPin_iface, "Got peer %p.\n", source_pin.peer);
 
     ref = IFilterGraph2_Release(graph);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 
     /* Test AM_RENDEREX_RENDERTOEXISTINGRENDERERS. */
 
@@ -2276,16 +2269,16 @@ static void test_graph_builder_render(void)
     IFilterGraph2_AddFilter(graph, &source.IBaseFilter_iface, NULL);
 
     hr = IFilterGraph2_RenderEx(graph, &source_pin.IPin_iface, AM_RENDEREX_RENDERTOEXISTINGRENDERERS, NULL);
-    ok(hr == VFW_E_CANNOT_RENDER, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_CANNOT_RENDER, "Got hr %#x.\n", hr);
 
     IFilterGraph2_AddFilter(graph, &sink1.IBaseFilter_iface, NULL);
 
     hr = IFilterGraph2_RenderEx(graph, &source_pin.IPin_iface, AM_RENDEREX_RENDERTOEXISTINGRENDERERS, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(source_pin.peer == &sink1_pin.IPin_iface, "Got peer %p.\n", source_pin.peer);
 
     ref = IFilterGraph2_Release(graph);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 
     IFilterMapper2_UnregisterFilter(mapper, NULL, NULL, &sink1_clsid);
     IFilterMapper2_UnregisterFilter(mapper, NULL, NULL, &sink2_clsid);
@@ -2294,15 +2287,15 @@ out:
     CoRevokeClassObject(cookie1);
     CoRevokeClassObject(cookie2);
     IFilterMapper2_Release(mapper);
-    ok(source.ref == 1, "Got outstanding refcount %ld.\n", source.ref);
-    ok(source_pin.ref == 1, "Got outstanding refcount %ld.\n", source_pin.ref);
-    ok(sink1.ref == 1, "Got outstanding refcount %ld.\n", sink1.ref);
-    ok(sink1_pin.ref == 1, "Got outstanding refcount %ld.\n", sink1_pin.ref);
-    ok(sink2.ref == 1, "Got outstanding refcount %ld.\n", sink2.ref);
-    ok(sink2_pin.ref == 1, "Got outstanding refcount %ld.\n", sink2_pin.ref);
-    ok(parser.ref == 1, "Got outstanding refcount %ld.\n", parser.ref);
-    ok(parser_pins[0].ref == 1, "Got outstanding refcount %ld.\n", parser_pins[0].ref);
-    ok(parser_pins[1].ref == 1, "Got outstanding refcount %ld.\n", parser_pins[1].ref);
+    ok(source.ref == 1, "Got outstanding refcount %d.\n", source.ref);
+    ok(source_pin.ref == 1, "Got outstanding refcount %d.\n", source_pin.ref);
+    ok(sink1.ref == 1, "Got outstanding refcount %d.\n", sink1.ref);
+    ok(sink1_pin.ref == 1, "Got outstanding refcount %d.\n", sink1_pin.ref);
+    ok(sink2.ref == 1, "Got outstanding refcount %d.\n", sink2.ref);
+    ok(sink2_pin.ref == 1, "Got outstanding refcount %d.\n", sink2_pin.ref);
+    ok(parser.ref == 1, "Got outstanding refcount %d.\n", parser.ref);
+    ok(parser_pins[0].ref == 1, "Got outstanding refcount %d.\n", parser_pins[0].ref);
+    ok(parser_pins[1].ref == 1, "Got outstanding refcount %d.\n", parser_pins[1].ref);
 }
 
 static void test_graph_builder_connect(void)
@@ -2357,7 +2350,7 @@ static void test_graph_builder_connect(void)
     IFilterGraph2_AddFilter(graph, &sink.IBaseFilter_iface, NULL);
 
     hr = IFilterGraph2_Connect(graph, &source_pin.IPin_iface, &sink_pin.IPin_iface);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(source_pin.peer == &sink_pin.IPin_iface, "Got peer %p.\n", source_pin.peer);
     IFilterGraph2_Disconnect(graph, source_pin.peer);
     IFilterGraph2_Disconnect(graph, &source_pin.IPin_iface);
@@ -2366,7 +2359,7 @@ static void test_graph_builder_connect(void)
             ++source_pin.Connect_hr)
     {
         hr = IFilterGraph2_Connect(graph, &source_pin.IPin_iface, &sink_pin.IPin_iface);
-        ok(hr == source_pin.Connect_hr, "Got hr %#lx for Connect() hr %#lx.\n",
+        ok(hr == source_pin.Connect_hr, "Got hr %#x for Connect() hr %#x.\n",
                 hr, source_pin.Connect_hr);
         ok(source_pin.peer == &sink_pin.IPin_iface, "Got peer %p.\n", source_pin.peer);
         IFilterGraph2_Disconnect(graph, source_pin.peer);
@@ -2376,7 +2369,7 @@ static void test_graph_builder_connect(void)
 
     sink_pin.accept_mt = &sink_type;
     hr = IFilterGraph2_Connect(graph, &source_pin.IPin_iface, &sink_pin.IPin_iface);
-    ok(hr == VFW_E_CANNOT_CONNECT, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_CANNOT_CONNECT, "Got hr %#x.\n", hr);
     ok(!source_pin.peer, "Got peer %p.\n", source_pin.peer);
 
     for (source_pin.Connect_hr = 0x80040200; source_pin.Connect_hr <= 0x800402ff;
@@ -2385,10 +2378,10 @@ static void test_graph_builder_connect(void)
         hr = IFilterGraph2_Connect(graph, &source_pin.IPin_iface, &sink_pin.IPin_iface);
         if (source_pin.Connect_hr == VFW_E_NOT_CONNECTED
                 || source_pin.Connect_hr == VFW_E_NO_AUDIO_HARDWARE)
-            ok(hr == source_pin.Connect_hr, "Got hr %#lx for Connect() hr %#lx.\n",
+            ok(hr == source_pin.Connect_hr, "Got hr %#x for Connect() hr %#x.\n",
                     hr, source_pin.Connect_hr);
         else
-            ok(hr == VFW_E_CANNOT_CONNECT, "Got hr %#lx for Connect() hr %#lx.\n",
+            ok(hr == VFW_E_CANNOT_CONNECT, "Got hr %#x for Connect() hr %#x.\n",
                     hr, source_pin.Connect_hr);
         ok(!source_pin.peer, "Got peer %p.\n", source_pin.peer);
         ok(!sink_pin.peer, "Got peer %p.\n", sink_pin.peer);
@@ -2399,7 +2392,7 @@ static void test_graph_builder_connect(void)
             ++source_pin.EnumMediaTypes_hr)
     {
         hr = IFilterGraph2_Connect(graph, &source_pin.IPin_iface, &sink_pin.IPin_iface);
-        ok(hr == source_pin.EnumMediaTypes_hr, "Got hr %#lx for EnumMediaTypes() hr %#lx.\n",
+        ok(hr == source_pin.EnumMediaTypes_hr, "Got hr %#x for EnumMediaTypes() hr %#x.\n",
                 hr, source_pin.EnumMediaTypes_hr);
         ok(!source_pin.peer, "Got peer %p.\n", source_pin.peer);
         ok(!sink_pin.peer, "Got peer %p.\n", sink_pin.peer);
@@ -2414,14 +2407,14 @@ static void test_graph_builder_connect(void)
 
     sink_pin.accept_mt = NULL;
     hr = IFilterGraph2_Connect(graph, &source_pin.IPin_iface, &sink_pin.IPin_iface);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(source_pin.peer == &sink_pin.IPin_iface, "Got peer %p.\n", source_pin.peer);
     IFilterGraph2_Disconnect(graph, source_pin.peer);
     IFilterGraph2_Disconnect(graph, &source_pin.IPin_iface);
 
     sink_pin.accept_mt = &sink_type;
     hr = IFilterGraph2_Connect(graph, &source_pin.IPin_iface, &sink_pin.IPin_iface);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(source_pin.peer == &parser2_pins[1].IPin_iface, "Got peer %p.\n", source_pin.peer);
     ok(sink_pin.peer == &parser2_pins[0].IPin_iface, "Got peer %p.\n", sink_pin.peer);
     IFilterGraph2_Disconnect(graph, source_pin.peer);
@@ -2433,7 +2426,7 @@ static void test_graph_builder_connect(void)
             ++source_pin.Connect_hr)
     {
         hr = IFilterGraph2_Connect(graph, &source_pin.IPin_iface, &sink_pin.IPin_iface);
-        ok(hr == S_OK, "Got hr %#lx for Connect() hr %#lx.\n", hr, source_pin.Connect_hr);
+        ok(hr == S_OK, "Got hr %#x for Connect() hr %#x.\n", hr, source_pin.Connect_hr);
         ok(source_pin.peer == &parser2_pins[1].IPin_iface, "Got peer %p.\n", source_pin.peer);
         ok(sink_pin.peer == &parser2_pins[0].IPin_iface, "Got peer %p.\n", sink_pin.peer);
         IFilterGraph2_Disconnect(graph, source_pin.peer);
@@ -2447,7 +2440,7 @@ static void test_graph_builder_connect(void)
     IFilterGraph2_AddFilter(graph, &parser1.IBaseFilter_iface, NULL);
 
     hr = IFilterGraph2_Connect(graph, &source_pin.IPin_iface, &sink_pin.IPin_iface);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(source_pin.peer == &parser1_pins[0].IPin_iface, "Got peer %p.\n", source_pin.peer);
     ok(sink_pin.peer == &parser1_pins[1].IPin_iface, "Got peer %p.\n", sink_pin.peer);
     IFilterGraph2_Disconnect(graph, source_pin.peer);
@@ -2459,7 +2452,7 @@ static void test_graph_builder_connect(void)
 
     IFilterGraph2_AddFilter(graph, &parser3.IBaseFilter_iface, NULL);
     hr = IFilterGraph2_Connect(graph, &source_pin.IPin_iface, &sink_pin.IPin_iface);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(source_pin.peer == &parser3_pins[0].IPin_iface, "Got peer %p.\n", source_pin.peer);
     ok(parser3_pins[1].peer == &parser1_pins[0].IPin_iface, "Got peer %p.\n", parser3_pins[1].peer);
     ok(sink_pin.peer == &parser1_pins[1].IPin_iface, "Got peer %p.\n", sink_pin.peer);
@@ -2481,7 +2474,8 @@ static void test_graph_builder_connect(void)
     IFilterGraph2_AddFilter(graph, &sink2.IBaseFilter_iface, NULL);
 
     hr = IFilterGraph2_Connect(graph, &source_pin.IPin_iface, &sink_pin.IPin_iface);
-    todo_wine ok(hr == VFW_S_PARTIAL_RENDER, "Got hr %#lx.\n", hr);
+todo_wine
+    ok(hr == VFW_S_PARTIAL_RENDER, "Got hr %#x.\n", hr);
     ok(source_pin.peer == &parser1_pins[0].IPin_iface, "Got peer %p.\n", source_pin.peer);
     ok(sink_pin.peer == &parser1_pins[1].IPin_iface, "Got peer %p.\n", sink_pin.peer);
     ok(!parser1_pins[2].peer, "Got peer %p.\n", parser1_pins[2].peer);
@@ -2495,7 +2489,7 @@ static void test_graph_builder_connect(void)
 
     parser1_pins[1].QueryInternalConnections_hr = S_OK;
     hr = IFilterGraph2_Connect(graph, &source_pin.IPin_iface, &sink_pin.IPin_iface);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(source_pin.peer == &parser1_pins[0].IPin_iface, "Got peer %p.\n", source_pin.peer);
     ok(sink_pin.peer == &parser1_pins[1].IPin_iface, "Got peer %p.\n", sink_pin.peer);
     IFilterGraph2_Disconnect(graph, source_pin.peer);
@@ -2508,12 +2502,12 @@ static void test_graph_builder_connect(void)
 
     parser1_pins[1].name[0] = '~';
     hr = IFilterGraph2_Connect(graph, &source_pin.IPin_iface, &sink_pin.IPin_iface);
-    ok(hr == VFW_E_CANNOT_CONNECT, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_CANNOT_CONNECT, "Got hr %#x.\n", hr);
     ok(!source_pin.peer, "Got peer %p.\n", source_pin.peer);
 
     parser1.pin_count = 3;
     hr = IFilterGraph2_Connect(graph, &source_pin.IPin_iface, &sink_pin.IPin_iface);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(source_pin.peer == &parser1_pins[0].IPin_iface, "Got peer %p.\n", source_pin.peer);
     ok(sink_pin.peer == &parser1_pins[2].IPin_iface, "Got peer %p.\n", sink_pin.peer);
     IFilterGraph2_Disconnect(graph, source_pin.peer);
@@ -2525,7 +2519,7 @@ static void test_graph_builder_connect(void)
     parser1_pins[1].name[0] = 0;
     parser1_pins[1].id[0] = '~';
     hr = IFilterGraph2_Connect(graph, &source_pin.IPin_iface, &sink_pin.IPin_iface);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(source_pin.peer == &parser1_pins[0].IPin_iface, "Got peer %p.\n", source_pin.peer);
     ok(sink_pin.peer == &parser1_pins[1].IPin_iface, "Got peer %p.\n", sink_pin.peer);
     IFilterGraph2_Disconnect(graph, source_pin.peer);
@@ -2534,15 +2528,15 @@ static void test_graph_builder_connect(void)
     IFilterGraph2_Disconnect(graph, &sink_pin.IPin_iface);
 
     hr = IFilterGraph2_Connect(graph, &parser1_pins[1].IPin_iface, &parser1_pins[0].IPin_iface);
-    ok(hr == VFW_E_CANNOT_CONNECT, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_CANNOT_CONNECT, "Got hr %#x.\n", hr);
 
     parser1_pins[0].QueryInternalConnections_hr = S_OK;
     hr = IFilterGraph2_Connect(graph, &parser1_pins[1].IPin_iface, &parser1_pins[0].IPin_iface);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
     parser1_pins[0].QueryInternalConnections_hr = E_NOTIMPL;
 
     ref = IFilterGraph2_Release(graph);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 
     /* The graph connects from source to sink, not from sink to source. */
 
@@ -2554,7 +2548,7 @@ static void test_graph_builder_connect(void)
     parser1_pins[0].require_connected_pin = &parser1_pins[1];
 
     hr = IFilterGraph2_Connect(graph, &source_pin.IPin_iface, &sink_pin.IPin_iface);
-    ok(hr == VFW_E_CANNOT_CONNECT, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_CANNOT_CONNECT, "Got hr %#x.\n", hr);
     ok(!source_pin.peer, "Got peer %p.\n", source_pin.peer);
     ok(!sink_pin.peer, "Got peer %p.\n", sink_pin.peer);
 
@@ -2562,14 +2556,14 @@ static void test_graph_builder_connect(void)
     parser1_pins[1].require_connected_pin = &parser1_pins[0];
 
     hr = IFilterGraph2_Connect(graph, &source_pin.IPin_iface, &sink_pin.IPin_iface);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(source_pin.peer == &parser1_pins[0].IPin_iface, "Got peer %p.\n", source_pin.peer);
     ok(sink_pin.peer == &parser1_pins[1].IPin_iface, "Got peer %p.\n", sink_pin.peer);
 
     parser1_pins[1].require_connected_pin = NULL;
 
     ref = IFilterGraph2_Release(graph);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 
     /* Test enumeration of filters from the registry. */
 
@@ -2605,19 +2599,19 @@ static void test_graph_builder_connect(void)
         skip("Not enough permission to register filters.\n");
         goto out;
     }
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     IFilterMapper2_RegisterFilter(mapper, &parser2_clsid, L"test", NULL, NULL, NULL, &regfilter);
 
     hr = IFilterGraph2_Connect(graph, &source_pin.IPin_iface, &sink_pin.IPin_iface);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(source_pin.peer == &parser1_pins[0].IPin_iface
             || source_pin.peer == &parser2_pins[1].IPin_iface, "Got peer %p.\n", source_pin.peer);
     ok(sink_pin.peer == &parser1_pins[1].IPin_iface
             || sink_pin.peer == &parser2_pins[0].IPin_iface, "Got peer %p.\n", sink_pin.peer);
 
     ref = IFilterGraph2_Release(graph);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 
     /* Preference is given to filters already in the graph. */
 
@@ -2627,12 +2621,12 @@ static void test_graph_builder_connect(void)
     IFilterGraph2_AddFilter(graph, &parser1.IBaseFilter_iface, NULL);
 
     hr = IFilterGraph2_Connect(graph, &source_pin.IPin_iface, &sink_pin.IPin_iface);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(source_pin.peer == &parser1_pins[0].IPin_iface, "Got peer %p.\n", source_pin.peer);
     ok(sink_pin.peer == &parser1_pins[1].IPin_iface, "Got peer %p.\n", sink_pin.peer);
 
     ref = IFilterGraph2_Release(graph);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 
     /* Preference is given to filters with higher merit. */
 
@@ -2649,12 +2643,12 @@ static void test_graph_builder_connect(void)
     IFilterMapper2_RegisterFilter(mapper, &parser2_clsid, L"test", NULL, NULL, NULL, &regfilter);
 
     hr = IFilterGraph2_Connect(graph, &source_pin.IPin_iface, &sink_pin.IPin_iface);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(source_pin.peer == &parser2_pins[1].IPin_iface, "Got peer %p.\n", source_pin.peer);
     ok(sink_pin.peer == &parser2_pins[0].IPin_iface, "Got peer %p.\n", sink_pin.peer);
 
     ref = IFilterGraph2_Release(graph);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 
     graph = create_graph();
     IFilterGraph2_AddFilter(graph, &source.IBaseFilter_iface, NULL);
@@ -2669,7 +2663,7 @@ static void test_graph_builder_connect(void)
     IFilterMapper2_RegisterFilter(mapper, &parser2_clsid, L"test", NULL, NULL, NULL, &regfilter);
 
     hr = IFilterGraph2_Connect(graph, &source_pin.IPin_iface, &sink_pin.IPin_iface);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(source_pin.peer == &parser1_pins[0].IPin_iface, "Got peer %p.\n", source_pin.peer);
     ok(sink_pin.peer == &parser1_pins[1].IPin_iface, "Got peer %p.\n", sink_pin.peer);
 
@@ -2681,21 +2675,21 @@ out:
     CoRevokeClassObject(cookie2);
     IFilterMapper2_Release(mapper);
     ref = IFilterGraph2_Release(graph);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
-    ok(source.ref == 1, "Got outstanding refcount %ld.\n", source.ref);
-    ok(source_pin.ref == 1, "Got outstanding refcount %ld.\n", source_pin.ref);
-    ok(sink.ref == 1, "Got outstanding refcount %ld.\n", sink.ref);
-    ok(sink_pin.ref == 1, "Got outstanding refcount %ld.\n", sink_pin.ref);
-    ok(parser1.ref == 1, "Got outstanding refcount %ld.\n", parser1.ref);
-    ok(parser1_pins[0].ref == 1, "Got outstanding refcount %ld.\n", parser1_pins[0].ref);
-    ok(parser1_pins[1].ref == 1, "Got outstanding refcount %ld.\n", parser1_pins[1].ref);
-    ok(parser1_pins[2].ref == 1, "Got outstanding refcount %ld.\n", parser1_pins[2].ref);
-    ok(parser2.ref == 1, "Got outstanding refcount %ld.\n", parser2.ref);
-    ok(parser2_pins[0].ref == 1, "Got outstanding refcount %ld.\n", parser2_pins[0].ref);
-    ok(parser2_pins[1].ref == 1, "Got outstanding refcount %ld.\n", parser2_pins[1].ref);
-    ok(parser3.ref == 1, "Got outstanding refcount %ld.\n", parser3.ref);
-    ok(parser3_pins[0].ref == 1, "Got outstanding refcount %ld.\n", parser3_pins[0].ref);
-    ok(parser3_pins[1].ref == 1, "Got outstanding refcount %ld.\n", parser3_pins[1].ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    ok(source.ref == 1, "Got outstanding refcount %d.\n", source.ref);
+    ok(source_pin.ref == 1, "Got outstanding refcount %d.\n", source_pin.ref);
+    ok(sink.ref == 1, "Got outstanding refcount %d.\n", sink.ref);
+    ok(sink_pin.ref == 1, "Got outstanding refcount %d.\n", sink_pin.ref);
+    ok(parser1.ref == 1, "Got outstanding refcount %d.\n", parser1.ref);
+    ok(parser1_pins[0].ref == 1, "Got outstanding refcount %d.\n", parser1_pins[0].ref);
+    ok(parser1_pins[1].ref == 1, "Got outstanding refcount %d.\n", parser1_pins[1].ref);
+    ok(parser1_pins[2].ref == 1, "Got outstanding refcount %d.\n", parser1_pins[2].ref);
+    ok(parser2.ref == 1, "Got outstanding refcount %d.\n", parser2.ref);
+    ok(parser2_pins[0].ref == 1, "Got outstanding refcount %d.\n", parser2_pins[0].ref);
+    ok(parser2_pins[1].ref == 1, "Got outstanding refcount %d.\n", parser2_pins[1].ref);
+    ok(parser3.ref == 1, "Got outstanding refcount %d.\n", parser3.ref);
+    ok(parser3_pins[0].ref == 1, "Got outstanding refcount %d.\n", parser3_pins[0].ref);
+    ok(parser3_pins[1].ref == 1, "Got outstanding refcount %d.\n", parser3_pins[1].ref);
 }
 
 static const GUID test_iid = {0x33333333};
@@ -2744,77 +2738,77 @@ static void test_aggregation(void)
     graph = (IFilterGraph2 *)0xdeadbeef;
     hr = CoCreateInstance(&CLSID_FilterGraph, &test_outer, CLSCTX_INPROC_SERVER,
             &IID_IFilterGraph2, (void **)&graph);
-    ok(hr == E_NOINTERFACE, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOINTERFACE, "Got hr %#x.\n", hr);
     ok(!graph, "Got interface %p.\n", graph);
 
     hr = CoCreateInstance(&CLSID_FilterGraph, &test_outer, CLSCTX_INPROC_SERVER,
             &IID_IUnknown, (void **)&unk);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(outer_ref == 1, "Got unexpected refcount %ld.\n", outer_ref);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
     ok(unk != &test_outer, "Returned IUnknown should not be outer IUnknown.\n");
     ref = get_refcount(unk);
-    ok(ref == 1, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
 
     ref = IUnknown_AddRef(unk);
-    ok(ref == 2, "Got unexpected refcount %ld.\n", ref);
-    ok(outer_ref == 1, "Got unexpected refcount %ld.\n", outer_ref);
+    ok(ref == 2, "Got unexpected refcount %d.\n", ref);
+    ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
 
     ref = IUnknown_Release(unk);
-    ok(ref == 1, "Got unexpected refcount %ld.\n", ref);
-    ok(outer_ref == 1, "Got unexpected refcount %ld.\n", outer_ref);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
+    ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
 
     hr = IUnknown_QueryInterface(unk, &IID_IUnknown, (void **)&unk2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(unk2 == unk, "Got unexpected IUnknown %p.\n", unk2);
     IUnknown_Release(unk2);
 
     hr = IUnknown_QueryInterface(unk, &IID_IFilterGraph2, (void **)&graph);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IFilterGraph2_QueryInterface(graph, &IID_IUnknown, (void **)&unk2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(unk2 == (IUnknown *)0xdeadbeef, "Got unexpected IUnknown %p.\n", unk2);
 
     hr = IFilterGraph2_QueryInterface(graph, &IID_IFilterGraph2, (void **)&graph2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(graph2 == (IFilterGraph2 *)0xdeadbeef, "Got unexpected IFilterGraph2 %p.\n", graph2);
 
     hr = IUnknown_QueryInterface(unk, &test_iid, (void **)&unk2);
-    ok(hr == E_NOINTERFACE, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOINTERFACE, "Got hr %#x.\n", hr);
     ok(!unk2, "Got unexpected IUnknown %p.\n", unk2);
 
     hr = IFilterGraph2_QueryInterface(graph, &test_iid, (void **)&unk2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(unk2 == (IUnknown *)0xdeadbeef, "Got unexpected IUnknown %p.\n", unk2);
 
     IFilterGraph2_Release(graph);
     ref = IUnknown_Release(unk);
-    ok(!ref, "Got unexpected refcount %ld.\n", ref);
-    ok(outer_ref == 1, "Got unexpected refcount %ld.\n", outer_ref);
+    ok(!ref, "Got unexpected refcount %d.\n", ref);
+    ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
 
     /* Test the aggregated filter mapper. */
 
     graph = create_graph();
 
     ref = get_refcount(graph);
-    ok(ref == 1, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
 
     hr = IFilterGraph2_QueryInterface(graph, &IID_IFilterMapper2, (void **)&mapper);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     ref = get_refcount(graph);
-    ok(ref == 2, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 2, "Got unexpected refcount %d.\n", ref);
     ref = get_refcount(mapper);
-    ok(ref == 2, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 2, "Got unexpected refcount %d.\n", ref);
 
     hr = IFilterMapper2_QueryInterface(mapper, &IID_IFilterGraph2, (void **)&graph2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(graph2 == graph, "Got unexpected IFilterGraph2 %p.\n", graph2);
     IFilterGraph2_Release(graph2);
 
     IFilterMapper2_Release(mapper);
     ref = IFilterGraph2_Release(graph);
-    ok(!ref, "Got unexpected refcount %ld.\n", ref);
+    ok(!ref, "Got unexpected refcount %d.\n", ref);
 }
 
 /* Test how methods from "control" interfaces (IBasicAudio, IBasicVideo,
@@ -2827,123 +2821,123 @@ static void test_control_delegation(void)
     IVideoWindow *window;
     IBasicVideo2 *video;
     ITypeInfo *typeinfo;
-    unsigned int count;
     TYPEATTR *typeattr;
+    ULONG count;
     HRESULT hr;
     LONG val;
 
     /* IBasicAudio */
 
     hr = IFilterGraph2_QueryInterface(graph, &IID_IBasicAudio, (void **)&audio);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "got %#x\n", hr);
 
     hr = IBasicAudio_GetTypeInfoCount(audio, &count);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(count == 1, "Got count %u.\n", count);
 
     hr = IBasicAudio_put_Volume(audio, -10);
-    ok(hr == E_NOTIMPL, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOTIMPL, "got %#x\n", hr);
     hr = IBasicAudio_get_Volume(audio, &val);
-    ok(hr == E_NOTIMPL, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOTIMPL, "got %#x\n", hr);
     hr = IBasicAudio_put_Balance(audio, 10);
-    ok(hr == E_NOTIMPL, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOTIMPL, "got %#x\n", hr);
     hr = IBasicAudio_get_Balance(audio, &val);
-    ok(hr == E_NOTIMPL, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOTIMPL, "got %#x\n", hr);
 
     hr = CoCreateInstance(&CLSID_DSoundRender, NULL, CLSCTX_INPROC_SERVER, &IID_IBaseFilter, (void **)&renderer);
     if (hr != VFW_E_NO_AUDIO_HARDWARE)
     {
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "got %#x\n", hr);
 
         hr = IFilterGraph2_AddFilter(graph, renderer, NULL);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "got %#x\n", hr);
 
         hr = IBasicAudio_put_Volume(audio, -10);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "got %#x\n", hr);
         hr = IBasicAudio_get_Volume(audio, &val);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
-        ok(val == -10, "got %ld\n", val);
+        ok(hr == S_OK, "got %#x\n", hr);
+        ok(val == -10, "got %d\n", val);
         hr = IBasicAudio_put_Balance(audio, 10);
-        ok(hr == S_OK || hr == VFW_E_MONO_AUDIO_HW, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK || hr == VFW_E_MONO_AUDIO_HW, "got %#x\n", hr);
         hr = IBasicAudio_get_Balance(audio, &val);
-        ok(hr == S_OK || hr == VFW_E_MONO_AUDIO_HW, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK || hr == VFW_E_MONO_AUDIO_HW, "got %#x\n", hr);
         if (hr == S_OK)
-            ok(val == 10, "got balance %ld\n", val);
+            ok(val == 10, "got balance %d\n", val);
 
         hr = IBaseFilter_QueryInterface(renderer, &IID_IBasicAudio, (void **)&filter_audio);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "got %#x\n", hr);
 
         hr = IBasicAudio_get_Volume(filter_audio, &val);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
-        ok(val == -10, "got volume %ld\n", val);
+        ok(hr == S_OK, "got %#x\n", hr);
+        ok(val == -10, "got volume %d\n", val);
 
         hr = IFilterGraph2_RemoveFilter(graph, renderer);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "got %#x\n", hr);
 
         IBaseFilter_Release(renderer);
         IBasicAudio_Release(filter_audio);
     }
 
     hr = IBasicAudio_put_Volume(audio, -10);
-    ok(hr == E_NOTIMPL, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOTIMPL, "got %#x\n", hr);
     hr = IBasicAudio_get_Volume(audio, &val);
-    ok(hr == E_NOTIMPL, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOTIMPL, "got %#x\n", hr);
     hr = IBasicAudio_put_Balance(audio, 10);
-    ok(hr == E_NOTIMPL, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOTIMPL, "got %#x\n", hr);
     hr = IBasicAudio_get_Balance(audio, &val);
-    ok(hr == E_NOTIMPL, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOTIMPL, "got %#x\n", hr);
 
     IBasicAudio_Release(audio);
 
     /* IBasicVideo and IVideoWindow */
 
     hr = IFilterGraph2_QueryInterface(graph, &IID_IBasicVideo2, (void **)&video);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "got %#x\n", hr);
     hr = IFilterGraph2_QueryInterface(graph, &IID_IVideoWindow, (void **)&window);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "got %#x\n", hr);
 
     /* Unlike IBasicAudio, these return E_NOINTERFACE. */
     hr = IBasicVideo2_get_BitRate(video, &val);
-    ok(hr == E_NOINTERFACE, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOINTERFACE, "got %#x\n", hr);
 
     hr = IBasicVideo2_GetTypeInfoCount(video, &count);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(count == 1, "Got count %u.\n", count);
 
     hr = IBasicVideo2_GetTypeInfo(video, 0, 0, &typeinfo);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = ITypeInfo_GetTypeAttr(typeinfo, &typeattr);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(typeattr->typekind == TKIND_DISPATCH, "Got kind %u.\n", typeattr->typekind);
     ok(IsEqualGUID(&typeattr->guid, &IID_IBasicVideo), "Got IID %s.\n", wine_dbgstr_guid(&typeattr->guid));
     ITypeInfo_ReleaseTypeAttr(typeinfo, typeattr);
     ITypeInfo_Release(typeinfo);
 
     hr = IVideoWindow_SetWindowForeground(window, OAFALSE);
-    ok(hr == E_NOINTERFACE, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOINTERFACE, "got %#x\n", hr);
 
     hr = IVideoWindow_GetTypeInfoCount(window, &count);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(count == 1, "Got count %u.\n", count);
 
     hr = CoCreateInstance(&CLSID_VideoRenderer, NULL, CLSCTX_INPROC_SERVER, &IID_IBaseFilter, (void **)&renderer);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "got %#x\n", hr);
 
     hr = IFilterGraph2_AddFilter(graph, renderer, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "got %#x\n", hr);
 
     hr = IBasicVideo2_get_BitRate(video, &val);
-    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_CONNECTED, "got %#x\n", hr);
     hr = IVideoWindow_SetWindowForeground(window, OAFALSE);
-    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_CONNECTED, "got %#x\n", hr);
 
     hr = IFilterGraph2_RemoveFilter(graph, renderer);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "got %#x\n", hr);
 
     hr = IBasicVideo2_get_BitRate(video, &val);
-    ok(hr == E_NOINTERFACE, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOINTERFACE, "got %#x\n", hr);
     hr = IVideoWindow_SetWindowForeground(window, OAFALSE);
-    ok(hr == E_NOINTERFACE, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOINTERFACE, "got %#x\n", hr);
 
     IBaseFilter_Release(renderer);
     IBasicVideo2_Release(video);
@@ -2958,52 +2952,51 @@ static void test_add_remove_filter(void)
     IFilterGraph2 *graph = create_graph();
     IBaseFilter *ret_filter;
     HRESULT hr;
-    LONG ref;
 
     testfilter_init(&filter, NULL, 0);
 
     hr = IFilterGraph2_FindFilterByName(graph, L"testid", &ret_filter);
-    ok(hr == VFW_E_NOT_FOUND, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_FOUND, "Got hr %#x.\n", hr);
     ok(!ret_filter, "Got filter %p.\n", ret_filter);
 
     hr = IFilterGraph2_AddFilter(graph, &filter.IBaseFilter_iface, L"testid");
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(filter.graph == (IFilterGraph *)graph, "Got graph %p.\n", filter.graph);
     ok(!wcscmp(filter.name, L"testid"), "Got name %s.\n", wine_dbgstr_w(filter.name));
 
     hr = IFilterGraph2_FindFilterByName(graph, L"testid", &ret_filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(ret_filter == &filter.IBaseFilter_iface, "Got filter %p.\n", ret_filter);
     IBaseFilter_Release(ret_filter);
 
     hr = IFilterGraph2_RemoveFilter(graph, &filter.IBaseFilter_iface);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(!filter.graph, "Got graph %p.\n", filter.graph);
     ok(!filter.name, "Got name %s.\n", wine_dbgstr_w(filter.name));
     ok(!filter.clock, "Got clock %p,\n", filter.clock);
-    ok(filter.ref == 1, "Got outstanding refcount %ld.\n", filter.ref);
+    ok(filter.ref == 1, "Got outstanding refcount %d.\n", filter.ref);
 
     hr = IFilterGraph2_FindFilterByName(graph, L"testid", &ret_filter);
-    ok(hr == VFW_E_NOT_FOUND, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_FOUND, "Got hr %#x.\n", hr);
     ok(!ret_filter, "Got filter %p.\n", ret_filter);
 
     hr = IFilterGraph2_AddFilter(graph, &filter.IBaseFilter_iface, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(filter.graph == (IFilterGraph *)graph, "Got graph %p.\n", filter.graph);
     ok(!wcscmp(filter.name, L"0001"), "Got name %s.\n", wine_dbgstr_w(filter.name));
 
     hr = IFilterGraph2_FindFilterByName(graph, L"0001", &ret_filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(ret_filter == &filter.IBaseFilter_iface, "Got filter %p.\n", ret_filter);
     IBaseFilter_Release(ret_filter);
 
     /* test releasing the filter graph while filters are still connected */
-    ref = IFilterGraph2_Release(graph);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    hr = IFilterGraph2_Release(graph);
+    ok(!hr, "Got outstanding refcount %d.\n", hr);
     ok(!filter.graph, "Got graph %p.\n", filter.graph);
     ok(!filter.name, "Got name %s.\n", wine_dbgstr_w(filter.name));
     ok(!filter.clock, "Got clock %p.\n", filter.clock);
-    ok(filter.ref == 1, "Got outstanding refcount %ld.\n", filter.ref);
+    ok(filter.ref == 1, "Got outstanding refcount %d.\n", filter.ref);
 }
 
 static HRESULT WINAPI test_connect_direct_Connect(IPin *iface, IPin *peer, const AM_MEDIA_TYPE *mt)
@@ -3053,7 +3046,6 @@ static void test_connect_direct(void)
     IMediaControl *control;
     AM_MEDIA_TYPE mt;
     HRESULT hr;
-    ULONG ref;
 
     test_connect_direct_init(&source_pin, PINDIR_OUTPUT);
     testfilter_init(&source, &source_pin, 1);
@@ -3067,75 +3059,83 @@ static void test_connect_direct(void)
     testfilter_init(&parser2, parser2_pins, 2);
 
     hr = IFilterGraph2_AddFilter(graph, &source.IBaseFilter_iface, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IFilterGraph2_AddFilter(graph, &sink.IBaseFilter_iface, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     /* The filter graph does not prevent connection while it is running; only
      * individual filters do. */
     IFilterGraph2_QueryInterface(graph, &IID_IMediaControl, (void **)&control);
     hr = IMediaControl_Pause(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IFilterGraph2_ConnectDirect(graph, &source_pin.IPin_iface, &sink_pin.IPin_iface, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(source_pin.peer == &sink_pin.IPin_iface, "Got peer %p.\n", source_pin.peer);
     ok(!source_pin.mt, "Got mt %p.\n", source_pin.mt);
     ok(!sink_pin.peer, "Got peer %p.\n", sink_pin.peer);
 
     hr = IFilterGraph2_Disconnect(graph, &sink_pin.IPin_iface);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     ok(source_pin.peer == &sink_pin.IPin_iface, "Got peer %p.\n", source_pin.peer);
     ok(!sink_pin.peer, "Got peer %p.\n", sink_pin.peer);
 
     hr = IFilterGraph2_Disconnect(graph, &source_pin.IPin_iface);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(!source_pin.peer, "Got peer %p.\n", source_pin.peer);
     ok(!sink_pin.peer, "Got peer %p.\n", sink_pin.peer);
 
     hr = IFilterGraph2_Connect(graph, &source_pin.IPin_iface, &sink_pin.IPin_iface);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(source_pin.peer == &sink_pin.IPin_iface, "Got peer %p.\n", source_pin.peer);
     ok(!source_pin.mt, "Got mt %p.\n", source_pin.mt);
     ok(!sink_pin.peer, "Got peer %p.\n", sink_pin.peer);
 
     hr = IFilterGraph2_Disconnect(graph, &sink_pin.IPin_iface);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     ok(source_pin.peer == &sink_pin.IPin_iface, "Got peer %p.\n", source_pin.peer);
     ok(!sink_pin.peer, "Got peer %p.\n", sink_pin.peer);
 
     hr = IFilterGraph2_Disconnect(graph, &source_pin.IPin_iface);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(!source_pin.peer, "Got peer %p.\n", source_pin.peer);
     ok(!sink_pin.peer, "Got peer %p.\n", sink_pin.peer);
 
     /* Swap the pins when connecting. */
     hr = IFilterGraph2_ConnectDirect(graph, &sink_pin.IPin_iface, &source_pin.IPin_iface, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    todo_wine ok(sink_pin.peer == &source_pin.IPin_iface, "Got peer %p.\n", sink_pin.peer);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+todo_wine
+    ok(sink_pin.peer == &source_pin.IPin_iface, "Got peer %p.\n", sink_pin.peer);
     ok(!sink_pin.mt, "Got mt %p.\n", sink_pin.mt);
-    todo_wine ok(!source_pin.peer, "Got peer %p.\n", source_pin.peer);
+todo_wine
+    ok(!source_pin.peer, "Got peer %p.\n", source_pin.peer);
 
     hr = IFilterGraph2_Disconnect(graph, &sink_pin.IPin_iface);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    todo_wine ok(!source_pin.peer, "Got peer %p.\n", source_pin.peer);
+todo_wine
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+todo_wine
+    ok(!source_pin.peer, "Got peer %p.\n", source_pin.peer);
     ok(!sink_pin.peer, "Got peer %p.\n", sink_pin.peer);
 
     hr = IFilterGraph2_Connect(graph, &sink_pin.IPin_iface, &source_pin.IPin_iface);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    todo_wine ok(sink_pin.peer == &source_pin.IPin_iface, "Got peer %p.\n", sink_pin.peer);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+todo_wine
+    ok(sink_pin.peer == &source_pin.IPin_iface, "Got peer %p.\n", sink_pin.peer);
     ok(!sink_pin.mt, "Got mt %p.\n", sink_pin.mt);
-    todo_wine ok(!source_pin.peer, "Got peer %p.\n", source_pin.peer);
+todo_wine
+    ok(!source_pin.peer, "Got peer %p.\n", source_pin.peer);
 
     hr = IFilterGraph2_Disconnect(graph, &sink_pin.IPin_iface);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    todo_wine ok(!source_pin.peer, "Got peer %p.\n", source_pin.peer);
+todo_wine
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+todo_wine
+    ok(!source_pin.peer, "Got peer %p.\n", source_pin.peer);
     ok(!sink_pin.peer, "Got peer %p.\n", sink_pin.peer);
 
     /* Disconnect() does not disconnect the peer. */
     hr = IFilterGraph2_ConnectDirect(graph, &source_pin.IPin_iface, &sink_pin.IPin_iface, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(source_pin.peer == &sink_pin.IPin_iface, "Got peer %p.\n", source_pin.peer);
     ok(!source_pin.mt, "Got mt %p.\n", source_pin.mt);
     ok(!sink_pin.peer, "Got peer %p.\n", sink_pin.peer);
@@ -3144,146 +3144,146 @@ static void test_connect_direct(void)
     IPin_AddRef(sink_pin.peer);
 
     hr = IFilterGraph2_Disconnect(graph, &sink_pin.IPin_iface);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(source_pin.peer == &sink_pin.IPin_iface, "Got peer %p.\n", source_pin.peer);
     ok(!sink_pin.peer, "Got peer %p.\n", sink_pin.peer);
 
     hr = IFilterGraph2_Disconnect(graph, &source_pin.IPin_iface);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(!source_pin.peer, "Got peer %p.\n", source_pin.peer);
     ok(!sink_pin.peer, "Got peer %p.\n", sink_pin.peer);
 
     /* Test specifying the media type. */
     hr = IFilterGraph2_ConnectDirect(graph, &source_pin.IPin_iface, &sink_pin.IPin_iface, &mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(source_pin.peer == &sink_pin.IPin_iface, "Got peer %p.\n", source_pin.peer);
     ok(source_pin.mt == &mt, "Got mt %p.\n", source_pin.mt);
     ok(!sink_pin.peer, "Got peer %p.\n", sink_pin.peer);
     hr = IFilterGraph2_Disconnect(graph, &source_pin.IPin_iface);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     /* Test Reconnect[Ex](). */
 
     hr = IFilterGraph2_Reconnect(graph, &source_pin.IPin_iface);
-    todo_wine ok(hr == VFW_E_WRONG_STATE, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == VFW_E_WRONG_STATE, "Got hr %#x.\n", hr);
     hr = IFilterGraph2_Reconnect(graph, &sink_pin.IPin_iface);
-    todo_wine ok(hr == VFW_E_WRONG_STATE, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == VFW_E_WRONG_STATE, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IFilterGraph2_Reconnect(graph, &source_pin.IPin_iface);
-    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#x.\n", hr);
     hr = IFilterGraph2_Reconnect(graph, &sink_pin.IPin_iface);
-    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#x.\n", hr);
 
     hr = IFilterGraph2_ConnectDirect(graph, &source_pin.IPin_iface, &sink_pin.IPin_iface, &mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IFilterGraph2_Reconnect(graph, &source_pin.IPin_iface);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(source_pin.peer == &sink_pin.IPin_iface, "Got peer %p.\n", source_pin.peer);
     ok(!source_pin.mt, "Got mt %p.\n", source_pin.mt);
     ok(!sink_pin.peer, "Got peer %p.\n", sink_pin.peer);
     hr = IFilterGraph2_Disconnect(graph, &source_pin.IPin_iface);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IFilterGraph2_ConnectDirect(graph, &source_pin.IPin_iface, &sink_pin.IPin_iface, &mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     sink_pin.peer = &source_pin.IPin_iface;
     IPin_AddRef(sink_pin.peer);
     hr = IFilterGraph2_Reconnect(graph, &sink_pin.IPin_iface);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(source_pin.peer == &sink_pin.IPin_iface, "Got peer %p.\n", source_pin.peer);
     ok(!source_pin.mt, "Got mt %p.\n", source_pin.mt);
     ok(!sink_pin.peer, "Got peer %p.\n", sink_pin.peer);
     hr = IFilterGraph2_Disconnect(graph, &source_pin.IPin_iface);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IFilterGraph2_ReconnectEx(graph, &source_pin.IPin_iface, NULL);
-    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#x.\n", hr);
     hr = IFilterGraph2_ReconnectEx(graph, &sink_pin.IPin_iface, NULL);
-    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#x.\n", hr);
 
     hr = IFilterGraph2_ConnectDirect(graph, &source_pin.IPin_iface, &sink_pin.IPin_iface, &mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IFilterGraph2_ReconnectEx(graph, &source_pin.IPin_iface, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(source_pin.peer == &sink_pin.IPin_iface, "Got peer %p.\n", source_pin.peer);
     ok(!source_pin.mt, "Got mt %p.\n", source_pin.mt);
     ok(!sink_pin.peer, "Got peer %p.\n", sink_pin.peer);
     hr = IFilterGraph2_Disconnect(graph, &source_pin.IPin_iface);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IFilterGraph2_ConnectDirect(graph, &source_pin.IPin_iface, &sink_pin.IPin_iface, &mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IFilterGraph2_ReconnectEx(graph, &source_pin.IPin_iface, &mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(source_pin.peer == &sink_pin.IPin_iface, "Got peer %p.\n", source_pin.peer);
     ok(source_pin.mt == &mt, "Got mt %p.\n", source_pin.mt);
     ok(!sink_pin.peer, "Got peer %p.\n", sink_pin.peer);
     hr = IFilterGraph2_Disconnect(graph, &source_pin.IPin_iface);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     /* ConnectDirect() protects against cyclical connections. */
     hr = IFilterGraph2_AddFilter(graph, &parser1.IBaseFilter_iface, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IFilterGraph2_AddFilter(graph, &parser2.IBaseFilter_iface, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IFilterGraph2_ConnectDirect(graph, &parser1_pins[1].IPin_iface, &parser1_pins[0].IPin_iface, NULL);
-    ok(hr == VFW_E_CIRCULAR_GRAPH, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_CIRCULAR_GRAPH, "Got hr %#x.\n", hr);
 
     hr = IFilterGraph2_ConnectDirect(graph, &parser1_pins[1].IPin_iface, &parser2_pins[0].IPin_iface, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IFilterGraph2_ConnectDirect(graph, &parser2_pins[1].IPin_iface, &parser1_pins[0].IPin_iface, NULL);
-    todo_wine ok(hr == VFW_E_CIRCULAR_GRAPH, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == VFW_E_CIRCULAR_GRAPH, "Got hr %#x.\n", hr);
     IFilterGraph2_Disconnect(graph, &parser1_pins[1].IPin_iface);
     IFilterGraph2_Disconnect(graph, &parser2_pins[0].IPin_iface);
 
     parser1_pins[0].QueryInternalConnections_hr = S_OK;
     hr = IFilterGraph2_ConnectDirect(graph, &parser1_pins[1].IPin_iface, &parser1_pins[0].IPin_iface, NULL);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(!parser1_pins[0].peer, "Got peer %p.\n", parser1_pins[0].peer);
     todo_wine ok(parser1_pins[1].peer == &parser1_pins[0].IPin_iface, "Got peer %p.\n", parser1_pins[1].peer);
     IFilterGraph2_Disconnect(graph, &parser1_pins[0].IPin_iface);
     IFilterGraph2_Disconnect(graph, &parser1_pins[1].IPin_iface);
 
     hr = IFilterGraph2_ConnectDirect(graph, &parser1_pins[1].IPin_iface, &parser2_pins[0].IPin_iface, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IFilterGraph2_ConnectDirect(graph, &parser2_pins[1].IPin_iface, &parser1_pins[0].IPin_iface, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     IFilterGraph2_Disconnect(graph, &parser1_pins[1].IPin_iface);
     IFilterGraph2_Disconnect(graph, &parser2_pins[0].IPin_iface);
 
     hr = IFilterGraph2_RemoveFilter(graph, &parser1.IBaseFilter_iface);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IFilterGraph2_RemoveFilter(graph, &parser2.IBaseFilter_iface);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     /* Both pins are disconnected when a filter is removed. */
     hr = IFilterGraph2_ConnectDirect(graph, &source_pin.IPin_iface, &sink_pin.IPin_iface, &mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     sink_pin.peer = &source_pin.IPin_iface;
     IPin_AddRef(sink_pin.peer);
     hr = IFilterGraph2_RemoveFilter(graph, &source.IBaseFilter_iface);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(!source_pin.peer, "Got peer %p.\n", source_pin.peer);
     ok(!sink_pin.peer, "Got peer %p.\n", sink_pin.peer);
 
     /* If the filter cannot be disconnected, then RemoveFilter() fails. */
 
     hr = IFilterGraph2_AddFilter(graph, &source.IBaseFilter_iface, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IFilterGraph2_ConnectDirect(graph, &source_pin.IPin_iface, &sink_pin.IPin_iface, &mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     sink_pin.peer = &source_pin.IPin_iface;
     IPin_AddRef(sink_pin.peer);
     hr = IMediaControl_Pause(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     source_pin.require_stopped_disconnect = TRUE;
     hr = IFilterGraph2_RemoveFilter(graph, &source.IBaseFilter_iface);
-    ok(hr == VFW_E_NOT_STOPPED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_STOPPED, "Got hr %#x.\n", hr);
     ok(source_pin.peer == &sink_pin.IPin_iface, "Got peer %p.\n", source_pin.peer);
     ok(!sink_pin.peer, "Got peer %p.\n", sink_pin.peer);
 
@@ -3292,19 +3292,20 @@ static void test_connect_direct(void)
     source_pin.require_stopped_disconnect = FALSE;
     sink_pin.require_stopped_disconnect = TRUE;
     hr = IFilterGraph2_RemoveFilter(graph, &source.IBaseFilter_iface);
-    ok(hr == VFW_E_NOT_STOPPED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_STOPPED, "Got hr %#x.\n", hr);
     ok(source_pin.peer == &sink_pin.IPin_iface, "Got peer %p.\n", source_pin.peer);
     ok(sink_pin.peer == &source_pin.IPin_iface, "Got peer %p.\n", sink_pin.peer);
 
     /* Filters are stopped, and pins disconnected, when the graph is destroyed. */
 
     IMediaControl_Release(control);
-    ref = IFilterGraph2_Release(graph);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
-    ok(source.ref == 1, "Got outstanding refcount %ld.\n", source.ref);
-    ok(sink.ref == 1, "Got outstanding refcount %ld.\n", sink.ref);
-    ok(source_pin.ref == 1, "Got outstanding refcount %ld.\n", source_pin.ref);
-    todo_wine ok(sink_pin.ref == 1, "Got outstanding refcount %ld.\n", sink_pin.ref);
+    hr = IFilterGraph2_Release(graph);
+    ok(!hr, "Got outstanding refcount %d.\n", hr);
+    ok(source.ref == 1, "Got outstanding refcount %d.\n", source.ref);
+    ok(sink.ref == 1, "Got outstanding refcount %d.\n", sink.ref);
+    ok(source_pin.ref == 1, "Got outstanding refcount %d.\n", source_pin.ref);
+todo_wine
+    ok(sink_pin.ref == 1, "Got outstanding refcount %d.\n", sink_pin.ref);
     ok(!source_pin.peer, "Got peer %p.\n", source_pin.peer);
     ok(!sink_pin.peer, "Got peer %p.\n", sink_pin.peer);
 }
@@ -3334,30 +3335,31 @@ static void test_sync_source(void)
             &IID_IReferenceClock, (void **)&systemclock);
 
     hr = IMediaFilter_SetSyncSource(filter, systemclock);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(filter1.clock == systemclock, "Got clock %p.\n", filter1.clock);
     ok(filter2.clock == systemclock, "Got clock %p.\n", filter2.clock);
 
     hr = IMediaFilter_GetSyncSource(filter, &clock);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(clock == systemclock, "Got clock %p.\n", clock);
     IReferenceClock_Release(clock);
 
     hr = IMediaFilter_SetSyncSource(filter, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(!filter1.clock, "Got clock %p.\n", filter1.clock);
     ok(!filter2.clock, "Got clock %p.\n", filter2.clock);
 
     hr = IMediaFilter_GetSyncSource(filter, &clock);
-    todo_wine ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+todo_wine
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     ok(!clock, "Got clock %p.\n", clock);
 
     IReferenceClock_Release(systemclock);
     IMediaFilter_Release(filter);
     ref = IFilterGraph2_Release(graph);
-    ok(!ref, "Got outstanding refcount %ld\n", ref);
-    ok(filter1.ref == 1, "Got outstanding refcount %ld.\n", filter1.ref);
-    ok(filter2.ref == 1, "Got outstanding refcount %ld.\n", filter2.ref);
+    ok(!ref, "Got outstanding refcount %d\n", ref);
+    ok(filter1.ref == 1, "Got outstanding refcount %d.\n", filter1.ref);
+    ok(filter2.ref == 1, "Got outstanding refcount %d.\n", filter2.ref);
 }
 
 #define check_filter_state(a, b) check_filter_state_(__LINE__, a, b)
@@ -3373,13 +3375,13 @@ static void check_filter_state_(unsigned int line, IFilterGraph2 *graph, FILTER_
 
     IFilterGraph2_QueryInterface(graph, &IID_IMediaFilter, (void **)&mediafilter);
     hr = IMediaFilter_GetState(mediafilter, 1000, &state);
-    ok_(__FILE__, line)(hr == S_OK, "IMediaFilter_GetState() returned %#lx.\n", hr);
+    ok_(__FILE__, line)(hr == S_OK, "IMediaFilter_GetState() returned %#x.\n", hr);
     ok_(__FILE__, line)(state == expect, "Expected state %u, got %u.\n", expect, state);
     IMediaFilter_Release(mediafilter);
 
     IFilterGraph2_QueryInterface(graph, &IID_IMediaControl, (void **)&control);
     hr = IMediaControl_GetState(control, 1000, &oastate);
-    ok_(__FILE__, line)(hr == S_OK, "IMediaControl_GetState() returned %#lx.\n", hr);
+    ok_(__FILE__, line)(hr == S_OK, "IMediaControl_GetState() returned %#x.\n", hr);
     ok_(__FILE__, line)(state == expect, "Expected state %u, got %u.\n", expect, state);
     IMediaControl_Release(control);
 
@@ -3387,7 +3389,7 @@ static void check_filter_state_(unsigned int line, IFilterGraph2 *graph, FILTER_
     while (IEnumFilters_Next(filterenum, 1, &filter, NULL) == S_OK)
     {
         hr = IBaseFilter_GetState(filter, 1000, &state);
-        ok_(__FILE__, line)(hr == S_OK, "IBaseFilter_GetState() returned %#lx.\n", hr);
+        ok_(__FILE__, line)(hr == S_OK, "IBaseFilter_GetState() returned %#x.\n", hr);
         ok_(__FILE__, line)(state == expect, "Expected state %u, got %u.\n", expect, state);
         IBaseFilter_Release(filter);
     }
@@ -3431,21 +3433,21 @@ static void test_filter_state(void)
     check_filter_state(graph, State_Stopped);
 
     hr = IMediaControl_Pause(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_filter_state(graph, State_Paused);
 
     /* Pausing sets the default sync source, if it's not already set. */
 
     hr = IMediaFilter_GetSyncSource(filter, &clock);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(!!clock, "Reference clock not set.\n");
     ok(source.clock == clock, "Expected %p, got %p.\n", clock, source.clock);
     ok(sink.clock == clock, "Expected %p, got %p.\n", clock, sink.clock);
 
     hr = IReferenceClock_GetTime(clock, &start_time);
-    ok(SUCCEEDED(hr), "Got hr %#lx.\n", hr);
+    ok(SUCCEEDED(hr), "Got hr %#x.\n", hr);
     hr = IMediaControl_Run(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_filter_state(graph, State_Running);
     if (winetest_interactive) /* Timing problems make this test too liable to fail. */
         ok(source.start_time >= start_time && source.start_time < start_time + 500 * 10000,
@@ -3455,84 +3457,84 @@ static void test_filter_state(void)
         wine_dbgstr_longlong(source.start_time), wine_dbgstr_longlong(sink.start_time));
 
     hr = IMediaControl_Pause(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_filter_state(graph, State_Paused);
 
     sink.state = State_Stopped;
     hr = IMediaControl_GetState(control, 0, &state);
-    ok(hr == E_FAIL, "Got hr %#lx.\n", hr);
-    ok(state == State_Paused, "Got state %lu.\n", state);
+    ok(hr == E_FAIL, "Got hr %#x.\n", hr);
+    ok(state == State_Paused, "Got state %u.\n", state);
 
     sink.state = State_Running;
     hr = IMediaControl_GetState(control, 0, &state);
-    ok(hr == E_FAIL, "Got hr %#lx.\n", hr);
-    ok(state == State_Paused, "Got state %lu.\n", state);
+    ok(hr == E_FAIL, "Got hr %#x.\n", hr);
+    ok(state == State_Paused, "Got state %u.\n", state);
 
     sink.state = State_Paused;
     hr = IMediaControl_GetState(control, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(state == State_Paused, "Got state %lu.\n", state);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(state == State_Paused, "Got state %u.\n", state);
 
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_filter_state(graph, State_Stopped);
 
     hr = IMediaControl_Run(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_filter_state(graph, State_Running);
 
     sink.state = State_Stopped;
     hr = IMediaControl_GetState(control, 0, &state);
-    ok(hr == E_FAIL, "Got hr %#lx.\n", hr);
-    ok(state == State_Running, "Got state %lu.\n", state);
+    ok(hr == E_FAIL, "Got hr %#x.\n", hr);
+    ok(state == State_Running, "Got state %u.\n", state);
 
     sink.state = State_Paused;
     hr = IMediaControl_GetState(control, 0, &state);
-    ok(hr == VFW_S_STATE_INTERMEDIATE, "Got hr %#lx.\n", hr);
-    ok(state == State_Running, "Got state %lu.\n", state);
+    ok(hr == VFW_S_STATE_INTERMEDIATE, "Got hr %#x.\n", hr);
+    ok(state == State_Running, "Got state %u.\n", state);
 
     sink.state = State_Running;
     hr = IMediaControl_GetState(control, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(state == State_Running, "Got state %lu.\n", state);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(state == State_Running, "Got state %u.\n", state);
 
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_filter_state(graph, State_Stopped);
 
     sink.state = State_Running;
     hr = IMediaControl_GetState(control, 0, &state);
-    ok(hr == E_FAIL, "Got hr %#lx.\n", hr);
-    ok(state == State_Stopped, "Got state %lu.\n", state);
+    ok(hr == E_FAIL, "Got hr %#x.\n", hr);
+    ok(state == State_Stopped, "Got state %u.\n", state);
 
     sink.state = State_Paused;
     hr = IMediaControl_GetState(control, 0, &state);
-    ok(hr == VFW_S_STATE_INTERMEDIATE, "Got hr %#lx.\n", hr);
-    ok(state == State_Stopped, "Got state %lu.\n", state);
+    ok(hr == VFW_S_STATE_INTERMEDIATE, "Got hr %#x.\n", hr);
+    ok(state == State_Stopped, "Got state %u.\n", state);
 
     sink.state = State_Stopped;
     hr = IMediaControl_GetState(control, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(state == State_Stopped, "Got state %lu.\n", state);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(state == State_Stopped, "Got state %u.\n", state);
 
     hr = IMediaControl_Pause(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_filter_state(graph, State_Paused);
 
     hr = IMediaControl_StopWhenReady(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_filter_state(graph, State_Stopped);
 
     hr = IMediaControl_Run(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_filter_state(graph, State_Running);
 
     hr = IMediaControl_StopWhenReady(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_filter_state(graph, State_Stopped);
 
     hr = IMediaControl_StopWhenReady(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_filter_state(graph, State_Stopped);
 
     IReferenceClock_Release(clock);
@@ -3555,44 +3557,44 @@ static void test_filter_state(void)
     IPin_Connect(&source_pin.IPin_iface, &sink_pin.IPin_iface, NULL);
 
     hr = IMediaFilter_Pause(filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_filter_state(graph, State_Paused);
 
     hr = IMediaFilter_GetSyncSource(filter, &clock);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(!!clock, "Reference clock not set.\n");
     ok(source.clock == clock, "Expected %p, got %p.\n", clock, source.clock);
     ok(sink.clock == clock, "Expected %p, got %p.\n", clock, sink.clock);
 
     hr = IMediaFilter_Run(filter, 0xdeadbeef);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_filter_state(graph, State_Running);
     ok(source.start_time == 0xdeadbeef, "Got time %s.\n", wine_dbgstr_longlong(source.start_time));
     ok(sink.start_time == 0xdeadbeef, "Got time %s.\n", wine_dbgstr_longlong(sink.start_time));
 
     hr = IMediaFilter_Pause(filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_filter_state(graph, State_Paused);
 
     hr = IMediaFilter_Run(filter, 0xdeadf00d);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_filter_state(graph, State_Running);
     ok(source.start_time == 0xdeadf00d, "Got time %s.\n", wine_dbgstr_longlong(source.start_time));
     ok(sink.start_time == 0xdeadf00d, "Got time %s.\n", wine_dbgstr_longlong(sink.start_time));
 
     hr = IMediaFilter_Pause(filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_filter_state(graph, State_Paused);
 
     hr = IMediaFilter_Stop(filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_filter_state(graph, State_Stopped);
 
     source.expect_run_prev = sink.expect_run_prev = State_Stopped;
     hr = IReferenceClock_GetTime(clock, &start_time);
-    ok(SUCCEEDED(hr), "Got hr %#lx.\n", hr);
+    ok(SUCCEEDED(hr), "Got hr %#x.\n", hr);
     hr = IMediaFilter_Run(filter, 0);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_filter_state(graph, State_Running);
     if (winetest_interactive) /* Timing problems make this test too liable to fail. */
         ok(source.start_time >= start_time && source.start_time < start_time + 500 * 10000,
@@ -3603,12 +3605,12 @@ static void test_filter_state(void)
 
     Sleep(600);
     hr = IMediaFilter_Pause(filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_filter_state(graph, State_Paused);
 
     source.expect_run_prev = sink.expect_run_prev = State_Paused;
     hr = IMediaFilter_Run(filter, 0);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_filter_state(graph, State_Running);
     if (winetest_interactive) /* Timing problems make this test too liable to fail. */
         ok(source.start_time >= start_time && source.start_time < start_time + 500 * 10000,
@@ -3618,13 +3620,13 @@ static void test_filter_state(void)
         wine_dbgstr_longlong(source.start_time), wine_dbgstr_longlong(sink.start_time));
 
     hr = IMediaFilter_Pause(filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_filter_state(graph, State_Paused);
     Sleep(600);
 
     start_time += 550 * 10000;
     hr = IMediaFilter_Run(filter, 0);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_filter_state(graph, State_Running);
     if (winetest_interactive) /* Timing problems make this test too liable to fail. */
         ok(source.start_time >= start_time && source.start_time < start_time + 500 * 10000,
@@ -3634,7 +3636,7 @@ static void test_filter_state(void)
         wine_dbgstr_longlong(source.start_time), wine_dbgstr_longlong(sink.start_time));
 
     hr = IMediaFilter_Stop(filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_filter_state(graph, State_Stopped);
 
     /* Test removing the sync source. */
@@ -3643,15 +3645,16 @@ static void test_filter_state(void)
     IMediaFilter_SetSyncSource(filter, NULL);
 
     hr = IMediaControl_Run(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_filter_state(graph, State_Running);
-    todo_wine ok(source.start_time > 0 && source.start_time < 500 * 10000,
-            "Got time %s.\n", wine_dbgstr_longlong(source.start_time));
+todo_wine
+    ok(source.start_time > 0 && source.start_time < 500 * 10000,
+        "Got time %s.\n", wine_dbgstr_longlong(source.start_time));
     ok(sink.start_time == source.start_time, "Expected time %s, got %s.\n",
         wine_dbgstr_longlong(source.start_time), wine_dbgstr_longlong(sink.start_time));
 
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_filter_state(graph, State_Stopped);
 
     /* Test asynchronous state change. */
@@ -3659,30 +3662,30 @@ static void test_filter_state(void)
     sink.state_hr = S_FALSE;
     sink.GetState_hr = VFW_S_STATE_INTERMEDIATE;
     hr = IMediaControl_Pause(control);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_GetState(control, 0, &state);
-    ok(hr == VFW_S_STATE_INTERMEDIATE, "Got hr %#lx.\n", hr);
-    ok(state == State_Paused, "Got state %lu.\n", state);
+    ok(hr == VFW_S_STATE_INTERMEDIATE, "Got hr %#x.\n", hr);
+    ok(state == State_Paused, "Got state %u.\n", state);
 
     sink.state_hr = sink.GetState_hr = S_OK;
     hr = IMediaControl_GetState(control, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(state == State_Paused, "Got state %lu.\n", state);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(state == State_Paused, "Got state %u.\n", state);
 
     sink.state_hr = S_FALSE;
     sink.GetState_hr = VFW_S_STATE_INTERMEDIATE;
     hr = IMediaControl_Stop(control);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_GetState(control, 0, &state);
-    ok(hr == VFW_S_STATE_INTERMEDIATE, "Got hr %#lx.\n", hr);
-    ok(state == State_Stopped, "Got state %lu.\n", state);
+    ok(hr == VFW_S_STATE_INTERMEDIATE, "Got hr %#x.\n", hr);
+    ok(state == State_Stopped, "Got state %u.\n", state);
 
     sink.state_hr = sink.GetState_hr = S_OK;
     hr = IMediaControl_GetState(control, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(state == State_Stopped, "Got state %lu.\n", state);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(state == State_Stopped, "Got state %u.\n", state);
 
     /* Renderers are expected to block completing a state change into paused
      * until they receive a sample. Because the graph can transition from
@@ -3698,11 +3701,11 @@ static void test_filter_state(void)
     sink.state_hr = S_FALSE;
     sink.GetState_hr = VFW_S_STATE_INTERMEDIATE;
     hr = IMediaControl_Run(control);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_GetState(control, 0, &state);
-    ok(hr == VFW_S_STATE_INTERMEDIATE, "Got hr %#lx.\n", hr);
-    ok(state == State_Running, "Got state %lu.\n", state);
+    ok(hr == VFW_S_STATE_INTERMEDIATE, "Got hr %#x.\n", hr);
+    ok(state == State_Running, "Got state %u.\n", state);
     ok(sink.state == State_Paused, "Got state %u.\n", sink.state);
     ok(source.state == State_Paused, "Got state %u.\n", source.state);
 
@@ -3711,14 +3714,14 @@ static void test_filter_state(void)
     time = 0;
     hr = IMediaSeeking_SetPositions(seeking, &time, AM_SEEKING_AbsolutePositioning,
             NULL, AM_SEEKING_NoPositioning);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_Run(control);
-    todo_wine ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_GetState(control, 0, &state);
-    ok(hr == VFW_S_STATE_INTERMEDIATE, "Got hr %#lx.\n", hr);
-    ok(state == State_Running, "Got state %lu.\n", state);
+    ok(hr == VFW_S_STATE_INTERMEDIATE, "Got hr %#x.\n", hr);
+    ok(state == State_Running, "Got state %u.\n", state);
     ok(sink.state == State_Paused, "Got state %u.\n", sink.state);
     ok(source.state == State_Paused, "Got state %u.\n", source.state);
 
@@ -3726,13 +3729,13 @@ static void test_filter_state(void)
 
     while ((hr = IMediaControl_GetState(control, INFINITE, &state)) == VFW_S_STATE_INTERMEDIATE)
     {
-        ok(state == State_Running, "Got state %lu.\n", state);
+        ok(state == State_Running, "Got state %u.\n", state);
         ok(sink.state == State_Paused, "Got state %u.\n", sink.state);
         ok(source.state == State_Paused, "Got state %u.\n", source.state);
         Sleep(10);
     }
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(state == State_Running, "Got state %lu.\n", state);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(state == State_Running, "Got state %u.\n", state);
     ok(sink.state == State_Running, "Got state %u.\n", sink.state);
     ok(source.state == State_Running, "Got state %u.\n", source.state);
 
@@ -3744,21 +3747,21 @@ static void test_filter_state(void)
     sink.state_hr = S_FALSE;
     sink.GetState_hr = VFW_S_STATE_INTERMEDIATE;
     hr = IMediaControl_Stop(control);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     ok(sink.state == State_Stopped, "Got state %u.\n", sink.state);
     ok(source.state == State_Stopped, "Got state %u.\n", source.state);
 
     hr = IMediaControl_GetState(control, 0, &state);
-    ok(hr == VFW_S_STATE_INTERMEDIATE, "Got hr %#lx.\n", hr);
-    ok(state == State_Stopped, "Got state %lu.\n", state);
+    ok(hr == VFW_S_STATE_INTERMEDIATE, "Got hr %#x.\n", hr);
+    ok(state == State_Stopped, "Got state %u.\n", state);
 
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     sink.state_hr = sink.GetState_hr = S_OK;
     hr = IMediaControl_GetState(control, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(state == State_Stopped, "Got state %lu.\n", state);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(state == State_Stopped, "Got state %u.\n", state);
 
     /* Try an asynchronous stopped->paused->running transition, but pause or
      * stop the graph before our filter is completely paused. */
@@ -3766,35 +3769,35 @@ static void test_filter_state(void)
     sink.state_hr = S_FALSE;
     sink.GetState_hr = VFW_S_STATE_INTERMEDIATE;
     hr = IMediaControl_Run(control);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_Pause(control);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     sink.state_hr = sink.GetState_hr = S_OK;
     hr = IMediaControl_GetState(control, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(state == State_Paused, "Got state %lu.\n", state);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(state == State_Paused, "Got state %u.\n", state);
     ok(sink.state == State_Paused, "Got state %u.\n", sink.state);
     ok(source.state == State_Paused, "Got state %u.\n", source.state);
 
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     sink.state_hr = S_FALSE;
     sink.GetState_hr = VFW_S_STATE_INTERMEDIATE;
     hr = IMediaControl_Run(control);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_Stop(control);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     ok(sink.state == State_Stopped, "Got state %u.\n", sink.state);
     ok(source.state == State_Stopped, "Got state %u.\n", source.state);
 
     sink.state_hr = sink.GetState_hr = S_OK;
     hr = IMediaControl_GetState(control, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(state == State_Stopped, "Got state %lu.\n", state);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(state == State_Stopped, "Got state %u.\n", state);
     ok(sink.state == State_Stopped, "Got state %u.\n", sink.state);
     ok(source.state == State_Stopped, "Got state %u.\n", source.state);
 
@@ -3803,13 +3806,13 @@ static void test_filter_state(void)
     sink.state_hr = S_FALSE;
     sink.GetState_hr = VFW_S_STATE_INTERMEDIATE;
     hr = IMediaControl_Run(control);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     IMediaFilter_Release(filter);
     IMediaControl_Release(control);
     IMediaSeeking_Release(seeking);
     ref = IFilterGraph2_Release(graph);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 
     graph = create_graph();
     IFilterGraph2_QueryInterface(graph, &IID_IMediaFilter, (void **)&filter);
@@ -3825,23 +3828,23 @@ static void test_filter_state(void)
     sink.state_hr = S_FALSE;
     sink.GetState_hr = VFW_S_STATE_INTERMEDIATE;
     hr = IMediaFilter_Run(filter, 0);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IMediaFilter_GetState(filter, 0, &mf_state);
-    ok(hr == VFW_S_STATE_INTERMEDIATE, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_S_STATE_INTERMEDIATE, "Got hr %#x.\n", hr);
     ok(mf_state == State_Running, "Got state %u.\n", mf_state);
     ok(sink.state == State_Running, "Got state %u.\n", sink.state);
     ok(source.state == State_Running, "Got state %u.\n", source.state);
 
     sink.state_hr = sink.GetState_hr = S_OK;
     hr = IMediaFilter_GetState(filter, 0, &mf_state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(mf_state == State_Running, "Got state %u.\n", mf_state);
     ok(sink.state == State_Running, "Got state %u.\n", sink.state);
     ok(source.state == State_Running, "Got state %u.\n", source.state);
 
     hr = IMediaFilter_Stop(filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(sink.state == State_Stopped, "Got state %u.\n", sink.state);
     ok(source.state == State_Stopped, "Got state %u.\n", source.state);
 
@@ -3851,79 +3854,79 @@ static void test_filter_state(void)
 
     sink.GetState_hr = VFW_S_CANT_CUE;
     hr = IMediaControl_Pause(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_GetState(control, 0, &state);
-    ok(hr == VFW_S_CANT_CUE, "Got hr %#lx.\n", hr);
-    ok(state == State_Paused, "Got state %lu.\n", state);
+    ok(hr == VFW_S_CANT_CUE, "Got hr %#x.\n", hr);
+    ok(state == State_Paused, "Got state %u.\n", state);
 
     sink.GetState_hr = VFW_S_STATE_INTERMEDIATE;
     source.GetState_hr = VFW_S_CANT_CUE;
     hr = IMediaControl_GetState(control, 0, &state);
-    ok(hr == VFW_S_CANT_CUE, "Got hr %#lx.\n", hr);
-    ok(state == State_Paused, "Got state %lu.\n", state);
+    ok(hr == VFW_S_CANT_CUE, "Got hr %#x.\n", hr);
+    ok(state == State_Paused, "Got state %u.\n", state);
 
     sink.GetState_hr = VFW_S_CANT_CUE;
     source.GetState_hr = VFW_S_STATE_INTERMEDIATE;
     hr = IMediaControl_GetState(control, 0, &state);
-    ok(hr == VFW_S_CANT_CUE, "Got hr %#lx.\n", hr);
-    ok(state == State_Paused, "Got state %lu.\n", state);
+    ok(hr == VFW_S_CANT_CUE, "Got hr %#x.\n", hr);
+    ok(state == State_Paused, "Got state %u.\n", state);
 
     sink.GetState_hr = source.GetState_hr = S_OK;
 
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     sink.state_hr = S_FALSE;
     sink.GetState_hr = VFW_S_STATE_INTERMEDIATE;
     source.GetState_hr = VFW_S_CANT_CUE;
     hr = IMediaControl_Run(control);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     ok(sink.state == State_Running, "Got state %u.\n", sink.state);
     ok(source.state == State_Running, "Got state %u.\n", source.state);
 
     hr = IMediaControl_GetState(control, 0, &state);
-    ok(hr == VFW_S_CANT_CUE, "Got hr %#lx.\n", hr);
-    ok(state == State_Running, "Got state %lu.\n", state);
+    ok(hr == VFW_S_CANT_CUE, "Got hr %#x.\n", hr);
+    ok(state == State_Running, "Got state %u.\n", state);
     ok(sink.state == State_Running, "Got state %u.\n", sink.state);
     ok(source.state == State_Running, "Got state %u.\n", source.state);
 
     sink.state_hr = sink.GetState_hr = source.GetState_hr = S_OK;
 
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     /* Add and remove a filter while the graph is running. */
 
     hr = IFilterGraph2_AddFilter(graph, &dummy.IBaseFilter_iface, L"dummy");
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(dummy.state == State_Stopped, "Got state %#x.\n", dummy.state);
 
     hr = IMediaControl_Pause(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_filter_state(graph, State_Paused);
     ok(dummy.state == State_Paused, "Got state %#x.\n", dummy.state);
 
     hr = IFilterGraph2_RemoveFilter(graph, &dummy.IBaseFilter_iface);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(dummy.state == State_Paused, "Got state %#x.\n", dummy.state);
 
     hr = IFilterGraph2_AddFilter(graph, &dummy.IBaseFilter_iface, L"dummy");
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(dummy.state == State_Paused, "Got state %#x.\n", dummy.state);
 
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_filter_state(graph, State_Stopped);
 
     hr = IFilterGraph2_RemoveFilter(graph, &dummy.IBaseFilter_iface);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(dummy.state == State_Stopped, "Got state %#x.\n", dummy.state);
 
     /* Destroying the graph while it's running stops all filters. */
 
     hr = IMediaControl_Run(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_filter_state(graph, State_Running);
 
     source.expect_stop_prev = sink.expect_stop_prev = State_Running;
@@ -3931,11 +3934,11 @@ static void test_filter_state(void)
     IMediaControl_Release(control);
     IMediaSeeking_Release(seeking);
     ref = IFilterGraph2_Release(graph);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
-    ok(source.ref == 1, "Got outstanding refcount %ld.\n", source.ref);
-    ok(sink.ref == 1, "Got outstanding refcount %ld.\n", sink.ref);
-    ok(source_pin.ref == 1, "Got outstanding refcount %ld.\n", source_pin.ref);
-    ok(sink_pin.ref == 1, "Got outstanding refcount %ld.\n", sink_pin.ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    ok(source.ref == 1, "Got outstanding refcount %d.\n", source.ref);
+    ok(sink.ref == 1, "Got outstanding refcount %d.\n", sink.ref);
+    ok(source_pin.ref == 1, "Got outstanding refcount %d.\n", source_pin.ref);
+    ok(sink_pin.ref == 1, "Got outstanding refcount %d.\n", sink_pin.ref);
     ok(source.state == State_Stopped, "Got state %u.\n", source.state);
     ok(sink.state == State_Stopped, "Got state %u.\n", sink.state);
 }
@@ -3958,22 +3961,22 @@ static HRESULT check_ec_complete(IFilterGraph2 *graph, IBaseFilter *filter)
     IMediaControl_Run(control);
 
     hr = IMediaEvent_GetEvent(eventsrc, &code, &param1, &param2, 0);
-    ok(hr == E_ABORT, "Got hr %#lx.\n", hr);
+    ok(hr == E_ABORT, "Got hr %#x.\n", hr);
 
     hr = IMediaEventSink_Notify(eventsink, EC_COMPLETE, S_OK, (LONG_PTR)filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     ret_hr = IMediaEvent_GetEvent(eventsrc, &code, &param1, &param2, 0);
     if (ret_hr == S_OK)
     {
-        ok(code == EC_COMPLETE, "Got code %#lx.\n", code);
-        ok(param1 == S_OK, "Got param1 %#Ix.\n", param1);
-        ok(!param2, "Got param2 %#Ix.\n", param2);
+        ok(code == EC_COMPLETE, "Got code %#x.\n", code);
+        ok(param1 == S_OK, "Got param1 %#lx.\n", param1);
+        ok(!param2, "Got param2 %#lx.\n", param2);
         hr = IMediaEvent_FreeEventParams(eventsrc, code, param1, param2);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
 
         hr = IMediaEvent_GetEvent(eventsrc, &code, &param1, &param2, 0);
-        ok(hr == E_ABORT, "Got hr %#lx.\n", hr);
+        ok(hr == E_ABORT, "Got hr %#x.\n", hr);
     }
 
     IMediaControl_Stop(control);
@@ -3994,8 +3997,8 @@ static void test_ec_complete(void)
     LONG_PTR param1, param2;
     IMediaControl *control;
     IMediaEvent *eventsrc;
-    LONG code, ref;
     HRESULT hr;
+    LONG code;
 
     testsink_init(&filter1_pin);
     testsink_init(&filter2_pin);
@@ -4028,33 +4031,33 @@ static void test_ec_complete(void)
         ok(code != EC_COMPLETE, "Got unexpected EC_COMPLETE.\n");
         IMediaEvent_FreeEventParams(eventsrc, code, param1, param2);
     }
-    ok(hr == E_ABORT, "Got hr %#lx.\n", hr);
+    ok(hr == E_ABORT, "Got hr %#x.\n", hr);
 
     hr = IMediaEventSink_Notify(eventsink, EC_COMPLETE, S_OK, (LONG_PTR)&filter1.IBaseFilter_iface);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaEvent_GetEvent(eventsrc, &code, &param1, &param2, 50);
-    ok(hr == E_ABORT, "Got hr %#lx.\n", hr);
+    ok(hr == E_ABORT, "Got hr %#x.\n", hr);
 
     hr = IMediaEventSink_Notify(eventsink, EC_COMPLETE, S_OK, (LONG_PTR)&filter2.IBaseFilter_iface);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaEvent_GetEvent(eventsrc, &code, &param1, &param2, 0);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(code == EC_COMPLETE, "Got code %#lx.\n", code);
-    ok(param1 == S_OK, "Got param1 %#Ix.\n", param1);
-    ok(!param2, "Got param2 %#Ix.\n", param2);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(code == EC_COMPLETE, "Got code %#x.\n", code);
+    ok(param1 == S_OK, "Got param1 %#lx.\n", param1);
+    ok(!param2, "Got param2 %#lx.\n", param2);
     hr = IMediaEvent_FreeEventParams(eventsrc, code, param1, param2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaEvent_GetEvent(eventsrc, &code, &param1, &param2, 50);
-    ok(hr == E_ABORT, "Got hr %#lx.\n", hr);
+    ok(hr == E_ABORT, "Got hr %#x.\n", hr);
 
     hr = IMediaEventSink_Notify(eventsink, EC_COMPLETE, S_OK, (LONG_PTR)&filter3.IBaseFilter_iface);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaEvent_GetEvent(eventsrc, &code, &param1, &param2, 50);
-    ok(hr == E_ABORT, "Got hr %#lx.\n", hr);
+    ok(hr == E_ABORT, "Got hr %#x.\n", hr);
 
     IMediaControl_Stop(control);
 
@@ -4063,42 +4066,42 @@ static void test_ec_complete(void)
     IMediaControl_Run(control);
 
     hr = IMediaEvent_CancelDefaultHandling(eventsrc, EC_COMPLETE);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaEvent_GetEvent(eventsrc, &code, &param1, &param2, 50);
-    ok(hr == E_ABORT, "Got hr %#lx.\n", hr);
+    ok(hr == E_ABORT, "Got hr %#x.\n", hr);
 
     hr = IMediaEventSink_Notify(eventsink, EC_COMPLETE, S_OK, (LONG_PTR)&filter1.IBaseFilter_iface);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaEvent_GetEvent(eventsrc, &code, &param1, &param2, 0);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(code == EC_COMPLETE, "Got code %#lx.\n", code);
-    ok(param1 == S_OK, "Got param1 %#Ix.\n", param1);
-    ok(param2 == (LONG_PTR)&filter1.IBaseFilter_iface, "Got param2 %#Ix.\n", param2);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(code == EC_COMPLETE, "Got code %#x.\n", code);
+    ok(param1 == S_OK, "Got param1 %#lx.\n", param1);
+    ok(param2 == (LONG_PTR)&filter1.IBaseFilter_iface, "Got param2 %#lx.\n", param2);
     hr = IMediaEvent_FreeEventParams(eventsrc, code, param1, param2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaEvent_GetEvent(eventsrc, &code, &param1, &param2, 50);
-    ok(hr == E_ABORT, "Got hr %#lx.\n", hr);
+    ok(hr == E_ABORT, "Got hr %#x.\n", hr);
 
     hr = IMediaEventSink_Notify(eventsink, EC_COMPLETE, S_OK, (LONG_PTR)&filter3.IBaseFilter_iface);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaEvent_GetEvent(eventsrc, &code, &param1, &param2, 0);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(code == EC_COMPLETE, "Got code %#lx.\n", code);
-    ok(param1 == S_OK, "Got param1 %#Ix.\n", param1);
-    ok(param2 == (LONG_PTR)&filter3.IBaseFilter_iface, "Got param2 %#Ix.\n", param2);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(code == EC_COMPLETE, "Got code %#x.\n", code);
+    ok(param1 == S_OK, "Got param1 %#lx.\n", param1);
+    ok(param2 == (LONG_PTR)&filter3.IBaseFilter_iface, "Got param2 %#lx.\n", param2);
     hr = IMediaEvent_FreeEventParams(eventsrc, code, param1, param2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaEvent_GetEvent(eventsrc, &code, &param1, &param2, 50);
-    ok(hr == E_ABORT, "Got hr %#lx.\n", hr);
+    ok(hr == E_ABORT, "Got hr %#x.\n", hr);
 
     IMediaControl_Stop(control);
     hr = IMediaEvent_RestoreDefaultHandling(eventsrc, EC_COMPLETE);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     /* A filter counts as a renderer if it (1) exposes IAMFilterMiscFlags and
      * reports itself as a renderer, or (2) exposes IMediaSeeking or
@@ -4112,7 +4115,7 @@ static void test_ec_complete(void)
     IFilterGraph2_AddFilter(graph, &filter1.IBaseFilter_iface, NULL);
 
     hr = check_ec_complete(graph, &filter1.IBaseFilter_iface);
-    ok(hr == E_ABORT, "Got hr %#lx.\n", hr);
+    ok(hr == E_ABORT, "Got hr %#x.\n", hr);
 
     IFilterGraph2_RemoveFilter(graph, &filter1.IBaseFilter_iface);
     filter1_pin.dir = PINDIR_INPUT;
@@ -4121,37 +4124,37 @@ static void test_ec_complete(void)
     IFilterGraph2_AddFilter(graph, &filter1.IBaseFilter_iface, NULL);
 
     hr = check_ec_complete(graph, &filter1.IBaseFilter_iface);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
-    ok(filter1.seeking_ref > 0, "Unexpected seeking refcount %ld.\n", filter1.seeking_ref);
+    ok(filter1.seeking_ref > 0, "Unexpected seeking refcount %d.\n", filter1.seeking_ref);
     IFilterGraph2_RemoveFilter(graph, &filter1.IBaseFilter_iface);
-    ok(filter1.seeking_ref == 0, "Unexpected seeking refcount %ld.\n", filter1.seeking_ref);
+    ok(filter1.seeking_ref == 0, "Unexpected seeking refcount %d.\n", filter1.seeking_ref);
 
     filter1_pin.dir = PINDIR_OUTPUT;
     IFilterGraph2_AddFilter(graph, &filter1.IBaseFilter_iface, NULL);
 
     hr = check_ec_complete(graph, &filter1.IBaseFilter_iface);
-    ok(hr == E_ABORT, "Got hr %#lx.\n", hr);
+    ok(hr == E_ABORT, "Got hr %#x.\n", hr);
 
-    ok(filter1.seeking_ref > 0, "Unexpected seeking refcount %ld.\n", filter1.seeking_ref);
+    ok(filter1.seeking_ref > 0, "Unexpected seeking refcount %d.\n", filter1.seeking_ref);
     IFilterGraph2_RemoveFilter(graph, &filter1.IBaseFilter_iface);
-    ok(filter1.seeking_ref == 0, "Unexpected seeking refcount %ld.\n", filter1.seeking_ref);
+    ok(filter1.seeking_ref == 0, "Unexpected seeking refcount %d.\n", filter1.seeking_ref);
 
     filter1_pin.dir = PINDIR_INPUT;
     filter1.support_media_time = FALSE;
     IFilterGraph2_AddFilter(graph, &filter1.IBaseFilter_iface, NULL);
 
     hr = check_ec_complete(graph, &filter1.IBaseFilter_iface);
-    ok(hr == E_ABORT, "Got hr %#lx.\n", hr);
+    ok(hr == E_ABORT, "Got hr %#x.\n", hr);
 
-    ok(filter1.seeking_ref == 0, "Unexpected seeking refcount %ld.\n", filter1.seeking_ref);
+    ok(filter1.seeking_ref == 0, "Unexpected seeking refcount %d.\n", filter1.seeking_ref);
     IFilterGraph2_RemoveFilter(graph, &filter1.IBaseFilter_iface);
 
     filter1.IMediaPosition_iface.lpVtbl = &testpos_vtbl;
     IFilterGraph2_AddFilter(graph, &filter1.IBaseFilter_iface, NULL);
 
     hr = check_ec_complete(graph, &filter1.IBaseFilter_iface);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     IFilterGraph2_RemoveFilter(graph, &filter1.IBaseFilter_iface);
 
@@ -4163,7 +4166,7 @@ static void test_ec_complete(void)
     IFilterGraph2_AddFilter(graph, &filter1.IBaseFilter_iface, NULL);
 
     hr = check_ec_complete(graph, &filter1.IBaseFilter_iface);
-    ok(hr == E_ABORT, "Got hr %#lx.\n", hr);
+    ok(hr == E_ABORT, "Got hr %#x.\n", hr);
 
     IFilterGraph2_RemoveFilter(graph, &filter1.IBaseFilter_iface);
 
@@ -4171,16 +4174,16 @@ static void test_ec_complete(void)
     IFilterGraph2_AddFilter(graph, &filter1.IBaseFilter_iface, NULL);
 
     hr = check_ec_complete(graph, &filter1.IBaseFilter_iface);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     IMediaControl_Release(control);
     IMediaEvent_Release(eventsrc);
     IMediaEventSink_Release(eventsink);
-    ref = IFilterGraph2_Release(graph);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
-    ok(filter1.ref == 1, "Got outstanding refcount %ld.\n", filter1.ref);
-    ok(filter2.ref == 1, "Got outstanding refcount %ld.\n", filter2.ref);
-    ok(filter3.ref == 1, "Got outstanding refcount %ld.\n", filter3.ref);
+    hr = IFilterGraph2_Release(graph);
+    ok(!hr, "Got outstanding refcount %d.\n", hr);
+    ok(filter1.ref == 1, "Got outstanding refcount %d.\n", filter1.ref);
+    ok(filter2.ref == 1, "Got outstanding refcount %d.\n", filter2.ref);
+    ok(filter3.ref == 1, "Got outstanding refcount %d.\n", filter3.ref);
 }
 
 static void test_renderfile_failure(void)
@@ -4202,28 +4205,28 @@ static void test_renderfile_failure(void)
     graph = create_graph();
     testfilter_init(&testfilter, NULL, 0);
     hr = IFilterGraph2_AddFilter(graph, &testfilter.IBaseFilter_iface, L"dummy");
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     filename = create_file(L"test.nonsense", bogus_data, sizeof(bogus_data));
     hr = IFilterGraph2_RenderFile(graph, filename, NULL);
-    todo_wine ok(hr == VFW_E_UNSUPPORTED_STREAM, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == VFW_E_UNSUPPORTED_STREAM, "Got hr %#x.\n", hr);
 
     hr = IFilterGraph2_EnumFilters(graph, &filterenum);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumFilters_Next(filterenum, 1, &filter, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(filter == &testfilter.IBaseFilter_iface, "Got unexpected filter %p.\n", filter);
 
     hr = IEnumFilters_Next(filterenum, 1, &filter, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     IEnumFilters_Release(filterenum);
 
     ref = IFilterGraph2_Release(graph);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ret = DeleteFileW(filename);
-    ok(ret, "Failed to delete %s, error %lu.\n", debugstr_w(filename), GetLastError());
+    ok(ret, "Failed to delete %s, error %u.\n", debugstr_w(filename), GetLastError());
 }
 
 /* Remove and re-add the filter, to flush the graph's internal
@@ -4284,156 +4287,156 @@ static void test_graph_seeking(void)
     IFilterGraph2_QueryInterface(graph, &IID_IMediaEventSink, (void **)&eventsink);
 
     hr = IMediaSeeking_GetCapabilities(seeking, &caps);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    todo_wine ok(!caps, "Got caps %#lx.\n", caps);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
+    todo_wine ok(!caps, "Got caps %#x.\n", caps);
 
     caps = 0;
     hr = IMediaSeeking_CheckCapabilities(seeking, &caps);
-    todo_wine ok(hr == E_FAIL, "Got hr %#lx.\n", hr);
-    ok(!caps, "Got caps %#lx.\n", caps);
+    todo_wine ok(hr == E_FAIL, "Got hr %#x.\n", hr);
+    ok(!caps, "Got caps %#x.\n", caps);
 
     caps = AM_SEEKING_CanSeekAbsolute;
     hr = IMediaSeeking_CheckCapabilities(seeking, &caps);
-    todo_wine ok(hr == E_FAIL, "Got hr %#lx.\n", hr);
-    todo_wine ok(!caps, "Got caps %#lx.\n", caps);
+    todo_wine ok(hr == E_FAIL, "Got hr %#x.\n", hr);
+    todo_wine ok(!caps, "Got caps %#x.\n", caps);
 
     hr = IMediaSeeking_IsFormatSupported(seeking, NULL);
-    todo_wine ok(hr == E_NOTIMPL, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == E_NOTIMPL, "Got hr %#x.\n", hr);
 
     for (i = 0; i < ARRAY_SIZE(all_formats); ++i)
     {
         hr = IMediaSeeking_IsFormatSupported(seeking, all_formats[i]);
-        todo_wine ok(hr == E_NOTIMPL, "Got hr %#lx for format %s.\n", hr, wine_dbgstr_guid(all_formats[i]));
+        todo_wine ok(hr == E_NOTIMPL, "Got hr %#x for format %s.\n", hr, wine_dbgstr_guid(all_formats[i]));
     }
 
     hr = IMediaSeeking_QueryPreferredFormat(seeking, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
     hr = IMediaSeeking_QueryPreferredFormat(seeking, &format);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(IsEqualGUID(&format, &TIME_FORMAT_MEDIA_TIME), "Got format %s.\n", wine_dbgstr_guid(&format));
 
     hr = IMediaSeeking_GetTimeFormat(seeking, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
     hr = IMediaSeeking_GetTimeFormat(seeking, &format);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(IsEqualGUID(&format, &TIME_FORMAT_MEDIA_TIME), "Got format %s.\n", wine_dbgstr_guid(&format));
 
     hr = IMediaSeeking_IsUsingTimeFormat(seeking, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
     hr = IMediaSeeking_IsUsingTimeFormat(seeking, &TIME_FORMAT_MEDIA_TIME);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMediaSeeking_IsUsingTimeFormat(seeking, &TIME_FORMAT_NONE);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IMediaSeeking_SetTimeFormat(seeking, &TIME_FORMAT_NONE);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaSeeking_QueryPreferredFormat(seeking, &format);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(IsEqualGUID(&format, &TIME_FORMAT_MEDIA_TIME), "Got format %s.\n", wine_dbgstr_guid(&format));
 
     hr = IMediaSeeking_IsUsingTimeFormat(seeking, &TIME_FORMAT_MEDIA_TIME);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMediaSeeking_IsUsingTimeFormat(seeking, &TIME_FORMAT_NONE);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IMediaSeeking_GetTimeFormat(seeking, &format);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(IsEqualGUID(&format, &TIME_FORMAT_MEDIA_TIME), "Got format %s.\n", wine_dbgstr_guid(&format));
 
     hr = IMediaSeeking_SetTimeFormat(seeking, &TIME_FORMAT_MEDIA_TIME);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     for (i = 0; i < ARRAY_SIZE(unsupported_formats); ++i)
     {
         hr = IMediaSeeking_SetTimeFormat(seeking, unsupported_formats[i]);
-        todo_wine ok(hr == E_NOTIMPL, "Got hr %#lx for format %s.\n", hr, wine_dbgstr_guid(unsupported_formats[i]));
+        todo_wine ok(hr == E_NOTIMPL, "Got hr %#x for format %s.\n", hr, wine_dbgstr_guid(unsupported_formats[i]));
     }
 
     time = 0xdeadbeef;
     hr = IMediaSeeking_ConvertTimeFormat(seeking, &time, NULL, 0x123456789a, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(time == 0x123456789a, "Got time %s.\n", wine_dbgstr_longlong(time));
 
     time = 0xdeadbeef;
     hr = IMediaSeeking_ConvertTimeFormat(seeking, &time, &TIME_FORMAT_MEDIA_TIME, 0x123456789a, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(time == 0x123456789a, "Got time %s.\n", wine_dbgstr_longlong(time));
 
     time = 0xdeadbeef;
     hr = IMediaSeeking_ConvertTimeFormat(seeking, &time, NULL, 0x123456789a, &TIME_FORMAT_MEDIA_TIME);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(time == 0x123456789a, "Got time %s.\n", wine_dbgstr_longlong(time));
 
     time = 0xdeadbeef;
     hr = IMediaSeeking_ConvertTimeFormat(seeking, &time, &TIME_FORMAT_MEDIA_TIME, 0x123456789a, &TIME_FORMAT_MEDIA_TIME);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(time == 0x123456789a, "Got time %s.\n", wine_dbgstr_longlong(time));
 
     hr = IMediaSeeking_ConvertTimeFormat(seeking, &time, &TIME_FORMAT_NONE, 0x123456789a, &TIME_FORMAT_MEDIA_TIME);
-    todo_wine ok(hr == E_NOTIMPL, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == E_NOTIMPL, "Got hr %#x.\n", hr);
     hr = IMediaSeeking_ConvertTimeFormat(seeking, &time, &TIME_FORMAT_NONE, 0x123456789a, NULL);
-    todo_wine ok(hr == E_NOTIMPL, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == E_NOTIMPL, "Got hr %#x.\n", hr);
     hr = IMediaSeeking_ConvertTimeFormat(seeking, &time, &TIME_FORMAT_MEDIA_TIME, 0x123456789a, &TIME_FORMAT_NONE);
-    todo_wine ok(hr == E_NOTIMPL, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == E_NOTIMPL, "Got hr %#x.\n", hr);
     hr = IMediaSeeking_ConvertTimeFormat(seeking, &time, NULL, 0x123456789a, &TIME_FORMAT_NONE);
-    todo_wine ok(hr == E_NOTIMPL, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == E_NOTIMPL, "Got hr %#x.\n", hr);
 
     time = 0xdeadbeef;
     hr = IMediaSeeking_ConvertTimeFormat(seeking, &time, &TIME_FORMAT_NONE, 0x123456789a, &TIME_FORMAT_NONE);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(time == 0x123456789a, "Got time %s.\n", wine_dbgstr_longlong(time));
 
     time = 0xdeadbeef;
     hr = IMediaSeeking_ConvertTimeFormat(seeking, &time, &testguid, 0x123456789a, &testguid);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(time == 0x123456789a, "Got time %s.\n", wine_dbgstr_longlong(time));
 
     hr = IMediaSeeking_GetDuration(seeking, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
     hr = IMediaSeeking_GetDuration(seeking, &time);
-    ok(hr == E_NOTIMPL, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOTIMPL, "Got hr %#x.\n", hr);
 
     hr = IMediaSeeking_GetStopPosition(seeking, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
     hr = IMediaSeeking_GetStopPosition(seeking, &time);
-    ok(hr == E_NOTIMPL, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOTIMPL, "Got hr %#x.\n", hr);
 
     hr = IMediaSeeking_SetPositions(seeking, &current, 0, &stop, 0);
-    ok(hr == E_NOTIMPL, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOTIMPL, "Got hr %#x.\n", hr);
 
     hr = IMediaSeeking_GetPositions(seeking, NULL, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMediaSeeking_GetPositions(seeking, NULL, &stop);
-    ok(hr == E_NOTIMPL, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOTIMPL, "Got hr %#x.\n", hr);
     hr = IMediaSeeking_GetPositions(seeking, &current, &stop);
-    ok(hr == E_NOTIMPL, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOTIMPL, "Got hr %#x.\n", hr);
     current = 0xdeadbeef;
     hr = IMediaSeeking_GetPositions(seeking, &current, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(!current, "Got time %s.\n", wine_dbgstr_longlong(time));
 
     hr = IMediaSeeking_GetCurrentPosition(seeking, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
     current = 0xdeadbeef;
     hr = IMediaSeeking_GetCurrentPosition(seeking, &current);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(!current, "Got time %s.\n", wine_dbgstr_longlong(time));
 
     hr = IMediaSeeking_GetAvailable(seeking, &earliest, &latest);
-    todo_wine ok(hr == E_NOTIMPL, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == E_NOTIMPL, "Got hr %#x.\n", hr);
 
     hr = IMediaSeeking_SetRate(seeking, 1.0);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMediaSeeking_SetRate(seeking, 2.0);
-    todo_wine ok(hr == E_NOTIMPL, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == E_NOTIMPL, "Got hr %#x.\n", hr);
 
     hr = IMediaSeeking_GetRate(seeking, &rate);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(rate == 1.0, "Got rate %.16e.\n", rate);
 
     hr = IMediaSeeking_GetPreroll(seeking, &time);
-    todo_wine ok(hr == E_NOTIMPL, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == E_NOTIMPL, "Got hr %#x.\n", hr);
 
     /* Try with filters added. Note that a filter need only expose
      * IMediaSeeking—no other heuristics are used to determine if it is a
@@ -4445,10 +4448,10 @@ static void test_graph_seeking(void)
     filter1.support_testguid = TRUE;
 
     hr = IMediaSeeking_GetDuration(seeking, &time);
-    ok(hr == E_NOTIMPL, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOTIMPL, "Got hr %#x.\n", hr);
 
     hr = IMediaSeeking_SetTimeFormat(seeking, &testguid);
-    todo_wine ok(hr == E_NOTIMPL, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == E_NOTIMPL, "Got hr %#x.\n", hr);
 
     IFilterGraph2_RemoveFilter(graph, &filter1.IBaseFilter_iface);
     filter1.support_media_time = TRUE;
@@ -4462,91 +4465,91 @@ static void test_graph_seeking(void)
     filter1.seek_caps = AM_SEEKING_CanDoSegments | AM_SEEKING_CanGetCurrentPos;
     filter2.seek_caps = AM_SEEKING_CanDoSegments | AM_SEEKING_CanGetDuration;
     hr = IMediaSeeking_GetCapabilities(seeking, &caps);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(caps == AM_SEEKING_CanDoSegments, "Got caps %#lx.\n", caps);
-    ok(filter1.seeking_ref > 0, "Unexpected seeking refcount %ld.\n", filter1.seeking_ref);
-    ok(filter2.seeking_ref > 0, "Unexpected seeking refcount %ld.\n", filter2.seeking_ref);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(caps == AM_SEEKING_CanDoSegments, "Got caps %#x.\n", caps);
+    ok(filter1.seeking_ref > 0, "Unexpected seeking refcount %d.\n", filter1.seeking_ref);
+    ok(filter2.seeking_ref > 0, "Unexpected seeking refcount %d.\n", filter2.seeking_ref);
 
     flush_cached_seeking(graph, &filter1);
     flush_cached_seeking(graph, &filter2);
 
     caps = AM_SEEKING_CanDoSegments | AM_SEEKING_CanGetCurrentPos;
     hr = IMediaSeeking_CheckCapabilities(seeking, &caps);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
-    ok(caps == AM_SEEKING_CanDoSegments, "Got caps %#lx.\n", caps);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    ok(caps == AM_SEEKING_CanDoSegments, "Got caps %#x.\n", caps);
 
     caps = AM_SEEKING_CanDoSegments;
     hr = IMediaSeeking_CheckCapabilities(seeking, &caps);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(caps == AM_SEEKING_CanDoSegments, "Got caps %#lx.\n", caps);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(caps == AM_SEEKING_CanDoSegments, "Got caps %#x.\n", caps);
 
     caps = AM_SEEKING_CanGetCurrentPos;
     hr = IMediaSeeking_CheckCapabilities(seeking, &caps);
-    ok(hr == E_FAIL, "Got hr %#lx.\n", hr);
-    ok(!caps, "Got caps %#lx.\n", caps);
+    ok(hr == E_FAIL, "Got hr %#x.\n", hr);
+    ok(!caps, "Got caps %#x.\n", caps);
 
     flush_cached_seeking(graph, &filter1);
     flush_cached_seeking(graph, &filter2);
 
     hr = IMediaSeeking_IsFormatSupported(seeking, &testguid);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     filter1.support_testguid = TRUE;
     hr = IMediaSeeking_IsFormatSupported(seeking, &testguid);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     filter1.support_testguid = FALSE;
     filter2.support_testguid = TRUE;
     hr = IMediaSeeking_IsFormatSupported(seeking, &testguid);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     /* Filters are not consulted about preferred formats. */
     hr = IMediaSeeking_QueryPreferredFormat(seeking, &format);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(IsEqualGUID(&format, &TIME_FORMAT_MEDIA_TIME), "Got format %s.\n", wine_dbgstr_guid(&format));
 
     hr = IMediaSeeking_GetTimeFormat(seeking, &format);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(IsEqualGUID(&format, &TIME_FORMAT_MEDIA_TIME), "Got format %s.\n", wine_dbgstr_guid(&format));
 
     filter2.support_testguid = FALSE;
     hr = IMediaSeeking_SetTimeFormat(seeking, &testguid);
-    todo_wine ok(hr == E_FAIL, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == E_FAIL, "Got hr %#x.\n", hr);
 
     hr = IMediaSeeking_GetTimeFormat(seeking, &format);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(IsEqualGUID(&format, &TIME_FORMAT_MEDIA_TIME), "Got format %s.\n", wine_dbgstr_guid(&format));
 
     filter1.support_testguid = TRUE;
     hr = IMediaSeeking_SetTimeFormat(seeking, &testguid);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
     todo_wine ok(IsEqualGUID(&filter1.time_format, &testguid), "Got format %s.\n",
             debugstr_guid(&filter1.time_format));
     ok(IsEqualGUID(&filter2.time_format, &TIME_FORMAT_MEDIA_TIME),
             "Got format %s.\n", debugstr_guid(&filter2.time_format));
 
     hr = IMediaSeeking_GetTimeFormat(seeking, &format);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     todo_wine ok(IsEqualGUID(&format, &testguid), "Got format %s.\n", wine_dbgstr_guid(&format));
 
     hr = IMediaSeeking_QueryPreferredFormat(seeking, &format);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(IsEqualGUID(&format, &TIME_FORMAT_MEDIA_TIME), "Got format %s.\n", wine_dbgstr_guid(&format));
 
     hr = IMediaSeeking_IsUsingTimeFormat(seeking, &TIME_FORMAT_MEDIA_TIME);
-    todo_wine ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     hr = IMediaSeeking_IsUsingTimeFormat(seeking, &testguid);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaSeeking_GetCapabilities(seeking, &caps);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(caps == AM_SEEKING_CanDoSegments, "Got caps %#lx.\n", caps);
-    ok(filter1.seeking_ref > 0, "Unexpected seeking refcount %ld.\n", filter1.seeking_ref);
-    ok(filter2.seeking_ref > 0, "Unexpected seeking refcount %ld.\n", filter2.seeking_ref);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(caps == AM_SEEKING_CanDoSegments, "Got caps %#x.\n", caps);
+    ok(filter1.seeking_ref > 0, "Unexpected seeking refcount %d.\n", filter1.seeking_ref);
+    ok(filter2.seeking_ref > 0, "Unexpected seeking refcount %d.\n", filter2.seeking_ref);
 
     filter2.support_testguid = TRUE;
     hr = IMediaSeeking_SetTimeFormat(seeking, &testguid);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(IsEqualGUID(&filter1.time_format, &TIME_FORMAT_MEDIA_TIME),
             "Got format %s.\n", debugstr_guid(&filter1.time_format));
     todo_wine ok(IsEqualGUID(&filter2.time_format, &testguid),
@@ -4556,43 +4559,43 @@ static void test_graph_seeking(void)
     flush_cached_seeking(graph, &filter1);
 
     hr = IMediaSeeking_GetCapabilities(seeking, &caps);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(caps == (AM_SEEKING_CanDoSegments | AM_SEEKING_CanGetDuration), "Got caps %#lx.\n", caps);
-    ok(!filter1.seeking_ref, "Unexpected seeking refcount %ld.\n", filter1.seeking_ref);
-    ok(filter2.seeking_ref > 0, "Unexpected seeking refcount %ld.\n", filter2.seeking_ref);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(caps == (AM_SEEKING_CanDoSegments | AM_SEEKING_CanGetDuration), "Got caps %#x.\n", caps);
+    ok(!filter1.seeking_ref, "Unexpected seeking refcount %d.\n", filter1.seeking_ref);
+    ok(filter2.seeking_ref > 0, "Unexpected seeking refcount %d.\n", filter2.seeking_ref);
 
     filter1.support_media_time = TRUE;
     filter1.support_testguid = FALSE;
     flush_cached_seeking(graph, &filter1);
 
     hr = IMediaSeeking_GetCapabilities(seeking, &caps);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(caps == AM_SEEKING_CanDoSegments, "Got caps %#lx.\n", caps);
-    ok(filter1.seeking_ref > 0, "Unexpected seeking refcount %ld.\n", filter1.seeking_ref);
-    ok(filter2.seeking_ref > 0, "Unexpected seeking refcount %ld.\n", filter2.seeking_ref);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(caps == AM_SEEKING_CanDoSegments, "Got caps %#x.\n", caps);
+    ok(filter1.seeking_ref > 0, "Unexpected seeking refcount %d.\n", filter1.seeking_ref);
+    ok(filter2.seeking_ref > 0, "Unexpected seeking refcount %d.\n", filter2.seeking_ref);
 
     ok(IsEqualGUID(&filter1.time_format, &TIME_FORMAT_MEDIA_TIME),
             "Got format %s.\n", debugstr_guid(&filter1.time_format));
     todo_wine ok(IsEqualGUID(&filter2.time_format, &testguid),
             "Got format %s.\n", debugstr_guid(&filter2.time_format));
     hr = IMediaSeeking_GetTimeFormat(seeking, &format);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     todo_wine ok(IsEqualGUID(&format, &testguid), "Got format %s.\n", wine_dbgstr_guid(&format));
 
     hr = IMediaSeeking_SetTimeFormat(seeking, &TIME_FORMAT_NONE);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaSeeking_GetTimeFormat(seeking, &format);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(IsEqualGUID(&format, &TIME_FORMAT_MEDIA_TIME), "Got format %s.\n", wine_dbgstr_guid(&format));
 
     time = 0xdeadbeef;
     hr = IMediaSeeking_ConvertTimeFormat(seeking, &time, &testguid, 0x123456789a, &testguid);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(time == 0x123456789a, "Got time %s.\n", wine_dbgstr_longlong(time));
 
     hr = IMediaSeeking_ConvertTimeFormat(seeking, &time, &testguid, 0x123456789a, &TIME_FORMAT_NONE);
-    todo_wine ok(hr == E_NOTIMPL, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == E_NOTIMPL, "Got hr %#x.\n", hr);
 
     flush_cached_seeking(graph, &filter1);
     flush_cached_seeking(graph, &filter2);
@@ -4600,33 +4603,33 @@ static void test_graph_seeking(void)
     filter1.seek_duration = 0x12345;
     filter2.seek_duration = 0x23456;
     hr = IMediaSeeking_GetDuration(seeking, &time);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(time == 0x23456, "Got time %s.\n", wine_dbgstr_longlong(time));
 
     filter2.seek_duration = 0x12345;
     filter1.seek_duration = 0x23456;
     hr = IMediaSeeking_GetDuration(seeking, &time);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(time == 0x23456, "Got time %s.\n", wine_dbgstr_longlong(time));
 
     filter1.seek_hr = filter2.seek_hr = 0xbeef;
     hr = IMediaSeeking_GetDuration(seeking, &time);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(time == 0x23456, "Got time %s.\n", wine_dbgstr_longlong(time));
 
     filter1.seek_hr = E_NOTIMPL;
     filter2.seek_hr = S_OK;
     hr = IMediaSeeking_GetDuration(seeking, &time);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(time == 0x12345, "Got time %s.\n", wine_dbgstr_longlong(time));
 
     filter1.seek_hr = 0xdeadbeef;
     hr = IMediaSeeking_GetDuration(seeking, &time);
-    ok(hr == 0xdeadbeef, "Got hr %#lx.\n", hr);
+    ok(hr == 0xdeadbeef, "Got hr %#x.\n", hr);
 
     filter1.seek_hr = filter2.seek_hr = E_NOTIMPL;
     hr = IMediaSeeking_GetDuration(seeking, &time);
-    ok(hr == E_NOTIMPL, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOTIMPL, "Got hr %#x.\n", hr);
     filter1.seek_hr = filter2.seek_hr = S_OK;
 
     flush_cached_seeking(graph, &filter1);
@@ -4635,40 +4638,40 @@ static void test_graph_seeking(void)
     filter1.seek_stop = 0x54321;
     filter2.seek_stop = 0x65432;
     hr = IMediaSeeking_GetStopPosition(seeking, &time);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(time == 0x65432, "Got time %s.\n", wine_dbgstr_longlong(time));
 
     filter2.seek_stop = 0x54321;
     filter1.seek_stop = 0x65432;
     hr = IMediaSeeking_GetStopPosition(seeking, &time);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(time == 0x65432, "Got time %s.\n", wine_dbgstr_longlong(time));
 
     filter1.seek_hr = filter2.seek_hr = 0xbeef;
     hr = IMediaSeeking_GetStopPosition(seeking, &time);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(time == 0x65432, "Got time %s.\n", wine_dbgstr_longlong(time));
 
     filter1.seek_hr = E_NOTIMPL;
     filter2.seek_hr = S_OK;
     hr = IMediaSeeking_GetStopPosition(seeking, &time);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(time == 0x54321, "Got time %s.\n", wine_dbgstr_longlong(time));
 
     filter1.seek_hr = 0xdeadbeef;
     hr = IMediaSeeking_GetStopPosition(seeking, &time);
-    ok(hr == 0xdeadbeef, "Got hr %#lx.\n", hr);
+    ok(hr == 0xdeadbeef, "Got hr %#x.\n", hr);
 
     filter1.seek_hr = filter2.seek_hr = E_NOTIMPL;
     hr = IMediaSeeking_GetStopPosition(seeking, &time);
-    ok(hr == E_NOTIMPL, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOTIMPL, "Got hr %#x.\n", hr);
     filter1.seek_hr = filter2.seek_hr = S_OK;
 
     flush_cached_seeking(graph, &filter1);
     flush_cached_seeking(graph, &filter2);
 
     hr = IMediaSeeking_GetCurrentPosition(seeking, &time);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(!time, "Got time %s.\n", wine_dbgstr_longlong(time));
 
     flush_cached_seeking(graph, &filter1);
@@ -4676,7 +4679,7 @@ static void test_graph_seeking(void)
 
     current = stop = 0xdeadbeef;
     hr = IMediaSeeking_GetPositions(seeking, &current, &stop);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(!current, "Got time %s.\n", wine_dbgstr_longlong(current));
     ok(stop == 0x65432, "Got time %s.\n", wine_dbgstr_longlong(stop));
 
@@ -4687,7 +4690,7 @@ static void test_graph_seeking(void)
     stop = 0x321;
     hr = IMediaSeeking_SetPositions(seeking, &current, AM_SEEKING_AbsolutePositioning,
             &stop, AM_SEEKING_AbsolutePositioning);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(current == 0x123, "Got time %s.\n", wine_dbgstr_longlong(current));
     ok(stop == 0x321, "Got time %s.\n", wine_dbgstr_longlong(stop));
     ok(filter1.seek_current == 0x123, "Got time %s.\n", wine_dbgstr_longlong(filter1.seek_current));
@@ -4698,32 +4701,32 @@ static void test_graph_seeking(void)
     filter1.seek_hr = filter2.seek_hr = 0xbeef;
     hr = IMediaSeeking_SetPositions(seeking, &current, AM_SEEKING_AbsolutePositioning,
             &stop, AM_SEEKING_AbsolutePositioning);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     filter1.seek_hr = E_NOTIMPL;
     filter2.seek_hr = S_OK;
     hr = IMediaSeeking_SetPositions(seeking, &current, AM_SEEKING_AbsolutePositioning,
             &stop, AM_SEEKING_AbsolutePositioning);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     filter1.seek_hr = 0xdeadbeef;
     hr = IMediaSeeking_SetPositions(seeking, &current, AM_SEEKING_AbsolutePositioning,
             &stop, AM_SEEKING_AbsolutePositioning);
-    ok(hr == 0xdeadbeef, "Got hr %#lx.\n", hr);
+    ok(hr == 0xdeadbeef, "Got hr %#x.\n", hr);
 
     filter1.seek_hr = filter2.seek_hr = E_NOTIMPL;
     hr = IMediaSeeking_SetPositions(seeking, &current, AM_SEEKING_AbsolutePositioning,
             &stop, AM_SEEKING_AbsolutePositioning);
-    ok(hr == E_NOTIMPL, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOTIMPL, "Got hr %#x.\n", hr);
     filter1.seek_hr = filter2.seek_hr = S_OK;
 
     hr = IMediaSeeking_GetCurrentPosition(seeking, &time);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(time == 12340000, "Got time %s.\n", wine_dbgstr_longlong(time));
 
     current = stop = 0xdeadbeef;
     hr = IMediaSeeking_GetPositions(seeking, &current, &stop);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(current == 12340000, "Got time %s.\n", wine_dbgstr_longlong(current));
     ok(stop == 0x321, "Got time %s.\n", wine_dbgstr_longlong(stop));
 
@@ -4731,7 +4734,7 @@ static void test_graph_seeking(void)
     stop = 0x321;
     hr = IMediaSeeking_SetPositions(seeking, &current, AM_SEEKING_AbsolutePositioning | AM_SEEKING_ReturnTime,
             &stop, AM_SEEKING_AbsolutePositioning);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(current == 12340000, "Got time %s.\n", wine_dbgstr_longlong(current));
     ok(stop == 0x321, "Got time %s.\n", wine_dbgstr_longlong(stop));
     ok(filter1.seek_current == 12340000, "Got time %s.\n", wine_dbgstr_longlong(filter1.seek_current));
@@ -4743,7 +4746,7 @@ static void test_graph_seeking(void)
     stop = 0x321;
     hr = IMediaSeeking_SetPositions(seeking, &current, AM_SEEKING_AbsolutePositioning,
             &stop, AM_SEEKING_AbsolutePositioning | AM_SEEKING_ReturnTime);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(current == 0x123, "Got time %s.\n", wine_dbgstr_longlong(current));
     ok(stop == 43210000, "Got time %s.\n", wine_dbgstr_longlong(stop));
     ok(filter1.seek_current == 0x123, "Got time %s.\n", wine_dbgstr_longlong(filter1.seek_current));
@@ -4755,17 +4758,17 @@ static void test_graph_seeking(void)
     flush_cached_seeking(graph, &filter2);
 
     hr = IMediaSeeking_SetRate(seeking, 2.0);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     todo_wine ok(filter1.seek_rate == 2.0, "Got rate %.16e.\n", filter1.seek_rate);
     todo_wine ok(filter2.seek_rate == 2.0, "Got rate %.16e.\n", filter2.seek_rate);
 
     hr = IMediaSeeking_SetRate(seeking, 1.0);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     todo_wine ok(filter1.seek_rate == 1.0, "Got rate %.16e.\n", filter1.seek_rate);
     todo_wine ok(filter2.seek_rate == 1.0, "Got rate %.16e.\n", filter2.seek_rate);
 
     hr = IMediaSeeking_SetRate(seeking, -1.0);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     todo_wine ok(filter1.seek_rate == -1.0, "Got rate %.16e.\n", filter1.seek_rate);
     todo_wine ok(filter2.seek_rate == -1.0, "Got rate %.16e.\n", filter2.seek_rate);
 
@@ -4773,34 +4776,34 @@ static void test_graph_seeking(void)
     flush_cached_seeking(graph, &filter2);
 
     hr = IMediaSeeking_GetRate(seeking, &rate);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     todo_wine ok(rate == -1.0, "Got rate %.16e.\n", rate);
 
     hr = IMediaSeeking_SetRate(seeking, 1.0);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     /* Test how retrieving the current position behaves while the graph is
      * running. Apparently the graph caches the last position returned by
      * SetPositions() and then adds the clock offset to the stream start. */
 
     hr = IMediaControl_Run(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     /* Note that if the graph is running, it is paused while seeking. */
     current = 0;
     stop = 9000 * 10000;
     hr = IMediaSeeking_SetPositions(seeking, &current, AM_SEEKING_AbsolutePositioning,
             &stop, AM_SEEKING_AbsolutePositioning);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaSeeking_GetCurrentPosition(seeking, &time);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     if (winetest_interactive) /* Timing problems make this test too liable to fail. */
         ok(compare_time(time, 1234 * 10000, 40 * 10000),
                 "Expected about 1234ms, got %s.\n", wine_dbgstr_longlong(time));
     current = stop = 0xdeadbeef;
     hr = IMediaSeeking_GetPositions(seeking, &current, &stop);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     if (winetest_interactive) /* Timing problems make this test too liable to fail. */
         ok(compare_time(current, 1234 * 10000, 40 * 10000),
                 "Expected about 1234ms, got %s.\n", wine_dbgstr_longlong(current));
@@ -4812,144 +4815,144 @@ static void test_graph_seeking(void)
     hr = IMediaSeeking_SetPositions(seeking, &current,
             AM_SEEKING_AbsolutePositioning | AM_SEEKING_NoFlush,
             &stop, AM_SEEKING_AbsolutePositioning | AM_SEEKING_NoFlush);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     Sleep(100);
 
     hr = IMediaSeeking_GetCurrentPosition(seeking, &time);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     if (winetest_interactive) /* Timing problems make this test too liable to fail. */
         ok(compare_time(time, 1334 * 10000, 80 * 10000),
                 "Expected about 1334ms, got %s.\n", wine_dbgstr_longlong(time));
     current = stop = 0xdeadbeef;
     hr = IMediaSeeking_GetPositions(seeking, &current, &stop);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     if (winetest_interactive) /* Timing problems make this test too liable to fail. */
         ok(compare_time(current, 1334 * 10000, 80 * 10000),
                 "Expected about 1334ms, got %s.\n", wine_dbgstr_longlong(current));
     ok(stop == 8000 * 10000, "Got time %s.\n", wine_dbgstr_longlong(stop));
 
     hr = IMediaControl_Pause(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     Sleep(100);
     hr = IMediaControl_Run(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaSeeking_GetCurrentPosition(seeking, &time);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     if (winetest_interactive) /* Timing problems make this test too liable to fail. */
         ok(compare_time(time, 1334 * 10000, 80 * 10000),
                 "Expected about 1334ms, got %s.\n", wine_dbgstr_longlong(time));
     current = stop = 0xdeadbeef;
     hr = IMediaSeeking_GetPositions(seeking, &current, &stop);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     if (winetest_interactive) /* Timing problems make this test too liable to fail. */
         ok(compare_time(current, 1334 * 10000, 80 * 10000),
                 "Expected about 1334ms, got %s.\n", wine_dbgstr_longlong(current));
     ok(stop == 8000 * 10000, "Got time %s.\n", wine_dbgstr_longlong(stop));
 
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMediaSeeking_GetCurrentPosition(seeking, &time);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(time == 12340000, "Got time %s.\n", wine_dbgstr_longlong(time));
 
     hr = IMediaFilter_SetSyncSource(filter, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_Run(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     Sleep(100);
     hr = IMediaSeeking_GetCurrentPosition(seeking, &time);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     todo_wine ok(!time, "Got time %s.\n", wine_dbgstr_longlong(time));
     current = stop = 0xdeadbeef;
     hr = IMediaSeeking_GetPositions(seeking, &current, &stop);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     todo_wine ok(!current, "Got time %s.\n", wine_dbgstr_longlong(current));
     ok(!stop, "Got time %s.\n", wine_dbgstr_longlong(stop));
 
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     /* GetCurrentPositions() will return the stop position once all renderers
      * report EC_COMPLETE. Atelier Sophie depends on this behaviour. */
 
     hr = IFilterGraph2_SetDefaultSyncSource(graph);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     filter1.seek_stop = 5000 * 10000;
     filter2.seek_stop = 6000 * 10000;
 
     hr = IMediaControl_Run(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaSeeking_GetCurrentPosition(seeking, &time);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(time < 5000 * 10000, "Got time %s.\n", wine_dbgstr_longlong(time));
 
     hr = IMediaEventSink_Notify(eventsink, EC_COMPLETE, S_OK, (LONG_PTR)&filter1.IBaseFilter_iface);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaSeeking_GetCurrentPosition(seeking, &time);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(time < 5000 * 10000, "Got time %s.\n", wine_dbgstr_longlong(time));
 
     hr = IMediaEventSink_Notify(eventsink, EC_COMPLETE, S_OK, (LONG_PTR)&filter2.IBaseFilter_iface);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaSeeking_GetCurrentPosition(seeking, &time);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(time == 6000 * 10000, "Got time %s.\n", wine_dbgstr_longlong(time));
 
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     filter1.seek_hr = filter2.seek_hr = E_NOTIMPL;
     filter1.seek_stop = filter2.seek_stop = 0xdeadbeef;
 
     hr = IMediaControl_Run(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaSeeking_GetCurrentPosition(seeking, &time);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(time < 5000 * 10000, "Got time %s.\n", wine_dbgstr_longlong(time));
 
     hr = IMediaEventSink_Notify(eventsink, EC_COMPLETE, S_OK, (LONG_PTR)&filter1.IBaseFilter_iface);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaEventSink_Notify(eventsink, EC_COMPLETE, S_OK, (LONG_PTR)&filter2.IBaseFilter_iface);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaSeeking_GetCurrentPosition(seeking, &time);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(time == 6000 * 10000, "Got time %s.\n", wine_dbgstr_longlong(time));
 
     hr = IMediaSeeking_SetTimeFormat(seeking, &TIME_FORMAT_MEDIA_TIME);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaSeeking_SetTimeFormat(seeking, &TIME_FORMAT_NONE);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     IMediaFilter_Release(filter);
     IMediaControl_Release(control);
     IMediaSeeking_Release(seeking);
     IMediaEventSink_Release(eventsink);
 
-    ok(filter1.seeking_ref > 0, "Unexpected seeking refcount %ld.\n", filter1.seeking_ref);
-    ok(filter2.seeking_ref > 0, "Unexpected seeking refcount %ld.\n", filter2.seeking_ref);
+    ok(filter1.seeking_ref > 0, "Unexpected seeking refcount %d.\n", filter1.seeking_ref);
+    ok(filter2.seeking_ref > 0, "Unexpected seeking refcount %d.\n", filter2.seeking_ref);
 
     ref = IFilterGraph2_Release(graph);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
-    ok(filter1.ref == 1, "Got outstanding refcount %ld.\n", filter1.ref);
-    ok(filter2.ref == 1, "Got outstanding refcount %ld.\n", filter2.ref);
-    ok(filter1.seeking_ref == 0, "Unexpected seeking refcount %ld.\n", filter1.seeking_ref);
-    ok(filter2.seeking_ref == 0, "Unexpected seeking refcount %ld.\n", filter2.seeking_ref);
+    ok(!ref, "Got outstanding refcount %d.\n", hr);
+    ok(filter1.ref == 1, "Got outstanding refcount %d.\n", filter1.ref);
+    ok(filter2.ref == 1, "Got outstanding refcount %d.\n", filter2.ref);
+    ok(filter1.seeking_ref == 0, "Unexpected seeking refcount %d.\n", filter1.seeking_ref);
+    ok(filter2.seeking_ref == 0, "Unexpected seeking refcount %d.\n", filter2.seeking_ref);
 }
 
 static void test_default_sync_source(void)
@@ -4978,20 +4981,20 @@ static void test_default_sync_source(void)
     IFilterGraph2_QueryInterface(graph, &IID_IMediaFilter, (void **)&filter);
 
     hr = IFilterGraph2_SetDefaultSyncSource(graph);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaFilter_GetSyncSource(filter, &clock);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(!!clock, "Reference clock not set.\n");
     IReferenceClock_Release(clock);
 
     source.IReferenceClock_iface.lpVtbl = &testclock_vtbl;
 
     hr = IFilterGraph2_SetDefaultSyncSource(graph);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaFilter_GetSyncSource(filter, &clock);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(clock == &source.IReferenceClock_iface, "Got unexpected clock.\n");
     IReferenceClock_Release(clock);
 
@@ -5001,29 +5004,29 @@ static void test_default_sync_source(void)
     sink2.IReferenceClock_iface.lpVtbl = &testclock_vtbl;
 
     hr = IFilterGraph2_SetDefaultSyncSource(graph);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaFilter_GetSyncSource(filter, &clock);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     todo_wine ok(clock == &sink2.IReferenceClock_iface, "Got unexpected clock.\n");
     IReferenceClock_Release(clock);
 
     sink1.IReferenceClock_iface.lpVtbl = &testclock_vtbl;
 
     hr = IFilterGraph2_SetDefaultSyncSource(graph);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaFilter_GetSyncSource(filter, &clock);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     todo_wine ok(clock == &sink1.IReferenceClock_iface, "Got unexpected clock.\n");
     IReferenceClock_Release(clock);
 
     IMediaFilter_Release(filter);
     ref = IFilterGraph2_Release(graph);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
-    ok(sink1.ref == 1, "Got outstanding refcount %ld.\n", sink1.ref);
-    ok(sink2.ref == 1, "Got outstanding refcount %ld.\n", sink2.ref);
-    ok(source.ref == 1, "Got outstanding refcount %ld.\n", source.ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    ok(sink1.ref == 1, "Got outstanding refcount %d.\n", sink1.ref);
+    ok(sink2.ref == 1, "Got outstanding refcount %d.\n", sink2.ref);
+    ok(source.ref == 1, "Got outstanding refcount %d.\n", source.ref);
 }
 
 static void test_add_source_filter(void)
@@ -5048,20 +5051,20 @@ static void test_add_source_filter(void)
 
     filename = create_file(L"test.mp3", midi_data, sizeof(midi_data));
     hr = IFilterGraph2_AddSourceFilter(graph, filename, L"test", &filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_GetClassID(filter, &clsid);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(IsEqualGUID(&clsid, &CLSID_AsyncReader), "Got filter %s.\n", wine_dbgstr_guid(&clsid));
     hr = IBaseFilter_QueryFilterInfo(filter, &filter_info);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(!wcscmp(filter_info.achName, L"test"), "Got unexpected name %s.\n", wine_dbgstr_w(filter_info.achName));
     IFilterGraph_Release(filter_info.pGraph);
 
     hr = IBaseFilter_QueryInterface(filter, &IID_IFileSourceFilter, (void **)&filesource);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IFileSourceFilter_GetCurFile(filesource, &ret_filename, &mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(!wcscmp(ret_filename, filename), "Expected filename %s, got %s.\n",
             wine_dbgstr_w(filename), wine_dbgstr_w(ret_filename));
     ok(IsEqualGUID(&mt.majortype, &MEDIATYPE_Stream), "Got major type %s.\n", wine_dbgstr_guid(&mt.majortype));
@@ -5069,38 +5072,38 @@ static void test_add_source_filter(void)
     IFileSourceFilter_Release(filesource);
 
     hr = IFilterGraph2_AddSourceFilter(graph, filename, L"test", &filter2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(filter2 != filter, "Filters shouldn't match.\n");
     hr = IFilterGraph2_RemoveFilter(graph, filter2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ref = IBaseFilter_Release(filter2);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 
     hr = IFilterGraph2_RemoveFilter(graph, filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ret = DeleteFileW(filename);
-    ok(ret, "Failed to delete %s, error %lu.\n", wine_dbgstr_w(filename), GetLastError());
+    ok(ret, "Failed to delete %s, error %u.\n", wine_dbgstr_w(filename), GetLastError());
 
     /* Test a file which should be registered by signature. */
 
     filename = create_file(L"test.avi", midi_data, sizeof(midi_data));
     hr = IFilterGraph2_AddSourceFilter(graph, filename, NULL, &filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_GetClassID(filter, &clsid);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(IsEqualGUID(&clsid, &CLSID_AsyncReader), "Got filter %s.\n", wine_dbgstr_guid(&clsid));
     hr = IBaseFilter_QueryFilterInfo(filter, &filter_info);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     todo_wine ok(!wcscmp(filter_info.achName, filename), "Got unexpected name %s.\n", wine_dbgstr_w(filter_info.achName));
     IFilterGraph_Release(filter_info.pGraph);
 
     hr = IBaseFilter_QueryInterface(filter, &IID_IFileSourceFilter, (void **)&filesource);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IFileSourceFilter_GetCurFile(filesource, &ret_filename, &mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(!wcscmp(ret_filename, filename), "Expected filename %s, got %s.\n",
             wine_dbgstr_w(filename), wine_dbgstr_w(ret_filename));
     ok(IsEqualGUID(&mt.majortype, &MEDIATYPE_Stream), "Got major type %s.\n", wine_dbgstr_guid(&mt.majortype));
@@ -5108,11 +5111,11 @@ static void test_add_source_filter(void)
     IFileSourceFilter_Release(filesource);
 
     hr = IFilterGraph2_RemoveFilter(graph, filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ret = DeleteFileW(filename);
-    ok(ret, "Failed to delete %s, error %lu.\n", wine_dbgstr_w(filename), GetLastError());
+    ok(ret, "Failed to delete %s, error %u.\n", wine_dbgstr_w(filename), GetLastError());
 
     if (!RegCreateKeyA(HKEY_CLASSES_ROOT, "Media Type\\{abbccdde-0000-0000-0000-000000000000}"
             "\\{bccddeef-0000-0000-0000-000000000000}", &key))
@@ -5134,16 +5137,16 @@ static void test_add_source_filter(void)
 
         filename = create_file(L"test.avi", bogus_data, sizeof(bogus_data));
         hr = IFilterGraph2_AddSourceFilter(graph, filename, NULL, &filter);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
         ok(filter == &testfilter.IBaseFilter_iface, "Got unexpected filter %p.\n", filter);
 
         hr = IFilterGraph2_RemoveFilter(graph, filter);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
         IBaseFilter_Release(filter);
         ref = IBaseFilter_Release(&testfilter.IBaseFilter_iface);
-        ok(!ref, "Got outstanding refcount %ld.\n", ref);
+        ok(!ref, "Got outstanding refcount %d.\n", ref);
         ret = DeleteFileW(filename);
-        ok(ret, "Failed to delete %s, error %lu.\n", wine_dbgstr_w(filename), GetLastError());
+        ok(ret, "Failed to delete %s, error %u.\n", wine_dbgstr_w(filename), GetLastError());
         RegDeleteKeyA(HKEY_CLASSES_ROOT, "Media Type\\{abbccdde-0000-0000-0000-000000000000}"
             "\\{bccddeef-0000-0000-0000-000000000000}");
         RegDeleteKeyA(HKEY_CLASSES_ROOT, "Media Type\\{abbccdde-0000-0000-0000-000000000000}");
@@ -5153,7 +5156,7 @@ static void test_add_source_filter(void)
         skip("Not enough permission to register media types.\n");
 
     ref = IFilterGraph2_Release(graph);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 static HWND get_renderer_hwnd(IFilterGraph2 *graph)
@@ -5167,20 +5170,20 @@ static HWND get_renderer_hwnd(IFilterGraph2 *graph)
     IPin *pin;
 
     hr = IFilterGraph2_EnumFilters(graph, &enum_filters);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     while (IEnumFilters_Next(enum_filters, 1, &filter, NULL) == S_OK)
     {
         hr = IBaseFilter_EnumPins(filter, &enum_pins);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
         hr = IEnumPins_Next(enum_pins, 1, &pin, NULL);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
         IEnumPins_Release(enum_pins);
 
         if (SUCCEEDED(IPin_QueryInterface(pin, &IID_IOverlay, (void **)&overlay)))
         {
             hr = IOverlay_GetWindowHandle(overlay, &hwnd);
-            ok(hr == S_OK, "Got hr %#lx.\n", hr);
+            ok(hr == S_OK, "Got hr %#x.\n", hr);
             IOverlay_Release(overlay);
         }
 
@@ -5226,12 +5229,12 @@ static void test_window_threading(void)
     hr = IFilterGraph2_RenderFile(graph, filename, NULL);
     if (FAILED(hr))
     {
-        skip("Cannot render test file, hr %#lx.\n", hr);
+        skip("Cannot render test file, hr %#x.\n", hr);
         IFilterGraph2_Release(graph);
         DeleteFileW(filename);
         return;
     }
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     if ((hwnd = get_renderer_hwnd(graph)))
     {
@@ -5245,9 +5248,9 @@ static void test_window_threading(void)
          * while the video window is released. In particular, we must not send
          * WM_PARENTNOTIFY. This is not achieved through window styles. */
         hr = IFilterGraph2_QueryInterface(graph, &IID_IVideoWindow, (void **)&window);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
         hr = IVideoWindow_put_Owner(window, (OAHWND)parent);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
         IVideoWindow_Release(window);
         ok(!(GetWindowLongW(hwnd, GWL_EXSTYLE) & WS_EX_NOPARENTNOTIFY), "Window has WS_EX_NOPARENTNOTIFY.\n");
     }
@@ -5257,7 +5260,7 @@ static void test_window_threading(void)
     SetActiveWindow(parent);
     expect_parent_message = FALSE;
     ref = IFilterGraph2_Release(graph);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     expect_parent_message = TRUE;
 
     hwnd = GetActiveWindow();
@@ -5265,10 +5268,10 @@ static void test_window_threading(void)
 
     hr = CoCreateInstance(&CLSID_FilterGraphNoThread, NULL, CLSCTX_INPROC_SERVER,
             &IID_IFilterGraph2, (void **)&graph);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IFilterGraph2_RenderFile(graph, filename, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     if ((hwnd = get_renderer_hwnd(graph)))
     {
@@ -5279,12 +5282,12 @@ static void test_window_threading(void)
         skip("Could not find renderer window.\n");
 
     ref = IFilterGraph2_Release(graph);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 
     DestroyWindow(parent);
     UnregisterClassA("quartz_test_parent", GetModuleHandleA(NULL));
     ret = DeleteFileW(filename);
-    ok(ret, "Failed to delete file, error %lu.\n", GetLastError());
+    ok(ret, "Failed to delete file, error %u.\n", GetLastError());
 }
 
 /* Hyperdevotion Noire needs to be able to Render() from UYVY. */
@@ -5323,12 +5326,12 @@ static void test_autoplug_uyvy(void)
      * failure to decode up to missing audio hardware, even though we're not
      * trying to render audio. */
     hr = IFilterGraph2_Render(graph, &source_pin.IPin_iface);
-    todo_wine ok(hr == S_OK || hr == VFW_E_NO_AUDIO_HARDWARE, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_OK || hr == VFW_E_NO_AUDIO_HARDWARE, "Got hr %#x.\n", hr);
 
     ref = IFilterGraph2_Release(graph);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
-    ok(source.ref == 1, "Got outstanding refcount %ld.\n", source.ref);
-    ok(source_pin.ref == 1, "Got outstanding refcount %ld.\n", source_pin.ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    ok(source.ref == 1, "Got outstanding refcount %d.\n", source.ref);
+    ok(source_pin.ref == 1, "Got outstanding refcount %d.\n", source_pin.ref);
 }
 
 static void test_set_notify_flags(void)
@@ -5353,129 +5356,129 @@ static void test_set_notify_flags(void)
     status = SysAllocString(L"status");
 
     hr = IFilterGraph2_QueryInterface(graph, &IID_IMediaControl, (void **)&media_control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IFilterGraph2_QueryInterface(graph, &IID_IMediaEventEx, (void **)&media_event);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IFilterGraph2_QueryInterface(graph, &IID_IMediaEventSink, (void **)&media_event_sink);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     testfilter_init(&filter, NULL, 0);
     filter.IAMFilterMiscFlags_iface.lpVtbl = &testmiscflags_vtbl;
     filter.misc_flags = AM_FILTER_MISC_FLAGS_IS_RENDERER;
 
     hr = IFilterGraph2_AddFilter(graph, &filter.IBaseFilter_iface, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaEventEx_GetEventHandle(media_event, (OAEVENT *)&event);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaEventEx_SetNotifyWindow(media_event, (OAHWND)window, WM_USER, 0);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_Run(media_control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     ok(WaitForSingleObject(event, 0) == 0, "Event should be signaled.\n");
 
     while (PeekMessageA(&msg, window, WM_USER, WM_USER, PM_REMOVE));
 
     hr = IMediaEventEx_SetNotifyFlags(media_event, 2);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
 
     hr = IMediaEventEx_GetNotifyFlags(media_event, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
 
     flags = 0xdeadbeef;
     hr = IMediaEventEx_GetNotifyFlags(media_event, &flags);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(!flags, "Got flags %#lx\n", flags);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(!flags, "Got flags %#x\n", flags);
 
     hr = IMediaEventEx_SetNotifyFlags(media_event, AM_MEDIAEVENT_NONOTIFY);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     flags = 0xdeadbeef;
     hr = IMediaEventEx_GetNotifyFlags(media_event, &flags);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(flags == AM_MEDIAEVENT_NONOTIFY, "Got flags %#lx\n", flags);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(flags == AM_MEDIAEVENT_NONOTIFY, "Got flags %#x\n", flags);
 
     ok(WaitForSingleObject(event, 0) == WAIT_TIMEOUT, "Event should not be signaled.\n");
 
     hr = IMediaEventEx_GetEvent(media_event, &code, &param1, &param2, 50);
-    ok(hr == E_ABORT, "Got hr %#lx.\n", hr);
+    ok(hr == E_ABORT, "Got hr %#x.\n", hr);
 
     hr = IMediaEventSink_Notify(media_event_sink, EC_STATUS, (LONG_PTR)status, (LONG_PTR)status);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     ok(WaitForSingleObject(event, 0) == WAIT_TIMEOUT, "Event should not be signaled.\n");
 
     ok(!PeekMessageA(&msg, window, WM_USER, WM_USER, PM_REMOVE), "Window should not be notified.\n");
 
     hr = IMediaEventEx_GetEvent(media_event, &code, &param1, &param2, 50);
-    ok(hr == E_ABORT, "Got hr %#lx.\n", hr);
+    ok(hr == E_ABORT, "Got hr %#x.\n", hr);
 
     hr = IMediaEventSink_Notify(media_event_sink, EC_COMPLETE, S_OK,
             (LONG_PTR)&filter.IBaseFilter_iface);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     ok(WaitForSingleObject(event, 0) == 0, "Event should be signaled.\n");
 
     hr = IMediaControl_Stop(media_control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     ok(WaitForSingleObject(event, 0) == 0, "Event should be signaled.\n");
 
     hr = IMediaControl_Pause(media_control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     ok(WaitForSingleObject(event, 0) == 0, "Event should be signaled.\n");
 
     hr = IMediaControl_Run(media_control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     ok(WaitForSingleObject(event, 0) == WAIT_TIMEOUT, "Event should not be signaled.\n");
 
     hr = IMediaEventSink_Notify(media_event_sink, EC_COMPLETE, S_OK,
             (LONG_PTR)&filter.IBaseFilter_iface);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     ok(WaitForSingleObject(event, 0) == 0, "Event should be signaled.\n");
 
     hr = IMediaEventEx_GetEvent(media_event, &code, &param1, &param2, 50);
-    ok(hr == E_ABORT, "Got hr %#lx.\n", hr);
+    ok(hr == E_ABORT, "Got hr %#x.\n", hr);
 
     ok(WaitForSingleObject(event, 0) == WAIT_TIMEOUT, "Event should not be signaled.\n");
 
     hr = IMediaEventEx_SetNotifyFlags(media_event, 0);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     flags = 0xdeadbeef;
     hr = IMediaEventEx_GetNotifyFlags(media_event, &flags);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(!flags, "Got flags %#lx\n", flags);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(!flags, "Got flags %#x\n", flags);
 
     hr = IMediaControl_Stop(media_control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMediaControl_Run(media_control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaEventSink_Notify(media_event_sink, EC_COMPLETE, S_OK,
             (LONG_PTR)&filter.IBaseFilter_iface);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaEventEx_SetNotifyFlags(media_event, AM_MEDIAEVENT_NONOTIFY);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     ok(WaitForSingleObject(event, 0) == WAIT_TIMEOUT, "Event should not be signaled.\n");
 
     hr = IMediaControl_Stop(media_control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     IMediaControl_Release(media_control);
     IMediaEventEx_Release(media_event);
     IMediaEventSink_Release(media_event_sink);
     ref = IFilterGraph2_Release(graph);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
-    ok(filter.ref == 1, "Got outstanding refcount %ld.\n", filter.ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    ok(filter.ref == 1, "Got outstanding refcount %d.\n", filter.ref);
 
     SysFreeString(status);
     DestroyWindow(window);
@@ -5500,9 +5503,9 @@ static void check_events_(unsigned int line, IMediaEventEx *media_event,
         if (code == EC_STATUS)
             ++ec_status_count;
         hr = IMediaEventEx_FreeEventParams(media_event, code, param1, param2);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
     }
-    ok(hr == E_ABORT, "Got hr %#lx.\n", hr);
+    ok(hr == E_ABORT, "Got hr %#x.\n", hr);
     ok_(__FILE__, line)(ec_complete_count == expected_ec_complete_count,
         "Expected %d EC_COMPLETE events.\n", expected_ec_complete_count);
     ok_(__FILE__, line)(ec_status_count == expected_ec_status_count,
@@ -5526,58 +5529,58 @@ static void test_events(void)
     status = SysAllocString(L"status");
 
     hr = IFilterGraph2_QueryInterface(graph, &IID_IMediaControl, (void **)&media_control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IFilterGraph2_QueryInterface(graph, &IID_IMediaEventEx, (void **)&media_event);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IFilterGraph2_QueryInterface(graph, &IID_IMediaEventSink, (void **)&media_event_sink);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     testfilter_init(&filter, NULL, 0);
     filter.IAMFilterMiscFlags_iface.lpVtbl = &testmiscflags_vtbl;
     filter.misc_flags = AM_FILTER_MISC_FLAGS_IS_RENDERER;
 
     hr = IFilterGraph2_AddFilter(graph, &filter.IBaseFilter_iface, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaEventEx_GetEventHandle(media_event, (OAEVENT *)&event);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     code = 0xdeadbeef;
     param1 = 0xdeadbeef;
     param2 = 0xdeadbeef;
     hr = IMediaEventEx_GetEvent(media_event, &code, &param1, &param2, 0);
-    ok(hr == E_ABORT, "Got hr %#lx.\n", hr);
-    ok(!code, "Got code %#lx.\n", code);
+    ok(hr == E_ABORT, "Got hr %#x.\n", hr);
+    ok(!code, "Got code %#x.\n", code);
     todo_wine ok(!param1, "Got param1 %#Ix.\n", param1);
     todo_wine ok(!param2, "Got param2 %#Ix.\n", param2);
 
     /* EC_COMPLETE is ignored while in stopped or paused state. */
 
     hr = IMediaEventSink_Notify(media_event_sink, EC_STATUS, (LONG_PTR)status, (LONG_PTR)status);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMediaEventSink_Notify(media_event_sink, EC_COMPLETE, S_OK,
             (LONG_PTR)&filter.IBaseFilter_iface);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMediaEventSink_Notify(media_event_sink, EC_STATUS, (LONG_PTR)status, (LONG_PTR)status);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     check_events(media_event, 0, 2);
 
     hr = IMediaControl_Pause(media_control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaEventSink_Notify(media_event_sink, EC_STATUS, (LONG_PTR)status, (LONG_PTR)status);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMediaEventSink_Notify(media_event_sink, EC_COMPLETE, S_OK,
             (LONG_PTR)&filter.IBaseFilter_iface);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMediaEventSink_Notify(media_event_sink, EC_STATUS, (LONG_PTR)status, (LONG_PTR)status);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     check_events(media_event, 0, 2);
 
     hr = IMediaControl_Run(media_control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     check_events(media_event, 0, 0);
 
@@ -5585,68 +5588,68 @@ static void test_events(void)
      * This remains true even with default handling canceled. */
 
     hr = IMediaEventEx_CancelDefaultHandling(media_event, EC_COMPLETE);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaEventSink_Notify(media_event_sink, EC_STATUS, (LONG_PTR)status, (LONG_PTR)status);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMediaEventSink_Notify(media_event_sink, EC_COMPLETE, S_OK,
             (LONG_PTR)&filter.IBaseFilter_iface);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMediaEventSink_Notify(media_event_sink, EC_STATUS, (LONG_PTR)status, (LONG_PTR)status);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_Stop(media_control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     check_events(media_event, 1, 2);
 
     hr = IMediaControl_Run(media_control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaEventSink_Notify(media_event_sink, EC_STATUS, (LONG_PTR)status, (LONG_PTR)status);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMediaEventSink_Notify(media_event_sink, EC_COMPLETE, S_OK,
             (LONG_PTR)&filter.IBaseFilter_iface);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMediaEventSink_Notify(media_event_sink, EC_STATUS, (LONG_PTR)status, (LONG_PTR)status);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_Stop(media_control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMediaControl_Run(media_control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     check_events(media_event, 0, 2);
 
     hr = IMediaEventSink_Notify(media_event_sink, EC_STATUS, (LONG_PTR)status, (LONG_PTR)status);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMediaEventSink_Notify(media_event_sink, EC_COMPLETE, S_OK,
             (LONG_PTR)&filter.IBaseFilter_iface);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMediaEventSink_Notify(media_event_sink, EC_STATUS, (LONG_PTR)status, (LONG_PTR)status);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_Stop(media_control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMediaControl_Pause(media_control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     check_events(media_event, 1, 2);
 
     hr = IMediaControl_Run(media_control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMediaEventSink_Notify(media_event_sink, EC_STATUS, (LONG_PTR)status, (LONG_PTR)status);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMediaEventSink_Notify(media_event_sink, EC_COMPLETE, S_OK,
             (LONG_PTR)&filter.IBaseFilter_iface);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMediaEventSink_Notify(media_event_sink, EC_STATUS, (LONG_PTR)status, (LONG_PTR)status);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_Pause(media_control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMediaControl_Run(media_control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     check_events(media_event, 0, 2);
 
@@ -5655,57 +5658,23 @@ static void test_events(void)
     SetEvent(event);
 
     hr = IMediaEventEx_GetEvent(media_event, &code, &param1, &param2, 50);
-    ok(hr == E_ABORT, "Got hr %#lx.\n", hr);
+    ok(hr == E_ABORT, "Got hr %#x.\n", hr);
 
     ok(WaitForSingleObject(event, 0) == WAIT_TIMEOUT, "Event should not be signaled.\n");
 
     hr = IMediaControl_Stop(media_control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     IMediaControl_Release(media_control);
     IMediaEventEx_Release(media_event);
     IMediaEventSink_Release(media_event_sink);
     ref = IFilterGraph2_Release(graph);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
-    ok(filter.ref == 1, "Got outstanding refcount %ld.\n", filter.ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    ok(filter.ref == 1, "Got outstanding refcount %d.\n", filter.ref);
 
     SysFreeString(status);
 }
 
-static void test_event_dispatch(void)
-{
-    IFilterGraph2 *graph = create_graph();
-    IMediaEventEx *event_ex;
-    ITypeInfo *typeinfo;
-    IMediaEvent *event;
-    TYPEATTR *typeattr;
-    unsigned int count;
-    HRESULT hr;
-    ULONG ref;
-
-    IFilterGraph2_QueryInterface(graph, &IID_IMediaEvent, (void **)&event);
-    IFilterGraph2_QueryInterface(graph, &IID_IMediaEventEx, (void **)&event_ex);
-    ok((void *)event == event_ex, "Interface pointers didn't match.\n");
-    IMediaEventEx_Release(event_ex);
-
-    hr = IMediaEvent_GetTypeInfoCount(event, &count);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(count == 1, "Got count %u.\n", count);
-
-    hr = IMediaEvent_GetTypeInfo(event, 0, 0, &typeinfo);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    hr = ITypeInfo_GetTypeAttr(typeinfo, &typeattr);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(typeattr->typekind == TKIND_DISPATCH, "Got kind %u.\n", typeattr->typekind);
-    ok(IsEqualGUID(&typeattr->guid, &IID_IMediaEvent), "Got IID %s.\n", debugstr_guid(&typeattr->guid));
-    ITypeInfo_ReleaseTypeAttr(typeinfo, typeattr);
-    ITypeInfo_Release(typeinfo);
-
-    IMediaEvent_Release(event);
-    ref = IFilterGraph2_Release(graph);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
-}
-
 START_TEST(filtergraph)
 {
     CoInitializeEx(NULL, COINIT_MULTITHREADED);
@@ -5733,7 +5702,6 @@ START_TEST(filtergraph)
     test_autoplug_uyvy();
     test_set_notify_flags();
     test_events();
-    test_event_dispatch();
 
     CoUninitialize();
     test_render_with_multithread();
diff --git a/dlls/quartz/tests/filtermapper.c b/dlls/quartz/tests/filtermapper.c
index 3c492845389..f1a942b1d25 100644
--- wine/dlls/quartz/tests/filtermapper.c
+++ wine/dlls/quartz/tests/filtermapper.c
@@ -35,7 +35,7 @@ static IFilterMapper3 *create_mapper(void)
     IFilterMapper3 *ret;
     HRESULT hr;
     hr = CoCreateInstance(&CLSID_FilterMapper2, NULL, CLSCTX_INPROC_SERVER, &IID_IFilterMapper3, (void **)&ret);
-    ok(hr == S_OK, "Failed to create filter mapper, hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to create filter mapper, hr %#x.\n", hr);
     return ret;
 }
 
@@ -56,7 +56,7 @@ static void check_interface_(unsigned int line, void *iface_ptr, REFIID iid, BOO
     expected_hr = supported ? S_OK : E_NOINTERFACE;
 
     hr = IUnknown_QueryInterface(iface, iid, (void **)&unk);
-    ok_(__FILE__, line)(hr == expected_hr, "Got hr %#lx, expected %#lx.\n", hr, expected_hr);
+    ok_(__FILE__, line)(hr == expected_hr, "Got hr %#x, expected %#x.\n", hr, expected_hr);
     if (SUCCEEDED(hr))
         IUnknown_Release(unk);
 }
@@ -92,10 +92,10 @@ static BOOL enum_find_filter(const WCHAR *wszFilterName, IEnumMoniker *pEnum)
         VariantInit(&var);
 
         hr = IMoniker_BindToStorage(pMoniker, NULL, NULL, &IID_IPropertyBag, (LPVOID*)&pPropBagCat);
-        ok(SUCCEEDED(hr), "Got hr %#lx.\n", hr);
+        ok(SUCCEEDED(hr), "IMoniker_BindToStorage failed with %x\n", hr);
 
         hr = IPropertyBag_Read(pPropBagCat, L"FriendlyName", &var, NULL);
-        ok(SUCCEEDED(hr), "Got hr %#lx.\n", hr);
+        ok(SUCCEEDED(hr), "IPropertyBag_Read failed with %x\n", hr);
 
         if (!wcscmp(V_BSTR(&var), wszFilterName))
             found = TRUE;
@@ -128,13 +128,13 @@ static void test_fm2_enummatchingfilters(void)
 
     hr = CoCreateInstance(&CLSID_FilterMapper2, NULL, CLSCTX_INPROC_SERVER,
             &IID_IFilterMapper2, (LPVOID*)&pMapper);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "CoCreateInstance failed with %x\n", hr);
     if (FAILED(hr)) goto out;
 
     hr = CoCreateGuid(&clsidFilter1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "CoCreateGuid failed with %x\n", hr);
     hr = CoCreateGuid(&clsidFilter2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "CoCreateGuid failed with %x\n", hr);
 
     /* Test that a test renderer filter is returned when enumerating filters with bRender=FALSE */
     rgf2.dwVersion = 2;
@@ -162,7 +162,7 @@ static void test_fm2_enummatchingfilters(void)
     }
     else
     {
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "IFilterMapper2_RegisterFilter failed with %x\n", hr);
 
         rgPins2[0].dwFlags = 0;
 
@@ -178,11 +178,11 @@ static void test_fm2_enummatchingfilters(void)
 
         hr = IFilterMapper2_RegisterFilter(pMapper, &clsidFilter2, L"Testfilter2", NULL,
                     &CLSID_LegacyAmFilterCategory, NULL, &rgf2);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "IFilterMapper2_RegisterFilter failed with %x\n", hr);
 
         hr = IFilterMapper2_EnumMatchingFilters(pMapper, &pEnum, 0, TRUE, MERIT_UNLIKELY, TRUE,
                 0, NULL, NULL, &GUID_NULL, FALSE, FALSE, 0, NULL, NULL, &GUID_NULL);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "IFilterMapper2_EnumMatchingFilters failed with %x\n", hr);
         if (SUCCEEDED(hr) && pEnum)
         {
             found = enum_find_filter(L"Testfilter1", pEnum);
@@ -194,7 +194,7 @@ static void test_fm2_enummatchingfilters(void)
 
         hr = IFilterMapper2_EnumMatchingFilters(pMapper, &pEnum, 0, TRUE, MERIT_UNLIKELY, TRUE,
                 0, NULL, NULL, &GUID_NULL, FALSE, FALSE, 0, NULL, NULL, &GUID_NULL);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "IFilterMapper2_EnumMatchingFilters failed with %x\n", hr);
         if (SUCCEEDED(hr) && pEnum)
         {
             found = enum_find_filter(L"Testfilter2", pEnum);
@@ -208,7 +208,7 @@ static void test_fm2_enummatchingfilters(void)
 
         hr = IFilterMapper2_EnumMatchingFilters(pMapper, &pEnum, 0, TRUE, MERIT_UNLIKELY, TRUE,
                 0, NULL, NULL, &GUID_NULL, TRUE, FALSE, 0, NULL, NULL, &GUID_NULL);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "IFilterMapper2_EnumMatchingFilters failed with %x\n", hr);
 
         if (SUCCEEDED(hr) && pEnum)
         {
@@ -217,12 +217,12 @@ static void test_fm2_enummatchingfilters(void)
         }
 
         hr = IFilterMapper2_QueryInterface(pMapper, &IID_IFilterMapper, (void **)&mapper);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "QueryInterface(IFilterMapper) failed: %#x\n", hr);
 
         found = FALSE;
         hr = IFilterMapper_EnumMatchingFilters(mapper, &enum_reg, MERIT_UNLIKELY,
             FALSE, GUID_NULL, GUID_NULL, FALSE, FALSE, GUID_NULL, GUID_NULL);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "IFilterMapper_EnumMatchingFilters failed: %#x\n", hr);
         while (!found && IEnumRegFilters_Next(enum_reg, 1, &regfilter, &count) == S_OK)
         {
             if (!wcscmp(regfilter->Name, L"Testfilter1") && IsEqualGUID(&clsidFilter1, &regfilter->Clsid))
@@ -239,7 +239,7 @@ static void test_fm2_enummatchingfilters(void)
 
     hr = IFilterMapper2_EnumMatchingFilters(pMapper, &pEnum, 0, TRUE, MERIT_UNLIKELY, TRUE,
                 0, NULL, NULL, &GUID_NULL, TRUE, FALSE, 0, NULL, NULL, &GUID_NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "IFilterMapper2_EnumMatchingFilters failed with %x\n", hr);
 
     if (SUCCEEDED(hr) && pEnum)
     {
@@ -251,18 +251,18 @@ static void test_fm2_enummatchingfilters(void)
     {
         hr = IFilterMapper2_UnregisterFilter(pMapper, &CLSID_LegacyAmFilterCategory, NULL,
                 &clsidFilter1);
-        ok(SUCCEEDED(hr), "Got hr %#lx.\n", hr);
+        ok(SUCCEEDED(hr), "IFilterMapper2_UnregisterFilter failed with %x\n", hr);
 
         hr = IFilterMapper2_UnregisterFilter(pMapper, &CLSID_LegacyAmFilterCategory, NULL,
                 &clsidFilter2);
-        ok(SUCCEEDED(hr), "Got hr %#lx.\n", hr);
+        ok(SUCCEEDED(hr), "IFilterMapper2_UnregisterFilter failed with %x\n", hr);
     }
 
     out:
 
     if (pEnum) IEnumMoniker_Release(pEnum);
     ref = IFilterMapper2_Release(pMapper);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 static void test_legacy_filter_registration(void)
@@ -298,34 +298,34 @@ static void test_legacy_filter_registration(void)
      * registers in this way. Filters so registered must then be accessible through both IFilterMapper_EnumMatchingFilters
      * and IFilterMapper2_EnumMatchingFilters. */
     hr = CoCreateInstance(&CLSID_FilterMapper2, NULL, CLSCTX_INPROC_SERVER, &IID_IFilterMapper2, (void **)&mapper2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "CoCreateInstance failed with %x\n", hr);
 
     hr = IFilterMapper2_QueryInterface(mapper2, &IID_IFilterMapper, (void **)&mapper);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "IFilterMapper2_QueryInterface failed with %x\n", hr);
 
     /* Set default value - this is interpreted as "friendly name" later. */
     RegSetValueExW(hkey, NULL, 0, REG_SZ, (const BYTE *)L"Testfilter", sizeof(L"Testfilter"));
     RegCloseKey(hkey);
 
     hr = IFilterMapper_RegisterFilter(mapper, clsid, L"Testfilter", MERIT_UNLIKELY);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "RegisterFilter failed: %#x\n", hr);
 
     hr = IFilterMapper_RegisterPin(mapper, clsid, L"Pin1", TRUE, FALSE, FALSE, FALSE, GUID_NULL, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "RegisterPin failed: %#x\n", hr);
 
     hr = IFilterMapper_RegisterPinType(mapper, clsid, L"Pin1", GUID_NULL, GUID_NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "RegisterPinType failed: %#x\n", hr);
 
     hr = IFilterMapper2_EnumMatchingFilters(mapper2, &enum_mon, 0, TRUE, MERIT_UNLIKELY, TRUE,
             0, NULL, NULL, &GUID_NULL, FALSE, FALSE, 0, NULL, NULL, &GUID_NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "IFilterMapper2_EnumMatchingFilters failed: %x\n", hr);
     ok(enum_find_filter(L"Testfilter", enum_mon), "IFilterMapper2 didn't find filter\n");
     IEnumMoniker_Release(enum_mon);
 
     found = FALSE;
     hr = IFilterMapper_EnumMatchingFilters(mapper, &enum_reg, MERIT_UNLIKELY, TRUE, GUID_NULL, GUID_NULL,
         FALSE, FALSE, GUID_NULL, GUID_NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "IFilterMapper_EnumMatchingFilters failed with %x\n", hr);
     while(!found && IEnumRegFilters_Next(enum_reg, 1, &regfilter, &count) == S_OK)
     {
         if (!wcscmp(regfilter->Name, L"Testfilter") && IsEqualGUID(&clsid, &regfilter->Clsid))
@@ -335,18 +335,18 @@ static void test_legacy_filter_registration(void)
     ok(found, "IFilterMapper didn't find filter\n");
 
     hr = IFilterMapper_UnregisterFilter(mapper, clsid);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "FilterMapper_UnregisterFilter failed with %x\n", hr);
 
     hr = IFilterMapper2_EnumMatchingFilters(mapper2, &enum_mon, 0, TRUE, MERIT_UNLIKELY, TRUE,
             0, NULL, NULL, &GUID_NULL, FALSE, FALSE, 0, NULL, NULL, &GUID_NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "IFilterMapper2_EnumMatchingFilters failed: %x\n", hr);
     ok(!enum_find_filter(L"Testfilter", enum_mon), "IFilterMapper2 shouldn't find filter\n");
     IEnumMoniker_Release(enum_mon);
 
     found = FALSE;
     hr = IFilterMapper_EnumMatchingFilters(mapper, &enum_reg, MERIT_UNLIKELY, TRUE, GUID_NULL, GUID_NULL,
         FALSE, FALSE, GUID_NULL, GUID_NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "IFilterMapper_EnumMatchingFilters failed with %x\n", hr);
     while(!found && IEnumRegFilters_Next(enum_reg, 1, &regfilter, &count) == S_OK)
     {
         if (!wcscmp(regfilter->Name, L"Testfilter") && IsEqualGUID(&clsid, &regfilter->Clsid))
@@ -356,13 +356,13 @@ static void test_legacy_filter_registration(void)
     ok(!found, "IFilterMapper shouldn't find filter\n");
 
     ret = RegDeleteKeyW(HKEY_CLASSES_ROOT, key_name);
-    ok(!ret, "RegDeleteKeyA failed: %Iu\n", ret);
+    ok(!ret, "RegDeleteKeyA failed: %lu\n", ret);
 
     hr = IFilterMapper_RegisterFilter(mapper, clsid, L"Testfilter", MERIT_UNLIKELY);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "RegisterFilter failed: %#x\n", hr);
 
     hr = IFilterMapper_UnregisterFilter(mapper, clsid);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "FilterMapper_UnregisterFilter failed with %x\n", hr);
 
     IFilterMapper_Release(mapper);
     IFilterMapper2_Release(mapper2);
@@ -382,13 +382,13 @@ static void test_register_filter_with_null_clsMinorType(void)
 
     hr = CoCreateInstance(&CLSID_FilterMapper2, NULL, CLSCTX_INPROC_SERVER,
             &IID_IFilterMapper2, (LPVOID*)&pMapper);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "CoCreateInstance failed with %x\n", hr);
     if (FAILED(hr)) goto out;
 
     hr = CoCreateGuid(&clsidFilter1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "CoCreateGuid failed with %x\n", hr);
     hr = CoCreateGuid(&clsidFilter2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "CoCreateGuid failed with %x\n", hr);
 
     rgPinType.clsMajorType = &GUID_NULL;
     /* Make sure quartz accepts it without crashing */
@@ -418,10 +418,10 @@ static void test_register_filter_with_null_clsMinorType(void)
         skip("Not authorized to register filters\n");
         goto out;
     }
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "IFilterMapper2_RegisterFilter failed with %x\n", hr);
 
     hr = IFilterMapper2_UnregisterFilter(pMapper, &CLSID_LegacyAmFilterCategory, NULL, &clsidFilter1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "FilterMapper_UnregisterFilter failed with %x\n", hr);
 
     /* Test with pin descript version 2 */
     ZeroMemory(&rgf2, sizeof(rgf2));
@@ -440,10 +440,10 @@ static void test_register_filter_with_null_clsMinorType(void)
 
     hr = IFilterMapper2_RegisterFilter(pMapper, &clsidFilter2, L"Testfilter2", NULL,
                     &CLSID_LegacyAmFilterCategory, NULL, &rgf2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "IFilterMapper2_RegisterFilter failed with %x\n", hr);
 
     hr = IFilterMapper2_UnregisterFilter(pMapper, &CLSID_LegacyAmFilterCategory, NULL, &clsidFilter2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "FilterMapper_UnregisterFilter failed with %x\n", hr);
 
     out:
 
@@ -473,7 +473,7 @@ static void test_parse_filter_data(void)
 
     hr = CoCreateInstance(&CLSID_FilterMapper2, NULL, CLSCTX_INPROC_SERVER,
             &IID_IFilterMapper2, (LPVOID*)&pMapper);
-    ok((hr == S_OK || broken(hr != S_OK)), "Got hr %#lx.\n", hr);
+    ok((hr == S_OK || broken(hr != S_OK)), "CoCreateInstance failed with %x\n", hr);
     if (FAILED(hr)) goto out;
 
     hr = IFilterMapper2_QueryInterface(pMapper, &IID_IAMFilterData, (LPVOID*)&pData);
@@ -559,53 +559,53 @@ static void test_aggregation(void)
     mapper = (IFilterMapper3 *)0xdeadbeef;
     hr = CoCreateInstance(&CLSID_FilterMapper2, &test_outer, CLSCTX_INPROC_SERVER,
             &IID_IFilterMapper3, (void **)&mapper);
-    ok(hr == E_NOINTERFACE, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOINTERFACE, "Got hr %#x.\n", hr);
     ok(!mapper, "Got interface %p.\n", mapper);
 
     hr = CoCreateInstance(&CLSID_FilterMapper2, &test_outer, CLSCTX_INPROC_SERVER,
             &IID_IUnknown, (void **)&unk);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(outer_ref == 1, "Got unexpected refcount %ld.\n", outer_ref);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
     ok(unk != &test_outer, "Returned IUnknown should not be outer IUnknown.\n");
     ref = get_refcount(unk);
-    ok(ref == 1, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
 
     ref = IUnknown_AddRef(unk);
-    ok(ref == 2, "Got unexpected refcount %ld.\n", ref);
-    ok(outer_ref == 1, "Got unexpected refcount %ld.\n", outer_ref);
+    ok(ref == 2, "Got unexpected refcount %d.\n", ref);
+    ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
 
     ref = IUnknown_Release(unk);
-    ok(ref == 1, "Got unexpected refcount %ld.\n", ref);
-    ok(outer_ref == 1, "Got unexpected refcount %ld.\n", outer_ref);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
+    ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
 
     hr = IUnknown_QueryInterface(unk, &IID_IUnknown, (void **)&unk2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(unk2 == unk, "Got unexpected IUnknown %p.\n", unk2);
     IUnknown_Release(unk2);
 
     hr = IUnknown_QueryInterface(unk, &IID_IFilterMapper3, (void **)&mapper);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IFilterMapper3_QueryInterface(mapper, &IID_IUnknown, (void **)&unk2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(unk2 == (IUnknown *)0xdeadbeef, "Got unexpected IUnknown %p.\n", unk2);
 
     hr = IFilterMapper3_QueryInterface(mapper, &IID_IFilterMapper3, (void **)&mapper2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(mapper2 == (IFilterMapper3 *)0xdeadbeef, "Got unexpected IFilterMapper3 %p.\n", mapper2);
 
     hr = IUnknown_QueryInterface(unk, &test_iid, (void **)&unk2);
-    ok(hr == E_NOINTERFACE, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOINTERFACE, "Got hr %#x.\n", hr);
     ok(!unk2, "Got unexpected IUnknown %p.\n", unk2);
 
     hr = IFilterMapper3_QueryInterface(mapper, &test_iid, (void **)&unk2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(unk2 == (IUnknown *)0xdeadbeef, "Got unexpected IUnknown %p.\n", unk2);
 
     IFilterMapper3_Release(mapper);
     ref = IUnknown_Release(unk);
-    ok(!ref, "Got unexpected refcount %ld.\n", ref);
-    ok(outer_ref == 1, "Got unexpected refcount %ld.\n", outer_ref);
+    ok(!ref, "Got unexpected refcount %d.\n", ref);
+    ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
 }
 
 static void test_dmo(void)
@@ -625,19 +625,19 @@ static void test_dmo(void)
         skip("Not enough permissions to register DMOs.\n");
         return;
     }
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     mapper = create_mapper();
 
     hr = IFilterMapper3_EnumMatchingFilters(mapper, &enumerator, 0, FALSE, 0,
             FALSE, 0, NULL, NULL, NULL, FALSE, FALSE, 0, NULL, NULL, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     found = FALSE;
     while (IEnumMoniker_Next(enumerator, 1, &moniker, NULL) == S_OK)
     {
         hr = IMoniker_GetDisplayName(moniker, NULL, NULL, &name);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
 
         if (!wcscmp(name, L"@device:dmo:{77777777-0000-0000-0000-000000000000}{57F2DB8B-E6BB-4513-9D43-DCD2A6593125}"))
             found = TRUE;
@@ -651,10 +651,10 @@ static void test_dmo(void)
     /* DMOs are enumerated by IFilterMapper in Windows 7 and higher. */
 
     ref = IFilterMapper3_Release(mapper);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 
     hr = DMOUnregister(&testclsid, &DMOCATEGORY_AUDIO_DECODER);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 }
 
 START_TEST(filtermapper)
diff --git a/dlls/quartz/tests/memallocator.c b/dlls/quartz/tests/memallocator.c
index 37df9a24bd2..164f3af47f4 100644
--- wine/dlls/quartz/tests/memallocator.c
+++ wine/dlls/quartz/tests/memallocator.c
@@ -27,7 +27,7 @@ static IMemAllocator *create_allocator(void)
     IMemAllocator *allocator = NULL;
     HRESULT hr = CoCreateInstance(&CLSID_MemoryAllocator, NULL, CLSCTX_INPROC_SERVER,
         &IID_IMemAllocator, (void **)&allocator);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     return allocator;
 }
 
@@ -63,59 +63,59 @@ static void test_properties(void)
 
     memset(&ret_props, 0xcc, sizeof(ret_props));
     hr = IMemAllocator_GetProperties(allocator, &ret_props);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(!ret_props.cBuffers, "Got %ld buffers.\n", ret_props.cBuffers);
-    ok(!ret_props.cbBuffer, "Got size %ld.\n", ret_props.cbBuffer);
-    ok(!ret_props.cbAlign, "Got align %ld.\n", ret_props.cbAlign);
-    ok(!ret_props.cbPrefix, "Got prefix %ld.\n", ret_props.cbPrefix);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(!ret_props.cBuffers, "Got %d buffers.\n", ret_props.cBuffers);
+    ok(!ret_props.cbBuffer, "Got size %d.\n", ret_props.cbBuffer);
+    ok(!ret_props.cbAlign, "Got align %d.\n", ret_props.cbAlign);
+    ok(!ret_props.cbPrefix, "Got prefix %d.\n", ret_props.cbPrefix);
 
     hr = IMemAllocator_SetProperties(allocator, &req_props, &ret_props);
-    ok(hr == VFW_E_BADALIGN, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_BADALIGN, "Got hr %#x.\n", hr);
 
     for (i = 0; i < ARRAY_SIZE(tests); i++)
     {
         req_props = tests[i];
         hr = IMemAllocator_SetProperties(allocator, &req_props, &ret_props);
-        ok(hr == S_OK, "Test %u: Got hr %#lx.\n", i, hr);
+        ok(hr == S_OK, "Test %u: Got hr %#x.\n", i, hr);
         ok(!memcmp(&req_props, &tests[i], sizeof(req_props)), "Test %u: Requested props should not be changed.\n", i);
-        ok(ret_props.cBuffers == req_props.cBuffers, "Test %u: Got %ld buffers.\n", i, ret_props.cBuffers);
-        ok(ret_props.cbBuffer >= req_props.cbBuffer, "Test %u: Got size %ld.\n", i, ret_props.cbBuffer);
-        ok(ret_props.cbAlign == req_props.cbAlign, "Test %u: Got alignment %ld.\n", i, ret_props.cbAlign);
-        ok(ret_props.cbPrefix == req_props.cbPrefix, "Test %u: Got prefix %ld.\n", i, ret_props.cbPrefix);
+        ok(ret_props.cBuffers == req_props.cBuffers, "Test %u: Got %d buffers.\n", i, ret_props.cBuffers);
+        ok(ret_props.cbBuffer >= req_props.cbBuffer, "Test %u: Got size %d.\n", i, ret_props.cbBuffer);
+        ok(ret_props.cbAlign == req_props.cbAlign, "Test %u: Got alignment %d.\n", i, ret_props.cbAlign);
+        ok(ret_props.cbPrefix == req_props.cbPrefix, "Test %u: Got prefix %d.\n", i, ret_props.cbPrefix);
         ret_size = ret_props.cbBuffer;
 
         hr = IMemAllocator_GetProperties(allocator, &ret_props);
-        ok(hr == S_OK, "Test %u: Got hr %#lx.\n", i, hr);
-        ok(ret_props.cBuffers == req_props.cBuffers, "Test %u: Got %ld buffers.\n", i, ret_props.cBuffers);
-        ok(ret_props.cbBuffer == ret_size, "Test %u: Got size %ld.\n", i, ret_props.cbBuffer);
-        ok(ret_props.cbAlign == req_props.cbAlign, "Test %u: Got alignment %ld.\n", i, ret_props.cbAlign);
-        ok(ret_props.cbPrefix == req_props.cbPrefix, "Test %u: Got prefix %ld.\n", i, ret_props.cbPrefix);
+        ok(hr == S_OK, "Test %u: Got hr %#x.\n", i, hr);
+        ok(ret_props.cBuffers == req_props.cBuffers, "Test %u: Got %d buffers.\n", i, ret_props.cBuffers);
+        ok(ret_props.cbBuffer == ret_size, "Test %u: Got size %d.\n", i, ret_props.cbBuffer);
+        ok(ret_props.cbAlign == req_props.cbAlign, "Test %u: Got alignment %d.\n", i, ret_props.cbAlign);
+        ok(ret_props.cbPrefix == req_props.cbPrefix, "Test %u: Got prefix %d.\n", i, ret_props.cbPrefix);
 
         hr = IMemAllocator_Commit(allocator);
         if (!req_props.cbBuffer)
         {
-            ok(hr == VFW_E_SIZENOTSET, "Test %u: Got hr %#lx.\n", i, hr);
+            ok(hr == VFW_E_SIZENOTSET, "Test %u: Got hr %#x.\n", i, hr);
             continue;
         }
-        ok(hr == S_OK, "Test %u: Got hr %#lx.\n", i, hr);
+        ok(hr == S_OK, "Test %u: Got hr %#x.\n", i, hr);
 
         hr = IMemAllocator_SetProperties(allocator, &req_props, &ret_props);
-        ok(hr == VFW_E_ALREADY_COMMITTED, "Test %u: Got hr %#lx.\n", i, hr);
+        ok(hr == VFW_E_ALREADY_COMMITTED, "Test %u: Got hr %#x.\n", i, hr);
 
         hr = IMemAllocator_GetBuffer(allocator, &sample, NULL, NULL, 0);
-        ok(hr == S_OK, "Test %u: Got hr %#lx.\n", i, hr);
+        ok(hr == S_OK, "Test %u: Got hr %#x.\n", i, hr);
 
         size = IMediaSample_GetSize(sample);
-        ok(size == ret_size, "Test %u: Got size %ld.\n", i, size);
+        ok(size == ret_size, "Test %u: Got size %d.\n", i, size);
 
         hr = IMemAllocator_Decommit(allocator);
-        ok(hr == S_OK, "Test %u: Got hr %#lx.\n", i, hr);
+        ok(hr == S_OK, "Test %u: Got hr %#x.\n", i, hr);
 
         hr = IMemAllocator_SetProperties(allocator, &req_props, &ret_props);
-        ok(hr == VFW_E_BUFFERS_OUTSTANDING, "Test %u: Got hr %#lx.\n", i, hr);
+        ok(hr == VFW_E_BUFFERS_OUTSTANDING, "Test %u: Got hr %#x.\n", i, hr);
 
         hr = IMediaSample_Release(sample);
-        ok(hr == S_OK, "Test %u: Got hr %#lx.\n", i, hr);
+        ok(hr == S_OK, "Test %u: Got hr %#x.\n", i, hr);
     }
 
     IMemAllocator_Release(allocator);
@@ -130,42 +130,42 @@ static void test_commit(void)
     BYTE *data;
 
     hr = IMemAllocator_SetProperties(allocator, &req_props, &ret_props);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMemAllocator_GetBuffer(allocator, &sample, NULL, NULL, 0);
-    ok(hr == VFW_E_NOT_COMMITTED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_COMMITTED, "Got hr %#x.\n", hr);
 
     hr = IMemAllocator_Commit(allocator);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMemAllocator_Commit(allocator);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMemAllocator_GetBuffer(allocator, &sample, NULL, NULL, 0);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     IMediaSample_Release(sample);
 
     hr = IMemAllocator_Decommit(allocator);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMemAllocator_Decommit(allocator);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     /* Extant samples remain valid even after Decommit() is called. */
     hr = IMemAllocator_Commit(allocator);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMemAllocator_GetBuffer(allocator, &sample, NULL, NULL, 0);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaSample_GetPointer(sample, &data);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMemAllocator_Decommit(allocator);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     memset(data, 0xcc, 65536);
 
     hr = IMemAllocator_GetBuffer(allocator, &sample2, NULL, NULL, 0);
-    ok(hr == VFW_E_NOT_COMMITTED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_COMMITTED, "Got hr %#x.\n", hr);
 
     IMediaSample_Release(sample);
     IMemAllocator_Release(allocator);
@@ -182,132 +182,132 @@ static void test_sample_time(void)
     HRESULT hr;
 
     hr = IMemAllocator_SetProperties(allocator, &req_props, &ret_props);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMemAllocator_Commit(allocator);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMemAllocator_GetBuffer(allocator, &sample, NULL, NULL, 0);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMediaSample_QueryInterface(sample, &IID_IMediaSample2, (void **)&sample2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     start = 0xdeadbeef;
     end = 0xdeadf00d;
     hr = IMediaSample_GetTime(sample, &start, &end);
-    ok(hr == VFW_E_SAMPLE_TIME_NOT_SET, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_SAMPLE_TIME_NOT_SET, "Got hr %#x.\n", hr);
     ok(start == 0xdeadbeef, "Got start %s.\n", wine_dbgstr_longlong(start));
     ok(end == 0xdeadf00d, "Got end %s.\n", wine_dbgstr_longlong(end));
 
     hr = IMediaSample2_GetProperties(sample2, sizeof(props), (BYTE *)&props);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(!props.dwSampleFlags, "Got flags %#lx.\n", props.dwSampleFlags);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(!props.dwSampleFlags, "Got flags %#x.\n", props.dwSampleFlags);
 
     hr = IMediaSample_SetTime(sample, NULL, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaSample_GetTime(sample, &start, &end);
-    ok(hr == VFW_E_SAMPLE_TIME_NOT_SET, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_SAMPLE_TIME_NOT_SET, "Got hr %#x.\n", hr);
 
     hr = IMediaSample2_GetProperties(sample2, sizeof(props), (BYTE *)&props);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(!props.dwSampleFlags, "Got flags %#lx.\n", props.dwSampleFlags);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(!props.dwSampleFlags, "Got flags %#x.\n", props.dwSampleFlags);
 
     start = 0x123;
     hr = IMediaSample_SetTime(sample, &start, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     start = end = 0;
     hr = IMediaSample_GetTime(sample, &start, &end);
-    ok(hr == VFW_S_NO_STOP_TIME, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_S_NO_STOP_TIME, "Got hr %#x.\n", hr);
     ok(start == 0x123, "Got start %s.\n", wine_dbgstr_longlong(start));
     ok(end == 0x124, "Got end %s.\n", wine_dbgstr_longlong(end));
 
     hr = IMediaSample2_GetProperties(sample2, sizeof(props), (BYTE *)&props);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(props.dwSampleFlags == AM_SAMPLE_TIMEVALID, "Got flags %#lx.\n", props.dwSampleFlags);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(props.dwSampleFlags == AM_SAMPLE_TIMEVALID, "Got flags %#x.\n", props.dwSampleFlags);
     ok(props.tStart == 0x123, "Got start %s.\n", wine_dbgstr_longlong(props.tStart));
 
     hr = IMediaSample_SetTime(sample, NULL, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaSample_GetTime(sample, &start, &end);
-    ok(hr == VFW_E_SAMPLE_TIME_NOT_SET, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_SAMPLE_TIME_NOT_SET, "Got hr %#x.\n", hr);
 
     hr = IMediaSample2_GetProperties(sample2, sizeof(props), (BYTE *)&props);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(!props.dwSampleFlags, "Got flags %#lx.\n", props.dwSampleFlags);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(!props.dwSampleFlags, "Got flags %#x.\n", props.dwSampleFlags);
 
     end = 0x321;
     hr = IMediaSample_SetTime(sample, NULL, &end);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaSample_GetTime(sample, &start, &end);
-    ok(hr == VFW_E_SAMPLE_TIME_NOT_SET, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_SAMPLE_TIME_NOT_SET, "Got hr %#x.\n", hr);
 
     hr = IMediaSample2_GetProperties(sample2, sizeof(props), (BYTE *)&props);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(!props.dwSampleFlags, "Got flags %#lx.\n", props.dwSampleFlags);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(!props.dwSampleFlags, "Got flags %#x.\n", props.dwSampleFlags);
 
     start = 0x123;
     end = 0x321;
     hr = IMediaSample_SetTime(sample, &start, &end);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     start = end = 0;
     hr = IMediaSample_GetTime(sample, &start, &end);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(start == 0x123, "Got start %s.\n", wine_dbgstr_longlong(start));
     ok(end == 0x321, "Got end %s.\n", wine_dbgstr_longlong(end));
 
     hr = IMediaSample2_GetProperties(sample2, sizeof(props), (BYTE *)&props);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(props.dwSampleFlags == (AM_SAMPLE_TIMEVALID | AM_SAMPLE_STOPVALID),
-            "Got flags %#lx.\n", props.dwSampleFlags);
+            "Got flags %#x.\n", props.dwSampleFlags);
     ok(props.tStart == 0x123, "Got start %s.\n", wine_dbgstr_longlong(props.tStart));
     ok(props.tStop == 0x321, "Got end %s.\n", wine_dbgstr_longlong(props.tStop));
 
     props.dwSampleFlags = 0;
     hr = IMediaSample2_SetProperties(sample2, sizeof(props), (BYTE *)&props);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaSample_GetTime(sample, &start, &end);
-    ok(hr == VFW_E_SAMPLE_TIME_NOT_SET, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_SAMPLE_TIME_NOT_SET, "Got hr %#x.\n", hr);
 
     hr = IMediaSample2_GetProperties(sample2, sizeof(props), (BYTE *)&props);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(!props.dwSampleFlags, "Got flags %#lx.\n", props.dwSampleFlags);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(!props.dwSampleFlags, "Got flags %#x.\n", props.dwSampleFlags);
 
     props.dwSampleFlags = AM_SAMPLE_TIMEVALID;
     props.tStart = 0x123;
     hr = IMediaSample2_SetProperties(sample2, sizeof(props), (BYTE *)&props);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     start = end = 0;
     hr = IMediaSample_GetTime(sample, &start, &end);
-    ok(hr == VFW_S_NO_STOP_TIME, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_S_NO_STOP_TIME, "Got hr %#x.\n", hr);
     ok(start == 0x123, "Got start %s.\n", wine_dbgstr_longlong(start));
     ok(end == 0x124, "Got end %s.\n", wine_dbgstr_longlong(end));
 
     hr = IMediaSample2_GetProperties(sample2, sizeof(props), (BYTE *)&props);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(props.dwSampleFlags == AM_SAMPLE_TIMEVALID, "Got flags %#lx.\n", props.dwSampleFlags);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(props.dwSampleFlags == AM_SAMPLE_TIMEVALID, "Got flags %#x.\n", props.dwSampleFlags);
     ok(props.tStart == 0x123, "Got start %s.\n", wine_dbgstr_longlong(props.tStart));
 
     props.dwSampleFlags = AM_SAMPLE_TIMEVALID | AM_SAMPLE_STOPVALID;
     props.tStart = 0x1234;
     props.tStop = 0x4321;
     hr = IMediaSample2_SetProperties(sample2, sizeof(props), (BYTE *)&props);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     start = end = 0;
     hr = IMediaSample_GetTime(sample, &start, &end);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(start == 0x1234, "Got start %s.\n", wine_dbgstr_longlong(start));
     ok(end == 0x4321, "Got end %s.\n", wine_dbgstr_longlong(end));
 
     hr = IMediaSample2_GetProperties(sample2, sizeof(props), (BYTE *)&props);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(props.dwSampleFlags == (AM_SAMPLE_TIMEVALID | AM_SAMPLE_STOPVALID),
-            "Got flags %#lx.\n", props.dwSampleFlags);
+            "Got flags %#x.\n", props.dwSampleFlags);
     ok(props.tStart == 0x1234, "Got start %s.\n", wine_dbgstr_longlong(props.tStart));
     ok(props.tStop == 0x4321, "Got end %s.\n", wine_dbgstr_longlong(props.tStop));
 
@@ -317,28 +317,28 @@ static void test_sample_time(void)
     start = 0x123;
     end = 0x321;
     hr = IMemAllocator_GetBuffer(allocator, &sample, &start, &end, 0);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMediaSample_QueryInterface(sample, &IID_IMediaSample2, (void **)&sample2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     start = 0xdeadbeef;
     end = 0xdeadf00d;
     hr = IMediaSample_GetTime(sample, &start, &end);
-    ok(hr == VFW_E_SAMPLE_TIME_NOT_SET, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_SAMPLE_TIME_NOT_SET, "Got hr %#x.\n", hr);
     ok(start == 0xdeadbeef, "Got start %s.\n", wine_dbgstr_longlong(start));
     ok(end == 0xdeadf00d, "Got end %s.\n", wine_dbgstr_longlong(end));
 
     hr = IMediaSample2_GetProperties(sample2, sizeof(props), (BYTE *)&props);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(!props.dwSampleFlags, "Got flags %#lx.\n", props.dwSampleFlags);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(!props.dwSampleFlags, "Got flags %#x.\n", props.dwSampleFlags);
 
     start = 0x123;
     end = 0x321;
     hr = IMediaSample_SetMediaTime(sample, &start, &end);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaSample_GetTime(sample, &start, &end);
-    ok(hr == VFW_E_SAMPLE_TIME_NOT_SET, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_SAMPLE_TIME_NOT_SET, "Got hr %#x.\n", hr);
 
     IMediaSample2_Release(sample2);
     IMediaSample_Release(sample);
@@ -355,48 +355,48 @@ static void test_media_time(void)
     HRESULT hr;
 
     hr = IMemAllocator_SetProperties(allocator, &req_props, &ret_props);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMemAllocator_Commit(allocator);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMemAllocator_GetBuffer(allocator, &sample, NULL, NULL, 0);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     start = 0xdeadbeef;
     end = 0xdeadf00d;
     hr = IMediaSample_GetMediaTime(sample, &start, &end);
-    ok(hr == VFW_E_MEDIA_TIME_NOT_SET, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_MEDIA_TIME_NOT_SET, "Got hr %#x.\n", hr);
     ok(start == 0xdeadbeef, "Got start %s.\n", wine_dbgstr_longlong(start));
     ok(end == 0xdeadf00d, "Got end %s.\n", wine_dbgstr_longlong(end));
 
     hr = IMediaSample_SetMediaTime(sample, NULL, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaSample_GetMediaTime(sample, &start, &end);
-    ok(hr == VFW_E_MEDIA_TIME_NOT_SET, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_MEDIA_TIME_NOT_SET, "Got hr %#x.\n", hr);
 
     /* This crashes on quartz.dll < 6.6. */
     if (0)
     {
         start = 0x123;
         hr = IMediaSample_SetMediaTime(sample, &start, NULL);
-        ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+        ok(hr == E_POINTER, "Got hr %#x.\n", hr);
     }
 
     end = 0x321;
     hr = IMediaSample_SetMediaTime(sample, NULL, &end);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaSample_GetMediaTime(sample, &start, &end);
-    ok(hr == VFW_E_MEDIA_TIME_NOT_SET, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_MEDIA_TIME_NOT_SET, "Got hr %#x.\n", hr);
 
     start = 0x123;
     end = 0x321;
     hr = IMediaSample_SetMediaTime(sample, &start, &end);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     start = end = 0;
     hr = IMediaSample_GetMediaTime(sample, &start, &end);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(start == 0x123, "Got start %s.\n", wine_dbgstr_longlong(start));
     ok(end == 0x321, "Got end %s.\n", wine_dbgstr_longlong(end));
 
@@ -405,35 +405,35 @@ static void test_media_time(void)
     start = 0x123;
     end = 0x321;
     hr = IMemAllocator_GetBuffer(allocator, &sample, &start, &end, 0);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     start = 0xdeadbeef;
     end = 0xdeadf00d;
     hr = IMediaSample_GetMediaTime(sample, &start, &end);
-    ok(hr == VFW_E_MEDIA_TIME_NOT_SET, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_MEDIA_TIME_NOT_SET, "Got hr %#x.\n", hr);
     ok(start == 0xdeadbeef, "Got start %s.\n", wine_dbgstr_longlong(start));
     ok(end == 0xdeadf00d, "Got end %s.\n", wine_dbgstr_longlong(end));
 
     start = 0x123;
     end = 0x321;
     hr = IMediaSample_SetTime(sample, &start, &end);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaSample_GetMediaTime(sample, &start, &end);
-    ok(hr == VFW_E_MEDIA_TIME_NOT_SET, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_MEDIA_TIME_NOT_SET, "Got hr %#x.\n", hr);
 
     start = 0x123;
     end = 0x321;
     hr = IMediaSample_SetMediaTime(sample, &start, &end);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     IMediaSample_Release(sample);
 
     hr = IMemAllocator_GetBuffer(allocator, &sample, NULL, NULL, 0);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaSample_GetMediaTime(sample, &start, &end);
-    ok(hr == VFW_E_MEDIA_TIME_NOT_SET, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_MEDIA_TIME_NOT_SET, "Got hr %#x.\n", hr);
 
     IMediaSample_Release(sample);
     IMemAllocator_Release(allocator);
@@ -457,193 +457,193 @@ static void test_sample_properties(void)
     expect_mt.pbFormat = NULL;
 
     hr = IMemAllocator_SetProperties(allocator, &req_props, &ret_props);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMemAllocator_Commit(allocator);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMemAllocator_GetBuffer(allocator, &sample, NULL, NULL, 0);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMediaSample_QueryInterface(sample, &IID_IMediaSample2, (void **)&sample2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaSample_GetPointer(sample, &data);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaSample2_GetProperties(sample2, sizeof(props), (BYTE *)&props);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(!props.dwTypeSpecificFlags, "Got type-specific flags %#lx.\n", props.dwTypeSpecificFlags);
-    ok(!props.dwSampleFlags, "Got flags %#lx.\n", props.dwSampleFlags);
-    ok(props.lActual == 65536, "Got actual length %ld.\n", props.lActual);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(!props.dwTypeSpecificFlags, "Got type-specific flags %#x.\n", props.dwTypeSpecificFlags);
+    ok(!props.dwSampleFlags, "Got flags %#x.\n", props.dwSampleFlags);
+    ok(props.lActual == 65536, "Got actual length %d.\n", props.lActual);
     ok(!props.tStart, "Got sample start %s.\n", wine_dbgstr_longlong(props.tStart));
-    ok(!props.dwStreamId, "Got stream ID %#lx.\n", props.dwStreamId);
+    ok(!props.dwStreamId, "Got stream ID %#x.\n", props.dwStreamId);
     ok(!props.pMediaType, "Got media type %p.\n", props.pMediaType);
     ok(props.pbBuffer == data, "Expected pointer %p, got %p.\n", data, props.pbBuffer);
-    ok(props.cbBuffer == 65536, "Got buffer length %ld.\n", props.cbBuffer);
+    ok(props.cbBuffer == 65536, "Got buffer length %d.\n", props.cbBuffer);
 
     /* media type */
 
     mt = (AM_MEDIA_TYPE *)0xdeadbeef;
     hr = IMediaSample_GetMediaType(sample, &mt);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     ok(!mt, "Got media type %p.\n", mt);
 
     hr = IMediaSample_SetMediaType(sample, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     mt = (AM_MEDIA_TYPE *)0xdeadbeef;
     hr = IMediaSample_GetMediaType(sample, &mt);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     ok(!mt, "Got media type %p.\n", mt);
 
     hr = IMediaSample2_GetProperties(sample2, sizeof(props), (BYTE *)&props);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(!props.dwSampleFlags, "Got flags %#lx.\n", props.dwSampleFlags);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(!props.dwSampleFlags, "Got flags %#x.\n", props.dwSampleFlags);
     ok(!props.pMediaType, "Got media type %p.\n", props.pMediaType);
 
     hr = IMediaSample_SetMediaType(sample, &expect_mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaSample_GetMediaType(sample, &mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(!memcmp(mt, &expect_mt, sizeof(AM_MEDIA_TYPE)), "Media types didn't match.\n");
     CoTaskMemFree(mt);
 
     hr = IMediaSample2_GetProperties(sample2, sizeof(props), (BYTE *)&props);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(props.dwSampleFlags == AM_SAMPLE_TYPECHANGED, "Got flags %#lx.\n", props.dwSampleFlags);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(props.dwSampleFlags == AM_SAMPLE_TYPECHANGED, "Got flags %#x.\n", props.dwSampleFlags);
     ok(!memcmp(props.pMediaType, &expect_mt, sizeof(AM_MEDIA_TYPE)), "Media types didn't match.\n");
 
     hr = IMediaSample_SetMediaType(sample, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     mt = (AM_MEDIA_TYPE *)0xdeadbeef;
     hr = IMediaSample_GetMediaType(sample, &mt);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     ok(!mt, "Got media type %p.\n", mt);
 
     hr = IMediaSample2_GetProperties(sample2, sizeof(props), (BYTE *)&props);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(!props.dwSampleFlags, "Got flags %#lx.\n", props.dwSampleFlags);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(!props.dwSampleFlags, "Got flags %#x.\n", props.dwSampleFlags);
     ok(!props.pMediaType, "Got media type %p.\n", props.pMediaType);
 
     /* actual length */
 
     len = IMediaSample_GetActualDataLength(sample);
-    ok(len == 65536, "Got length %ld.\n", len);
+    ok(len == 65536, "Got length %d.\n", len);
 
     hr = IMediaSample_SetActualDataLength(sample, 65537);
-    ok(hr == VFW_E_BUFFER_OVERFLOW, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_BUFFER_OVERFLOW, "Got hr %#x.\n", hr);
     hr = IMediaSample_SetActualDataLength(sample, -1);
-    ok(hr == VFW_E_BUFFER_OVERFLOW || broken(hr == S_OK), "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_BUFFER_OVERFLOW || broken(hr == S_OK), "Got hr %#x.\n", hr);
     hr = IMediaSample_SetActualDataLength(sample, 65536);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMediaSample_SetActualDataLength(sample, 0);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     len = IMediaSample_GetActualDataLength(sample);
-    ok(len == 0, "Got length %ld.\n", len);
+    ok(len == 0, "Got length %d.\n", len);
 
     hr = IMediaSample2_GetProperties(sample2, sizeof(props), (BYTE *)&props);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(props.lActual == 0, "Got actual length %ld.\n", props.lActual);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(props.lActual == 0, "Got actual length %d.\n", props.lActual);
 
     props.lActual = 123;
     hr = IMediaSample2_SetProperties(sample2, sizeof(props), (BYTE *)&props);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaSample2_GetProperties(sample2, sizeof(props), (BYTE *)&props);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(props.lActual == 123, "Got actual length %ld.\n", props.lActual);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(props.lActual == 123, "Got actual length %d.\n", props.lActual);
 
     len = IMediaSample_GetActualDataLength(sample);
-    ok(len == 123, "Got length %ld.\n", len);
+    ok(len == 123, "Got length %d.\n", len);
 
     /* boolean flags */
 
     hr = IMediaSample_IsPreroll(sample);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     hr = IMediaSample_SetPreroll(sample, TRUE);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMediaSample_IsPreroll(sample);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMediaSample2_GetProperties(sample2, sizeof(props), (BYTE *)&props);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(props.dwSampleFlags == AM_SAMPLE_PREROLL, "Got flags %#lx.\n", props.dwSampleFlags);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(props.dwSampleFlags == AM_SAMPLE_PREROLL, "Got flags %#x.\n", props.dwSampleFlags);
     hr = IMediaSample_SetPreroll(sample, FALSE);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMediaSample_IsPreroll(sample);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     hr = IMediaSample2_GetProperties(sample2, sizeof(props), (BYTE *)&props);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(!props.dwSampleFlags, "Got flags %#lx.\n", props.dwSampleFlags);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(!props.dwSampleFlags, "Got flags %#x.\n", props.dwSampleFlags);
 
     hr = IMediaSample_IsDiscontinuity(sample);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     hr = IMediaSample_SetDiscontinuity(sample, TRUE);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMediaSample_IsDiscontinuity(sample);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMediaSample2_GetProperties(sample2, sizeof(props), (BYTE *)&props);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(props.dwSampleFlags == AM_SAMPLE_DATADISCONTINUITY, "Got flags %#lx.\n", props.dwSampleFlags);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(props.dwSampleFlags == AM_SAMPLE_DATADISCONTINUITY, "Got flags %#x.\n", props.dwSampleFlags);
     hr = IMediaSample_SetDiscontinuity(sample, FALSE);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMediaSample_IsDiscontinuity(sample);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     hr = IMediaSample2_GetProperties(sample2, sizeof(props), (BYTE *)&props);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(!props.dwSampleFlags, "Got flags %#lx.\n", props.dwSampleFlags);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(!props.dwSampleFlags, "Got flags %#x.\n", props.dwSampleFlags);
 
     hr = IMediaSample_IsSyncPoint(sample);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     hr = IMediaSample_SetSyncPoint(sample, TRUE);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMediaSample_IsSyncPoint(sample);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMediaSample2_GetProperties(sample2, sizeof(props), (BYTE *)&props);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(props.dwSampleFlags == AM_SAMPLE_SPLICEPOINT, "Got flags %#lx.\n", props.dwSampleFlags);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(props.dwSampleFlags == AM_SAMPLE_SPLICEPOINT, "Got flags %#x.\n", props.dwSampleFlags);
     hr = IMediaSample_SetSyncPoint(sample, FALSE);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMediaSample_IsSyncPoint(sample);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     hr = IMediaSample2_GetProperties(sample2, sizeof(props), (BYTE *)&props);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(!props.dwSampleFlags, "Got flags %#lx.\n", props.dwSampleFlags);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(!props.dwSampleFlags, "Got flags %#x.\n", props.dwSampleFlags);
 
     props.dwSampleFlags = (AM_SAMPLE_PREROLL | AM_SAMPLE_DATADISCONTINUITY | AM_SAMPLE_SPLICEPOINT);
     hr = IMediaSample2_SetProperties(sample2, sizeof(props), (BYTE *)&props);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMediaSample_IsPreroll(sample);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMediaSample_IsDiscontinuity(sample);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMediaSample_IsSyncPoint(sample);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMediaSample2_GetProperties(sample2, sizeof(props), (BYTE *)&props);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(props.dwSampleFlags == (AM_SAMPLE_PREROLL | AM_SAMPLE_DATADISCONTINUITY | AM_SAMPLE_SPLICEPOINT),
-            "Got flags %#lx.\n", props.dwSampleFlags);
+            "Got flags %#x.\n", props.dwSampleFlags);
 
     hr = IMediaSample_SetMediaType(sample, &expect_mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     IMediaSample2_Release(sample2);
     IMediaSample_Release(sample);
 
     hr = IMemAllocator_GetBuffer(allocator, &sample, NULL, NULL, 0);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMediaSample_QueryInterface(sample, &IID_IMediaSample2, (void **)&sample2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaSample2_GetProperties(sample2, sizeof(props), (BYTE *)&props);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(!props.dwTypeSpecificFlags, "Got type-specific flags %#lx.\n", props.dwTypeSpecificFlags);
-    ok(!props.dwSampleFlags, "Got flags %#lx.\n", props.dwSampleFlags);
-    ok(props.lActual == 123, "Got actual length %ld.\n", props.lActual);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(!props.dwTypeSpecificFlags, "Got type-specific flags %#x.\n", props.dwTypeSpecificFlags);
+    ok(!props.dwSampleFlags, "Got flags %#x.\n", props.dwSampleFlags);
+    ok(props.lActual == 123, "Got actual length %d.\n", props.lActual);
     ok(!props.tStart, "Got sample start %s.\n", wine_dbgstr_longlong(props.tStart));
-    ok(!props.dwStreamId, "Got stream ID %#lx.\n", props.dwStreamId);
+    ok(!props.dwStreamId, "Got stream ID %#x.\n", props.dwStreamId);
     ok(!props.pMediaType, "Got media type %p.\n", props.pMediaType);
-    ok(props.cbBuffer == 65536, "Got buffer length %ld.\n", props.cbBuffer);
+    ok(props.cbBuffer == 65536, "Got buffer length %d.\n", props.cbBuffer);
 
     IMediaSample2_Release(sample2);
     IMediaSample_Release(sample);
diff --git a/dlls/quartz/tests/mpegsplit.c b/dlls/quartz/tests/mpegsplit.c
index b2cced84c68..0809c5f861f 100644
--- wine/dlls/quartz/tests/mpegsplit.c
+++ wine/dlls/quartz/tests/mpegsplit.c
@@ -32,7 +32,7 @@ static IBaseFilter *create_mpeg_splitter(void)
     IBaseFilter *filter = NULL;
     HRESULT hr = CoCreateInstance(&CLSID_MPEG1Splitter, NULL, CLSCTX_INPROC_SERVER,
             &IID_IBaseFilter, (void **)&filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     return filter;
 }
 
@@ -54,11 +54,11 @@ static WCHAR *load_resource(const WCHAR *name)
     wcscat(pathW, name);
 
     file = CreateFileW(pathW, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, 0);
-    ok(file != INVALID_HANDLE_VALUE, "Failed to create file %s, error %lu.\n",
+    ok(file != INVALID_HANDLE_VALUE, "Failed to create file %s, error %u.\n",
             wine_dbgstr_w(pathW), GetLastError());
 
     res = FindResourceW(NULL, name, (LPCWSTR)RT_RCDATA);
-    ok(!!res, "Failed to load resource, error %lu.\n", GetLastError());
+    ok(!!res, "Failed to load resource, error %u.\n", GetLastError());
     ptr = LockResource(LoadResource(GetModuleHandleA(NULL), res));
     WriteFile(file, ptr, SizeofResource( GetModuleHandleA(NULL), res), &written, NULL);
     ok(written == SizeofResource(GetModuleHandleA(NULL), res), "Failed to write resource.\n");
@@ -96,7 +96,7 @@ static IFilterGraph2 *connect_input(IBaseFilter *splitter, const WCHAR *filename
     IBaseFilter_FindPin(reader, L"Output", &source);
 
     hr = IFilterGraph2_ConnectDirect(graph, source, sink, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     IPin_Release(source);
     IPin_Release(sink);
@@ -115,7 +115,7 @@ static void check_interface_(unsigned int line, void *iface_ptr, REFIID iid, BOO
     expected_hr = supported ? S_OK : E_NOINTERFACE;
 
     hr = IUnknown_QueryInterface(iface, iid, (void **)&unk);
-    ok_(__FILE__, line)(hr == expected_hr, "Got hr %#lx, expected %#lx.\n", hr, expected_hr);
+    ok_(__FILE__, line)(hr == expected_hr, "Got hr %#x, expected %#x.\n", hr, expected_hr);
     if (SUCCEEDED(hr))
         IUnknown_Release(unk);
 }
@@ -222,53 +222,53 @@ static void test_aggregation(void)
     filter = (IBaseFilter *)0xdeadbeef;
     hr = CoCreateInstance(&CLSID_MPEG1Splitter, &test_outer, CLSCTX_INPROC_SERVER,
             &IID_IBaseFilter, (void **)&filter);
-    ok(hr == E_NOINTERFACE, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOINTERFACE, "Got hr %#x.\n", hr);
     ok(!filter, "Got interface %p.\n", filter);
 
     hr = CoCreateInstance(&CLSID_MPEG1Splitter, &test_outer, CLSCTX_INPROC_SERVER,
             &IID_IUnknown, (void **)&unk);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(outer_ref == 1, "Got unexpected refcount %ld.\n", outer_ref);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
     ok(unk != &test_outer, "Returned IUnknown should not be outer IUnknown.\n");
     ref = get_refcount(unk);
-    ok(ref == 1, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
 
     ref = IUnknown_AddRef(unk);
-    ok(ref == 2, "Got unexpected refcount %ld.\n", ref);
-    ok(outer_ref == 1, "Got unexpected refcount %ld.\n", outer_ref);
+    ok(ref == 2, "Got unexpected refcount %d.\n", ref);
+    ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
 
     ref = IUnknown_Release(unk);
-    ok(ref == 1, "Got unexpected refcount %ld.\n", ref);
-    ok(outer_ref == 1, "Got unexpected refcount %ld.\n", outer_ref);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
+    ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
 
     hr = IUnknown_QueryInterface(unk, &IID_IUnknown, (void **)&unk2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(unk2 == unk, "Got unexpected IUnknown %p.\n", unk2);
     IUnknown_Release(unk2);
 
     hr = IUnknown_QueryInterface(unk, &IID_IBaseFilter, (void **)&filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_QueryInterface(filter, &IID_IUnknown, (void **)&unk2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(unk2 == (IUnknown *)0xdeadbeef, "Got unexpected IUnknown %p.\n", unk2);
 
     hr = IBaseFilter_QueryInterface(filter, &IID_IBaseFilter, (void **)&filter2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(filter2 == (IBaseFilter *)0xdeadbeef, "Got unexpected IBaseFilter %p.\n", filter2);
 
     hr = IUnknown_QueryInterface(unk, &test_iid, (void **)&unk2);
-    ok(hr == E_NOINTERFACE, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOINTERFACE, "Got hr %#x.\n", hr);
     ok(!unk2, "Got unexpected IUnknown %p.\n", unk2);
 
     hr = IBaseFilter_QueryInterface(filter, &test_iid, (void **)&unk2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(unk2 == (IUnknown *)0xdeadbeef, "Got unexpected IUnknown %p.\n", unk2);
 
     IBaseFilter_Release(filter);
     ref = IUnknown_Release(unk);
-    ok(!ref, "Got unexpected refcount %ld.\n", ref);
-    ok(outer_ref == 1, "Got unexpected refcount %ld.\n", outer_ref);
+    ok(!ref, "Got unexpected refcount %d.\n", ref);
+    ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
 }
 
 static void test_enum_pins(void)
@@ -283,71 +283,71 @@ static void test_enum_pins(void)
     BOOL ret;
 
     ref = get_refcount(filter);
-    ok(ref == 1, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
 
     hr = IBaseFilter_EnumPins(filter, &enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ref = get_refcount(filter);
-    ok(ref == 2, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 2, "Got unexpected refcount %d.\n", ref);
     ref = get_refcount(enum1);
-    ok(ref == 1, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
 
     hr = IEnumPins_Next(enum1, 1, pins, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ref = get_refcount(filter);
-    ok(ref == 3, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 3, "Got unexpected refcount %d.\n", ref);
     ref = get_refcount(pins[0]);
-    ok(ref == 3, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 3, "Got unexpected refcount %d.\n", ref);
     ref = get_refcount(enum1);
-    ok(ref == 1, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
     IPin_Release(pins[0]);
 
     hr = IEnumPins_Next(enum1, 1, pins, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum1, 1, pins, &count);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(count == 1, "Got count %lu.\n", count);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(count == 1, "Got count %u.\n", count);
     IPin_Release(pins[0]);
 
     hr = IEnumPins_Next(enum1, 1, pins, &count);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
-    ok(!count, "Got count %lu.\n", count);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    ok(!count, "Got count %u.\n", count);
 
     hr = IEnumPins_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum1, 2, pins, NULL);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum1, 2, pins, &count);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
-    ok(count == 1, "Got count %lu.\n", count);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    ok(count == 1, "Got count %u.\n", count);
     IPin_Release(pins[0]);
 
     hr = IEnumPins_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Clone(enum1, &enum2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Skip(enum1, 2);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Skip(enum1, 1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Skip(enum1, 1);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum1, 1, pins, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum2, 1, pins, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     IPin_Release(pins[0]);
 
     IEnumPins_Release(enum2);
@@ -355,46 +355,46 @@ static void test_enum_pins(void)
     graph = connect_input(filter, filename);
 
     hr = IEnumPins_Next(enum1, 1, pins, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum1, 1, pins, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     IPin_Release(pins[0]);
 
     hr = IEnumPins_Next(enum1, 1, pins, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     IPin_Release(pins[0]);
 
     hr = IEnumPins_Next(enum1, 1, pins, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum1, 2, pins, &count);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(count == 2, "Got count %lu.\n", count);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(count == 2, "Got count %u.\n", count);
     IPin_Release(pins[0]);
     IPin_Release(pins[1]);
 
     hr = IEnumPins_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum1, 3, pins, &count);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
-    ok(count == 2, "Got count %lu.\n", count);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    ok(count == 2, "Got count %u.\n", count);
     IPin_Release(pins[0]);
     IPin_Release(pins[1]);
 
     IEnumPins_Release(enum1);
     IFilterGraph2_Release(graph);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ret = DeleteFileW(filename);
-    ok(ret, "Failed to delete file, error %lu.\n", GetLastError());
+    ok(ret, "Failed to delete file, error %u.\n", GetLastError());
 }
 
 static void test_find_pin(void)
@@ -409,34 +409,34 @@ static void test_find_pin(void)
     BOOL ret;
 
     hr = IBaseFilter_FindPin(filter, L"input pin", &pin);
-    ok(hr == VFW_E_NOT_FOUND, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_FOUND, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_FindPin(filter, L"Input", &pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     IPin_Release(pin);
 
     hr = IBaseFilter_FindPin(filter, L"Audio", &pin);
-    ok(hr == VFW_E_NOT_FOUND, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_FOUND, "Got hr %#x.\n", hr);
 
     graph = connect_input(filter, filename);
 
     hr = IBaseFilter_EnumPins(filter, &enum_pins);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum_pins, 1, &pin2, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_FindPin(filter, L"Input", &pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(pin == pin2, "Expected pin %p, got %p.\n", pin2, pin);
     IPin_Release(pin);
     IPin_Release(pin2);
 
     hr = IEnumPins_Next(enum_pins, 1, &pin2, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_FindPin(filter, L"Audio", &pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(pin == pin2, "Expected pin %p, got %p.\n", pin2, pin);
     IPin_Release(pin);
     IPin_Release(pin2);
@@ -444,9 +444,9 @@ static void test_find_pin(void)
     IEnumPins_Release(enum_pins);
     IFilterGraph2_Release(graph);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ret = DeleteFileW(filename);
-    ok(ret, "Failed to delete file, error %lu.\n", GetLastError());
+    ok(ret, "Failed to delete file, error %u.\n", GetLastError());
 }
 
 static void test_pin_info(void)
@@ -465,49 +465,49 @@ static void test_pin_info(void)
     graph = connect_input(filter, filename);
 
     hr = IBaseFilter_FindPin(filter, L"Input", &pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     expect_ref = get_refcount(filter);
     ref = get_refcount(pin);
-    ok(ref == expect_ref, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == expect_ref, "Got unexpected refcount %d.\n", ref);
 
     hr = IPin_QueryPinInfo(pin, &info);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(info.pFilter == filter, "Expected filter %p, got %p.\n", filter, info.pFilter);
     ok(info.dir == PINDIR_INPUT, "Got direction %d.\n", info.dir);
     ok(!wcscmp(info.achName, L"Input"), "Got name %s.\n", wine_dbgstr_w(info.achName));
     ref = get_refcount(filter);
-    ok(ref == expect_ref + 1, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == expect_ref + 1, "Got unexpected refcount %d.\n", ref);
     ref = get_refcount(pin);
-    ok(ref == expect_ref + 1, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == expect_ref + 1, "Got unexpected refcount %d.\n", ref);
     IBaseFilter_Release(info.pFilter);
 
     hr = IPin_QueryDirection(pin, &dir);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(dir == PINDIR_INPUT, "Got direction %d.\n", dir);
 
     hr = IPin_QueryId(pin, &id);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(!wcscmp(id, L"Input"), "Got id %s.\n", wine_dbgstr_w(id));
     CoTaskMemFree(id);
 
     IPin_Release(pin);
 
     hr = IBaseFilter_FindPin(filter, L"Audio", &pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IPin_QueryPinInfo(pin, &info);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(info.pFilter == filter, "Expected filter %p, got %p.\n", filter, info.pFilter);
     ok(info.dir == PINDIR_OUTPUT, "Got direction %d.\n", info.dir);
     ok(!wcscmp(info.achName, L"Audio"), "Got name %s.\n", wine_dbgstr_w(info.achName));
     IBaseFilter_Release(info.pFilter);
 
     hr = IPin_QueryDirection(pin, &dir);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(dir == PINDIR_OUTPUT, "Got direction %d.\n", dir);
 
     hr = IPin_QueryId(pin, &id);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(!wcscmp(id, L"Audio"), "Got id %s.\n", wine_dbgstr_w(id));
     CoTaskMemFree(id);
 
@@ -515,9 +515,9 @@ static void test_pin_info(void)
 
     IFilterGraph2_Release(graph);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ret = DeleteFileW(filename);
-    ok(ret, "Failed to delete file, error %lu.\n", GetLastError());
+    ok(ret, "Failed to delete file, error %u.\n", GetLastError());
 }
 
 static void test_media_types(void)
@@ -548,7 +548,7 @@ static void test_media_types(void)
     IBaseFilter_FindPin(filter, L"Input", &pin);
 
     hr = IPin_EnumMediaTypes(pin, &enummt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     expect_mt.majortype = MEDIATYPE_Stream;
     expect_mt.bFixedSizeSamples = TRUE;
@@ -556,7 +556,7 @@ static void test_media_types(void)
     expect_mt.lSampleSize = 1;
 
     hr = IEnumMediaTypes_Next(enummt, 1, &pmt, NULL);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
     expect_mt.subtype = MEDIASUBTYPE_MPEG1System;
     if (hr == S_OK)
     {
@@ -565,7 +565,7 @@ static void test_media_types(void)
     }
 
     hr = IEnumMediaTypes_Next(enummt, 1, &pmt, NULL);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
     expect_mt.subtype = MEDIASUBTYPE_MPEG1VideoCD;
     if (hr == S_OK)
     {
@@ -574,7 +574,7 @@ static void test_media_types(void)
     }
 
     hr = IEnumMediaTypes_Next(enummt, 1, &pmt, NULL);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
     expect_mt.subtype = MEDIASUBTYPE_MPEG1Video;
     if (hr == S_OK)
     {
@@ -583,7 +583,7 @@ static void test_media_types(void)
     }
 
     hr = IEnumMediaTypes_Next(enummt, 1, &pmt, NULL);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
     expect_mt.subtype = MEDIASUBTYPE_MPEG1Audio;
     if (hr == S_OK)
     {
@@ -592,70 +592,70 @@ static void test_media_types(void)
     }
 
     hr = IEnumMediaTypes_Next(enummt, 1, &pmt, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     IEnumMediaTypes_Release(enummt);
 
     mt.majortype = MEDIATYPE_Stream;
     mt.subtype = MEDIASUBTYPE_MPEG1Audio;
     hr = IPin_QueryAccept(pin, &mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     mt.subtype = MEDIASUBTYPE_MPEG1Video;
     hr = IPin_QueryAccept(pin, &mt);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
     mt.subtype = MEDIASUBTYPE_MPEG1VideoCD;
     hr = IPin_QueryAccept(pin, &mt);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
     mt.subtype = MEDIASUBTYPE_MPEG1System;
     hr = IPin_QueryAccept(pin, &mt);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
     mt.subtype = MEDIASUBTYPE_MPEG1AudioPayload;
     hr = IPin_QueryAccept(pin, &mt);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     mt.subtype = MEDIASUBTYPE_MPEG1Payload;
     hr = IPin_QueryAccept(pin, &mt);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     mt.subtype = MEDIASUBTYPE_MPEG1Packet;
     hr = IPin_QueryAccept(pin, &mt);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     mt.subtype = GUID_NULL;
     hr = IPin_QueryAccept(pin, &mt);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     mt.subtype = MEDIASUBTYPE_MPEG1Audio;
 
     mt.majortype = MEDIATYPE_Audio;
     hr = IPin_QueryAccept(pin, &mt);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     mt.majortype = GUID_NULL;
     hr = IPin_QueryAccept(pin, &mt);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     mt.majortype = MEDIATYPE_Stream;
 
     mt.formattype = FORMAT_None;
     hr = IPin_QueryAccept(pin, &mt);
-    todo_wine ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     mt.formattype = FORMAT_VideoInfo;
     hr = IPin_QueryAccept(pin, &mt);
-    todo_wine ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     mt.formattype = FORMAT_WaveFormatEx;
     hr = IPin_QueryAccept(pin, &mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     mt.bFixedSizeSamples = TRUE;
     mt.bTemporalCompression = TRUE;
     mt.lSampleSize = 123;
     hr = IPin_QueryAccept(pin, &mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     graph = connect_input(filter, filename);
 
     /* Connecting input doesn't change the reported media types. */
     hr = IPin_EnumMediaTypes(pin, &enummt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enummt, 1, &pmt, NULL);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
     expect_mt.subtype = MEDIASUBTYPE_MPEG1System;
     if (hr == S_OK)
     {
@@ -669,21 +669,21 @@ static void test_media_types(void)
     IBaseFilter_FindPin(filter, L"Audio", &pin);
 
     hr = IPin_EnumMediaTypes(pin, &enummt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enummt, 1, &pmt, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(IsEqualGUID(&pmt->majortype, &MEDIATYPE_Audio), "Got major type %s.\n",
             wine_dbgstr_guid(&pmt->majortype));
     todo_wine ok(IsEqualGUID(&pmt->subtype, &MEDIASUBTYPE_MPEG1AudioPayload), "Got subtype %s.\n",
             wine_dbgstr_guid(&pmt->subtype));
     todo_wine ok(pmt->bFixedSizeSamples == TRUE, "Got fixed size %d.\n", pmt->bFixedSizeSamples);
     ok(!pmt->bTemporalCompression, "Got temporal compression %d.\n", pmt->bTemporalCompression);
-    todo_wine ok(pmt->lSampleSize == 1, "Got sample size %lu.\n", pmt->lSampleSize);
+    todo_wine ok(pmt->lSampleSize == 1, "Got sample size %u.\n", pmt->lSampleSize);
     ok(IsEqualGUID(&pmt->formattype, &FORMAT_WaveFormatEx), "Got format type %s.\n",
             wine_dbgstr_guid(&pmt->formattype));
     ok(!pmt->pUnk, "Got pUnk %p.\n", pmt->pUnk);
-    todo_wine ok(pmt->cbFormat == sizeof(MPEG1WAVEFORMAT), "Got format size %lu.\n", pmt->cbFormat);
+    todo_wine ok(pmt->cbFormat == sizeof(MPEG1WAVEFORMAT), "Got format size %u.\n", pmt->cbFormat);
     if (pmt->cbFormat == sizeof(MPEG1WAVEFORMAT))
     {
         /* Native will sometimes leave junk in the joint stereo flags. */
@@ -692,58 +692,58 @@ static void test_media_types(void)
     }
 
     hr = IPin_QueryAccept(pin, pmt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     pmt->bFixedSizeSamples = FALSE;
     pmt->bTemporalCompression = TRUE;
     pmt->lSampleSize = 123;
     hr = IPin_QueryAccept(pin, pmt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     pmt->majortype = MEDIATYPE_Video;
     hr = IPin_QueryAccept(pin, pmt);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     pmt->majortype = GUID_NULL;
     hr = IPin_QueryAccept(pin, pmt);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     pmt->majortype = MEDIATYPE_Audio;
 
     pmt->subtype = MEDIASUBTYPE_MPEG1Audio;
     hr = IPin_QueryAccept(pin, pmt);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     pmt->subtype = MEDIASUBTYPE_MPEG1Packet;
     hr = IPin_QueryAccept(pin, pmt);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     pmt->subtype = MEDIASUBTYPE_MPEG1Video;
     hr = IPin_QueryAccept(pin, pmt);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     pmt->subtype = MEDIASUBTYPE_MPEG1AudioPayload;
 
     pmt->formattype = FORMAT_None;
     hr = IPin_QueryAccept(pin, pmt);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     pmt->formattype = GUID_NULL;
     hr = IPin_QueryAccept(pin, pmt);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     pmt->formattype = FORMAT_WaveFormatEx;
 
     wfx = (MPEG1WAVEFORMAT *)pmt->pbFormat;
 
     wfx->fwHeadLayer = ACM_MPEG_LAYER2;
     hr = IPin_QueryAccept(pin, pmt);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     wfx->fwHeadLayer = ACM_MPEG_LAYER3;
 
     wfx->wfx.wFormatTag = WAVE_FORMAT_MPEGLAYER3;
     hr = IPin_QueryAccept(pin, pmt);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     wfx->wfx.wFormatTag = WAVE_FORMAT_MPEG;
 
     CoTaskMemFree(pmt->pbFormat);
     CoTaskMemFree(pmt);
 
     hr = IEnumMediaTypes_Next(enummt, 1, &pmt, NULL);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
     if (hr != S_OK)
         goto done;
     ok(IsEqualGUID(&pmt->majortype, &MEDIATYPE_Audio), "Got major type %s.\n",
@@ -752,80 +752,80 @@ static void test_media_types(void)
             wine_dbgstr_guid(&pmt->subtype));
     ok(pmt->bFixedSizeSamples == TRUE, "Got fixed size %d.\n", pmt->bFixedSizeSamples);
     ok(!pmt->bTemporalCompression, "Got temporal compression %d.\n", pmt->bTemporalCompression);
-    ok(pmt->lSampleSize == 1, "Got sample size %lu.\n", pmt->lSampleSize);
+    ok(pmt->lSampleSize == 1, "Got sample size %u.\n", pmt->lSampleSize);
     ok(IsEqualGUID(&pmt->formattype, &FORMAT_WaveFormatEx), "Got format type %s.\n",
             wine_dbgstr_guid(&pmt->formattype));
     ok(!pmt->pUnk, "Got pUnk %p.\n", pmt->pUnk);
-    ok(pmt->cbFormat == sizeof(MPEG1WAVEFORMAT), "Got format size %lu.\n", pmt->cbFormat);
+    ok(pmt->cbFormat == sizeof(MPEG1WAVEFORMAT), "Got format size %u.\n", pmt->cbFormat);
     /* Native will sometimes leave junk in the joint stereo flags. */
     expect_wfx.fwHeadModeExt = ((MPEG1WAVEFORMAT *)pmt->pbFormat)->fwHeadModeExt;
     ok(!memcmp(pmt->pbFormat, &expect_wfx, sizeof(MPEG1WAVEFORMAT)), "Format blocks didn't match.\n");
 
     hr = IPin_QueryAccept(pin, pmt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     CoTaskMemFree(pmt->pbFormat);
     CoTaskMemFree(pmt);
 
     hr = IEnumMediaTypes_Next(enummt, 1, &pmt, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(IsEqualGUID(&pmt->majortype, &MEDIATYPE_Audio), "Got major type %s.\n",
             wine_dbgstr_guid(&pmt->majortype));
     ok(IsEqualGUID(&pmt->subtype, &MEDIASUBTYPE_mp3), "Got subtype %s.\n",
             wine_dbgstr_guid(&pmt->subtype));
     ok(pmt->bFixedSizeSamples == TRUE, "Got fixed size %d.\n", pmt->bFixedSizeSamples);
     ok(!pmt->bTemporalCompression, "Got temporal compression %d.\n", pmt->bTemporalCompression);
-    ok(pmt->lSampleSize == 1, "Got sample size %lu.\n", pmt->lSampleSize);
+    ok(pmt->lSampleSize == 1, "Got sample size %u.\n", pmt->lSampleSize);
     ok(IsEqualGUID(&pmt->formattype, &FORMAT_WaveFormatEx), "Got format type %s.\n",
             wine_dbgstr_guid(&pmt->formattype));
     ok(!pmt->pUnk, "Got pUnk %p.\n", pmt->pUnk);
-    ok(pmt->cbFormat == sizeof(MPEGLAYER3WAVEFORMAT), "Got format size %lu.\n", pmt->cbFormat);
+    ok(pmt->cbFormat == sizeof(MPEGLAYER3WAVEFORMAT), "Got format size %u.\n", pmt->cbFormat);
     ok(!memcmp(pmt->pbFormat, &expect_mp3_wfx, sizeof(MPEGLAYER3WAVEFORMAT)),
             "Format blocks didn't match.\n");
 
     hr = IPin_QueryAccept(pin, pmt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     pmt->bFixedSizeSamples = FALSE;
     pmt->bTemporalCompression = TRUE;
     pmt->lSampleSize = 123;
     hr = IPin_QueryAccept(pin, pmt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     pmt->majortype = MEDIATYPE_Video;
     hr = IPin_QueryAccept(pin, pmt);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     pmt->majortype = MEDIATYPE_Audio;
 
     pmt->subtype = MEDIASUBTYPE_MPEG1Audio;
     hr = IPin_QueryAccept(pin, pmt);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     pmt->subtype = MEDIASUBTYPE_MPEG1Packet;
     hr = IPin_QueryAccept(pin, pmt);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     pmt->subtype = MEDIASUBTYPE_MPEG1Video;
     hr = IPin_QueryAccept(pin, pmt);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     pmt->subtype = MEDIASUBTYPE_MPEG1AudioPayload;
 
     pmt->formattype = FORMAT_None;
     hr = IPin_QueryAccept(pin, pmt);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     pmt->formattype = GUID_NULL;
     hr = IPin_QueryAccept(pin, pmt);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     pmt->formattype = FORMAT_WaveFormatEx;
 
     mp3wfx = (MPEGLAYER3WAVEFORMAT *)pmt->pbFormat;
 
     mp3wfx->fdwFlags = MPEGLAYER3_FLAG_PADDING_OFF;
     hr = IPin_QueryAccept(pin, pmt);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     mp3wfx->fdwFlags = MPEGLAYER3_FLAG_PADDING_ISO;
 
     mp3wfx->wfx.wFormatTag = WAVE_FORMAT_MPEG;
     hr = IPin_QueryAccept(pin, pmt);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     mp3wfx->wfx.wFormatTag = WAVE_FORMAT_MPEGLAYER3;
 
     CoTaskMemFree(pmt->pbFormat);
@@ -833,16 +833,16 @@ static void test_media_types(void)
 
 done:
     hr = IEnumMediaTypes_Next(enummt, 1, &pmt, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     IEnumMediaTypes_Release(enummt);
     IPin_Release(pin);
 
     IFilterGraph2_Release(graph);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ret = DeleteFileW(filename);
-    ok(ret, "Failed to delete file, error %lu.\n", GetLastError());
+    ok(ret, "Failed to delete file, error %u.\n", GetLastError());
 }
 
 static void test_enum_media_types(void)
@@ -861,78 +861,78 @@ static void test_enum_media_types(void)
     IBaseFilter_FindPin(filter, L"Input", &pin);
 
     hr = IPin_EnumMediaTypes(pin, &enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     for (i = 0; i < 4; ++i)
     {
         hr = IEnumMediaTypes_Next(enum1, 1, mts, NULL);
-        todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
         if (hr == S_OK) CoTaskMemFree(mts[0]);
     }
 
     hr = IEnumMediaTypes_Next(enum1, 1, mts, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     for (i = 0; i < 4; ++i)
     {
         hr = IEnumMediaTypes_Next(enum1, 1, mts, &count);
-        todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
-        todo_wine ok(count == 1, "Got count %lu.\n", count);
+        todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
+        todo_wine ok(count == 1, "Got count %u.\n", count);
         if (hr == S_OK) CoTaskMemFree(mts[0]);
     }
 
     hr = IEnumMediaTypes_Next(enum1, 1, mts, &count);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
-    ok(!count, "Got count %lu.\n", count);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    ok(!count, "Got count %u.\n", count);
 
     hr = IEnumMediaTypes_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enum1, 2, mts, &count);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    todo_wine ok(count == 2, "Got count %lu.\n", count);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
+    todo_wine ok(count == 2, "Got count %u.\n", count);
     if (count > 0) CoTaskMemFree(mts[0]);
     if (count > 1) CoTaskMemFree(mts[1]);
 
     hr = IEnumMediaTypes_Next(enum1, 3, mts, &count);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
-    todo_wine ok(count == 2, "Got count %lu.\n", count);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    todo_wine ok(count == 2, "Got count %u.\n", count);
     if (count > 0) CoTaskMemFree(mts[0]);
     if (count > 1) CoTaskMemFree(mts[1]);
 
     hr = IEnumMediaTypes_Next(enum1, 2, mts, &count);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
-    ok(!count, "Got count %lu.\n", count);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    ok(!count, "Got count %u.\n", count);
 
     hr = IEnumMediaTypes_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Clone(enum1, &enum2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Skip(enum1, 5);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Skip(enum1, 1);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Skip(enum1, 4);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Skip(enum1, 1);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enum1, 1, mts, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enum2, 1, mts, NULL);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
     if (hr == S_OK) CoTaskMemFree(mts[0]);
 
     IEnumMediaTypes_Release(enum1);
@@ -942,82 +942,82 @@ static void test_enum_media_types(void)
     IBaseFilter_FindPin(filter, L"Audio", &pin);
 
     hr = IPin_EnumMediaTypes(pin, &enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     for (i = 0; i < 3; ++i)
     {
         hr = IEnumMediaTypes_Next(enum1, 1, mts, NULL);
-        todo_wine_if(i) ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        todo_wine_if(i) ok(hr == S_OK, "Got hr %#x.\n", hr);
         if (hr == S_OK) CoTaskMemFree(mts[0]->pbFormat);
         if (hr == S_OK) CoTaskMemFree(mts[0]);
     }
 
     hr = IEnumMediaTypes_Next(enum1, 1, mts, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     for (i = 0; i < 3; ++i)
     {
         hr = IEnumMediaTypes_Next(enum1, 1, mts, &count);
-        todo_wine_if(i) ok(hr == S_OK, "Got hr %#lx.\n", hr);
-        todo_wine_if(i) ok(count == 1, "Got count %lu.\n", count);
+        todo_wine_if(i) ok(hr == S_OK, "Got hr %#x.\n", hr);
+        todo_wine_if(i) ok(count == 1, "Got count %u.\n", count);
         if (hr == S_OK) CoTaskMemFree(mts[0]->pbFormat);
         if (hr == S_OK) CoTaskMemFree(mts[0]);
     }
 
     hr = IEnumMediaTypes_Next(enum1, 1, mts, &count);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
-    ok(!count, "Got count %lu.\n", count);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    ok(!count, "Got count %u.\n", count);
 
     hr = IEnumMediaTypes_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enum1, 2, mts, &count);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    todo_wine ok(count == 2, "Got count %lu.\n", count);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
+    todo_wine ok(count == 2, "Got count %u.\n", count);
     CoTaskMemFree(mts[0]->pbFormat);
     CoTaskMemFree(mts[0]);
     if (count > 1) CoTaskMemFree(mts[1]->pbFormat);
     if (count > 1) CoTaskMemFree(mts[1]);
 
     hr = IEnumMediaTypes_Next(enum1, 2, mts, &count);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
-    todo_wine ok(count == 1, "Got count %lu.\n", count);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    todo_wine ok(count == 1, "Got count %u.\n", count);
     if (count) CoTaskMemFree(mts[0]->pbFormat);
     if (count) CoTaskMemFree(mts[0]);
 
     hr = IEnumMediaTypes_Next(enum1, 2, mts, &count);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
-    ok(!count, "Got count %lu.\n", count);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    ok(!count, "Got count %u.\n", count);
 
     hr = IEnumMediaTypes_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Clone(enum1, &enum2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Skip(enum1, 4);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Skip(enum1, 1);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Skip(enum1, 3);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Skip(enum1, 1);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enum1, 1, mts, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enum2, 1, mts, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     CoTaskMemFree(mts[0]->pbFormat);
     CoTaskMemFree(mts[0]);
 
@@ -1027,9 +1027,9 @@ static void test_enum_media_types(void)
 
     IFilterGraph2_Release(graph);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ret = DeleteFileW(filename);
-    ok(ret, "Failed to delete file, error %lu.\n", GetLastError());
+    ok(ret, "Failed to delete file, error %u.\n", GetLastError());
 }
 
 static void test_unconnected_filter_state(void)
@@ -1040,53 +1040,53 @@ static void test_unconnected_filter_state(void)
     ULONG ref;
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(state == State_Stopped, "Got state %u.\n", state);
 
     hr = IBaseFilter_Pause(filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(state == State_Paused, "Got state %u.\n", state);
 
     hr = IBaseFilter_Run(filter, 0);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(state == State_Running, "Got state %u.\n", state);
 
     hr = IBaseFilter_Pause(filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(state == State_Paused, "Got state %u.\n", state);
 
     hr = IBaseFilter_Stop(filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(state == State_Stopped, "Got state %u.\n", state);
 
     hr = IBaseFilter_Run(filter, 0);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(state == State_Running, "Got state %u.\n", state);
 
     hr = IBaseFilter_Stop(filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(state == State_Stopped, "Got state %u.\n", state);
 
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 struct testfilter
@@ -1098,7 +1098,7 @@ struct testfilter
     const AM_MEDIA_TYPE *mt;
     HANDLE eos_event;
     unsigned int sample_count, eos_count, new_segment_count;
-    REFERENCE_TIME segment_start, segment_end, seek_start, seek_end;
+    REFERENCE_TIME seek_start, seek_end;
 };
 
 static inline struct testfilter *impl_from_strmbase_filter(struct strmbase_filter *iface)
@@ -1125,21 +1125,10 @@ static void testfilter_destroy(struct strmbase_filter *iface)
     CloseHandle(filter->eos_event);
 }
 
-static HRESULT testfilter_init_stream(struct strmbase_filter *iface)
-{
-    struct testfilter *filter = impl_from_strmbase_filter(iface);
-
-    filter->new_segment_count = 0;
-    filter->eos_count = 0;
-    filter->sample_count = 0;
-    return S_OK;
-}
-
 static const struct strmbase_filter_ops testfilter_ops =
 {
     .filter_get_pin = testfilter_get_pin,
     .filter_destroy = testfilter_destroy,
-    .filter_init_stream = testfilter_init_stream,
 };
 
 static HRESULT testsource_query_interface(struct strmbase_pin *iface, REFIID iid, void **out)
@@ -1166,7 +1155,7 @@ static HRESULT WINAPI testsource_AttemptConnection(struct strmbase_source *iface
 
     if (FAILED(hr = IPin_ReceiveConnection(peer, &iface->pin.IPin_iface, mt)))
     {
-        ok(hr == VFW_E_TYPE_NOT_ACCEPTED, "Got hr %#lx.\n", hr);
+        ok(hr == VFW_E_TYPE_NOT_ACCEPTED, "Got hr %#x.\n", hr);
         IPin_Release(peer);
         iface->pin.peer = NULL;
         FreeMediaType(&iface->pin.mt);
@@ -1221,16 +1210,16 @@ static HRESULT WINAPI testsink_Receive(struct strmbase_sink *iface, IMediaSample
     HRESULT hr;
 
     hr = IMediaSample_GetTime(sample, &start, &end);
-    todo_wine_if (hr == VFW_S_NO_STOP_TIME) ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine_if (hr == VFW_S_NO_STOP_TIME) ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     if (winetest_debug > 1)
-        trace("%04lx: Got sample with timestamps %I64d-%I64d.\n", GetCurrentThreadId(), start, end);
+        trace("%04x: Got sample with timestamps %I64d-%I64d.\n", GetCurrentThreadId(), start, end);
 
     ok(filter->new_segment_count, "Expected NewSegment() before Receive().\n");
 
     IPin_QueryInterface(iface->pin.peer, &IID_IMediaSeeking, (void **)&seeking);
     hr = IMediaSeeking_GetPositions(seeking, &start, &end);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(start == filter->seek_start, "Expected start position %I64u, got %I64u.\n", filter->seek_start, start);
     ok(end == filter->seek_end, "Expected end position %I64u, got %I64u.\n", filter->seek_end, end);
     IMediaSeeking_Release(seeking);
@@ -1245,7 +1234,7 @@ static HRESULT testsink_eos(struct strmbase_sink *iface)
     struct testfilter *filter = impl_from_strmbase_filter(iface->pin.filter);
 
     if (winetest_debug > 1)
-        trace("%04lx: Got EOS.\n", GetCurrentThreadId());
+        trace("%04x: Got EOS.\n", GetCurrentThreadId());
 
     ok(!filter->eos_count, "Got %u EOS events.\n", filter->eos_count + 1);
     ++filter->eos_count;
@@ -1260,19 +1249,13 @@ static HRESULT testsink_new_segment(struct strmbase_sink *iface,
     IMediaSeeking *seeking;
     HRESULT hr;
 
-    if (winetest_debug > 1)
-        trace("%04lx: Got segment with timestamps %I64d-%I64d.\n", GetCurrentThreadId(), start, end);
-
     ++filter->new_segment_count;
 
     IPin_QueryInterface(iface->pin.peer, &IID_IMediaSeeking, (void **)&seeking);
     hr = IMediaSeeking_GetPositions(seeking, &filter->seek_start, &filter->seek_end);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    IMediaSeeking_Release(seeking);
-
-    ok(start == filter->segment_start, "Expected start %I64d, got %I64d.\n", filter->segment_start, start);
-    ok(end == filter->segment_end, "Expected end %I64d, got %I64d.\n", filter->segment_end, end);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(rate == 1.0, "Got rate %.16e.\n", rate);
+    IMediaSeeking_Release(seeking);
 
     return S_OK;
 }
@@ -1373,7 +1356,6 @@ static void testfilter_init(struct testfilter *filter)
     strmbase_sink_init(&filter->sink, &filter->filter, L"sink", &testsink_ops, NULL);
     filter->IAsyncReader_iface.lpVtbl = &async_reader_vtbl;
     filter->eos_event = CreateEventW(NULL, FALSE, FALSE, NULL);
-    filter->segment_end = 5392500;
 }
 
 static void test_connect_pin(void)
@@ -1421,48 +1403,48 @@ static void test_connect_pin(void)
 
     peer = (IPin *)0xdeadbeef;
     hr = IPin_ConnectedTo(sink, &peer);
-    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#x.\n", hr);
     ok(!peer, "Got peer %p.\n", peer);
 
     hr = IPin_ConnectionMediaType(sink, &mt);
-    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_Pause(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IFilterGraph2_ConnectDirect(graph, &testsource.source.pin.IPin_iface, sink, &req_mt);
-    ok(hr == VFW_E_NOT_STOPPED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_STOPPED, "Got hr %#x.\n", hr);
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     req_mt.majortype = MEDIATYPE_Video;
     hr = IFilterGraph2_ConnectDirect(graph, &testsource.source.pin.IPin_iface, sink, &req_mt);
-    ok(hr == VFW_E_TYPE_NOT_ACCEPTED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_TYPE_NOT_ACCEPTED, "Got hr %#x.\n", hr);
     req_mt.majortype = MEDIATYPE_Stream;
 
     req_mt.subtype = MEDIASUBTYPE_RGB8;
     hr = IFilterGraph2_ConnectDirect(graph, &testsource.source.pin.IPin_iface, sink, &req_mt);
-    ok(hr == VFW_E_TYPE_NOT_ACCEPTED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_TYPE_NOT_ACCEPTED, "Got hr %#x.\n", hr);
     req_mt.subtype = MEDIASUBTYPE_MPEG1Audio;
 
     hr = IFilterGraph2_ConnectDirect(graph, &testsource.source.pin.IPin_iface, sink, &req_mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IPin_ConnectedTo(sink, &peer);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(peer == &testsource.source.pin.IPin_iface, "Got peer %p.\n", peer);
     IPin_Release(peer);
 
     hr = IPin_ConnectionMediaType(sink, &mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(compare_media_types(&mt, &req_mt), "Media types didn't match.\n");
     ok(compare_media_types(&testsource.source.pin.mt, &req_mt), "Media types didn't match.\n");
 
     hr = IMediaControl_Pause(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IFilterGraph2_Disconnect(graph, sink);
-    ok(hr == VFW_E_NOT_STOPPED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_STOPPED, "Got hr %#x.\n", hr);
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     /* Test source connection. */
 
@@ -1470,11 +1452,11 @@ static void test_connect_pin(void)
 
     peer = (IPin *)0xdeadbeef;
     hr = IPin_ConnectedTo(source, &peer);
-    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#x.\n", hr);
     ok(!peer, "Got peer %p.\n", peer);
 
     hr = IPin_ConnectionMediaType(source, &mt);
-    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#x.\n", hr);
 
     /* Exact connection. */
 
@@ -1484,71 +1466,71 @@ static void test_connect_pin(void)
     CopyMediaType(&req_mt, source_mt);
 
     hr = IMediaControl_Pause(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IFilterGraph2_ConnectDirect(graph, source, &testsink.sink.pin.IPin_iface, &req_mt);
-    ok(hr == VFW_E_NOT_STOPPED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_STOPPED, "Got hr %#x.\n", hr);
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IFilterGraph2_ConnectDirect(graph, source, &testsink.sink.pin.IPin_iface, &req_mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IPin_ConnectedTo(source, &peer);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(peer == &testsink.sink.pin.IPin_iface, "Got peer %p.\n", peer);
     IPin_Release(peer);
 
     hr = IPin_ConnectionMediaType(source, &mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(compare_media_types(&mt, &req_mt), "Media types didn't match.\n");
     ok(compare_media_types(&testsink.sink.pin.mt, &req_mt), "Media types didn't match.\n");
 
     hr = IMediaControl_Pause(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IFilterGraph2_Disconnect(graph, source);
-    ok(hr == VFW_E_NOT_STOPPED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_STOPPED, "Got hr %#x.\n", hr);
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IFilterGraph2_Disconnect(graph, source);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IFilterGraph2_Disconnect(graph, source);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     ok(testsink.sink.pin.peer == source, "Got peer %p.\n", testsink.sink.pin.peer);
     IFilterGraph2_Disconnect(graph, &testsink.sink.pin.IPin_iface);
 
     req_mt.lSampleSize = 999;
     req_mt.bTemporalCompression = req_mt.bFixedSizeSamples = TRUE;
     hr = IFilterGraph2_ConnectDirect(graph, source, &testsink.sink.pin.IPin_iface, &req_mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(compare_media_types(&testsink.sink.pin.mt, &req_mt), "Media types didn't match.\n");
     IFilterGraph2_Disconnect(graph, source);
     IFilterGraph2_Disconnect(graph, &testsink.sink.pin.IPin_iface);
 
     req_mt.majortype = MEDIATYPE_Stream;
     hr = IFilterGraph2_ConnectDirect(graph, source, &testsink.sink.pin.IPin_iface, &req_mt);
-    ok(hr == VFW_E_TYPE_NOT_ACCEPTED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_TYPE_NOT_ACCEPTED, "Got hr %#x.\n", hr);
     req_mt.majortype = MEDIATYPE_Audio;
 
     req_mt.subtype = MEDIASUBTYPE_PCM;
     hr = IFilterGraph2_ConnectDirect(graph, source, &testsink.sink.pin.IPin_iface, &req_mt);
-    ok(hr == VFW_E_TYPE_NOT_ACCEPTED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_TYPE_NOT_ACCEPTED, "Got hr %#x.\n", hr);
     req_mt.subtype = GUID_NULL;
     hr = IFilterGraph2_ConnectDirect(graph, source, &testsink.sink.pin.IPin_iface, &req_mt);
-    ok(hr == VFW_E_TYPE_NOT_ACCEPTED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_TYPE_NOT_ACCEPTED, "Got hr %#x.\n", hr);
     req_mt.subtype = MEDIASUBTYPE_MPEG1AudioPayload;
 
     /* Connection with wildcards. */
 
     hr = IFilterGraph2_ConnectDirect(graph, source, &testsink.sink.pin.IPin_iface, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(compare_media_types(&testsink.sink.pin.mt, source_mt), "Media types didn't match.\n");
     IFilterGraph2_Disconnect(graph, source);
     IFilterGraph2_Disconnect(graph, &testsink.sink.pin.IPin_iface);
 
     req_mt.majortype = GUID_NULL;
     hr = IFilterGraph2_ConnectDirect(graph, source, &testsink.sink.pin.IPin_iface, &req_mt);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
     if (hr == S_OK)
         ok(compare_media_types(&testsink.sink.pin.mt, source_mt), "Media types didn't match.\n");
     IFilterGraph2_Disconnect(graph, source);
@@ -1556,24 +1538,24 @@ static void test_connect_pin(void)
 
     req_mt.subtype = MEDIASUBTYPE_PCM;
     hr = IFilterGraph2_ConnectDirect(graph, source, &testsink.sink.pin.IPin_iface, &req_mt);
-    ok(hr == VFW_E_NO_ACCEPTABLE_TYPES, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NO_ACCEPTABLE_TYPES, "Got hr %#x.\n", hr);
 
     req_mt.subtype = GUID_NULL;
     hr = IFilterGraph2_ConnectDirect(graph, source, &testsink.sink.pin.IPin_iface, &req_mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(compare_media_types(&testsink.sink.pin.mt, source_mt), "Media types didn't match.\n");
     IFilterGraph2_Disconnect(graph, source);
     IFilterGraph2_Disconnect(graph, &testsink.sink.pin.IPin_iface);
 
     req_mt.formattype = FORMAT_None;
     hr = IFilterGraph2_ConnectDirect(graph, source, &testsink.sink.pin.IPin_iface, &req_mt);
-    ok(hr == VFW_E_NO_ACCEPTABLE_TYPES, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NO_ACCEPTABLE_TYPES, "Got hr %#x.\n", hr);
 
     req_mt.majortype = MEDIATYPE_Audio;
     req_mt.subtype = MEDIASUBTYPE_MPEG1AudioPayload;
     req_mt.formattype = GUID_NULL;
     hr = IFilterGraph2_ConnectDirect(graph, source, &testsink.sink.pin.IPin_iface, &req_mt);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
     if (hr == S_OK)
         ok(compare_media_types(&testsink.sink.pin.mt, source_mt), "Media types didn't match.\n");
     IFilterGraph2_Disconnect(graph, source);
@@ -1581,38 +1563,38 @@ static void test_connect_pin(void)
 
     req_mt.subtype = MEDIASUBTYPE_PCM;
     hr = IFilterGraph2_ConnectDirect(graph, source, &testsink.sink.pin.IPin_iface, &req_mt);
-    ok(hr == VFW_E_NO_ACCEPTABLE_TYPES, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NO_ACCEPTABLE_TYPES, "Got hr %#x.\n", hr);
 
     req_mt.subtype = GUID_NULL;
     hr = IFilterGraph2_ConnectDirect(graph, source, &testsink.sink.pin.IPin_iface, &req_mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(compare_media_types(&testsink.sink.pin.mt, source_mt), "Media types didn't match.\n");
     IFilterGraph2_Disconnect(graph, source);
     IFilterGraph2_Disconnect(graph, &testsink.sink.pin.IPin_iface);
 
     req_mt.majortype = MEDIATYPE_Stream;
     hr = IFilterGraph2_ConnectDirect(graph, source, &testsink.sink.pin.IPin_iface, &req_mt);
-    ok(hr == VFW_E_NO_ACCEPTABLE_TYPES, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NO_ACCEPTABLE_TYPES, "Got hr %#x.\n", hr);
 
     /* Test enumeration of sink media types. */
 
     testsink.mt = &req_mt;
     hr = IFilterGraph2_ConnectDirect(graph, source, &testsink.sink.pin.IPin_iface, NULL);
-    ok(hr == VFW_E_NO_ACCEPTABLE_TYPES, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NO_ACCEPTABLE_TYPES, "Got hr %#x.\n", hr);
 
     req_mt.majortype = MEDIATYPE_Audio;
     req_mt.subtype = MEDIASUBTYPE_MPEG1AudioPayload;
     req_mt.formattype = FORMAT_WaveFormatEx;
     req_mt.lSampleSize = 444;
     hr = IFilterGraph2_ConnectDirect(graph, source, &testsink.sink.pin.IPin_iface, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     todo_wine ok(compare_media_types(&testsink.sink.pin.mt, &req_mt), "Media types didn't match.\n");
 
     IPin_Release(source);
     hr = IFilterGraph2_Disconnect(graph, sink);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IFilterGraph2_Disconnect(graph, sink);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     ok(testsource.source.pin.peer == sink, "Got peer %p.\n", testsource.source.pin.peer);
     IFilterGraph2_Disconnect(graph, &testsource.source.pin.IPin_iface);
 
@@ -1624,17 +1606,17 @@ static void test_connect_pin(void)
     IPin_Release(sink);
     IMediaControl_Release(control);
     ref = IFilterGraph2_Release(graph);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ref = IBaseFilter_Release(reader);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ref = IBaseFilter_Release(&testsource.filter.IBaseFilter_iface);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ref = IBaseFilter_Release(&testsink.filter.IBaseFilter_iface);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ret = DeleteFileW(filename);
-    ok(ret, "Failed to delete file, error %lu.\n", GetLastError());
+    ok(ret, "Failed to delete file, error %u.\n", GetLastError());
 }
 
 static void test_seeking(void)
@@ -1674,121 +1656,121 @@ static void test_seeking(void)
     IPin_QueryInterface(pin, &IID_IMediaSeeking, (void **)&seeking);
 
     hr = IMediaSeeking_GetCapabilities(seeking, &caps);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(caps == (AM_SEEKING_CanSeekAbsolute | AM_SEEKING_CanSeekForwards
             | AM_SEEKING_CanSeekBackwards | AM_SEEKING_CanGetStopPos
-            | AM_SEEKING_CanGetDuration), "Got caps %#lx.\n", caps);
+            | AM_SEEKING_CanGetDuration), "Got caps %#x.\n", caps);
 
     caps = AM_SEEKING_CanSeekAbsolute | AM_SEEKING_CanSeekForwards;
     hr = IMediaSeeking_CheckCapabilities(seeking, &caps);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(caps == (AM_SEEKING_CanSeekAbsolute | AM_SEEKING_CanSeekForwards), "Got caps %#lx.\n", caps);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(caps == (AM_SEEKING_CanSeekAbsolute | AM_SEEKING_CanSeekForwards), "Got caps %#x.\n", caps);
 
     caps = AM_SEEKING_CanSeekAbsolute | AM_SEEKING_CanGetCurrentPos;
     hr = IMediaSeeking_CheckCapabilities(seeking, &caps);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
-    ok(caps == AM_SEEKING_CanSeekAbsolute, "Got caps %#lx.\n", caps);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    ok(caps == AM_SEEKING_CanSeekAbsolute, "Got caps %#x.\n", caps);
 
     caps = AM_SEEKING_CanGetCurrentPos;
     hr = IMediaSeeking_CheckCapabilities(seeking, &caps);
-    ok(hr == E_FAIL, "Got hr %#lx.\n", hr);
-    ok(!caps, "Got caps %#lx.\n", caps);
+    ok(hr == E_FAIL, "Got hr %#x.\n", hr);
+    ok(!caps, "Got caps %#x.\n", caps);
 
     caps = 0;
     hr = IMediaSeeking_CheckCapabilities(seeking, &caps);
-    ok(hr == E_FAIL, "Got hr %#lx.\n", hr);
-    ok(!caps, "Got caps %#lx.\n", caps);
+    ok(hr == E_FAIL, "Got hr %#x.\n", hr);
+    ok(!caps, "Got caps %#x.\n", caps);
 
     for (i = 0; i < ARRAY_SIZE(format_tests); ++i)
     {
         hr = IMediaSeeking_IsFormatSupported(seeking, format_tests[i].guid);
-        ok(hr == format_tests[i].hr, "Got hr %#lx for format %s.\n",
+        ok(hr == format_tests[i].hr, "Got hr %#x for format %s.\n",
                 hr, wine_dbgstr_guid(format_tests[i].guid));
     }
 
     hr = IMediaSeeking_QueryPreferredFormat(seeking, &format);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(IsEqualGUID(&format, &TIME_FORMAT_MEDIA_TIME), "Got format %s.\n", wine_dbgstr_guid(&format));
 
     hr = IMediaSeeking_GetTimeFormat(seeking, &format);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(IsEqualGUID(&format, &TIME_FORMAT_MEDIA_TIME), "Got format %s.\n", wine_dbgstr_guid(&format));
 
     hr = IMediaSeeking_IsUsingTimeFormat(seeking, &TIME_FORMAT_MEDIA_TIME);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMediaSeeking_IsUsingTimeFormat(seeking, &TIME_FORMAT_SAMPLE);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IMediaSeeking_SetTimeFormat(seeking, &TIME_FORMAT_FRAME);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
     hr = IMediaSeeking_SetTimeFormat(seeking, &TIME_FORMAT_MEDIA_TIME);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     duration = 0;
     hr = IMediaSeeking_GetDuration(seeking, &duration);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(duration == 5392500, "Got duration %I64d.\n", duration);
 
     stop = current = 0xdeadbeef;
     hr = IMediaSeeking_GetStopPosition(seeking, &stop);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(stop == duration, "Expected time %s, got %s.\n",
             wine_dbgstr_longlong(duration), wine_dbgstr_longlong(stop));
     hr = IMediaSeeking_GetCurrentPosition(seeking, &current);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(!current, "Got time %s.\n", wine_dbgstr_longlong(current));
     stop = current = 0xdeadbeef;
     hr = IMediaSeeking_GetPositions(seeking, &current, &stop);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(!current, "Got time %s.\n", wine_dbgstr_longlong(current));
     ok(stop == duration, "Expected time %s, got %s.\n",
             wine_dbgstr_longlong(duration), wine_dbgstr_longlong(stop));
 
     time = 0xdeadbeef;
     hr = IMediaSeeking_ConvertTimeFormat(seeking, &time, &TIME_FORMAT_MEDIA_TIME, 0x123456789a, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(time == 0x123456789a, "Got time %s.\n", wine_dbgstr_longlong(time));
     time = 0xdeadbeef;
     hr = IMediaSeeking_ConvertTimeFormat(seeking, &time, NULL, 0x123456789a, &TIME_FORMAT_MEDIA_TIME);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(time == 0x123456789a, "Got time %s.\n", wine_dbgstr_longlong(time));
 
     earliest = latest = 0xdeadbeef;
     hr = IMediaSeeking_GetAvailable(seeking, &earliest, &latest);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(!earliest, "Got time %s.\n", wine_dbgstr_longlong(earliest));
     ok(latest == duration, "Expected time %s, got %s.\n",
             wine_dbgstr_longlong(duration), wine_dbgstr_longlong(latest));
 
     rate = 0;
     hr = IMediaSeeking_GetRate(seeking, &rate);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(rate == 1.0, "Got rate %.16e.\n", rate);
 
     hr = IMediaSeeking_SetRate(seeking, 200.0);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
     rate = 0;
     hr = IMediaSeeking_GetRate(seeking, &rate);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     todo_wine ok(rate == 200.0, "Got rate %.16e.\n", rate);
 
     hr = IMediaSeeking_SetRate(seeking, -1.0);
-    todo_wine ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
 
     hr = IMediaSeeking_GetPreroll(seeking, &time);
-    todo_wine ok(hr == E_NOTIMPL, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == E_NOTIMPL, "Got hr %#x.\n", hr);
 
     current = 200 * 10000;
     stop = 400 * 10000;
     hr = IMediaSeeking_SetPositions(seeking, &current, AM_SEEKING_AbsolutePositioning,
             &stop, AM_SEEKING_AbsolutePositioning);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(current == 200 * 10000, "Got time %s.\n", wine_dbgstr_longlong(current));
     ok(stop == 400 * 10000, "Got time %s.\n", wine_dbgstr_longlong(stop));
 
     stop = current = 0xdeadbeef;
     hr = IMediaSeeking_GetPositions(seeking, &current, &stop);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(current == 200 * 10000, "Got time %s.\n", wine_dbgstr_longlong(current));
     ok(stop == 400 * 10000, "Got time %s.\n", wine_dbgstr_longlong(stop));
 
@@ -1796,7 +1778,7 @@ static void test_seeking(void)
     stop = 400 * 10000;
     hr = IMediaSeeking_SetPositions(seeking, &current, AM_SEEKING_AbsolutePositioning | AM_SEEKING_ReturnTime,
             &stop, AM_SEEKING_AbsolutePositioning | AM_SEEKING_ReturnTime);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(current == 200 * 10000, "Got time %s.\n", wine_dbgstr_longlong(current));
     ok(stop == 400 * 10000, "Got time %s.\n", wine_dbgstr_longlong(stop));
 
@@ -1804,18 +1786,18 @@ static void test_seeking(void)
     stop = 200 * 10000;
     hr = IMediaSeeking_SetPositions(seeking, &current, AM_SEEKING_AbsolutePositioning | AM_SEEKING_ReturnTime,
             &stop, AM_SEEKING_AbsolutePositioning | AM_SEEKING_ReturnTime);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(current == 100 * 10000, "Got time %s.\n", wine_dbgstr_longlong(current));
     ok(stop == 200 * 10000, "Got time %s.\n", wine_dbgstr_longlong(stop));
 
     current = 50 * 10000;
     hr = IMediaSeeking_SetPositions(seeking, &current, AM_SEEKING_AbsolutePositioning,
             NULL, AM_SEEKING_NoPositioning);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     stop = current = 0xdeadbeef;
     hr = IMediaSeeking_GetPositions(seeking, &current, &stop);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(current == 50 * 10000, "Got time %s.\n", wine_dbgstr_longlong(current));
     ok(stop == 200 * 10000, "Got time %s.\n", wine_dbgstr_longlong(stop));
 
@@ -1823,9 +1805,9 @@ static void test_seeking(void)
     IPin_Release(pin);
     IFilterGraph2_Release(graph);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ret = DeleteFileW(filename);
-    ok(ret, "Failed to delete file, error %lu.\n", GetLastError());
+    ok(ret, "Failed to delete file, error %u.\n", GetLastError());
 }
 
 static void test_streaming(void)
@@ -1849,32 +1831,33 @@ static void test_streaming(void)
     IPin_QueryInterface(source, &IID_IMediaSeeking, (void **)&seeking);
 
     hr = IFilterGraph2_ConnectDirect(graph, source, &testsink.sink.pin.IPin_iface, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     ok(WaitForSingleObject(testsink.eos_event, 100) == WAIT_TIMEOUT, "Expected timeout.\n");
 
     hr = IMediaControl_Pause(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     ok(!WaitForSingleObject(testsink.eos_event, 1000), "Did not receive EOS.\n");
     ok(WaitForSingleObject(testsink.eos_event, 100) == WAIT_TIMEOUT, "Got more than one EOS.\n");
     ok(testsink.sample_count, "Expected at least one sample.\n");
 
+    testsink.sample_count = testsink.eos_count = 0;
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMediaControl_Pause(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     ok(!WaitForSingleObject(testsink.eos_event, 1000), "Did not receive EOS.\n");
     ok(WaitForSingleObject(testsink.eos_event, 100) == WAIT_TIMEOUT, "Got more than one EOS.\n");
     ok(testsink.sample_count, "Expected at least one sample.\n");
 
-    testsink.new_segment_count = testsink.sample_count = testsink.eos_count = 0;
-    testsink.segment_start = 100 * 10000;
-    testsink.segment_end = 300 * 10000;
-    hr = IMediaSeeking_SetPositions(seeking, &testsink.segment_start, AM_SEEKING_AbsolutePositioning,
-            &testsink.segment_end, AM_SEEKING_AbsolutePositioning);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    testsink.sample_count = testsink.eos_count = 0;
+    start = 100 * 10000;
+    end = 300 * 10000;
+    hr = IMediaSeeking_SetPositions(seeking, &start, AM_SEEKING_AbsolutePositioning,
+            &end, AM_SEEKING_AbsolutePositioning);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     ok(!WaitForSingleObject(testsink.eos_event, 1000), "Did not receive EOS.\n");
     ok(WaitForSingleObject(testsink.eos_event, 100) == WAIT_TIMEOUT, "Got more than one EOS.\n");
@@ -1882,14 +1865,15 @@ static void test_streaming(void)
 
     start = end = 0xdeadbeef;
     hr = IMediaSeeking_GetPositions(seeking, &start, &end);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(start == testsink.seek_start, "Expected start position %I64u, got %I64u.\n", testsink.seek_start, start);
     ok(end == testsink.seek_end, "Expected end position %I64u, got %I64u.\n", testsink.seek_end, end);
 
+    testsink.sample_count = testsink.eos_count = 0;
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMediaControl_Pause(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     ok(!WaitForSingleObject(testsink.eos_event, 1000), "Did not receive EOS.\n");
     ok(WaitForSingleObject(testsink.eos_event, 100) == WAIT_TIMEOUT, "Got more than one EOS.\n");
@@ -1897,7 +1881,7 @@ static void test_streaming(void)
 
     start = end = 0xdeadbeef;
     hr = IMediaSeeking_GetPositions(seeking, &start, &end);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(start == testsink.seek_start, "Expected start position %I64u, got %I64u.\n", testsink.seek_start, start);
     ok(end == testsink.seek_end, "Expected end position %I64u, got %I64u.\n", testsink.seek_end, end);
 
@@ -1905,13 +1889,13 @@ static void test_streaming(void)
     IPin_Release(source);
     IMediaControl_Release(control);
     ref = IFilterGraph2_Release(graph);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ref = IBaseFilter_Release(&testsink.filter.IBaseFilter_iface);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ret = DeleteFileW(filename);
-    ok(ret, "Failed to delete file, error %lu.\n", GetLastError());
+    ok(ret, "Failed to delete file, error %u.\n", GetLastError());
 }
 
 static void test_large_file(void)
@@ -1949,17 +1933,17 @@ static void test_large_file(void)
 
     duration = 0xdeadbeef;
     hr = IMediaSeeking_GetDuration(seeking, &duration);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(duration == 2400 * 10000000ull, "Got duration %I64d.\n", duration);
 
     IMediaSeeking_Release(seeking);
     IPin_Release(source);
     ref = IFilterGraph2_Release(graph);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ret = DeleteFileW(path);
-    ok(ret, "Failed to delete file, error %lu.\n", GetLastError());
+    ok(ret, "Failed to delete file, error %u.\n", GetLastError());
 }
 
 START_TEST(mpegsplit)
diff --git a/dlls/quartz/tests/passthrough.c b/dlls/quartz/tests/passthrough.c
index 0e542d1733a..ce7365928e5 100644
--- wine/dlls/quartz/tests/passthrough.c
+++ wine/dlls/quartz/tests/passthrough.c
@@ -74,53 +74,53 @@ static void test_aggregation(void)
     passthrough = (ISeekingPassThru *)0xdeadbeef;
     hr = CoCreateInstance(&CLSID_SeekingPassThru, &test_outer, CLSCTX_INPROC_SERVER,
             &IID_ISeekingPassThru, (void **)&passthrough);
-    ok(hr == E_NOINTERFACE, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOINTERFACE, "Got hr %#x.\n", hr);
     ok(!passthrough, "Got interface %p.\n", passthrough);
 
     hr = CoCreateInstance(&CLSID_SeekingPassThru, &test_outer, CLSCTX_INPROC_SERVER,
             &IID_IUnknown, (void **)&unk);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(outer_ref == 1, "Got unexpected refcount %ld.\n", outer_ref);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
     ok(unk != &test_outer, "Returned IUnknown should not be outer IUnknown.\n");
     ref = get_refcount(unk);
-    ok(ref == 1, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
 
     ref = IUnknown_AddRef(unk);
-    ok(ref == 2, "Got unexpected refcount %ld.\n", ref);
-    ok(outer_ref == 1, "Got unexpected refcount %ld.\n", outer_ref);
+    ok(ref == 2, "Got unexpected refcount %d.\n", ref);
+    ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
 
     ref = IUnknown_Release(unk);
-    ok(ref == 1, "Got unexpected refcount %ld.\n", ref);
-    ok(outer_ref == 1, "Got unexpected refcount %ld.\n", outer_ref);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
+    ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
 
     hr = IUnknown_QueryInterface(unk, &IID_IUnknown, (void **)&unk2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(unk2 == unk, "Got unexpected IUnknown %p.\n", unk2);
     IUnknown_Release(unk2);
 
     hr = IUnknown_QueryInterface(unk, &IID_ISeekingPassThru, (void **)&passthrough);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = ISeekingPassThru_QueryInterface(passthrough, &IID_IUnknown, (void **)&unk2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(unk2 == (IUnknown *)0xdeadbeef, "Got unexpected IUnknown %p.\n", unk2);
 
     hr = ISeekingPassThru_QueryInterface(passthrough, &IID_ISeekingPassThru, (void **)&passthrough2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(passthrough2 == (ISeekingPassThru *)0xdeadbeef, "Got unexpected ISeekingPassThru %p.\n", passthrough2);
 
     hr = IUnknown_QueryInterface(unk, &test_iid, (void **)&unk2);
-    ok(hr == E_NOINTERFACE, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOINTERFACE, "Got hr %#x.\n", hr);
     ok(!unk2, "Got unexpected IUnknown %p.\n", unk2);
 
     hr = ISeekingPassThru_QueryInterface(passthrough, &test_iid, (void **)&unk2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(unk2 == (IUnknown *)0xdeadbeef, "Got unexpected IUnknown %p.\n", unk2);
 
     ISeekingPassThru_Release(passthrough);
     ref = IUnknown_Release(unk);
-    ok(!ref, "Got unexpected refcount %ld.\n", ref);
-    ok(outer_ref == 1, "Got unexpected refcount %ld.\n", outer_ref);
+    ok(!ref, "Got unexpected refcount %d.\n", ref);
+    ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
 }
 
 START_TEST(passthrough)
diff --git a/dlls/quartz/tests/systemclock.c b/dlls/quartz/tests/systemclock.c
index 65bc406f35f..3b39d2aadb4 100644
--- wine/dlls/quartz/tests/systemclock.c
+++ wine/dlls/quartz/tests/systemclock.c
@@ -27,7 +27,7 @@ static IReferenceClock *create_system_clock(void)
     IReferenceClock *clock = NULL;
     HRESULT hr = CoCreateInstance(&CLSID_SystemClock, NULL, CLSCTX_INPROC_SERVER,
             &IID_IReferenceClock, (void **)&clock);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     return clock;
 }
 
@@ -48,7 +48,7 @@ static void check_interface_(unsigned int line, void *iface_ptr, REFIID iid, BOO
     expected_hr = supported ? S_OK : E_NOINTERFACE;
 
     hr = IUnknown_QueryInterface(iface, iid, (void **)&unk);
-    ok_(__FILE__, line)(hr == expected_hr, "Got hr %#lx, expected %#lx.\n", hr, expected_hr);
+    ok_(__FILE__, line)(hr == expected_hr, "Got hr %#x, expected %#x.\n", hr, expected_hr);
     if (SUCCEEDED(hr))
         IUnknown_Release(unk);
 }
@@ -64,7 +64,7 @@ static void test_interfaces(void)
     check_interface(clock, &IID_IDirectDraw, FALSE);
 
     ref = IReferenceClock_Release(clock);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 static const GUID test_iid = {0x33333333};
@@ -112,53 +112,53 @@ static void test_aggregation(void)
     clock = (IReferenceClock *)0xdeadbeef;
     hr = CoCreateInstance(&CLSID_SystemClock, &test_outer, CLSCTX_INPROC_SERVER,
             &IID_IReferenceClock, (void **)&clock);
-    ok(hr == E_NOINTERFACE, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOINTERFACE, "Got hr %#x.\n", hr);
     ok(!clock, "Got interface %p.\n", clock);
 
     hr = CoCreateInstance(&CLSID_SystemClock, &test_outer, CLSCTX_INPROC_SERVER,
             &IID_IUnknown, (void **)&unk);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(outer_ref == 1, "Got unexpected refcount %ld.\n", outer_ref);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
     ok(unk != &test_outer, "Returned IUnknown should not be outer IUnknown.\n");
     ref = get_refcount(unk);
-    ok(ref == 1, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
 
     ref = IUnknown_AddRef(unk);
-    ok(ref == 2, "Got unexpected refcount %ld.\n", ref);
-    ok(outer_ref == 1, "Got unexpected refcount %ld.\n", outer_ref);
+    ok(ref == 2, "Got unexpected refcount %d.\n", ref);
+    ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
 
     ref = IUnknown_Release(unk);
-    ok(ref == 1, "Got unexpected refcount %ld.\n", ref);
-    ok(outer_ref == 1, "Got unexpected refcount %ld.\n", outer_ref);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
+    ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
 
     hr = IUnknown_QueryInterface(unk, &IID_IUnknown, (void **)&unk2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(unk2 == unk, "Got unexpected IUnknown %p.\n", unk2);
     IUnknown_Release(unk2);
 
     hr = IUnknown_QueryInterface(unk, &IID_IReferenceClock, (void **)&clock);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IReferenceClock_QueryInterface(clock, &IID_IUnknown, (void **)&unk2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(unk2 == (IUnknown *)0xdeadbeef, "Got unexpected IUnknown %p.\n", unk2);
 
     hr = IReferenceClock_QueryInterface(clock, &IID_IReferenceClock, (void **)&clock2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(clock2 == (IReferenceClock *)0xdeadbeef, "Got unexpected IReferenceClock %p.\n", clock2);
 
     hr = IUnknown_QueryInterface(unk, &test_iid, (void **)&unk2);
-    ok(hr == E_NOINTERFACE, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOINTERFACE, "Got hr %#x.\n", hr);
     ok(!unk2, "Got unexpected IUnknown %p.\n", unk2);
 
     hr = IReferenceClock_QueryInterface(clock, &test_iid, (void **)&unk2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(unk2 == (IUnknown *)0xdeadbeef, "Got unexpected IUnknown %p.\n", unk2);
 
     IReferenceClock_Release(clock);
     ref = IUnknown_Release(unk);
-    ok(!ref, "Got unexpected refcount %ld.\n", ref);
-    ok(outer_ref == 1, "Got unexpected refcount %ld.\n", outer_ref);
+    ok(!ref, "Got unexpected refcount %d.\n", ref);
+    ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
 }
 
 static void test_get_time(void)
@@ -169,17 +169,17 @@ static void test_get_time(void)
     ULONG ref;
 
     hr = IReferenceClock_GetTime(clock, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
 
     hr = IReferenceClock_GetTime(clock, &time1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(time1 % 10000 == 0, "Expected no less than 1ms coarseness, but got time %s.\n",
             wine_dbgstr_longlong(time1));
 
     ticks = (REFERENCE_TIME)timeGetTime() * 10000;
 
     hr = IReferenceClock_GetTime(clock, &time2);
-    ok(hr == (time2 == time1 ? S_FALSE : S_OK), "Got hr %#lx.\n", hr);
+    ok(hr == (time2 == time1 ? S_FALSE : S_OK), "Got hr %#x.\n", hr);
     ok(time2 % 10000 == 0, "Expected no less than 1ms coarseness, but got time %s.\n",
             wine_dbgstr_longlong(time1));
 
@@ -187,12 +187,12 @@ static void test_get_time(void)
 
     Sleep(100);
     hr = IReferenceClock_GetTime(clock, &time2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(time2 - time1 > 80 * 10000, "Expected about %s, but got %s.\n",
             wine_dbgstr_longlong(time1 + 80 * 10000), wine_dbgstr_longlong(time2));
 
     ref = IReferenceClock_Release(clock);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 static void test_advise(void)
@@ -209,72 +209,72 @@ static void test_advise(void)
     semaphore = CreateSemaphoreA(NULL, 0, 10, NULL);
 
     hr = IReferenceClock_GetTime(clock, &current);
-    ok(SUCCEEDED(hr), "Got hr %#lx.\n", hr);
+    ok(SUCCEEDED(hr), "Got hr %#x.\n", hr);
 
     hr = IReferenceClock_AdviseTime(clock, current, 500 * 10000, (HEVENT)event, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
 
     hr = IReferenceClock_AdviseTime(clock, -1000 * 10000, 500 * 10000, (HEVENT)event, &cookie);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
 
     hr = IReferenceClock_AdviseTime(clock, current, 500 * 10000, (HEVENT)event, &cookie);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(WaitForSingleObject(event, 460) == WAIT_TIMEOUT, "Event should not be signaled.\n");
     ok(!WaitForSingleObject(event, 80), "Event should be signaled.\n");
 
     hr = IReferenceClock_Unadvise(clock, cookie);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     ResetEvent(event);
     hr = IReferenceClock_GetTime(clock, &current);
-    ok(SUCCEEDED(hr), "Got hr %#lx.\n", hr);
+    ok(SUCCEEDED(hr), "Got hr %#x.\n", hr);
     hr = IReferenceClock_AdviseTime(clock, current, 500 * 10000, (HEVENT)event, &cookie);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IReferenceClock_Unadvise(clock, cookie);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(WaitForSingleObject(event, 540) == WAIT_TIMEOUT, "Event should not be signaled.\n");
 
     ResetEvent(event);
     hr = IReferenceClock_GetTime(clock, &current);
-    ok(SUCCEEDED(hr), "Got hr %#lx.\n", hr);
+    ok(SUCCEEDED(hr), "Got hr %#x.\n", hr);
     hr = IReferenceClock_AdviseTime(clock, current + 500 * 10000, 0, (HEVENT)event, &cookie);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(WaitForSingleObject(event, 460) == WAIT_TIMEOUT, "Event should not be signaled.\n");
     ok(!WaitForSingleObject(event, 80), "Event should be signaled.\n");
 
     hr = IReferenceClock_GetTime(clock, &current);
-    ok(SUCCEEDED(hr), "Got hr %#lx.\n", hr);
+    ok(SUCCEEDED(hr), "Got hr %#x.\n", hr);
 
     hr = IReferenceClock_AdvisePeriodic(clock, current, 500 * 10000, (HSEMAPHORE)semaphore, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
 
     hr = IReferenceClock_AdvisePeriodic(clock, current, 0, (HSEMAPHORE)semaphore, &cookie);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
 
     hr = IReferenceClock_AdvisePeriodic(clock, current, -500 * 10000, (HSEMAPHORE)semaphore, &cookie);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
 
     hr = IReferenceClock_AdvisePeriodic(clock, -500 * 10000, 1000 * 10000, (HSEMAPHORE)semaphore, &cookie);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
 
     hr = IReferenceClock_AdvisePeriodic(clock, current, 100 * 10000, (HSEMAPHORE)semaphore, &cookie);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(!WaitForSingleObject(semaphore, 50), "Semaphore should be signaled.\n");
     for (i = 0; i < 5; ++i)
         ok(!WaitForSingleObject(semaphore, 500), "Semaphore should be signaled.\n");
 
     hr = IReferenceClock_Unadvise(clock, cookie);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(WaitForSingleObject(semaphore, 200) == WAIT_TIMEOUT, "Semaphore should not be signaled.\n");
 
     ResetEvent(event);
     hr = IReferenceClock_GetTime(clock, &current);
-    ok(SUCCEEDED(hr), "Got hr %#lx.\n", hr);
+    ok(SUCCEEDED(hr), "Got hr %#x.\n", hr);
     hr = IReferenceClock_AdviseTime(clock, current, 500 * 10000, (HEVENT)event, &cookie);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     ref = IReferenceClock_Release(clock);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 
     ok(WaitForSingleObject(event, 0) == WAIT_TIMEOUT, "Event should not be signaled.\n");
 
diff --git a/dlls/quartz/tests/videorenderer.c b/dlls/quartz/tests/videorenderer.c
index c76dae15e91..5625971426b 100644
--- wine/dlls/quartz/tests/videorenderer.c
+++ wine/dlls/quartz/tests/videorenderer.c
@@ -20,7 +20,6 @@
 
 #define COBJMACROS
 #include "dshow.h"
-#include "videoacc.h"
 #include "wine/strmbase.h"
 #include "wine/test.h"
 
@@ -29,7 +28,7 @@ static IBaseFilter *create_video_renderer(void)
     IBaseFilter *filter = NULL;
     HRESULT hr = CoCreateInstance(&CLSID_VideoRenderer, NULL, CLSCTX_INPROC_SERVER,
             &IID_IBaseFilter, (void **)&filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     return filter;
 }
 
@@ -44,7 +43,7 @@ static IFilterGraph2 *create_graph(void)
     IFilterGraph2 *ret;
     HRESULT hr;
     hr = CoCreateInstance(&CLSID_FilterGraph, NULL, CLSCTX_INPROC_SERVER, &IID_IFilterGraph2, (void **)&ret);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to create FilterGraph: %#x\n", hr);
     return ret;
 }
 
@@ -65,7 +64,7 @@ static void check_interface_(unsigned int line, void *iface_ptr, REFIID iid, BOO
     expected_hr = supported ? S_OK : E_NOINTERFACE;
 
     hr = IUnknown_QueryInterface(iface, iid, (void **)&unk);
-    ok_(__FILE__, line)(hr == expected_hr, "Got hr %#lx, expected %#lx.\n", hr, expected_hr);
+    ok_(__FILE__, line)(hr == expected_hr, "Got hr %#x, expected %#x.\n", hr, expected_hr);
     if (SUCCEEDED(hr))
         IUnknown_Release(unk);
 }
@@ -90,7 +89,6 @@ static void test_interfaces(void)
     check_interface(filter, &IID_IVideoWindow, TRUE);
 
     check_interface(filter, &IID_IAMFilterMiscFlags, FALSE);
-    check_interface(filter, &IID_IAMVideoAccelerator, FALSE);
     check_interface(filter, &IID_IBasicAudio, FALSE);
     check_interface(filter, &IID_IDispatch, FALSE);
     check_interface(filter, &IID_IOverlay, FALSE);
@@ -107,7 +105,6 @@ static void test_interfaces(void)
     todo_wine check_interface(pin, &IID_IQualityControl, TRUE);
     check_interface(pin, &IID_IUnknown, TRUE);
 
-    check_interface(pin, &IID_IAMVideoAccelerator, FALSE);
     check_interface(pin, &IID_IAsyncReader, FALSE);
     check_interface(pin, &IID_IMediaPosition, FALSE);
     check_interface(pin, &IID_IMediaSeeking, FALSE);
@@ -161,53 +158,53 @@ static void test_aggregation(void)
     filter = (IBaseFilter *)0xdeadbeef;
     hr = CoCreateInstance(&CLSID_VideoRenderer, &test_outer, CLSCTX_INPROC_SERVER,
             &IID_IBaseFilter, (void **)&filter);
-    ok(hr == E_NOINTERFACE, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOINTERFACE, "Got hr %#x.\n", hr);
     ok(!filter, "Got interface %p.\n", filter);
 
     hr = CoCreateInstance(&CLSID_VideoRenderer, &test_outer, CLSCTX_INPROC_SERVER,
             &IID_IUnknown, (void **)&unk);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(outer_ref == 1, "Got unexpected refcount %ld.\n", outer_ref);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
     ok(unk != &test_outer, "Returned IUnknown should not be outer IUnknown.\n");
     ref = get_refcount(unk);
-    ok(ref == 1, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
 
     ref = IUnknown_AddRef(unk);
-    ok(ref == 2, "Got unexpected refcount %ld.\n", ref);
-    ok(outer_ref == 1, "Got unexpected refcount %ld.\n", outer_ref);
+    ok(ref == 2, "Got unexpected refcount %d.\n", ref);
+    ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
 
     ref = IUnknown_Release(unk);
-    ok(ref == 1, "Got unexpected refcount %ld.\n", ref);
-    ok(outer_ref == 1, "Got unexpected refcount %ld.\n", outer_ref);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
+    ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
 
     hr = IUnknown_QueryInterface(unk, &IID_IUnknown, (void **)&unk2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(unk2 == unk, "Got unexpected IUnknown %p.\n", unk2);
     IUnknown_Release(unk2);
 
     hr = IUnknown_QueryInterface(unk, &IID_IBaseFilter, (void **)&filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_QueryInterface(filter, &IID_IUnknown, (void **)&unk2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(unk2 == (IUnknown *)0xdeadbeef, "Got unexpected IUnknown %p.\n", unk2);
 
     hr = IBaseFilter_QueryInterface(filter, &IID_IBaseFilter, (void **)&filter2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(filter2 == (IBaseFilter *)0xdeadbeef, "Got unexpected IBaseFilter %p.\n", filter2);
 
     hr = IUnknown_QueryInterface(unk, &test_iid, (void **)&unk2);
-    ok(hr == E_NOINTERFACE, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOINTERFACE, "Got hr %#x.\n", hr);
     ok(!unk2, "Got unexpected IUnknown %p.\n", unk2);
 
     hr = IBaseFilter_QueryInterface(filter, &test_iid, (void **)&unk2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(unk2 == (IUnknown *)0xdeadbeef, "Got unexpected IUnknown %p.\n", unk2);
 
     IBaseFilter_Release(filter);
     ref = IUnknown_Release(unk);
-    ok(!ref, "Got unexpected refcount %ld.\n", ref);
-    ok(outer_ref == 1, "Got unexpected refcount %ld.\n", outer_ref);
+    ok(!ref, "Got unexpected refcount %d.\n", ref);
+    ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
 }
 
 static void test_enum_pins(void)
@@ -220,85 +217,85 @@ static void test_enum_pins(void)
     ULONG ref;
 
     ref = get_refcount(filter);
-    ok(ref == 1, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
 
     hr = IBaseFilter_EnumPins(filter, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_EnumPins(filter, &enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ref = get_refcount(filter);
-    ok(ref == 2, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 2, "Got unexpected refcount %d.\n", ref);
     ref = get_refcount(enum1);
-    ok(ref == 1, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
 
     hr = IEnumPins_Next(enum1, 1, NULL, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum1, 1, pins, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ref = get_refcount(filter);
-    ok(ref == 3, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 3, "Got unexpected refcount %d.\n", ref);
     ref = get_refcount(pins[0]);
-    ok(ref == 3, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 3, "Got unexpected refcount %d.\n", ref);
     ref = get_refcount(enum1);
-    ok(ref == 1, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
     IPin_Release(pins[0]);
     ref = get_refcount(filter);
-    ok(ref == 2, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 2, "Got unexpected refcount %d.\n", ref);
 
     hr = IEnumPins_Next(enum1, 1, pins, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum1, 1, pins, &count);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(count == 1, "Got count %lu.\n", count);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(count == 1, "Got count %u.\n", count);
     IPin_Release(pins[0]);
 
     hr = IEnumPins_Next(enum1, 1, pins, &count);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
-    ok(!count, "Got count %lu.\n", count);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    ok(!count, "Got count %u.\n", count);
 
     hr = IEnumPins_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum1, 2, pins, NULL);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum1, 2, pins, &count);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
-    ok(count == 1, "Got count %lu.\n", count);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    ok(count == 1, "Got count %u.\n", count);
     IPin_Release(pins[0]);
 
     hr = IEnumPins_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Clone(enum1, &enum2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Skip(enum1, 2);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Skip(enum1, 1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Skip(enum1, 1);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum1, 1, pins, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum2, 1, pins, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     IPin_Release(pins[0]);
 
     IEnumPins_Release(enum2);
     IEnumPins_Release(enum1);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 static void test_find_pin(void)
@@ -310,23 +307,23 @@ static void test_find_pin(void)
     ULONG ref;
 
     hr = IBaseFilter_FindPin(filter, L"input pin", &pin);
-    ok(hr == VFW_E_NOT_FOUND, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_FOUND, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_FindPin(filter, L"In", &pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_EnumPins(filter, &enum_pins);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum_pins, 1, &pin2, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(pin == pin2, "Expected pin %p, got %p.\n", pin2, pin);
     IPin_Release(pin);
     IPin_Release(pin2);
 
     IEnumPins_Release(enum_pins);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 static void test_pin_info(void)
@@ -340,38 +337,39 @@ static void test_pin_info(void)
     IPin *pin;
 
     hr = IBaseFilter_FindPin(filter, L"In", &pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ref = get_refcount(filter);
-    ok(ref == 2, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 2, "Got unexpected refcount %d.\n", ref);
     ref = get_refcount(pin);
-    ok(ref == 2, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 2, "Got unexpected refcount %d.\n", ref);
 
     hr = IPin_QueryPinInfo(pin, &info);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(info.pFilter == filter, "Expected filter %p, got %p.\n", filter, info.pFilter);
     ok(info.dir == PINDIR_INPUT, "Got direction %d.\n", info.dir);
-    ok(!wcscmp(info.achName, L"Input"), "Got name %s.\n", debugstr_w(info.achName));
+todo_wine
+    ok(!wcscmp(info.achName, L"Input"), "Got name %s.\n", wine_dbgstr_w(info.achName));
     ref = get_refcount(filter);
-    ok(ref == 3, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 3, "Got unexpected refcount %d.\n", ref);
     ref = get_refcount(pin);
-    ok(ref == 3, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 3, "Got unexpected refcount %d.\n", ref);
     IBaseFilter_Release(info.pFilter);
 
     hr = IPin_QueryDirection(pin, &dir);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(dir == PINDIR_INPUT, "Got direction %d.\n", dir);
 
     hr = IPin_QueryId(pin, &id);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(!wcscmp(id, L"In"), "Got id %s.\n", wine_dbgstr_w(id));
     CoTaskMemFree(id);
 
     hr = IPin_QueryInternalConnections(pin, NULL, NULL);
-    ok(hr == E_NOTIMPL, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOTIMPL, "Got hr %#x.\n", hr);
 
     IPin_Release(pin);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 static void test_media_types(void)
@@ -400,10 +398,10 @@ static void test_media_types(void)
     IBaseFilter_FindPin(filter, L"In", &pin);
 
     hr = IPin_EnumMediaTypes(pin, &enummt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enummt, 1, &mt, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     IEnumMediaTypes_Release(enummt);
 
@@ -416,30 +414,30 @@ static void test_media_types(void)
     {
         req_mt.subtype = *subtype_tests[i];
         hr = IPin_QueryAccept(pin, &req_mt);
-        ok(hr == S_OK, "Got hr %#lx for subtype %s.\n", hr, wine_dbgstr_guid(subtype_tests[i]));
+        ok(hr == S_OK, "Got hr %#x for subtype %s.\n", hr, wine_dbgstr_guid(subtype_tests[i]));
     }
 
     req_mt.subtype = MEDIASUBTYPE_NULL;
     hr = IPin_QueryAccept(pin, &req_mt);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     req_mt.subtype = MEDIASUBTYPE_RGB24;
 
     req_mt.majortype = MEDIATYPE_NULL;
     hr = IPin_QueryAccept(pin, &req_mt);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     req_mt.majortype = MEDIATYPE_Video;
 
     req_mt.formattype = FORMAT_None;
     hr = IPin_QueryAccept(pin, &req_mt);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     req_mt.formattype = GUID_NULL;
     hr = IPin_QueryAccept(pin, &req_mt);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     IPin_Release(pin);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 static void test_enum_media_types(void)
@@ -454,36 +452,36 @@ static void test_enum_media_types(void)
     IBaseFilter_FindPin(filter, L"In", &pin);
 
     hr = IPin_EnumMediaTypes(pin, &enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enum1, 1, mts, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enum1, 1, mts, &count);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
-    ok(!count, "Got count %lu.\n", count);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    ok(!count, "Got count %u.\n", count);
 
     hr = IEnumMediaTypes_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enum1, 1, mts, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Clone(enum1, &enum2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Skip(enum1, 1);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enum2, 1, mts, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     IEnumMediaTypes_Release(enum1);
     IEnumMediaTypes_Release(enum2);
     IPin_Release(pin);
 
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 struct testfilter
@@ -715,36 +713,36 @@ static void test_allocator(IMemInputPin *input)
     HRESULT hr;
 
     hr = IMemInputPin_GetAllocatorRequirements(input, &props);
-    ok(hr == E_NOTIMPL, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOTIMPL, "Got hr %#x.\n", hr);
 
     hr = IMemInputPin_GetAllocator(input, &ret_allocator);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     if (hr == S_OK)
     {
         hr = IMemAllocator_GetProperties(ret_allocator, &props);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
-        ok(!props.cBuffers, "Got %ld buffers.\n", props.cBuffers);
-        ok(!props.cbBuffer, "Got size %ld.\n", props.cbBuffer);
-        ok(!props.cbAlign, "Got alignment %ld.\n", props.cbAlign);
-        ok(!props.cbPrefix, "Got prefix %ld.\n", props.cbPrefix);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
+        ok(!props.cBuffers, "Got %d buffers.\n", props.cBuffers);
+        ok(!props.cbBuffer, "Got size %d.\n", props.cbBuffer);
+        ok(!props.cbAlign, "Got alignment %d.\n", props.cbAlign);
+        ok(!props.cbPrefix, "Got prefix %d.\n", props.cbPrefix);
 
         hr = IMemInputPin_NotifyAllocator(input, ret_allocator, TRUE);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
         IMemAllocator_Release(ret_allocator);
     }
 
     hr = IMemInputPin_NotifyAllocator(input, NULL, TRUE);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
 
     CoCreateInstance(&CLSID_MemoryAllocator, NULL, CLSCTX_INPROC_SERVER,
             &IID_IMemAllocator, (void **)&req_allocator);
 
     hr = IMemInputPin_NotifyAllocator(input, req_allocator, TRUE);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMemInputPin_GetAllocator(input, &ret_allocator);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(ret_allocator == req_allocator, "Allocators didn't match.\n");
 
     IMemAllocator_Release(req_allocator);
@@ -762,9 +760,9 @@ static DWORD WINAPI frame_thread(void *arg)
     struct frame_thread_params *params = arg;
     HRESULT hr;
 
-    if (winetest_debug > 1) trace("%04lx: Sending frame.\n", GetCurrentThreadId());
+    if (winetest_debug > 1) trace("%04x: Sending frame.\n", GetCurrentThreadId());
     hr = IMemInputPin_Receive(params->sink, params->sample);
-    if (winetest_debug > 1) trace("%04lx: Returned %#lx.\n", GetCurrentThreadId(), hr);
+    if (winetest_debug > 1) trace("%04x: Returned %#x.\n", GetCurrentThreadId(), hr);
     IMediaSample_Release(params->sample);
     free(params);
     return hr;
@@ -781,25 +779,25 @@ static HANDLE send_frame_time(IMemInputPin *sink, REFERENCE_TIME start_time, uns
     BYTE *data;
 
     hr = IMemInputPin_GetAllocator(sink, &allocator);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMemAllocator_GetBuffer(allocator, &sample, NULL, NULL, 0);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaSample_GetPointer(sample, &data);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     memset(data, color, 32 * 16 * 2);
 
     hr = IMediaSample_SetActualDataLength(sample, 32 * 16 * 2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     start_time *= 10000000;
     end_time = start_time + 10000000;
     hr = IMediaSample_SetTime(sample, &start_time, &end_time);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaSample_SetPreroll(sample, TRUE);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     params->sink = sink;
     params->sample = sample;
@@ -834,129 +832,129 @@ static void test_filter_state(IMemInputPin *input, IMediaControl *control)
 
     thread = send_frame(input);
     hr = join_thread(thread);
-    todo_wine ok(hr == E_FAIL, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == E_FAIL, "Got hr %#x.\n", hr);
 
     /* The renderer is not fully paused until it receives a sample. The thread
      * sending the sample blocks in IMemInputPin_Receive() until the filter is
      * stopped or run. */
 
     hr = IMediaControl_Pause(control);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_GetState(control, 0, &state);
-    ok(hr == VFW_S_STATE_INTERMEDIATE, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_S_STATE_INTERMEDIATE, "Got hr %#x.\n", hr);
 
     thread = send_frame(input);
 
     hr = IMediaControl_GetState(control, 1000, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     ok(WaitForSingleObject(thread, 100) == WAIT_TIMEOUT, "Thread should block in Receive().\n");
 
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = join_thread(thread);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     /* The sink will decommit our allocator for us when stopping, and recommit
      * it when pausing. */
     hr = IMemInputPin_GetAllocator(input, &allocator);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMemAllocator_GetBuffer(allocator, &sample, NULL, NULL, 0);
-    todo_wine ok(hr == VFW_E_NOT_COMMITTED, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == VFW_E_NOT_COMMITTED, "Got hr %#x.\n", hr);
     if (hr == S_OK) IMediaSample_Release(sample);
 
     hr = IMemAllocator_Commit(allocator);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     thread = send_frame(input);
     hr = join_thread(thread);
-    todo_wine ok(hr == E_FAIL, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == E_FAIL, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_Pause(control);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_GetState(control, 0, &state);
-    ok(hr == VFW_S_STATE_INTERMEDIATE, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_S_STATE_INTERMEDIATE, "Got hr %#x.\n", hr);
 
     thread = send_frame(input);
 
     hr = IMediaControl_GetState(control, 1000, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     ok(WaitForSingleObject(thread, 100) == WAIT_TIMEOUT, "Thread should block in Receive().\n");
 
     hr = IMediaControl_Run(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_GetState(control, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = join_thread(thread);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     thread = send_frame(input);
     hr = join_thread(thread);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_Pause(control);
-    todo_wine ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_GetState(control, 0, &state);
-    todo_wine ok(hr == VFW_S_STATE_INTERMEDIATE, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == VFW_S_STATE_INTERMEDIATE, "Got hr %#x.\n", hr);
 
     thread = send_frame(input);
 
     hr = IMediaControl_GetState(control, 1000, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     ok(WaitForSingleObject(thread, 100) == WAIT_TIMEOUT, "Thread should block in Receive().\n");
 
     hr = IMediaControl_Run(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_GetState(control, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = join_thread(thread);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_Pause(control);
-    todo_wine ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_GetState(control, 0, &state);
-    todo_wine ok(hr == VFW_S_STATE_INTERMEDIATE, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == VFW_S_STATE_INTERMEDIATE, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_GetState(control, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_Pause(control);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_GetState(control, 0, &state);
-    ok(hr == VFW_S_STATE_INTERMEDIATE, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_S_STATE_INTERMEDIATE, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_Run(control);
-    todo_wine ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_GetState(control, 0, &state);
-    todo_wine ok(hr == VFW_S_STATE_INTERMEDIATE, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == VFW_S_STATE_INTERMEDIATE, "Got hr %#x.\n", hr);
 
     thread = send_frame(input);
     hr = join_thread(thread);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_GetState(control, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_GetState(control, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     IMemAllocator_Release(allocator);
 }
@@ -968,54 +966,54 @@ static void test_flushing(IPin *pin, IMemInputPin *input, IMediaControl *control
     HRESULT hr;
 
     hr = IMediaControl_Pause(control);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     thread = send_frame(input);
     ok(WaitForSingleObject(thread, 100) == WAIT_TIMEOUT, "Thread should block in Receive().\n");
 
     hr = IMediaControl_GetState(control, 1000, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IPin_BeginFlush(pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = join_thread(thread);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     thread = send_frame(input);
     hr = join_thread(thread);
-    todo_wine ok(hr == E_FAIL, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == E_FAIL, "Got hr %#x.\n", hr);
 
     hr = IPin_EndFlush(pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     /* We dropped the sample we were holding, so now we need a new one... */
 
     hr = IMediaControl_GetState(control, 0, &state);
-    todo_wine ok(hr == VFW_S_STATE_INTERMEDIATE, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == VFW_S_STATE_INTERMEDIATE, "Got hr %#x.\n", hr);
 
     thread = send_frame(input);
     ok(WaitForSingleObject(thread, 100) == WAIT_TIMEOUT, "Thread should block in Receive().\n");
 
     hr = IMediaControl_Run(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = join_thread(thread);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IPin_BeginFlush(pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = join_thread(send_frame(input));
-    todo_wine ok(hr == E_FAIL, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == E_FAIL, "Got hr %#x.\n", hr);
 
     hr = IPin_EndFlush(pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = join_thread(send_frame(input));
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 }
 
 static void test_sample_time(IBaseFilter *filter, IPin *pin, IMemInputPin *input, IMediaControl *control)
@@ -1029,32 +1027,32 @@ static void test_sample_time(IBaseFilter *filter, IPin *pin, IMemInputPin *input
     IBaseFilter_QueryInterface(filter, &IID_IMediaSeeking, (void **)&seeking);
 
     hr = IMediaControl_Pause(control);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_GetState(control, 0, &state);
-    ok(hr == VFW_S_STATE_INTERMEDIATE, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_S_STATE_INTERMEDIATE, "Got hr %#x.\n", hr);
 
     hr = IMediaSeeking_GetCurrentPosition(seeking, &time);
-    ok(hr == 0xdeadbeef, "Got hr %#lx.\n", hr);
+    ok(hr == 0xdeadbeef, "Got hr %#x.\n", hr);
 
     thread = send_frame_time(input, 1, 0x11); /* dark blue */
 
     hr = IMediaControl_GetState(control, 1000, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaSeeking_GetCurrentPosition(seeking, &time);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(time == 10000000, "Got time %s.\n", wine_dbgstr_longlong(time));
 
     ok(WaitForSingleObject(thread, 100) == WAIT_TIMEOUT, "Thread should block in Receive().\n");
 
     hr = IMediaControl_Run(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     ok(WaitForSingleObject(thread, 500) == WAIT_TIMEOUT, "Thread should block in Receive().\n");
 
     hr = join_thread(thread);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     /* Sample time is relative to the time passed to Run(). Thus a sample
      * stamped at or earlier than 1s will now be displayed immediately, because
@@ -1066,38 +1064,38 @@ static void test_sample_time(IBaseFilter *filter, IPin *pin, IMemInputPin *input
      * are marked as discontinuous. */
 
     hr = join_thread(send_frame_time(input, 1, 0x22)); /* dark green */
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = join_thread(send_frame_time(input, 0, 0x33)); /* light green */
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = join_thread(send_frame_time(input, -2, 0x44)); /* dark red */
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     thread = send_frame_time(input, 2, 0x66); /* orange */
     ok(WaitForSingleObject(thread, 500) == WAIT_TIMEOUT, "Thread should block in Receive().\n");
     hr = join_thread(thread);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     thread = send_frame_time(input, 1000000, 0xff); /* white */
     ok(WaitForSingleObject(thread, 100) == WAIT_TIMEOUT, "Thread should block in Receive().\n");
 
     hr = IPin_BeginFlush(pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = join_thread(thread);
     /* If the frame makes it to Receive() in time to be rendered, we get S_OK. */
-    ok(hr == S_OK || hr == E_FAIL, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK || hr == E_FAIL, "Got hr %#x.\n", hr);
     hr = IPin_EndFlush(pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     thread = send_frame_time(input, 1000000, 0xff);
     ok(WaitForSingleObject(thread, 100) == WAIT_TIMEOUT, "Thread should block in Receive().\n");
 
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = join_thread(thread);
     /* If the frame makes it to Receive() in time to be rendered, we get S_OK. */
-    ok(hr == S_OK || hr == E_FAIL, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK || hr == E_FAIL, "Got hr %#x.\n", hr);
 
     IMediaSeeking_Release(seeking);
 }
@@ -1113,14 +1111,14 @@ static unsigned int check_event_code(IMediaEvent *eventsrc, DWORD timeout, LONG
     {
         if (code == expected_code)
         {
-            ok(param1 == expected1, "Got param1 %#Ix.\n", param1);
-            ok(param2 == expected2, "Got param2 %#Ix.\n", param2);
+            ok(param1 == expected1, "Got param1 %#lx.\n", param1);
+            ok(param2 == expected2, "Got param2 %#lx.\n", param2);
             ret++;
         }
         IMediaEvent_FreeEventParams(eventsrc, code, param1, param2);
         timeout = 0;
     }
-    ok(hr == E_ABORT, "Got hr %#lx.\n", hr);
+    ok(hr == E_ABORT, "Got hr %#x.\n", hr);
 
     return ret;
 }
@@ -1140,28 +1138,28 @@ static void test_eos(IPin *pin, IMemInputPin *input, IMediaControl *control)
     IMediaControl_QueryInterface(control, &IID_IMediaEvent, (void **)&eventsrc);
 
     hr = IMediaControl_Pause(control);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     ret = check_ec_complete(eventsrc, 0);
     ok(!ret, "Got unexpected EC_COMPLETE.\n");
 
     hr = IPin_EndOfStream(pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_GetState(control, 1000, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ret = check_ec_complete(eventsrc, 0);
     ok(!ret, "Got unexpected EC_COMPLETE.\n");
 
     hr = join_thread(send_frame(input));
-    todo_wine ok(hr == E_UNEXPECTED, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == E_UNEXPECTED, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_Run(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ret = check_ec_complete(eventsrc, 0);
     ok(ret == 1, "Expected EC_COMPLETE.\n");
 
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ret = check_ec_complete(eventsrc, 0);
     ok(!ret, "Got unexpected EC_COMPLETE.\n");
 
@@ -1169,73 +1167,73 @@ static void test_eos(IPin *pin, IMemInputPin *input, IMediaControl *control)
      * done rendering. */
 
     hr = IMediaControl_Run(control);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     hr = join_thread(send_frame(input));
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMediaControl_GetState(control, 1000, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ret = check_ec_complete(eventsrc, 0);
     ok(!ret, "Got unexpected EC_COMPLETE.\n");
 
     hr = IPin_EndOfStream(pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ret = check_ec_complete(eventsrc, 0);
     todo_wine ok(!ret, "Got unexpected EC_COMPLETE.\n");
     ret = check_ec_complete(eventsrc, 1600);
     todo_wine ok(ret == 1, "Expected EC_COMPLETE.\n");
 
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ret = check_ec_complete(eventsrc, 0);
     ok(!ret, "Got unexpected EC_COMPLETE.\n");
 
     /* Test sending EOS while flushing. */
 
     hr = IMediaControl_Run(control);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     hr = join_thread(send_frame(input));
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IPin_BeginFlush(pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IPin_EndOfStream(pin);
-    todo_wine ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     hr = IPin_EndFlush(pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ret = check_ec_complete(eventsrc, 0);
     todo_wine ok(!ret, "Got unexpected EC_COMPLETE.\n");
 
     /* Test sending EOS and then flushing or stopping. */
 
     hr = IMediaControl_Run(control);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     hr = join_thread(send_frame(input));
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMediaControl_GetState(control, 1000, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IPin_EndOfStream(pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ret = check_ec_complete(eventsrc, 0);
     todo_wine ok(!ret, "Got unexpected EC_COMPLETE.\n");
 
     hr = IPin_BeginFlush(pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IPin_EndFlush(pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = join_thread(send_frame(input));
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IPin_EndOfStream(pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ret = check_ec_complete(eventsrc, 0);
     ok(!ret, "Got unexpected EC_COMPLETE.\n");
 
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ret = check_ec_complete(eventsrc, 0);
     ok(!ret, "Got unexpected EC_COMPLETE.\n");
 
@@ -1257,43 +1255,43 @@ static void test_current_image(IBaseFilter *filter, IMemInputPin *input,
     IBaseFilter_QueryInterface(filter, &IID_IBasicVideo, (void **)&video);
 
     hr = IBasicVideo_GetCurrentImage(video, NULL, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_GetCurrentImage(video, NULL, buffer);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
 
     size = 0xdeadbeef;
     hr = IBasicVideo_GetCurrentImage(video, &size, NULL);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    todo_wine ok(size == sizeof(BITMAPINFOHEADER) + 32 * 16 * 2, "Got size %ld.\n", size);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
+    todo_wine ok(size == sizeof(BITMAPINFOHEADER) + 32 * 16 * 2, "Got size %d.\n", size);
 
     size = 0xdeadbeef;
     hr = IBasicVideo_GetCurrentImage(video, &size, buffer);
-    ok(hr == VFW_E_NOT_PAUSED, "Got hr %#lx.\n", hr);
-    ok(size == 0xdeadbeef, "Got size %ld.\n", size);
+    ok(hr == VFW_E_NOT_PAUSED, "Got hr %#x.\n", hr);
+    ok(size == 0xdeadbeef, "Got size %d.\n", size);
 
     hr = IMediaControl_Pause(control);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     size = 0xdeadbeef;
     hr = IBasicVideo_GetCurrentImage(video, &size, buffer);
-    ok(hr == E_UNEXPECTED, "Got hr %#lx.\n", hr);
-    ok(size == 0xdeadbeef, "Got size %ld.\n", size);
+    ok(hr == E_UNEXPECTED, "Got hr %#x.\n", hr);
+    ok(size == 0xdeadbeef, "Got size %d.\n", size);
 
     thread = send_frame(input);
     hr = IMediaControl_GetState(control, 1000, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     size = sizeof(BITMAPINFOHEADER) + 32 * 16 * 2 - 1;
     hr = IBasicVideo_GetCurrentImage(video, &size, buffer);
-    ok(hr == E_OUTOFMEMORY, "Got hr %#lx.\n", hr);
-    ok(size == sizeof(BITMAPINFOHEADER) + 32 * 16 * 2 - 1, "Got size %ld.\n", size);
+    ok(hr == E_OUTOFMEMORY, "Got hr %#x.\n", hr);
+    ok(size == sizeof(BITMAPINFOHEADER) + 32 * 16 * 2 - 1, "Got size %d.\n", size);
 
     size = sizeof(BITMAPINFOHEADER) + 32 * 16 * 2;
     memset(buffer, 0xcc, sizeof(buffer));
     hr = IBasicVideo_GetCurrentImage(video, &size, buffer);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(size == sizeof(BITMAPINFOHEADER) + 32 * 16 * 2, "Got size %ld.\n", size);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(size == sizeof(BITMAPINFOHEADER) + 32 * 16 * 2, "Got size %d.\n", size);
     ok(!memcmp(bih, expect_bih, sizeof(BITMAPINFOHEADER)), "Bitmap headers didn't match.\n");
     for (i = 0; i < 32 * 16 * 2; ++i)
     {
@@ -1302,14 +1300,14 @@ static void test_current_image(IBaseFilter *filter, IMemInputPin *input,
     }
 
     hr = IMediaControl_Run(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     join_thread(thread);
 
     hr = IBasicVideo_GetCurrentImage(video, &size, buffer);
-    ok(hr == VFW_E_NOT_PAUSED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_PAUSED, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     IBasicVideo_Release(video);
 }
@@ -1333,18 +1331,18 @@ static void test_window_close(IPin *pin, IMemInputPin *input, IMediaControl *con
     IPin_QueryInterface(pin, &IID_IOverlay, (void **)&overlay);
 
     hr = IOverlay_GetWindowHandle(overlay, &hwnd);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     IOverlay_Release(overlay);
 
     hr = IMediaControl_Pause(control);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     ret = check_ec_userabort(eventsrc, 0);
     ok(!ret, "Got unexpected EC_USERABORT.\n");
 
     SendMessageW(hwnd, WM_CLOSE, 0, 0);
 
     hr = IMediaControl_GetState(control, 1000, &state);
-    ok(hr == VFW_S_STATE_INTERMEDIATE, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_S_STATE_INTERMEDIATE, "Got hr %#x.\n", hr);
     ret = check_ec_userabort(eventsrc, 0);
     ok(ret == 1, "Expected EC_USERABORT.\n");
 
@@ -1357,28 +1355,28 @@ static void test_window_close(IPin *pin, IMemInputPin *input, IMediaControl *con
     if (ret == WAIT_OBJECT_0)
     {
         GetExitCodeThread(thread, (DWORD *)&hr);
-        ok(hr == E_UNEXPECTED, "Got hr %#lx.\n", hr);
+        ok(hr == E_UNEXPECTED, "Got hr %#x.\n", hr);
     }
     CloseHandle(thread);
 
     hr = IMediaControl_Run(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ret = check_ec_userabort(eventsrc, 0);
     ok(!ret, "Got unexpected EC_USERABORT.\n");
 
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ret = check_ec_userabort(eventsrc, 0);
     ok(!ret, "Got unexpected EC_USERABORT.\n");
 
     /* We receive an EC_USERABORT notification immediately. */
 
     hr = IMediaControl_Run(control);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     hr = join_thread(send_frame(input));
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMediaControl_GetState(control, 1000, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ret = check_ec_userabort(eventsrc, 0);
     ok(!ret, "Got unexpected EC_USERABORT.\n");
 
@@ -1391,7 +1389,7 @@ static void test_window_close(IPin *pin, IMemInputPin *input, IMediaControl *con
     ok(!IsWindowVisible(hwnd), "Window should be visible.\n");
 
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ret = check_ec_userabort(eventsrc, 0);
     ok(!ret, "Got unexpected EC_USERABORT.\n");
 
@@ -1449,52 +1447,52 @@ static void test_connect_pin(void)
     {
         req_mt.subtype = *subtype_tests[i];
         hr = IFilterGraph2_ConnectDirect(graph, &source.source.pin.IPin_iface, pin, &req_mt);
-        ok(hr == S_OK, "Got hr %#lx for subtype %s.\n", hr, wine_dbgstr_guid(subtype_tests[i]));
+        ok(hr == S_OK, "Got hr %#x for subtype %s.\n", hr, wine_dbgstr_guid(subtype_tests[i]));
 
         hr = IFilterGraph2_Disconnect(graph, &source.source.pin.IPin_iface);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
         hr = IFilterGraph2_Disconnect(graph, pin);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
     }
 
     req_mt.formattype = FORMAT_None;
     hr = IFilterGraph2_ConnectDirect(graph, &source.source.pin.IPin_iface, pin, &req_mt);
-    ok(hr == VFW_E_TYPE_NOT_ACCEPTED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_TYPE_NOT_ACCEPTED, "Got hr %#x.\n", hr);
     req_mt.formattype = FORMAT_VideoInfo;
 
     peer = (IPin *)0xdeadbeef;
     hr = IPin_ConnectedTo(pin, &peer);
-    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#x.\n", hr);
     ok(!peer, "Got peer %p.\n", peer);
 
     hr = IPin_ConnectionMediaType(pin, &mt);
-    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_Pause(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IFilterGraph2_ConnectDirect(graph, &source.source.pin.IPin_iface, pin, &req_mt);
-    ok(hr == VFW_E_NOT_STOPPED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_STOPPED, "Got hr %#x.\n", hr);
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IFilterGraph2_ConnectDirect(graph, &source.source.pin.IPin_iface, pin, &req_mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IPin_ConnectedTo(pin, &peer);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(peer == &source.source.pin.IPin_iface, "Got peer %p.\n", peer);
     IPin_Release(peer);
 
     hr = IPin_ConnectionMediaType(pin, &mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(compare_media_types(&mt, &req_mt), "Media types didn't match.\n");
 
     hr = IMediaControl_Pause(control);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     hr = IFilterGraph2_Disconnect(graph, pin);
-    ok(hr == VFW_E_NOT_STOPPED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_STOPPED, "Got hr %#x.\n", hr);
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     IPin_QueryInterface(pin, &IID_IMemInputPin, (void **)&input);
 
@@ -1502,17 +1500,17 @@ static void test_connect_pin(void)
 
     hr = CoCreateInstance(&CLSID_MemoryAllocator, NULL, CLSCTX_INPROC_SERVER,
             &IID_IMemAllocator, (void **)&allocator);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMemAllocator_SetProperties(allocator, &req_props, &ret_props);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(!memcmp(&ret_props, &req_props, sizeof(req_props)), "Properties did not match.\n");
     hr = IMemInputPin_NotifyAllocator(input, allocator, TRUE);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMemAllocator_Commit(allocator);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMemInputPin_ReceiveCanBlock(input);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     test_filter_state(input, control);
     test_flushing(pin, input, control);
@@ -1522,31 +1520,31 @@ static void test_connect_pin(void)
     test_window_close(pin, input, control);
 
     hr = IFilterGraph2_Disconnect(graph, pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IFilterGraph2_Disconnect(graph, pin);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     ok(source.source.pin.peer == pin, "Got peer %p.\n", peer);
     IFilterGraph2_Disconnect(graph, &source.source.pin.IPin_iface);
 
     peer = (IPin *)0xdeadbeef;
     hr = IPin_ConnectedTo(pin, &peer);
-    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#x.\n", hr);
     ok(!peer, "Got peer %p.\n", peer);
 
     hr = IPin_ConnectionMediaType(pin, &mt);
-    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#x.\n", hr);
 
     ref = IMemAllocator_Release(allocator);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     IMemInputPin_Release(input);
     IPin_Release(pin);
     IMediaControl_Release(control);
     ref = IFilterGraph2_Release(graph);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ref = IBaseFilter_Release(&source.filter.IBaseFilter_iface);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 static void test_unconnected_filter_state(void)
@@ -1557,53 +1555,53 @@ static void test_unconnected_filter_state(void)
     ULONG ref;
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(state == State_Stopped, "Got state %u.\n", state);
 
     hr = IBaseFilter_Pause(filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(state == State_Paused, "Got state %u.\n", state);
 
     hr = IBaseFilter_Run(filter, 0);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(state == State_Running, "Got state %u.\n", state);
 
     hr = IBaseFilter_Pause(filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(state == State_Paused, "Got state %u.\n", state);
 
     hr = IBaseFilter_Stop(filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(state == State_Stopped, "Got state %u.\n", state);
 
     hr = IBaseFilter_Run(filter, 0);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(state == State_Running, "Got state %u.\n", state);
 
     hr = IBaseFilter_Stop(filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(state == State_Stopped, "Got state %u.\n", state);
 
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 static void test_overlay(void)
@@ -1618,17 +1616,17 @@ static void test_overlay(void)
     IBaseFilter_FindPin(filter, L"In", &pin);
 
     hr = IPin_QueryInterface(pin, &IID_IOverlay, (void **)&overlay);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hwnd = (HWND)0xdeadbeef;
     hr = IOverlay_GetWindowHandle(overlay, &hwnd);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(hwnd && hwnd != (HWND)0xdeadbeef, "Got invalid window %p.\n", hwnd);
 
     IOverlay_Release(overlay);
     IPin_Release(pin);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 /* try to make sure pending X events have been processed before continuing */
@@ -1652,7 +1650,7 @@ static void flush_events(void)
 static LRESULT CALLBACK window_proc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam)
 {
     if (winetest_debug > 1)
-        trace("hwnd %p, msg %#x, wparam %#Ix, lparam %#Ix.\n", hwnd, msg, wparam, lparam);
+        trace("hwnd %p, msg %#x, wparam %#lx, lparam %#lx.\n", hwnd, msg, wparam, lparam);
 
     if (wparam == 0xdeadbeef)
         return 0;
@@ -1667,7 +1665,7 @@ static void test_video_window_caption(IVideoWindow *window, HWND hwnd)
     HRESULT hr;
 
     hr = IVideoWindow_get_Caption(window, &caption);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(!wcscmp(caption, L"ActiveMovie Window"), "Got caption %s.\n", wine_dbgstr_w(caption));
     SysFreeString(caption);
 
@@ -1676,11 +1674,11 @@ static void test_video_window_caption(IVideoWindow *window, HWND hwnd)
 
     caption = SysAllocString(L"foo");
     hr = IVideoWindow_put_Caption(window, caption);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     SysFreeString(caption);
 
     hr = IVideoWindow_get_Caption(window, &caption);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(!wcscmp(caption, L"foo"), "Got caption %s.\n", wine_dbgstr_w(caption));
     SysFreeString(caption);
 
@@ -1694,53 +1692,53 @@ static void test_video_window_style(IVideoWindow *window, HWND hwnd, HWND our_hw
     LONG style;
 
     hr = IVideoWindow_get_WindowStyle(window, &style);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(style == (WS_CLIPSIBLINGS | WS_CLIPCHILDREN | WS_OVERLAPPEDWINDOW),
-            "Got style %#lx.\n", style);
+            "Got style %#x.\n", style);
 
     style = GetWindowLongA(hwnd, GWL_STYLE);
     ok(style == (WS_CLIPSIBLINGS | WS_CLIPCHILDREN | WS_OVERLAPPEDWINDOW),
-            "Got style %#lx.\n", style);
+            "Got style %#x.\n", style);
 
     hr = IVideoWindow_put_WindowStyle(window, style | WS_DISABLED);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
     hr = IVideoWindow_put_WindowStyle(window, style | WS_HSCROLL);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
     hr = IVideoWindow_put_WindowStyle(window, style | WS_VSCROLL);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
     hr = IVideoWindow_put_WindowStyle(window, style | WS_MAXIMIZE);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
     hr = IVideoWindow_put_WindowStyle(window, style | WS_MINIMIZE);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_put_WindowStyle(window, style & ~WS_CLIPCHILDREN);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_get_WindowStyle(window, &style);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(style == (WS_CLIPSIBLINGS | WS_OVERLAPPEDWINDOW), "Got style %#lx.\n", style);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(style == (WS_CLIPSIBLINGS | WS_OVERLAPPEDWINDOW), "Got style %#x.\n", style);
 
     style = GetWindowLongA(hwnd, GWL_STYLE);
-    ok(style == (WS_CLIPSIBLINGS | WS_OVERLAPPEDWINDOW), "Got style %#lx.\n", style);
+    ok(style == (WS_CLIPSIBLINGS | WS_OVERLAPPEDWINDOW), "Got style %#x.\n", style);
 
     ok(GetActiveWindow() == our_hwnd, "Got active window %p.\n", GetActiveWindow());
 
     hr = IVideoWindow_get_WindowStyleEx(window, &style);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(style == WS_EX_WINDOWEDGE, "Got style %#lx.\n", style);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(style == WS_EX_WINDOWEDGE, "Got style %#x.\n", style);
 
     style = GetWindowLongA(hwnd, GWL_EXSTYLE);
-    ok(style == WS_EX_WINDOWEDGE, "Got style %#lx.\n", style);
+    ok(style == WS_EX_WINDOWEDGE, "Got style %#x.\n", style);
 
     hr = IVideoWindow_put_WindowStyleEx(window, style | WS_EX_TRANSPARENT);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_get_WindowStyleEx(window, &style);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(style == (WS_EX_WINDOWEDGE | WS_EX_TRANSPARENT), "Got style %#lx.\n", style);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(style == (WS_EX_WINDOWEDGE | WS_EX_TRANSPARENT), "Got style %#x.\n", style);
 
     style = GetWindowLongA(hwnd, GWL_EXSTYLE);
-    ok(style == (WS_EX_WINDOWEDGE | WS_EX_TRANSPARENT), "Got style %#lx.\n", style);
+    ok(style == (WS_EX_WINDOWEDGE | WS_EX_TRANSPARENT), "Got style %#x.\n", style);
 }
 
 static BOOL CALLBACK top_window_cb(HWND hwnd, LPARAM ctx)
@@ -1771,25 +1769,25 @@ static void test_video_window_state(IVideoWindow *window, HWND hwnd, HWND our_hw
     SetWindowPos(our_hwnd, HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);
 
     hr = IVideoWindow_get_WindowState(window, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(state == SW_HIDE, "Got state %ld.\n", state);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(state == SW_HIDE, "Got state %d.\n", state);
 
     hr = IVideoWindow_get_Visible(window, &state);
-    ok(state == OAFALSE, "Got state %ld.\n", state);
+    ok(state == OAFALSE, "Got state %d.\n", state);
 
     ok(!IsWindowVisible(hwnd), "Window should not be visible.\n");
     ok(!IsIconic(hwnd), "Window should not be minimized.\n");
     ok(!IsZoomed(hwnd), "Window should not be maximized.\n");
 
     hr = IVideoWindow_put_WindowState(window, SW_SHOWNA);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_get_WindowState(window, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(state == SW_SHOW, "Got state %ld.\n", state);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(state == SW_SHOW, "Got state %d.\n", state);
 
     hr = IVideoWindow_get_Visible(window, &state);
-    ok(state == OATRUE, "Got state %ld.\n", state);
+    ok(state == OATRUE, "Got state %d.\n", state);
 
     ok(IsWindowVisible(hwnd), "Window should be visible.\n");
     ok(!IsIconic(hwnd), "Window should not be minimized.\n");
@@ -1799,14 +1797,14 @@ static void test_video_window_state(IVideoWindow *window, HWND hwnd, HWND our_hw
     ok(top == hwnd, "Got top window %p.\n", top);
 
     hr = IVideoWindow_put_WindowState(window, SW_MINIMIZE);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_get_WindowState(window, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(state == SW_MINIMIZE, "Got state %ld.\n", state);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(state == SW_MINIMIZE, "Got state %d.\n", state);
 
     hr = IVideoWindow_get_Visible(window, &state);
-    ok(state == OATRUE, "Got state %ld.\n", state);
+    ok(state == OATRUE, "Got state %d.\n", state);
 
     ok(IsWindowVisible(hwnd), "Window should be visible.\n");
     ok(IsIconic(hwnd), "Window should be minimized.\n");
@@ -1814,14 +1812,14 @@ static void test_video_window_state(IVideoWindow *window, HWND hwnd, HWND our_hw
     ok(GetActiveWindow() == our_hwnd, "Got active window %p.\n", GetActiveWindow());
 
     hr = IVideoWindow_put_WindowState(window, SW_RESTORE);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_get_WindowState(window, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(state == SW_SHOW, "Got state %ld.\n", state);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(state == SW_SHOW, "Got state %d.\n", state);
 
     hr = IVideoWindow_get_Visible(window, &state);
-    ok(state == OATRUE, "Got state %ld.\n", state);
+    ok(state == OATRUE, "Got state %d.\n", state);
 
     ok(IsWindowVisible(hwnd), "Window should be visible.\n");
     ok(!IsIconic(hwnd), "Window should not be minimized.\n");
@@ -1829,14 +1827,14 @@ static void test_video_window_state(IVideoWindow *window, HWND hwnd, HWND our_hw
     ok(GetActiveWindow() == hwnd, "Got active window %p.\n", GetActiveWindow());
 
     hr = IVideoWindow_put_WindowState(window, SW_MAXIMIZE);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_get_WindowState(window, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(state == SW_MAXIMIZE, "Got state %ld.\n", state);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(state == SW_MAXIMIZE, "Got state %d.\n", state);
 
     hr = IVideoWindow_get_Visible(window, &state);
-    ok(state == OATRUE, "Got state %ld.\n", state);
+    ok(state == OATRUE, "Got state %d.\n", state);
 
     ok(IsWindowVisible(hwnd), "Window should be visible.\n");
     ok(!IsIconic(hwnd), "Window should be minimized.\n");
@@ -1844,17 +1842,17 @@ static void test_video_window_state(IVideoWindow *window, HWND hwnd, HWND our_hw
     ok(GetActiveWindow() == hwnd, "Got active window %p.\n", GetActiveWindow());
 
     hr = IVideoWindow_put_WindowState(window, SW_RESTORE);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_put_WindowState(window, SW_HIDE);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_get_WindowState(window, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(state == SW_HIDE, "Got state %ld.\n", state);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(state == SW_HIDE, "Got state %d.\n", state);
 
     hr = IVideoWindow_get_Visible(window, &state);
-    ok(state == OAFALSE, "Got state %ld.\n", state);
+    ok(state == OAFALSE, "Got state %d.\n", state);
 
     ok(!IsWindowVisible(hwnd), "Window should not be visible.\n");
     ok(!IsIconic(hwnd), "Window should not be minimized.\n");
@@ -1862,14 +1860,14 @@ static void test_video_window_state(IVideoWindow *window, HWND hwnd, HWND our_hw
     ok(GetActiveWindow() == our_hwnd, "Got active window %p.\n", GetActiveWindow());
 
     hr = IVideoWindow_put_Visible(window, OATRUE);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_get_WindowState(window, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(state == SW_SHOW, "Got state %ld.\n", state);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(state == SW_SHOW, "Got state %d.\n", state);
 
     hr = IVideoWindow_get_Visible(window, &state);
-    ok(state == OATRUE, "Got state %ld.\n", state);
+    ok(state == OATRUE, "Got state %d.\n", state);
 
     ok(IsWindowVisible(hwnd), "Window should be visible.\n");
     ok(!IsIconic(hwnd), "Window should not be minimized.\n");
@@ -1877,14 +1875,14 @@ static void test_video_window_state(IVideoWindow *window, HWND hwnd, HWND our_hw
     ok(GetActiveWindow() == hwnd, "Got active window %p.\n", GetActiveWindow());
 
     hr = IVideoWindow_put_Visible(window, OAFALSE);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_get_WindowState(window, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(state == SW_HIDE, "Got state %ld.\n", state);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(state == SW_HIDE, "Got state %d.\n", state);
 
     hr = IVideoWindow_get_Visible(window, &state);
-    ok(state == OAFALSE, "Got state %ld.\n", state);
+    ok(state == OAFALSE, "Got state %d.\n", state);
 
     ok(!IsWindowVisible(hwnd), "Window should not be visible.\n");
     ok(!IsIconic(hwnd), "Window should not be minimized.\n");
@@ -1892,14 +1890,14 @@ static void test_video_window_state(IVideoWindow *window, HWND hwnd, HWND our_hw
     ok(GetActiveWindow() == our_hwnd, "Got active window %p.\n", GetActiveWindow());
 
     hr = IVideoWindow_put_WindowState(window, SW_SHOWNA);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_SetWindowForeground(window, TRUE);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
 
     SetWindowPos(our_hwnd, HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);
     hr = IVideoWindow_SetWindowForeground(window, OATRUE);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(GetActiveWindow() == hwnd, "Got active window %p.\n", GetActiveWindow());
     ok(GetFocus() == hwnd, "Got focus window %p.\n", GetFocus());
     ok(GetForegroundWindow() == hwnd, "Got foreground window %p.\n", GetForegroundWindow());
@@ -1907,7 +1905,7 @@ static void test_video_window_state(IVideoWindow *window, HWND hwnd, HWND our_hw
     ok(top == hwnd, "Got top window %p.\n", top);
 
     hr = IVideoWindow_SetWindowForeground(window, OAFALSE);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(GetActiveWindow() == hwnd, "Got active window %p.\n", GetActiveWindow());
     ok(GetFocus() == hwnd, "Got focus window %p.\n", GetFocus());
     ok(GetForegroundWindow() == hwnd, "Got foreground window %p.\n", GetForegroundWindow());
@@ -1916,7 +1914,7 @@ static void test_video_window_state(IVideoWindow *window, HWND hwnd, HWND our_hw
 
     SetWindowPos(our_hwnd, HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);
     hr = IVideoWindow_SetWindowForeground(window, OAFALSE);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(GetActiveWindow() == our_hwnd, "Got active window %p.\n", GetActiveWindow());
     ok(GetFocus() == our_hwnd, "Got focus window %p.\n", GetFocus());
     ok(GetForegroundWindow() == our_hwnd, "Got foreground window %p.\n", GetForegroundWindow());
@@ -1938,114 +1936,114 @@ static void test_video_window_position(IVideoWindow *window, HWND hwnd, HWND our
     expect_height = rect.bottom - rect.top;
 
     hr = IVideoWindow_put_Left(window, 0);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IVideoWindow_put_Top(window, 0);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_get_Left(window, &left);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(left == 0, "Got left %ld.\n", left);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(left == 0, "Got left %d.\n", left);
     hr = IVideoWindow_get_Top(window, &top);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(top == 0, "Got top %ld.\n", top);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(top == 0, "Got top %d.\n", top);
     hr = IVideoWindow_get_Width(window, &width);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(width == expect_width, "Got width %ld.\n", width);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(width == expect_width, "Got width %d.\n", width);
     hr = IVideoWindow_get_Height(window, &height);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(height == expect_height, "Got height %ld.\n", height);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(height == expect_height, "Got height %d.\n", height);
     hr = IVideoWindow_GetWindowPosition(window, &left, &top, &width, &height);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(left == 0, "Got left %ld.\n", left);
-    ok(top == 0, "Got top %ld.\n", top);
-    ok(width == expect_width, "Got width %ld.\n", width);
-    ok(height == expect_height, "Got height %ld.\n", height);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(left == 0, "Got left %d.\n", left);
+    ok(top == 0, "Got top %d.\n", top);
+    ok(width == expect_width, "Got width %d.\n", width);
+    ok(height == expect_height, "Got height %d.\n", height);
     GetWindowRect(hwnd, &rect);
-    ok(rect.left == 0, "Got window left %ld.\n", rect.left);
-    ok(rect.top == 0, "Got window top %ld.\n", rect.top);
-    ok(rect.right == expect_width, "Got window right %ld.\n", rect.right);
-    ok(rect.bottom == expect_height, "Got window bottom %ld.\n", rect.bottom);
+    ok(rect.left == 0, "Got window left %d.\n", rect.left);
+    ok(rect.top == 0, "Got window top %d.\n", rect.top);
+    ok(rect.right == expect_width, "Got window right %d.\n", rect.right);
+    ok(rect.bottom == expect_height, "Got window bottom %d.\n", rect.bottom);
 
     hr = IVideoWindow_put_Left(window, 10);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_get_Left(window, &left);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(left == 10, "Got left %ld.\n", left);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(left == 10, "Got left %d.\n", left);
     hr = IVideoWindow_get_Top(window, &top);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(top == 0, "Got top %ld.\n", top);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(top == 0, "Got top %d.\n", top);
     hr = IVideoWindow_get_Width(window, &width);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(width == expect_width, "Got width %ld.\n", width);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(width == expect_width, "Got width %d.\n", width);
     hr = IVideoWindow_get_Height(window, &height);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(height == expect_height, "Got height %ld.\n", height);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(height == expect_height, "Got height %d.\n", height);
     hr = IVideoWindow_GetWindowPosition(window, &left, &top, &width, &height);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(left == 10, "Got left %ld.\n", left);
-    ok(top == 0, "Got top %ld.\n", top);
-    ok(width == expect_width, "Got width %ld.\n", width);
-    ok(height == expect_height, "Got height %ld.\n", height);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(left == 10, "Got left %d.\n", left);
+    ok(top == 0, "Got top %d.\n", top);
+    ok(width == expect_width, "Got width %d.\n", width);
+    ok(height == expect_height, "Got height %d.\n", height);
     GetWindowRect(hwnd, &rect);
-    ok(rect.left == 10, "Got window left %ld.\n", rect.left);
-    ok(rect.top == 0, "Got window top %ld.\n", rect.top);
-    ok(rect.right == 10 + expect_width, "Got window right %ld.\n", rect.right);
-    ok(rect.bottom == expect_height, "Got window bottom %ld.\n", rect.bottom);
+    ok(rect.left == 10, "Got window left %d.\n", rect.left);
+    ok(rect.top == 0, "Got window top %d.\n", rect.top);
+    ok(rect.right == 10 + expect_width, "Got window right %d.\n", rect.right);
+    ok(rect.bottom == expect_height, "Got window bottom %d.\n", rect.bottom);
 
     hr = IVideoWindow_put_Height(window, 200);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_get_Left(window, &left);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(left == 10, "Got left %ld.\n", left);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(left == 10, "Got left %d.\n", left);
     hr = IVideoWindow_get_Top(window, &top);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(top == 0, "Got top %ld.\n", top);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(top == 0, "Got top %d.\n", top);
     hr = IVideoWindow_get_Width(window, &width);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(width == expect_width, "Got width %ld.\n", width);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(width == expect_width, "Got width %d.\n", width);
     hr = IVideoWindow_get_Height(window, &height);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(height == 200, "Got height %ld.\n", height);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(height == 200, "Got height %d.\n", height);
     hr = IVideoWindow_GetWindowPosition(window, &left, &top, &width, &height);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(left == 10, "Got left %ld.\n", left);
-    ok(top == 0, "Got top %ld.\n", top);
-    ok(width == expect_width, "Got width %ld.\n", width);
-    ok(height == 200, "Got height %ld.\n", height);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(left == 10, "Got left %d.\n", left);
+    ok(top == 0, "Got top %d.\n", top);
+    ok(width == expect_width, "Got width %d.\n", width);
+    ok(height == 200, "Got height %d.\n", height);
     GetWindowRect(hwnd, &rect);
-    ok(rect.left == 10, "Got window left %ld.\n", rect.left);
-    ok(rect.top == 0, "Got window top %ld.\n", rect.top);
-    ok(rect.right == 10 + expect_width, "Got window right %ld.\n", rect.right);
-    ok(rect.bottom == 200, "Got window bottom %ld.\n", rect.bottom);
+    ok(rect.left == 10, "Got window left %d.\n", rect.left);
+    ok(rect.top == 0, "Got window top %d.\n", rect.top);
+    ok(rect.right == 10 + expect_width, "Got window right %d.\n", rect.right);
+    ok(rect.bottom == 200, "Got window bottom %d.\n", rect.bottom);
 
     hr = IVideoWindow_SetWindowPosition(window, 100, 200, 300, 400);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_get_Left(window, &left);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(left == 100, "Got left %ld.\n", left);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(left == 100, "Got left %d.\n", left);
     hr = IVideoWindow_get_Top(window, &top);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(top == 200, "Got top %ld.\n", top);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(top == 200, "Got top %d.\n", top);
     hr = IVideoWindow_get_Width(window, &width);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(width == 300, "Got width %ld.\n", width);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(width == 300, "Got width %d.\n", width);
     hr = IVideoWindow_get_Height(window, &height);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(height == 400, "Got height %ld.\n", height);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(height == 400, "Got height %d.\n", height);
     hr = IVideoWindow_GetWindowPosition(window, &left, &top, &width, &height);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(left == 100, "Got left %ld.\n", left);
-    ok(top == 200, "Got top %ld.\n", top);
-    ok(width == 300, "Got width %ld.\n", width);
-    ok(height == 400, "Got height %ld.\n", height);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(left == 100, "Got left %d.\n", left);
+    ok(top == 200, "Got top %d.\n", top);
+    ok(width == 300, "Got width %d.\n", width);
+    ok(height == 400, "Got height %d.\n", height);
     GetWindowRect(hwnd, &rect);
-    ok(rect.left == 100, "Got window left %ld.\n", rect.left);
-    ok(rect.top == 200, "Got window top %ld.\n", rect.top);
-    ok(rect.right == 400, "Got window right %ld.\n", rect.right);
-    ok(rect.bottom == 600, "Got window bottom %ld.\n", rect.bottom);
+    ok(rect.left == 100, "Got window left %d.\n", rect.left);
+    ok(rect.top == 200, "Got window top %d.\n", rect.top);
+    ok(rect.right == 400, "Got window right %d.\n", rect.right);
+    ok(rect.bottom == 600, "Got window bottom %d.\n", rect.bottom);
 
     ok(GetActiveWindow() == our_hwnd, "Got active window %p.\n", GetActiveWindow());
     top_hwnd = get_top_window();
@@ -2062,25 +2060,25 @@ static void test_video_window_owner(IVideoWindow *window, HWND hwnd, HWND our_hw
     SetWindowPos(our_hwnd, HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);
 
     hr = IVideoWindow_get_Owner(window, &oahwnd);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(!oahwnd, "Got owner %#Ix.\n", oahwnd);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(!oahwnd, "Got owner %#lx.\n", oahwnd);
 
     parent = GetAncestor(hwnd, GA_PARENT);
     ok(parent == GetDesktopWindow(), "Got parent %p.\n", parent);
     style = GetWindowLongA(hwnd, GWL_STYLE);
-    ok(!(style & WS_CHILD), "Got style %#lx.\n", style);
+    ok(!(style & WS_CHILD), "Got style %#x.\n", style);
 
     hr = IVideoWindow_put_Owner(window, (OAHWND)our_hwnd);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_get_Owner(window, &oahwnd);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(oahwnd == (OAHWND)our_hwnd, "Got owner %#Ix.\n", oahwnd);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(oahwnd == (OAHWND)our_hwnd, "Got owner %#lx.\n", oahwnd);
 
     parent = GetAncestor(hwnd, GA_PARENT);
     ok(parent == our_hwnd, "Got parent %p.\n", parent);
     style = GetWindowLongA(hwnd, GWL_STYLE);
-    ok((style & WS_CHILD), "Got style %#lx.\n", style);
+    ok((style & WS_CHILD), "Got style %#x.\n", style);
 
     ok(GetActiveWindow() == our_hwnd, "Got active window %p.\n", GetActiveWindow());
     top_hwnd = get_top_window();
@@ -2089,31 +2087,31 @@ static void test_video_window_owner(IVideoWindow *window, HWND hwnd, HWND our_hw
     ShowWindow(our_hwnd, SW_HIDE);
 
     hr = IVideoWindow_put_Visible(window, OATRUE);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_get_Visible(window, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(state == OAFALSE, "Got state %ld.\n", state);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(state == OAFALSE, "Got state %d.\n", state);
 
     hr = IVideoWindow_put_Owner(window, 0);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_get_Owner(window, &oahwnd);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(!oahwnd, "Got owner %#Ix.\n", oahwnd);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(!oahwnd, "Got owner %#lx.\n", oahwnd);
 
     parent = GetAncestor(hwnd, GA_PARENT);
     ok(parent == GetDesktopWindow(), "Got parent %p.\n", parent);
     style = GetWindowLongA(hwnd, GWL_STYLE);
-    ok(!(style & WS_CHILD), "Got style %#lx.\n", style);
+    ok(!(style & WS_CHILD), "Got style %#x.\n", style);
 
     ok(GetActiveWindow() == hwnd, "Got active window %p.\n", GetActiveWindow());
     top_hwnd = get_top_window();
     ok(top_hwnd == hwnd, "Got top window %p.\n", top_hwnd);
 
     hr = IVideoWindow_get_Visible(window, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(state == OATRUE, "Got state %ld.\n", state);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(state == OATRUE, "Got state %d.\n", state);
 }
 
 struct notify_message_params
@@ -2127,7 +2125,7 @@ static DWORD CALLBACK notify_message_proc(void *arg)
 {
     const struct notify_message_params *params = arg;
     HRESULT hr = IVideoWindow_NotifyOwnerMessage(params->window, (OAHWND)params->hwnd, params->message, 0, 0);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     return 0;
 }
 
@@ -2170,15 +2168,15 @@ static void test_video_window_messages(IVideoWindow *window, HWND hwnd, HWND our
     flush_events();
 
     hr = IVideoWindow_get_MessageDrain(window, &oahwnd);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(!oahwnd, "Got window %#Ix.\n", oahwnd);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(!oahwnd, "Got window %#lx.\n", oahwnd);
 
     hr = IVideoWindow_put_MessageDrain(window, (OAHWND)our_hwnd);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_get_MessageDrain(window, &oahwnd);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(oahwnd == (OAHWND)our_hwnd, "Got window %#Ix.\n", oahwnd);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(oahwnd == (OAHWND)our_hwnd, "Got window %#lx.\n", oahwnd);
 
     for (i = 0; i < ARRAY_SIZE(drain_tests); ++i)
     {
@@ -2187,8 +2185,8 @@ static void test_video_window_messages(IVideoWindow *window, HWND hwnd, HWND our
         ok(ret, "Expected a message.\n");
         ok(msg.hwnd == our_hwnd, "Got hwnd %p.\n", msg.hwnd);
         ok(msg.message == drain_tests[i], "Got message %#x.\n", msg.message);
-        ok(msg.wParam == 0xdeadbeef, "Got wparam %#Ix.\n", msg.wParam);
-        ok(!msg.lParam, "Got lparam %#Ix.\n", msg.lParam);
+        ok(msg.wParam == 0xdeadbeef, "Got wparam %#lx.\n", msg.wParam);
+        ok(!msg.lParam, "Got lparam %#lx.\n", msg.lParam);
         DispatchMessageA(&msg);
 
         ret = PeekMessageA(&msg, 0, drain_tests[i], drain_tests[i], PM_REMOVE);
@@ -2196,10 +2194,10 @@ static void test_video_window_messages(IVideoWindow *window, HWND hwnd, HWND our
     }
 
     hr = IVideoWindow_put_MessageDrain(window, 0);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_put_Owner(window, (OAHWND)our_hwnd);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     flush_events();
 
@@ -2208,7 +2206,7 @@ static void test_video_window_messages(IVideoWindow *window, HWND hwnd, HWND our
      * posted all messages. */
 
     hr = IVideoWindow_NotifyOwnerMessage(window, (OAHWND)our_hwnd, WM_SYSCOLORCHANGE, 0, 0);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     while (PeekMessageA(&msg, 0, 0, 0, PM_REMOVE))
     {
@@ -2217,7 +2215,7 @@ static void test_video_window_messages(IVideoWindow *window, HWND hwnd, HWND our
     }
 
     hr = IVideoWindow_NotifyOwnerMessage(window, (OAHWND)our_hwnd, WM_FONTCHANGE, 0, 0);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     while (PeekMessageA(&msg, 0, 0, 0, PM_REMOVE))
     {
@@ -2254,7 +2252,7 @@ static void test_video_window_messages(IVideoWindow *window, HWND hwnd, HWND our
     }
 
     hr = IVideoWindow_put_Owner(window, 0);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 }
 
 static void test_video_window_autoshow(IVideoWindow *window, IFilterGraph2 *graph, HWND hwnd)
@@ -2266,41 +2264,41 @@ static void test_video_window_autoshow(IVideoWindow *window, IFilterGraph2 *grap
     IFilterGraph2_QueryInterface(graph, &IID_IMediaControl, (void **)&control);
 
     hr = IVideoWindow_get_AutoShow(window, &l);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(l == OATRUE, "Got %ld.\n", l);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(l == OATRUE, "Got %d.\n", l);
 
     hr = IVideoWindow_put_Visible(window, OAFALSE);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_Pause(control);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_get_Visible(window, &l);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(l == OATRUE, "Got %ld.\n", l);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(l == OATRUE, "Got %d.\n", l);
 
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_get_Visible(window, &l);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(l == OATRUE, "Got %ld.\n", l);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(l == OATRUE, "Got %d.\n", l);
 
     hr = IVideoWindow_put_AutoShow(window, OAFALSE);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_put_Visible(window, OAFALSE);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_Pause(control);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_get_Visible(window, &l);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(l == OAFALSE, "Got %ld.\n", l);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(l == OAFALSE, "Got %d.\n", l);
 
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     IMediaControl_Release(control);
 }
@@ -2354,36 +2352,36 @@ static void test_video_window(void)
     IBaseFilter_FindPin(filter, L"In", &pin);
 
     hr = IPin_QueryInterface(pin, &IID_IOverlay, (void **)&overlay);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IOverlay_GetWindowHandle(overlay, &hwnd);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     if (winetest_debug > 1) trace("ours %p, theirs %p\n", our_hwnd, hwnd);
     GetWindowRect(hwnd, &rect);
 
     tid = GetWindowThreadProcessId(hwnd, NULL);
-    ok(tid == GetCurrentThreadId(), "Expected tid %#lx, got %#lx.\n", GetCurrentThreadId(), tid);
+    ok(tid == GetCurrentThreadId(), "Expected tid %#x, got %#x.\n", GetCurrentThreadId(), tid);
 
     hr = IBaseFilter_QueryInterface(filter, &IID_IVideoWindow, (void **)&window);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_get_Visible(window, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_get_Caption(window, &caption);
-    todo_wine ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_get_WindowStyle(window, &l);
-    todo_wine ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_get_AutoShow(window, &l);
-    todo_wine ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#x.\n", hr);
 
     testfilter_init(&source);
     IFilterGraph2_AddFilter(graph, &source.filter.IBaseFilter_iface, NULL);
     IFilterGraph2_AddFilter(graph, filter, NULL);
     hr = IFilterGraph2_ConnectDirect(graph, &source.source.pin.IPin_iface, pin, &req_mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     ok(GetActiveWindow() == our_hwnd, "Got active window %p.\n", GetActiveWindow());
 
@@ -2396,29 +2394,29 @@ static void test_video_window(void)
     test_video_window_messages(window, hwnd, our_hwnd);
 
     hr = IVideoWindow_put_FullScreenMode(window, OATRUE);
-    todo_wine ok(hr == E_NOTIMPL, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == E_NOTIMPL, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_get_FullScreenMode(window, &l);
-    todo_wine ok(hr == E_NOTIMPL, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == E_NOTIMPL, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_GetMinIdealImageSize(window, &width, &height);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(width == 640, "Got width %ld.\n", width);
-    ok(height == 480, "Got height %ld.\n", height);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(width == 640, "Got width %d.\n", width);
+    ok(height == 480, "Got height %d.\n", height);
 
     hr = IVideoWindow_GetMaxIdealImageSize(window, &width, &height);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(width == 640, "Got width %ld.\n", width);
-    ok(height == 480, "Got height %ld.\n", height);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(width == 640, "Got width %d.\n", width);
+    ok(height == 480, "Got height %d.\n", height);
 
     IFilterGraph2_Release(graph);
     IVideoWindow_Release(window);
     IOverlay_Release(overlay);
     IPin_Release(pin);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ref = IBaseFilter_Release(&source.filter.IBaseFilter_iface);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     DestroyWindow(our_hwnd);
 }
 
@@ -2430,31 +2428,31 @@ static void check_source_position_(int line, IBasicVideo *video,
 
     left = top = width = height = 0xdeadbeef;
     hr = IBasicVideo_GetSourcePosition(video, &left, &top, &width, &height);
-    ok_(__FILE__,line)(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok_(__FILE__,line)(left == expect_left, "Got left %ld.\n", left);
-    ok_(__FILE__,line)(top == expect_top, "Got top %ld.\n", top);
-    ok_(__FILE__,line)(width == expect_width, "Got width %ld.\n", width);
-    ok_(__FILE__,line)(height == expect_height, "Got height %ld.\n", height);
+    ok_(__FILE__,line)(hr == S_OK, "Got hr %#x.\n", hr);
+    ok_(__FILE__,line)(left == expect_left, "Got left %d.\n", left);
+    ok_(__FILE__,line)(top == expect_top, "Got top %d.\n", top);
+    ok_(__FILE__,line)(width == expect_width, "Got width %d.\n", width);
+    ok_(__FILE__,line)(height == expect_height, "Got height %d.\n", height);
 
     l = 0xdeadbeef;
     hr = IBasicVideo_get_SourceLeft(video, &l);
-    ok_(__FILE__,line)(hr == S_OK, "Failed to get left, hr %#lx.\n", hr);
-    ok_(__FILE__,line)(l == left, "Got left %ld.\n", l);
+    ok_(__FILE__,line)(hr == S_OK, "Failed to get left, hr %#x.\n", hr);
+    ok_(__FILE__,line)(l == left, "Got left %d.\n", l);
 
     l = 0xdeadbeef;
     hr = IBasicVideo_get_SourceTop(video, &l);
-    ok_(__FILE__,line)(hr == S_OK, "Failed to get top, hr %#lx.\n", hr);
-    ok_(__FILE__,line)(l == top, "Got top %ld.\n", l);
+    ok_(__FILE__,line)(hr == S_OK, "Failed to get top, hr %#x.\n", hr);
+    ok_(__FILE__,line)(l == top, "Got top %d.\n", l);
 
     l = 0xdeadbeef;
     hr = IBasicVideo_get_SourceWidth(video, &l);
-    ok_(__FILE__,line)(hr == S_OK, "Failed to get width, hr %#lx.\n", hr);
-    ok_(__FILE__,line)(l == width, "Got width %ld.\n", l);
+    ok_(__FILE__,line)(hr == S_OK, "Failed to get width, hr %#x.\n", hr);
+    ok_(__FILE__,line)(l == width, "Got width %d.\n", l);
 
     l = 0xdeadbeef;
     hr = IBasicVideo_get_SourceHeight(video, &l);
-    ok_(__FILE__,line)(hr == S_OK, "Failed to get height, hr %#lx.\n", hr);
-    ok_(__FILE__,line)(l == height, "Got height %ld.\n", l);
+    ok_(__FILE__,line)(hr == S_OK, "Failed to get height, hr %#x.\n", hr);
+    ok_(__FILE__,line)(l == height, "Got height %d.\n", l);
 }
 #define check_source_position(a,b,c,d,e) check_source_position_(__LINE__,a,b,c,d,e)
 
@@ -2464,77 +2462,77 @@ static void test_basic_video_source(IBasicVideo *video)
 
     check_source_position(video, 0, 0, 600, 400);
     hr = IBasicVideo_IsUsingDefaultSource(video);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_put_SourceLeft(video, -10);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
     hr = IBasicVideo_put_SourceLeft(video, 10);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_put_SourceTop(video, -10);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
     hr = IBasicVideo_put_SourceTop(video, 10);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_put_SourceWidth(video, -500);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
     hr = IBasicVideo_put_SourceWidth(video, 0);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
     hr = IBasicVideo_put_SourceWidth(video, 700);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
     hr = IBasicVideo_put_SourceWidth(video, 500);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_source_position(video, 0, 0, 500, 400);
     hr = IBasicVideo_IsUsingDefaultSource(video);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_put_SourceHeight(video, -300);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
     hr = IBasicVideo_put_SourceHeight(video, 0);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
     hr = IBasicVideo_put_SourceHeight(video, 600);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
     hr = IBasicVideo_put_SourceHeight(video, 300);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_source_position(video, 0, 0, 500, 300);
     hr = IBasicVideo_IsUsingDefaultSource(video);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_put_SourceLeft(video, -10);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
     hr = IBasicVideo_put_SourceLeft(video, 10);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_source_position(video, 10, 0, 500, 300);
     hr = IBasicVideo_IsUsingDefaultSource(video);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_put_SourceTop(video, -10);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
     hr = IBasicVideo_put_SourceTop(video, 20);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_source_position(video, 10, 20, 500, 300);
     hr = IBasicVideo_IsUsingDefaultSource(video);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_SetSourcePosition(video, 4, 5, 60, 40);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_source_position(video, 4, 5, 60, 40);
     hr = IBasicVideo_IsUsingDefaultSource(video);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_SetSourcePosition(video, 0, 0, 600, 400);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_source_position(video, 0, 0, 600, 400);
     hr = IBasicVideo_IsUsingDefaultSource(video);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_SetSourcePosition(video, 4, 5, 60, 40);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IBasicVideo_SetDefaultSourcePosition(video);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_source_position(video, 0, 0, 600, 400);
     hr = IBasicVideo_IsUsingDefaultSource(video);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 }
 
 static void check_destination_position_(int line, IBasicVideo *video,
@@ -2545,31 +2543,31 @@ static void check_destination_position_(int line, IBasicVideo *video,
 
     left = top = width = height = 0xdeadbeef;
     hr = IBasicVideo_GetDestinationPosition(video, &left, &top, &width, &height);
-    ok_(__FILE__,line)(hr == S_OK, "Failed to get position, hr %#lx.\n", hr);
-    ok_(__FILE__,line)(left == expect_left, "Got left %ld.\n", left);
-    ok_(__FILE__,line)(top == expect_top, "Got top %ld.\n", top);
-    ok_(__FILE__,line)(width == expect_width, "Got width %ld.\n", width);
-    ok_(__FILE__,line)(height == expect_height, "Got height %ld.\n", height);
+    ok_(__FILE__,line)(hr == S_OK, "Failed to get position, hr %#x.\n", hr);
+    ok_(__FILE__,line)(left == expect_left, "Got left %d.\n", left);
+    ok_(__FILE__,line)(top == expect_top, "Got top %d.\n", top);
+    ok_(__FILE__,line)(width == expect_width, "Got width %d.\n", width);
+    ok_(__FILE__,line)(height == expect_height, "Got height %d.\n", height);
 
     l = 0xdeadbeef;
     hr = IBasicVideo_get_DestinationLeft(video, &l);
-    ok_(__FILE__,line)(hr == S_OK, "Failed to get left, hr %#lx.\n", hr);
-    ok_(__FILE__,line)(l == left, "Got left %ld.\n", l);
+    ok_(__FILE__,line)(hr == S_OK, "Failed to get left, hr %#x.\n", hr);
+    ok_(__FILE__,line)(l == left, "Got left %d.\n", l);
 
     l = 0xdeadbeef;
     hr = IBasicVideo_get_DestinationTop(video, &l);
-    ok_(__FILE__,line)(hr == S_OK, "Failed to get top, hr %#lx.\n", hr);
-    ok_(__FILE__,line)(l == top, "Got top %ld.\n", l);
+    ok_(__FILE__,line)(hr == S_OK, "Failed to get top, hr %#x.\n", hr);
+    ok_(__FILE__,line)(l == top, "Got top %d.\n", l);
 
     l = 0xdeadbeef;
     hr = IBasicVideo_get_DestinationWidth(video, &l);
-    ok_(__FILE__,line)(hr == S_OK, "Failed to get width, hr %#lx.\n", hr);
-    ok_(__FILE__,line)(l == width, "Got width %ld.\n", l);
+    ok_(__FILE__,line)(hr == S_OK, "Failed to get width, hr %#x.\n", hr);
+    ok_(__FILE__,line)(l == width, "Got width %d.\n", l);
 
     l = 0xdeadbeef;
     hr = IBasicVideo_get_DestinationHeight(video, &l);
-    ok_(__FILE__,line)(hr == S_OK, "Failed to get height, hr %#lx.\n", hr);
-    ok_(__FILE__,line)(l == height, "Got height %ld.\n", l);
+    ok_(__FILE__,line)(hr == S_OK, "Failed to get height, hr %#x.\n", hr);
+    ok_(__FILE__,line)(l == height, "Got height %d.\n", l);
 }
 #define check_destination_position(a,b,c,d,e) check_destination_position_(__LINE__,a,b,c,d,e)
 
@@ -2583,107 +2581,107 @@ static void test_basic_video_destination(IBasicVideo *video)
 
     check_destination_position(video, 0, 0, 600, 400);
     hr = IBasicVideo_IsUsingDefaultDestination(video);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_put_DestinationLeft(video, -10);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_destination_position(video, -10, 0, 600, 400);
     hr = IBasicVideo_IsUsingDefaultDestination(video);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_put_DestinationLeft(video, 10);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_destination_position(video, 10, 0, 600, 400);
     hr = IBasicVideo_IsUsingDefaultDestination(video);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_put_DestinationTop(video, -20);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_destination_position(video, 10, -20, 600, 400);
     hr = IBasicVideo_IsUsingDefaultDestination(video);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_put_DestinationTop(video, 20);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_destination_position(video, 10, 20, 600, 400);
     hr = IBasicVideo_IsUsingDefaultDestination(video);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_put_DestinationWidth(video, -700);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
     hr = IBasicVideo_put_DestinationWidth(video, 0);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
     hr = IBasicVideo_put_DestinationWidth(video, 700);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_destination_position(video, 10, 20, 700, 400);
     hr = IBasicVideo_IsUsingDefaultDestination(video);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_put_DestinationWidth(video, 500);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_destination_position(video, 10, 20, 500, 400);
     hr = IBasicVideo_IsUsingDefaultDestination(video);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_put_DestinationHeight(video, -500);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
     hr = IBasicVideo_put_DestinationHeight(video, 0);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
     hr = IBasicVideo_put_DestinationHeight(video, 500);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_destination_position(video, 10, 20, 500, 500);
     hr = IBasicVideo_IsUsingDefaultDestination(video);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_put_DestinationHeight(video, 300);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_destination_position(video, 10, 20, 500, 300);
     hr = IBasicVideo_IsUsingDefaultDestination(video);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_SetDestinationPosition(video, 4, 5, 60, 40);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_destination_position(video, 4, 5, 60, 40);
     hr = IBasicVideo_IsUsingDefaultDestination(video);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_SetDestinationPosition(video, 0, 0, 600, 400);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_destination_position(video, 0, 0, 600, 400);
     hr = IBasicVideo_IsUsingDefaultDestination(video);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_SetDestinationPosition(video, 4, 5, 60, 40);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IBasicVideo_SetDefaultDestinationPosition(video);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_destination_position(video, 0, 0, 600, 400);
     hr = IBasicVideo_IsUsingDefaultDestination(video);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     SetRect(&rect, 100, 200, 500, 500);
     AdjustWindowRect(&rect, WS_OVERLAPPEDWINDOW, FALSE);
     hr = IVideoWindow_SetWindowPosition(window, rect.left, rect.top,
             rect.right - rect.left, rect.bottom - rect.top);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_destination_position(video, 0, 0, 400, 300);
     hr = IBasicVideo_IsUsingDefaultDestination(video);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_SetDestinationPosition(video, 0, 0, 400, 300);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_destination_position(video, 0, 0, 400, 300);
     hr = IBasicVideo_IsUsingDefaultDestination(video);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     SetRect(&rect, 100, 200, 600, 600);
     AdjustWindowRect(&rect, WS_OVERLAPPEDWINDOW, FALSE);
     hr = IVideoWindow_SetWindowPosition(window, rect.left, rect.top,
             rect.right - rect.left, rect.bottom - rect.top);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_destination_position(video, 0, 0, 400, 300);
     hr = IBasicVideo_IsUsingDefaultDestination(video);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     IVideoWindow_Release(window);
 }
@@ -2728,127 +2726,127 @@ static void test_basic_video(void)
     IBaseFilter_FindPin(filter, L"In", &pin);
 
     hr = IBasicVideo_GetTypeInfoCount(video, &count);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(count == 1, "Got count %u.\n", count);
 
     hr = IBasicVideo_GetTypeInfo(video, 0, 0, &typeinfo);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = ITypeInfo_GetTypeAttr(typeinfo, &typeattr);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(typeattr->typekind == TKIND_DISPATCH, "Got kind %u.\n", typeattr->typekind);
     ok(IsEqualGUID(&typeattr->guid, &IID_IBasicVideo), "Got IID %s.\n", wine_dbgstr_guid(&typeattr->guid));
     ITypeInfo_ReleaseTypeAttr(typeinfo, typeattr);
     ITypeInfo_Release(typeinfo);
 
     hr = IBasicVideo_get_AvgTimePerFrame(video, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
     hr = IBasicVideo_get_AvgTimePerFrame(video, &reftime);
-    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_get_BitRate(video, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
     hr = IBasicVideo_get_BitRate(video, &l);
-    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_get_BitErrorRate(video, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
     hr = IBasicVideo_get_BitErrorRate(video, &l);
-    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_get_VideoWidth(video, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
     hr = IBasicVideo_get_VideoHeight(video, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_get_SourceLeft(video, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
     hr = IBasicVideo_get_SourceWidth(video, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
     hr = IBasicVideo_get_SourceTop(video, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
     hr = IBasicVideo_get_SourceHeight(video, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_get_DestinationLeft(video, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
     hr = IBasicVideo_get_DestinationWidth(video, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
     hr = IBasicVideo_get_DestinationTop(video, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
     hr = IBasicVideo_get_DestinationHeight(video, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_GetSourcePosition(video, NULL, &top, &width, &height);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
     hr = IBasicVideo_GetSourcePosition(video, &left, NULL, &width, &height);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
     hr = IBasicVideo_GetSourcePosition(video, &left, &top, NULL, &height);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
     hr = IBasicVideo_GetSourcePosition(video, &left, &top, &width, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_GetDestinationPosition(video, NULL, &top, &width, &height);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
     hr = IBasicVideo_GetDestinationPosition(video, &left, NULL, &width, &height);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
     hr = IBasicVideo_GetDestinationPosition(video, &left, &top, NULL, &height);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
     hr = IBasicVideo_GetDestinationPosition(video, &left, &top, &width, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_GetVideoSize(video, &width, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
     hr = IBasicVideo_GetVideoSize(video, NULL, &height);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_GetVideoPaletteEntries(video, 0, 1, NULL, &l);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
     hr = IBasicVideo_GetVideoPaletteEntries(video, 0, 1, &l, NULL);
-    todo_wine ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#x.\n", hr);
 
     testfilter_init(&source);
     IFilterGraph2_AddFilter(graph, &source.filter.IBaseFilter_iface, L"vmr9");
     IFilterGraph2_AddFilter(graph, filter, L"source");
     hr = IFilterGraph2_ConnectDirect(graph, &source.source.pin.IPin_iface, pin, &req_mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     reftime = 0.0;
     hr = IBasicVideo_get_AvgTimePerFrame(video, &reftime);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(reftime == 0.02, "Got frame rate %.16e.\n", reftime);
 
     l = 0xdeadbeef;
     hr = IBasicVideo_get_BitRate(video, &l);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(!l, "Got bit rate %ld.\n", l);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(!l, "Got bit rate %d.\n", l);
 
     l = 0xdeadbeef;
     hr = IBasicVideo_get_BitErrorRate(video, &l);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(!l, "Got bit rate %ld.\n", l);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(!l, "Got bit rate %d.\n", l);
 
     hr = IBasicVideo_GetVideoPaletteEntries(video, 0, 1, &l, NULL);
-    todo_wine ok(hr == VFW_E_NO_PALETTE_AVAILABLE, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == VFW_E_NO_PALETTE_AVAILABLE, "Got hr %#x.\n", hr);
 
     width = height = 0xdeadbeef;
     hr = IBasicVideo_GetVideoSize(video, &width, &height);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(width == 600, "Got width %ld.\n", width);
-    ok(height == 400, "Got height %ld.\n", height);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(width == 600, "Got width %d.\n", width);
+    ok(height == 400, "Got height %d.\n", height);
 
     test_basic_video_source(video);
     test_basic_video_destination(video);
 
     hr = IFilterGraph2_Disconnect(graph, &source.source.pin.IPin_iface);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IFilterGraph2_Disconnect(graph, pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     vih.bmiHeader.biWidth = 16;
     vih.bmiHeader.biHeight = 16;
     vih.bmiHeader.biSizeImage = 0;
     hr = IFilterGraph2_ConnectDirect(graph, &source.source.pin.IPin_iface, pin, &req_mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     check_source_position(video, 0, 0, 16, 16);
 
@@ -2858,13 +2856,13 @@ static void test_basic_video(void)
             max(16, GetSystemMetrics(SM_CYMIN) - (rect.bottom - rect.top)));
 
     ref = IFilterGraph2_Release(graph);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     IBasicVideo_Release(video);
     IPin_Release(pin);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ref = IBaseFilter_Release(&source.filter.IBaseFilter_iface);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 static void test_unconnected_eos(void)
@@ -2878,49 +2876,49 @@ static void test_unconnected_eos(void)
     ULONG ref;
 
     hr = IFilterGraph2_AddFilter(graph, filter, L"renderer");
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IFilterGraph2_QueryInterface(graph, &IID_IMediaControl, (void **)&control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IFilterGraph2_QueryInterface(graph, &IID_IMediaEvent, (void **)&eventsrc);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     ret = check_ec_complete(eventsrc, 0);
     ok(!ret, "Got %u EC_COMPLETE events.\n", ret);
 
     hr = IMediaControl_Pause(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     ret = check_ec_complete(eventsrc, 0);
     ok(!ret, "Got %u EC_COMPLETE events.\n", ret);
 
     hr = IMediaControl_Run(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     ret = check_ec_complete(eventsrc, 0);
     ok(ret == 1, "Got %u EC_COMPLETE events.\n", ret);
 
     hr = IMediaControl_Pause(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     ret = check_ec_complete(eventsrc, 0);
     ok(!ret, "Got %u EC_COMPLETE events.\n", ret);
 
     hr = IMediaControl_Run(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     ret = check_ec_complete(eventsrc, 0);
     ok(ret == 1, "Got %u EC_COMPLETE events.\n", ret);
 
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     ret = check_ec_complete(eventsrc, 0);
     ok(!ret, "Got %u EC_COMPLETE events.\n", ret);
 
     hr = IMediaControl_Run(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     ret = check_ec_complete(eventsrc, 0);
     ok(ret == 1, "Got %u EC_COMPLETE events.\n", ret);
@@ -2928,9 +2926,9 @@ static void test_unconnected_eos(void)
     IMediaControl_Release(control);
     IMediaEvent_Release(eventsrc);
     ref = IFilterGraph2_Release(graph);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 START_TEST(videorenderer)
diff --git a/dlls/quartz/tests/vmr7.c b/dlls/quartz/tests/vmr7.c
index 88c82bec0d3..efc876a845c 100644
--- wine/dlls/quartz/tests/vmr7.c
+++ wine/dlls/quartz/tests/vmr7.c
@@ -23,7 +23,6 @@
 #include "dshow.h"
 #include "d3d9.h"
 #include "vmr9.h"
-#include "videoacc.h"
 #include "wine/strmbase.h"
 #include "wine/test.h"
 
@@ -33,13 +32,13 @@ static IBaseFilter *create_vmr7(DWORD mode)
     IVMRFilterConfig *config;
     HRESULT hr = CoCreateInstance(&CLSID_VideoMixingRenderer, NULL, CLSCTX_INPROC_SERVER,
             &IID_IBaseFilter, (void **)&filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     if (mode)
     {
         hr = IBaseFilter_QueryInterface(filter, &IID_IVMRFilterConfig, (void **)&config);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
         hr = IVMRFilterConfig_SetRenderingMode(config, mode);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
         IVMRFilterConfig_Release(config);
     }
     return filter;
@@ -51,10 +50,10 @@ static HRESULT set_mixing_mode(IBaseFilter *filter)
     HRESULT hr;
 
     hr = IBaseFilter_QueryInterface(filter, &IID_IVMRFilterConfig, (void **)&config);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVMRFilterConfig_SetNumberOfStreams(config, 2);
-    todo_wine ok(hr == VFW_E_DDRAW_CAPS_NOT_SUITABLE || hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == VFW_E_DDRAW_CAPS_NOT_SUITABLE || hr == S_OK, "Got hr %#x.\n", hr);
 
     IVMRFilterConfig_Release(config);
     return hr;
@@ -88,7 +87,7 @@ static IFilterGraph2 *create_graph(void)
     IFilterGraph2 *ret;
     HRESULT hr;
     hr = CoCreateInstance(&CLSID_FilterGraph, NULL, CLSCTX_INPROC_SERVER, &IID_IFilterGraph2, (void **)&ret);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to create FilterGraph: %#x\n", hr);
     return ret;
 }
 
@@ -108,101 +107,101 @@ static void test_filter_config(void)
 
     hr = CoCreateInstance(&CLSID_VideoMixingRenderer, NULL, CLSCTX_INPROC_SERVER,
             &IID_IVMRFilterConfig, (void **)&config);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVMRFilterConfig_GetRenderingMode(config, &mode);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(mode == VMRMode_Windowed, "Got mode %#lx.\n", mode);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(mode == VMRMode_Windowed, "Got mode %#x.\n", mode);
 
     hr = IVMRFilterConfig_SetRenderingMode(config, VMRMode_Windowed);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVMRFilterConfig_GetRenderingMode(config, &mode);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(mode == VMRMode_Windowed, "Got mode %#lx.\n", mode);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(mode == VMRMode_Windowed, "Got mode %#x.\n", mode);
 
     hr = IVMRFilterConfig_SetRenderingMode(config, VMRMode_Windowed);
-    ok(hr == VFW_E_WRONG_STATE, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_WRONG_STATE, "Got hr %#x.\n", hr);
 
     ref = IVMRFilterConfig_Release(config);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 
     hr = CoCreateInstance(&CLSID_VideoMixingRenderer, NULL, CLSCTX_INPROC_SERVER,
             &IID_IVMRFilterConfig, (void **)&config);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVMRFilterConfig_SetRenderingMode(config, VMRMode_Windowless);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVMRFilterConfig_GetRenderingMode(config, &mode);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(mode == VMRMode_Windowless, "Got mode %#lx.\n", mode);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(mode == VMRMode_Windowless, "Got mode %#x.\n", mode);
 
     hr = IVMRFilterConfig_SetRenderingMode(config, VMRMode_Windowed);
-    ok(hr == VFW_E_WRONG_STATE, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_WRONG_STATE, "Got hr %#x.\n", hr);
 
     ref = IVMRFilterConfig_Release(config);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 
     hr = CoCreateInstance(&CLSID_VideoMixingRenderer, NULL, CLSCTX_INPROC_SERVER,
             &IID_IVMRFilterConfig, (void **)&config);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVMRFilterConfig_SetRenderingMode(config, VMRMode_Renderless);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVMRFilterConfig_GetRenderingMode(config, &mode);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(mode == VMRMode_Renderless, "Got mode %#lx.\n", mode);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(mode == VMRMode_Renderless, "Got mode %#x.\n", mode);
 
     hr = IVMRFilterConfig_SetRenderingMode(config, VMRMode_Windowless);
-    ok(hr == VFW_E_WRONG_STATE, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_WRONG_STATE, "Got hr %#x.\n", hr);
 
     ref = IVMRFilterConfig_Release(config);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 
     hr = CoCreateInstance(&CLSID_VideoMixingRenderer, NULL, CLSCTX_INPROC_SERVER,
             &IID_IVMRFilterConfig, (void **)&config);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVMRFilterConfig_GetNumberOfStreams(config, &count);
-    todo_wine ok(hr == VFW_E_VMR_NOT_IN_MIXER_MODE, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == VFW_E_VMR_NOT_IN_MIXER_MODE, "Got hr %#x.\n", hr);
 
     hr = IVMRFilterConfig_SetNumberOfStreams(config, 3);
     if (hr != VFW_E_DDRAW_CAPS_NOT_SUITABLE)
     {
-        todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
 
         hr = IVMRFilterConfig_GetNumberOfStreams(config, &count);
         todo_wine {
-            ok(hr == S_OK, "Got hr %#lx.\n", hr);
-            ok(count == 3, "Got count %lu.\n", count);
+            ok(hr == S_OK, "Got hr %#x.\n", hr);
+            ok(count == 3, "Got count %u.\n", count);
         }
 
         hr = IVMRFilterConfig_GetRenderingMode(config, &mode);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
-        ok(mode == VMRMode_Windowed, "Got mode %#lx.\n", mode);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
+        ok(mode == VMRMode_Windowed, "Got mode %#x.\n", mode);
 
         /* Despite MSDN, you can still change the rendering mode after setting the
          * stream count. */
         hr = IVMRFilterConfig_SetRenderingMode(config, VMRMode_Windowless);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
 
         hr = IVMRFilterConfig_GetRenderingMode(config, &mode);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
-        ok(mode == VMRMode_Windowless, "Got mode %#lx.\n", mode);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
+        ok(mode == VMRMode_Windowless, "Got mode %#x.\n", mode);
 
         hr = IVMRFilterConfig_GetNumberOfStreams(config, &count);
         todo_wine {
-            ok(hr == S_OK, "Got hr %#lx.\n", hr);
-            ok(count == 3, "Got count %lu.\n", count);
+            ok(hr == S_OK, "Got hr %#x.\n", hr);
+            ok(count == 3, "Got count %u.\n", count);
         }
     }
     else
         skip("Mixing mode is not supported.\n");
 
     ref = IVMRFilterConfig_Release(config);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 #define check_interface(a, b, c) check_interface_(__LINE__, a, b, c)
@@ -215,18 +214,22 @@ static void check_interface_(unsigned int line, void *iface_ptr, REFIID iid, BOO
     expected_hr = supported ? S_OK : E_NOINTERFACE;
 
     hr = IUnknown_QueryInterface(iface, iid, (void **)&unk);
-    ok_(__FILE__, line)(hr == expected_hr, "Got hr %#lx, expected %#lx.\n", hr, expected_hr);
+    ok_(__FILE__, line)(hr == expected_hr, "Got hr %#x, expected %#x.\n", hr, expected_hr);
     if (SUCCEEDED(hr))
         IUnknown_Release(unk);
 }
 
-static void test_common_interfaces(IBaseFilter *filter)
+static void test_interfaces(void)
 {
+    IBaseFilter *filter = create_vmr7(0);
+    ULONG ref;
     IPin *pin;
 
     check_interface(filter, &IID_IAMCertifiedOutputProtection, TRUE);
     check_interface(filter, &IID_IAMFilterMiscFlags, TRUE);
     check_interface(filter, &IID_IBaseFilter, TRUE);
+    check_interface(filter, &IID_IBasicVideo, TRUE);
+    todo_wine check_interface(filter, &IID_IBasicVideo2, TRUE);
     todo_wine check_interface(filter, &IID_IKsPropertySet, TRUE);
     check_interface(filter, &IID_IMediaFilter, TRUE);
     check_interface(filter, &IID_IMediaPosition, TRUE);
@@ -235,12 +238,13 @@ static void test_common_interfaces(IBaseFilter *filter)
     check_interface(filter, &IID_IQualityControl, TRUE);
     todo_wine check_interface(filter, &IID_IQualProp, TRUE);
     check_interface(filter, &IID_IUnknown, TRUE);
+    check_interface(filter, &IID_IVideoWindow, TRUE);
     todo_wine check_interface(filter, &IID_IVMRAspectRatioControl, TRUE);
     todo_wine check_interface(filter, &IID_IVMRDeinterlaceControl, TRUE);
     check_interface(filter, &IID_IVMRFilterConfig, TRUE);
     todo_wine check_interface(filter, &IID_IVMRMixerBitmap, TRUE);
+    check_interface(filter, &IID_IVMRMonitorConfig, TRUE);
 
-    check_interface(filter, &IID_IAMVideoAccelerator, FALSE);
     check_interface(filter, &IID_IBasicAudio, FALSE);
     check_interface(filter, &IID_IDirectDrawVideo, FALSE);
     check_interface(filter, &IID_IPersistPropertyBag, FALSE);
@@ -250,14 +254,16 @@ static void test_common_interfaces(IBaseFilter *filter)
     check_interface(filter, &IID_IVMRDeinterlaceControl9, FALSE);
     check_interface(filter, &IID_IVMRFilterConfig9, FALSE);
     check_interface(filter, &IID_IVMRMixerBitmap9, FALSE);
+    check_interface(filter, &IID_IVMRMixerControl, FALSE);
     check_interface(filter, &IID_IVMRMixerControl9, FALSE);
     check_interface(filter, &IID_IVMRMonitorConfig9, FALSE);
+    check_interface(filter, &IID_IVMRSurfaceAllocatorNotify, FALSE);
     check_interface(filter, &IID_IVMRSurfaceAllocatorNotify9, FALSE);
+    check_interface(filter, &IID_IVMRWindowlessControl, FALSE);
     check_interface(filter, &IID_IVMRWindowlessControl9, FALSE);
 
     IBaseFilter_FindPin(filter, L"VMR Input0", &pin);
 
-    check_interface(pin, &IID_IAMVideoAccelerator, TRUE);
     check_interface(pin, &IID_IMemInputPin, TRUE);
     check_interface(pin, &IID_IOverlay, TRUE);
     check_interface(pin, &IID_IPin, TRUE);
@@ -269,27 +275,8 @@ static void test_common_interfaces(IBaseFilter *filter)
     check_interface(pin, &IID_IMediaSeeking, FALSE);
 
     IPin_Release(pin);
-}
-
-static void test_interfaces(void)
-{
-    IBaseFilter *filter = create_vmr7(0);
-    ULONG ref;
-
-    test_common_interfaces(filter);
-
-    check_interface(filter, &IID_IBasicVideo, TRUE);
-    todo_wine check_interface(filter, &IID_IBasicVideo2, TRUE);
-    check_interface(filter, &IID_IVideoWindow, TRUE);
-    check_interface(filter, &IID_IVMRMonitorConfig, TRUE);
-
-    check_interface(filter, &IID_IVMRMixerControl, FALSE);
-    check_interface(filter, &IID_IVMRSurfaceAllocatorNotify, FALSE);
-    check_interface(filter, &IID_IVMRWindowlessControl, FALSE);
-
-    ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
 
+    IBaseFilter_Release(filter);
     filter = create_vmr7(VMRMode_Windowless);
 
     check_interface(filter, &IID_IVMRMonitorConfig, TRUE);
@@ -298,12 +285,28 @@ static void test_interfaces(void)
     todo_wine check_interface(filter, &IID_IBasicVideo, FALSE);
     check_interface(filter, &IID_IBasicVideo2, FALSE);
     todo_wine check_interface(filter, &IID_IVideoWindow, FALSE);
-    check_interface(filter, &IID_IVMRMixerControl, FALSE);
     check_interface(filter, &IID_IVMRSurfaceAllocatorNotify, FALSE);
+    check_interface(filter, &IID_IVMRSurfaceAllocatorNotify9, FALSE);
+    check_interface(filter, &IID_IVMRMixerControl, FALSE);
+    check_interface(filter, &IID_IVMRMixerControl9, FALSE);
+    check_interface(filter, &IID_IVMRMonitorConfig9, FALSE);
+    check_interface(filter, &IID_IVMRWindowlessControl9, FALSE);
 
-    ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    IBaseFilter_FindPin(filter, L"VMR Input0", &pin);
 
+    check_interface(pin, &IID_IMemInputPin, TRUE);
+    check_interface(pin, &IID_IOverlay, TRUE);
+    check_interface(pin, &IID_IPin, TRUE);
+    todo_wine check_interface(pin, &IID_IQualityControl, TRUE);
+    check_interface(pin, &IID_IUnknown, TRUE);
+
+    check_interface(pin, &IID_IKsPropertySet, FALSE);
+    check_interface(pin, &IID_IMediaPosition, FALSE);
+    check_interface(pin, &IID_IMediaSeeking, FALSE);
+
+    IPin_Release(pin);
+
+    IBaseFilter_Release(filter);
     filter = create_vmr7(VMRMode_Renderless);
 
     check_interface(filter, &IID_IVMRSurfaceAllocatorNotify, TRUE);
@@ -313,10 +316,27 @@ static void test_interfaces(void)
     todo_wine check_interface(filter, &IID_IVideoWindow, FALSE);
     check_interface(filter, &IID_IVMRMixerControl, FALSE);
     todo_wine check_interface(filter, &IID_IVMRMonitorConfig, FALSE);
+    check_interface(filter, &IID_IVMRMonitorConfig9, FALSE);
+    check_interface(filter, &IID_IVMRSurfaceAllocatorNotify9, FALSE);
     check_interface(filter, &IID_IVMRWindowlessControl, FALSE);
+    check_interface(filter, &IID_IVMRWindowlessControl9, FALSE);
+
+    IBaseFilter_FindPin(filter, L"VMR Input0", &pin);
+
+    check_interface(pin, &IID_IMemInputPin, TRUE);
+    check_interface(pin, &IID_IOverlay, TRUE);
+    check_interface(pin, &IID_IPin, TRUE);
+    todo_wine check_interface(pin, &IID_IQualityControl, TRUE);
+    check_interface(pin, &IID_IUnknown, TRUE);
+
+    check_interface(pin, &IID_IKsPropertySet, FALSE);
+    check_interface(pin, &IID_IMediaPosition, FALSE);
+    check_interface(pin, &IID_IMediaSeeking, FALSE);
+
+    IPin_Release(pin);
 
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 static const GUID test_iid = {0x33333333};
@@ -364,53 +384,53 @@ static void test_aggregation(void)
     filter = (IBaseFilter *)0xdeadbeef;
     hr = CoCreateInstance(&CLSID_VideoMixingRenderer, &test_outer, CLSCTX_INPROC_SERVER,
             &IID_IBaseFilter, (void **)&filter);
-    ok(hr == E_NOINTERFACE, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOINTERFACE, "Got hr %#x.\n", hr);
     ok(!filter, "Got interface %p.\n", filter);
 
     hr = CoCreateInstance(&CLSID_VideoMixingRenderer, &test_outer, CLSCTX_INPROC_SERVER,
             &IID_IUnknown, (void **)&unk);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(outer_ref == 1, "Got unexpected refcount %ld.\n", outer_ref);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
     ok(unk != &test_outer, "Returned IUnknown should not be outer IUnknown.\n");
     ref = get_refcount(unk);
-    ok(ref == 1, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
 
     ref = IUnknown_AddRef(unk);
-    ok(ref == 2, "Got unexpected refcount %ld.\n", ref);
-    ok(outer_ref == 1, "Got unexpected refcount %ld.\n", outer_ref);
+    ok(ref == 2, "Got unexpected refcount %d.\n", ref);
+    ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
 
     ref = IUnknown_Release(unk);
-    ok(ref == 1, "Got unexpected refcount %ld.\n", ref);
-    ok(outer_ref == 1, "Got unexpected refcount %ld.\n", outer_ref);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
+    ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
 
     hr = IUnknown_QueryInterface(unk, &IID_IUnknown, (void **)&unk2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(unk2 == unk, "Got unexpected IUnknown %p.\n", unk2);
     IUnknown_Release(unk2);
 
     hr = IUnknown_QueryInterface(unk, &IID_IBaseFilter, (void **)&filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_QueryInterface(filter, &IID_IUnknown, (void **)&unk2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(unk2 == (IUnknown *)0xdeadbeef, "Got unexpected IUnknown %p.\n", unk2);
 
     hr = IBaseFilter_QueryInterface(filter, &IID_IBaseFilter, (void **)&filter2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(filter2 == (IBaseFilter *)0xdeadbeef, "Got unexpected IBaseFilter %p.\n", filter2);
 
     hr = IUnknown_QueryInterface(unk, &test_iid, (void **)&unk2);
-    ok(hr == E_NOINTERFACE, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOINTERFACE, "Got hr %#x.\n", hr);
     ok(!unk2, "Got unexpected IUnknown %p.\n", unk2);
 
     hr = IBaseFilter_QueryInterface(filter, &test_iid, (void **)&unk2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(unk2 == (IUnknown *)0xdeadbeef, "Got unexpected IUnknown %p.\n", unk2);
 
     IBaseFilter_Release(filter);
     ref = IUnknown_Release(unk);
-    ok(!ref, "Got unexpected refcount %ld.\n", ref);
-    ok(outer_ref == 1, "Got unexpected refcount %ld.\n", outer_ref);
+    ok(!ref, "Got unexpected refcount %d.\n", ref);
+    ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
 }
 
 static void test_enum_pins(void)
@@ -422,79 +442,79 @@ static void test_enum_pins(void)
     HRESULT hr;
 
     ref = get_refcount(filter);
-    ok(ref == 1, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
 
     hr = IBaseFilter_EnumPins(filter, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_EnumPins(filter, &enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ref = get_refcount(filter);
-    ok(ref == 2, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 2, "Got unexpected refcount %d.\n", ref);
     ref = get_refcount(enum1);
-    ok(ref == 1, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
 
     hr = IEnumPins_Next(enum1, 1, NULL, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum1, 1, pins, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ref = get_refcount(filter);
-    ok(ref == 3, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 3, "Got unexpected refcount %d.\n", ref);
     ref = get_refcount(pins[0]);
-    ok(ref == 3, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 3, "Got unexpected refcount %d.\n", ref);
     ref = get_refcount(enum1);
-    ok(ref == 1, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
     IPin_Release(pins[0]);
     ref = get_refcount(filter);
-    ok(ref == 2, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 2, "Got unexpected refcount %d.\n", ref);
 
     hr = IEnumPins_Next(enum1, 1, pins, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum1, 1, pins, &count);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(count == 1, "Got count %lu.\n", count);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(count == 1, "Got count %u.\n", count);
     IPin_Release(pins[0]);
 
     hr = IEnumPins_Next(enum1, 1, pins, &count);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
-    ok(!count, "Got count %lu.\n", count);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    ok(!count, "Got count %u.\n", count);
 
     hr = IEnumPins_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum1, 2, pins, NULL);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum1, 2, pins, &count);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
-    ok(count == 1, "Got count %lu.\n", count);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    ok(count == 1, "Got count %u.\n", count);
     IPin_Release(pins[0]);
 
     hr = IEnumPins_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Clone(enum1, &enum2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Skip(enum1, 2);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Skip(enum1, 1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Skip(enum1, 1);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum1, 1, pins, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum2, 1, pins, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     IPin_Release(pins[0]);
 
     IEnumPins_Release(enum2);
@@ -502,37 +522,37 @@ static void test_enum_pins(void)
     if (SUCCEEDED(set_mixing_mode(filter)))
     {
         hr = IEnumPins_Next(enum1, 1, pins, NULL);
-        todo_wine ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+        todo_wine ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
         hr = IEnumPins_Reset(enum1);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
 
         hr = IEnumPins_Next(enum1, 1, pins, NULL);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
         IPin_Release(pins[0]);
 
         hr = IEnumPins_Next(enum1, 1, pins, NULL);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
         IPin_Release(pins[0]);
 
         hr = IEnumPins_Next(enum1, 1, pins, NULL);
-        ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+        ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
         hr = IEnumPins_Reset(enum1);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
 
         hr = IEnumPins_Next(enum1, 2, pins, &count);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
-        ok(count == 2, "Got count %lu.\n", count);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
+        ok(count == 2, "Got count %u.\n", count);
         IPin_Release(pins[0]);
         IPin_Release(pins[1]);
 
         hr = IEnumPins_Reset(enum1);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
 
         hr = IEnumPins_Next(enum1, 3, pins, &count);
-        ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
-        ok(count == 2, "Got count %lu.\n", count);
+        ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+        ok(count == 2, "Got count %u.\n", count);
         IPin_Release(pins[0]);
         IPin_Release(pins[1]);
     }
@@ -541,7 +561,7 @@ static void test_enum_pins(void)
 
     IEnumPins_Release(enum1);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 static void test_find_pin(void)
@@ -555,51 +575,51 @@ static void test_find_pin(void)
     IBaseFilter_EnumPins(filter, &enum_pins);
 
     hr = IBaseFilter_FindPin(filter, L"input pin", &pin);
-    ok(hr == VFW_E_NOT_FOUND, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_FOUND, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_FindPin(filter, L"In", &pin);
-    ok(hr == VFW_E_NOT_FOUND, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_FOUND, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_FindPin(filter, L"VMR Input0", &pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IEnumPins_Next(enum_pins, 1, &pin2, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(pin == pin2, "Pins did not match.\n");
     IPin_Release(pin);
     IPin_Release(pin2);
 
     hr = IBaseFilter_FindPin(filter, L"VMR input1", &pin);
-    ok(hr == VFW_E_NOT_FOUND, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_FOUND, "Got hr %#x.\n", hr);
 
     if (SUCCEEDED(set_mixing_mode(filter)))
     {
         IEnumPins_Reset(enum_pins);
 
         hr = IBaseFilter_FindPin(filter, L"VMR Input0", &pin);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
         hr = IEnumPins_Next(enum_pins, 1, &pin2, NULL);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
         ok(pin == pin2, "Pins did not match.\n");
         IPin_Release(pin);
         IPin_Release(pin2);
 
         hr = IBaseFilter_FindPin(filter, L"VMR Input1", &pin);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
         hr = IEnumPins_Next(enum_pins, 1, &pin2, NULL);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
         ok(pin == pin2, "Pins did not match.\n");
         IPin_Release(pin);
         IPin_Release(pin2);
 
         hr = IBaseFilter_FindPin(filter, L"VMR Input2", &pin);
-        ok(hr == VFW_E_NOT_FOUND, "Got hr %#lx.\n", hr);
+        ok(hr == VFW_E_NOT_FOUND, "Got hr %#x.\n", hr);
     }
     else
         skip("Mixing mode is not supported.\n");
 
     IEnumPins_Release(enum_pins);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 static void test_pin_info(void)
@@ -620,16 +640,16 @@ static void test_pin_info(void)
     IBaseFilter_Release(info.pFilter);
 
     hr = IPin_QueryDirection(pin, &dir);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(dir == PINDIR_INPUT, "Got direction %d.\n", dir);
 
     hr = IPin_QueryId(pin, &id);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(!wcscmp(id, L"VMR Input0"), "Got id %s.\n", wine_dbgstr_w(id));
     CoTaskMemFree(id);
 
     hr = IPin_QueryInternalConnections(pin, NULL, &count);
-    ok(hr == E_NOTIMPL, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOTIMPL, "Got hr %#x.\n", hr);
 
     IPin_Release(pin);
 
@@ -643,16 +663,16 @@ static void test_pin_info(void)
         IBaseFilter_Release(info.pFilter);
 
         hr = IPin_QueryDirection(pin, &dir);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
         ok(dir == PINDIR_INPUT, "Got direction %d.\n", dir);
 
         hr = IPin_QueryId(pin, &id);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
         ok(!wcscmp(id, L"VMR Input1"), "Got id %s.\n", wine_dbgstr_w(id));
         CoTaskMemFree(id);
 
         hr = IPin_QueryInternalConnections(pin, NULL, &count);
-        ok(hr == E_NOTIMPL, "Got hr %#lx.\n", hr);
+        ok(hr == E_NOTIMPL, "Got hr %#x.\n", hr);
 
         IPin_Release(pin);
     }
@@ -660,7 +680,7 @@ static void test_pin_info(void)
         skip("Mixing mode is not supported.\n");
 
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 static void test_media_types(void)
@@ -689,10 +709,10 @@ static void test_media_types(void)
     IBaseFilter_FindPin(filter, L"VMR Input0", &pin);
 
     hr = IPin_EnumMediaTypes(pin, &enummt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enummt, 1, &mt, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     IEnumMediaTypes_Release(enummt);
 
@@ -705,30 +725,30 @@ static void test_media_types(void)
     {
         req_mt.subtype = *subtype_tests[i];
         hr = IPin_QueryAccept(pin, &req_mt);
-        ok(hr == S_OK, "Got hr %#lx for subtype %s.\n", hr, wine_dbgstr_guid(subtype_tests[i]));
+        ok(hr == S_OK, "Got hr %#x for subtype %s.\n", hr, wine_dbgstr_guid(subtype_tests[i]));
     }
 
     req_mt.subtype = MEDIASUBTYPE_RGB8;
     hr = IPin_QueryAccept(pin, &req_mt);
-    todo_wine ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     req_mt.subtype = MEDIASUBTYPE_RGB24;
 
     req_mt.majortype = MEDIATYPE_NULL;
     hr = IPin_QueryAccept(pin, &req_mt);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     req_mt.majortype = MEDIATYPE_Video;
 
     req_mt.formattype = FORMAT_None;
     hr = IPin_QueryAccept(pin, &req_mt);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     req_mt.formattype = GUID_NULL;
     hr = IPin_QueryAccept(pin, &req_mt);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     IPin_Release(pin);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 static void test_enum_media_types(void)
@@ -743,36 +763,36 @@ static void test_enum_media_types(void)
     IBaseFilter_FindPin(filter, L"VMR Input0", &pin);
 
     hr = IPin_EnumMediaTypes(pin, &enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enum1, 1, mts, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enum1, 1, mts, &count);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
-    ok(!count, "Got count %lu.\n", count);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    ok(!count, "Got count %u.\n", count);
 
     hr = IEnumMediaTypes_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enum1, 1, mts, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Clone(enum1, &enum2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Skip(enum1, 1);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enum2, 1, mts, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     IEnumMediaTypes_Release(enum1);
     IEnumMediaTypes_Release(enum2);
     IPin_Release(pin);
 
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 static void test_unconnected_filter_state(void)
@@ -783,53 +803,53 @@ static void test_unconnected_filter_state(void)
     ULONG ref;
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(state == State_Stopped, "Got state %u.\n", state);
 
     hr = IBaseFilter_Pause(filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(state == State_Paused, "Got state %u.\n", state);
 
     hr = IBaseFilter_Run(filter, 0);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(state == State_Running, "Got state %u.\n", state);
 
     hr = IBaseFilter_Pause(filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(state == State_Paused, "Got state %u.\n", state);
 
     hr = IBaseFilter_Stop(filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(state == State_Stopped, "Got state %u.\n", state);
 
     hr = IBaseFilter_Run(filter, 0);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(state == State_Running, "Got state %u.\n", state);
 
     hr = IBaseFilter_Stop(filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(state == State_Stopped, "Got state %u.\n", state);
 
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 struct testfilter
@@ -890,45 +910,45 @@ static void test_allocator(IMemInputPin *input)
     HRESULT hr;
 
     hr = IMemInputPin_GetAllocatorRequirements(input, &props);
-    ok(hr == E_NOTIMPL, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOTIMPL, "Got hr %#x.\n", hr);
 
     hr = IMemInputPin_GetAllocator(input, &ret_allocator);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     if (hr == S_OK)
     {
         hr = IMemAllocator_GetProperties(ret_allocator, &props);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
-        ok(!props.cBuffers, "Got %ld buffers.\n", props.cBuffers);
-        ok(!props.cbBuffer, "Got size %ld.\n", props.cbBuffer);
-        ok(!props.cbAlign, "Got alignment %ld.\n", props.cbAlign);
-        ok(!props.cbPrefix, "Got prefix %ld.\n", props.cbPrefix);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
+        ok(!props.cBuffers, "Got %d buffers.\n", props.cBuffers);
+        ok(!props.cbBuffer, "Got size %d.\n", props.cbBuffer);
+        ok(!props.cbAlign, "Got alignment %d.\n", props.cbAlign);
+        ok(!props.cbPrefix, "Got prefix %d.\n", props.cbPrefix);
 
         hr = IMemInputPin_NotifyAllocator(input, ret_allocator, TRUE);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
 
         req_props.cBuffers = 1;
         req_props.cbBuffer = 32 * 16 * 4;
         req_props.cbAlign = 1;
         req_props.cbPrefix = 0;
         hr = IMemAllocator_SetProperties(ret_allocator, &req_props, &props);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
-        ok(props.cBuffers == 1, "Got %ld buffers.\n", props.cBuffers);
-        ok(props.cbBuffer == 32 * 16 * 4, "Got size %ld.\n", props.cbBuffer);
-        ok(props.cbAlign == 1, "Got alignment %ld.\n", props.cbAlign);
-        ok(!props.cbPrefix, "Got prefix %ld.\n", props.cbPrefix);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
+        ok(props.cBuffers == 1, "Got %d buffers.\n", props.cBuffers);
+        ok(props.cbBuffer == 32 * 16 * 4, "Got size %d.\n", props.cbBuffer);
+        ok(props.cbAlign == 1, "Got alignment %d.\n", props.cbAlign);
+        ok(!props.cbPrefix, "Got prefix %d.\n", props.cbPrefix);
 
         IMemAllocator_Release(ret_allocator);
     }
 
     hr = IMemInputPin_NotifyAllocator(input, NULL, TRUE);
-    todo_wine ok(hr == E_FAIL, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == E_FAIL, "Got hr %#x.\n", hr);
 
     CoCreateInstance(&CLSID_MemoryAllocator, NULL, CLSCTX_INPROC_SERVER,
             &IID_IMemAllocator, (void **)&req_allocator);
 
     hr = IMemInputPin_NotifyAllocator(input, req_allocator, TRUE);
-    todo_wine ok(hr == E_FAIL, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == E_FAIL, "Got hr %#x.\n", hr);
 
     IMemAllocator_Release(req_allocator);
 }
@@ -944,9 +964,9 @@ static DWORD WINAPI frame_thread(void *arg)
     struct frame_thread_params *params = arg;
     HRESULT hr;
 
-    if (winetest_debug > 1) trace("%04lx: Sending frame.\n", GetCurrentThreadId());
+    if (winetest_debug > 1) trace("%04x: Sending frame.\n", GetCurrentThreadId());
     hr = IMemInputPin_Receive(params->sink, params->sample);
-    if (winetest_debug > 1) trace("%04lx: Returned %#lx.\n", GetCurrentThreadId(), hr);
+    if (winetest_debug > 1) trace("%04x: Returned %#x.\n", GetCurrentThreadId(), hr);
     IMediaSample_Release(params->sample);
     free(params);
     return hr;
@@ -963,25 +983,25 @@ static HANDLE send_frame(IMemInputPin *sink)
     BYTE *data;
 
     hr = IMemInputPin_GetAllocator(sink, &allocator);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMemAllocator_GetBuffer(allocator, &sample, NULL, NULL, 0);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaSample_GetPointer(sample, &data);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     memset(data, 0x55, IMediaSample_GetSize(sample));
 
     hr = IMediaSample_SetActualDataLength(sample, IMediaSample_GetSize(sample));
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     start_time = 0;
     end_time = start_time + 10000000;
     hr = IMediaSample_SetTime(sample, &start_time, &end_time);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaSample_SetPreroll(sample, TRUE);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     params->sink = sink;
     params->sample = sample;
@@ -1007,9 +1027,9 @@ static void commit_allocator(IMemInputPin *input)
     HRESULT hr;
 
     hr = IMemInputPin_GetAllocator(input, &allocator);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMemAllocator_Commit(allocator);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     IMemAllocator_Release(allocator);
 }
 
@@ -1023,130 +1043,130 @@ static void test_filter_state(IMemInputPin *input, IMediaControl *control)
 
     thread = send_frame(input);
     hr = join_thread(thread);
-    ok(hr == VFW_E_WRONG_STATE, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_WRONG_STATE, "Got hr %#x.\n", hr);
 
     /* The renderer is not fully paused until it receives a sample. The thread
      * sending the sample blocks in IMemInputPin_Receive() until the filter is
      * stopped or run. */
 
     hr = IMediaControl_Pause(control);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_GetState(control, 0, &state);
-    ok(hr == VFW_S_STATE_INTERMEDIATE, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_S_STATE_INTERMEDIATE, "Got hr %#x.\n", hr);
 
     thread = send_frame(input);
 
     hr = IMediaControl_GetState(control, 1000, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     ok(WaitForSingleObject(thread, 100) == WAIT_TIMEOUT, "Thread should block in Receive().\n");
 
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = join_thread(thread);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     /* The sink will decommit our allocator for us when stopping, however it
      * will not recommit it when pausing. */
     hr = IMemInputPin_GetAllocator(input, &allocator);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMemAllocator_GetBuffer(allocator, &sample, NULL, NULL, 0);
-    todo_wine ok(hr == VFW_E_NOT_COMMITTED, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == VFW_E_NOT_COMMITTED, "Got hr %#x.\n", hr);
     if (hr == S_OK) IMediaSample_Release(sample);
 
     hr = IMemAllocator_Commit(allocator);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     thread = send_frame(input);
     hr = join_thread(thread);
-    ok(hr == VFW_E_WRONG_STATE, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_WRONG_STATE, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_Pause(control);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_GetState(control, 0, &state);
-    ok(hr == VFW_S_STATE_INTERMEDIATE, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_S_STATE_INTERMEDIATE, "Got hr %#x.\n", hr);
 
     thread = send_frame(input);
 
     hr = IMediaControl_GetState(control, 1000, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     ok(WaitForSingleObject(thread, 100) == WAIT_TIMEOUT, "Thread should block in Receive().\n");
 
     hr = IMediaControl_Run(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_GetState(control, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = join_thread(thread);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     thread = send_frame(input);
     hr = join_thread(thread);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_Pause(control);
-    todo_wine ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_GetState(control, 0, &state);
-    todo_wine ok(hr == VFW_S_STATE_INTERMEDIATE, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == VFW_S_STATE_INTERMEDIATE, "Got hr %#x.\n", hr);
 
     thread = send_frame(input);
 
     hr = IMediaControl_GetState(control, 1000, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     ok(WaitForSingleObject(thread, 100) == WAIT_TIMEOUT, "Thread should block in Receive().\n");
 
     hr = IMediaControl_Run(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_GetState(control, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = join_thread(thread);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_Pause(control);
-    todo_wine ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_GetState(control, 0, &state);
-    todo_wine ok(hr == VFW_S_STATE_INTERMEDIATE, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == VFW_S_STATE_INTERMEDIATE, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_GetState(control, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     commit_allocator(input);
     hr = IMediaControl_Pause(control);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_GetState(control, 0, &state);
-    ok(hr == VFW_S_STATE_INTERMEDIATE, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_S_STATE_INTERMEDIATE, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_Run(control);
-    todo_wine ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_GetState(control, 0, &state);
-    todo_wine ok(hr == VFW_S_STATE_INTERMEDIATE, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == VFW_S_STATE_INTERMEDIATE, "Got hr %#x.\n", hr);
 
     thread = send_frame(input);
     hr = join_thread(thread);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_GetState(control, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_GetState(control, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     IMemAllocator_Release(allocator);
 }
@@ -1159,61 +1179,61 @@ static void test_flushing(IPin *pin, IMemInputPin *input, IMediaControl *control
 
     commit_allocator(input);
     hr = IMediaControl_Pause(control);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     thread = send_frame(input);
     ok(WaitForSingleObject(thread, 100) == WAIT_TIMEOUT, "Thread should block in Receive().\n");
 
     hr = IMediaControl_GetState(control, 1000, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IPin_BeginFlush(pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = join_thread(thread);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     thread = send_frame(input);
     hr = join_thread(thread);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IPin_EndFlush(pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     /* We dropped the sample we were holding, so now we need a new one... */
 
     hr = IMediaControl_GetState(control, 0, &state);
-    todo_wine ok(hr == VFW_S_STATE_INTERMEDIATE, "Got hr %#lx.\n", hr);
-    ok(state == State_Paused, "Got state %#lx.\n", state);
+    todo_wine ok(hr == VFW_S_STATE_INTERMEDIATE, "Got hr %#x.\n", hr);
+    ok(state == State_Paused, "Got state %#x.\n", state);
 
     thread = send_frame(input);
     ok(WaitForSingleObject(thread, 100) == WAIT_TIMEOUT, "Thread should block in Receive().\n");
 
     hr = IMediaControl_GetState(control, 1000, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(state == State_Paused, "Got state %#lx.\n", state);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(state == State_Paused, "Got state %#x.\n", state);
 
     hr = IMediaControl_Run(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = join_thread(thread);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IPin_BeginFlush(pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     thread = send_frame(input);
     hr = join_thread(thread);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IPin_EndFlush(pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     thread = send_frame(input);
     hr = join_thread(thread);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 }
 
 static unsigned int check_event_code(IMediaEvent *eventsrc, DWORD timeout, LONG expected_code, LONG_PTR expected1, LONG_PTR expected2)
@@ -1227,14 +1247,14 @@ static unsigned int check_event_code(IMediaEvent *eventsrc, DWORD timeout, LONG
     {
         if (code == expected_code)
         {
-            ok(param1 == expected1, "Got param1 %#Ix.\n", param1);
-            ok(param2 == expected2, "Got param2 %#Ix.\n", param2);
+            ok(param1 == expected1, "Got param1 %#lx.\n", param1);
+            ok(param2 == expected2, "Got param2 %#lx.\n", param2);
             ret++;
         }
         IMediaEvent_FreeEventParams(eventsrc, code, param1, param2);
         timeout = 0;
     }
-    ok(hr == E_ABORT, "Got hr %#lx.\n", hr);
+    ok(hr == E_ABORT, "Got hr %#x.\n", hr);
 
     return ret;
 }
@@ -1266,68 +1286,68 @@ static void test_current_image(IBaseFilter *filter, IMemInputPin *input,
     IBaseFilter_QueryInterface(filter, &IID_IBasicVideo, (void **)&video);
 
     hr = IBasicVideo_GetCurrentImage(video, NULL, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_GetCurrentImage(video, NULL, buffer);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
 
     size = 0xdeadbeef;
     hr = IBasicVideo_GetCurrentImage(video, &size, NULL);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    todo_wine ok(size == sizeof(BITMAPINFOHEADER) + 32 * 16 * 4, "Got size %ld.\n", size);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
+    todo_wine ok(size == sizeof(BITMAPINFOHEADER) + 32 * 16 * 4, "Got size %d.\n", size);
 
     size = sizeof(buffer);
     hr = IBasicVideo_GetCurrentImage(video, &size, buffer);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(size == sizeof(buffer), "Got size %ld.\n", size);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(size == sizeof(buffer), "Got size %d.\n", size);
     ok(!memcmp(bih, &expect_bih, sizeof(BITMAPINFOHEADER)), "Bitmap headers didn't match.\n");
     /* The contents seem to reflect the last frame rendered. */
 
     commit_allocator(input);
     hr = IMediaControl_Pause(control);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     size = sizeof(buffer);
     hr = IBasicVideo_GetCurrentImage(video, &size, buffer);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(size == sizeof(buffer), "Got size %ld.\n", size);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(size == sizeof(buffer), "Got size %d.\n", size);
     ok(!memcmp(bih, &expect_bih, sizeof(BITMAPINFOHEADER)), "Bitmap headers didn't match.\n");
     /* The contents seem to reflect the last frame rendered. */
 
     thread = send_frame(input);
     hr = IMediaControl_GetState(control, 1000, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     size = 1;
     memset(buffer, 0xcc, sizeof(buffer));
     hr = IBasicVideo_GetCurrentImage(video, &size, buffer);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(size == 1, "Got size %ld.\n", size);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(size == 1, "Got size %d.\n", size);
 
     size = sizeof(buffer);
     memset(buffer, 0xcc, sizeof(buffer));
     hr = IBasicVideo_GetCurrentImage(video, &size, buffer);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(size == sizeof(buffer), "Got size %ld.\n", size);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(size == sizeof(buffer), "Got size %d.\n", size);
     ok(!memcmp(bih, &expect_bih, sizeof(BITMAPINFOHEADER)), "Bitmap headers didn't match.\n");
     for (i = 0; i < 32 * 16; ++i)
-        ok((data[i] & 0xffffff) == 0x555555, "Got unexpected color %08lx at %u.\n", data[i], i);
+        ok((data[i] & 0xffffff) == 0x555555, "Got unexpected color %08x at %u.\n", data[i], i);
 
     hr = IMediaControl_Run(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     join_thread(thread);
 
     size = sizeof(buffer);
     memset(buffer, 0xcc, sizeof(buffer));
     hr = IBasicVideo_GetCurrentImage(video, &size, buffer);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(size == sizeof(buffer), "Got size %ld.\n", size);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(size == sizeof(buffer), "Got size %d.\n", size);
     ok(!memcmp(bih, &expect_bih, sizeof(BITMAPINFOHEADER)), "Bitmap headers didn't match.\n");
     for (i = 0; i < 32 * 16; ++i)
-        ok((data[i] & 0xffffff) == 0x555555, "Got unexpected color %08lx at %u.\n", data[i], i);
+        ok((data[i] & 0xffffff) == 0x555555, "Got unexpected color %08x at %u.\n", data[i], i);
 
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     IBasicVideo_Release(video);
 }
@@ -1343,14 +1363,14 @@ static unsigned int check_ec_userabort(IMediaEvent *eventsrc, DWORD timeout)
     {
         if (code == EC_USERABORT)
         {
-            ok(!param1, "Got param1 %#Ix.\n", param1);
-            ok(!param2, "Got param2 %#Ix.\n", param2);
+            ok(!param1, "Got param1 %#lx.\n", param1);
+            ok(!param2, "Got param2 %#lx.\n", param2);
             ret++;
         }
         IMediaEvent_FreeEventParams(eventsrc, code, param1, param2);
         timeout = 0;
     }
-    ok(hr == E_ABORT, "Got hr %#lx.\n", hr);
+    ok(hr == E_ABORT, "Got hr %#x.\n", hr);
 
     return ret;
 }
@@ -1369,19 +1389,19 @@ static void test_window_close(IPin *pin, IMemInputPin *input, IMediaControl *con
     IPin_QueryInterface(pin, &IID_IOverlay, (void **)&overlay);
 
     hr = IOverlay_GetWindowHandle(overlay, &hwnd);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     IOverlay_Release(overlay);
 
     commit_allocator(input);
     hr = IMediaControl_Pause(control);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     ret = check_ec_userabort(eventsrc, 0);
     ok(!ret, "Got unexpected EC_USERABORT.\n");
 
     SendMessageW(hwnd, WM_CLOSE, 0, 0);
 
     hr = IMediaControl_GetState(control, 1000, &state);
-    ok(hr == VFW_S_STATE_INTERMEDIATE, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_S_STATE_INTERMEDIATE, "Got hr %#x.\n", hr);
     ret = check_ec_userabort(eventsrc, 0);
     ok(ret == 1, "Expected EC_USERABORT.\n");
 
@@ -1394,17 +1414,17 @@ static void test_window_close(IPin *pin, IMemInputPin *input, IMediaControl *con
     if (ret == WAIT_OBJECT_0)
     {
         GetExitCodeThread(thread, (DWORD *)&hr);
-        ok(hr == E_UNEXPECTED, "Got hr %#lx.\n", hr);
+        ok(hr == E_UNEXPECTED, "Got hr %#x.\n", hr);
     }
     CloseHandle(thread);
 
     hr = IMediaControl_Run(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ret = check_ec_userabort(eventsrc, 0);
     ok(!ret, "Got unexpected EC_USERABORT.\n");
 
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ret = check_ec_userabort(eventsrc, 0);
     ok(!ret, "Got unexpected EC_USERABORT.\n");
 
@@ -1412,11 +1432,11 @@ static void test_window_close(IPin *pin, IMemInputPin *input, IMediaControl *con
 
     commit_allocator(input);
     hr = IMediaControl_Run(control);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     hr = join_thread(send_frame(input));
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMediaControl_GetState(control, 1000, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ret = check_ec_userabort(eventsrc, 0);
     ok(!ret, "Got unexpected EC_USERABORT.\n");
 
@@ -1429,7 +1449,7 @@ static void test_window_close(IPin *pin, IMemInputPin *input, IMediaControl *con
     ok(!IsWindowVisible(hwnd), "Window should be visible.\n");
 
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ret = check_ec_userabort(eventsrc, 0);
     ok(!ret, "Got unexpected EC_USERABORT.\n");
 
@@ -1485,7 +1505,7 @@ static void test_connect_pin(void)
 
     vih.bmiHeader.biBitCount = 16;
     hr = IFilterGraph2_ConnectDirect(graph, &source.source.pin.IPin_iface, pin, &req_mt);
-    ok(hr == VFW_E_TYPE_NOT_ACCEPTED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_TYPE_NOT_ACCEPTED, "Got hr %#x.\n", hr);
 
     vih.bmiHeader.biBitCount = 32;
     hr = IFilterGraph2_ConnectDirect(graph, &source.source.pin.IPin_iface, pin, &req_mt);
@@ -1498,32 +1518,32 @@ static void test_connect_pin(void)
          * the actual samples only have a size of 32 * 16 * 3. */
         req_props.cbBuffer = 32 * 16 * 3;
     }
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IFilterGraph2_Disconnect(graph, &source.source.pin.IPin_iface);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IFilterGraph2_Disconnect(graph, pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     for (i = 0; i < ARRAY_SIZE(subtype_tests); ++i)
     {
         req_mt.subtype = *subtype_tests[i];
         hr = IFilterGraph2_ConnectDirect(graph, &source.source.pin.IPin_iface, pin, &req_mt);
-        ok(hr == S_OK, "Got hr %#lx for subtype %s.\n", hr, wine_dbgstr_guid(subtype_tests[i]));
+        ok(hr == S_OK, "Got hr %#x for subtype %s.\n", hr, wine_dbgstr_guid(subtype_tests[i]));
 
         hr = IFilterGraph2_Disconnect(graph, &source.source.pin.IPin_iface);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
         hr = IFilterGraph2_Disconnect(graph, pin);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
     }
 
     req_mt.formattype = FORMAT_None;
     hr = IFilterGraph2_ConnectDirect(graph, &source.source.pin.IPin_iface, pin, &req_mt);
-    ok(hr == VFW_E_TYPE_NOT_ACCEPTED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_TYPE_NOT_ACCEPTED, "Got hr %#x.\n", hr);
     req_mt.formattype = FORMAT_VideoInfo;
 
     req_mt.subtype = MEDIASUBTYPE_RGB8;
     hr = IFilterGraph2_ConnectDirect(graph, &source.source.pin.IPin_iface, pin, &req_mt);
-    todo_wine ok(hr == VFW_E_TYPE_NOT_ACCEPTED, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == VFW_E_TYPE_NOT_ACCEPTED, "Got hr %#x.\n", hr);
     if (hr == S_OK)
     {
         IFilterGraph2_Disconnect(graph, &source.source.pin.IPin_iface);
@@ -1533,29 +1553,29 @@ static void test_connect_pin(void)
 
     peer = (IPin *)0xdeadbeef;
     hr = IPin_ConnectedTo(pin, &peer);
-    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#x.\n", hr);
     ok(!peer, "Got peer %p.\n", peer);
 
     hr = IPin_ConnectionMediaType(pin, &mt);
-    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_Pause(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IFilterGraph2_ConnectDirect(graph, &source.source.pin.IPin_iface, pin, &req_mt);
-    ok(hr == VFW_E_NOT_STOPPED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_STOPPED, "Got hr %#x.\n", hr);
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IFilterGraph2_ConnectDirect(graph, &source.source.pin.IPin_iface, pin, &req_mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IPin_ConnectedTo(pin, &peer);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(peer == &source.source.pin.IPin_iface, "Got peer %p.\n", peer);
     IPin_Release(peer);
 
     hr = IPin_ConnectionMediaType(pin, &mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(compare_media_types(&mt, &req_mt), "Media types didn't match.\n");
 
     /* Disconnecting while not stopped is broken: it returns S_OK, but
@@ -1566,16 +1586,16 @@ static void test_connect_pin(void)
     test_allocator(input);
 
     hr = IMemInputPin_GetAllocator(input, &allocator);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMemAllocator_SetProperties(allocator, &req_props, &ret_props);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(!memcmp(&ret_props, &req_props, sizeof(req_props)), "Properties did not match.\n");
     hr = IMemAllocator_Commit(allocator);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     IMemAllocator_Release(allocator);
 
     hr = IMemInputPin_ReceiveCanBlock(input);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     test_filter_state(input, control);
     test_flushing(pin, input, control);
@@ -1583,29 +1603,29 @@ static void test_connect_pin(void)
     test_window_close(pin, input, control);
 
     hr = IFilterGraph2_Disconnect(graph, pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IFilterGraph2_Disconnect(graph, pin);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     ok(source.source.pin.peer == pin, "Got peer %p.\n", peer);
     IFilterGraph2_Disconnect(graph, &source.source.pin.IPin_iface);
 
     peer = (IPin *)0xdeadbeef;
     hr = IPin_ConnectedTo(pin, &peer);
-    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#x.\n", hr);
     ok(!peer, "Got peer %p.\n", peer);
 
     hr = IPin_ConnectionMediaType(pin, &mt);
-    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#x.\n", hr);
 
     IMemInputPin_Release(input);
     IPin_Release(pin);
     IMediaControl_Release(control);
     ref = IFilterGraph2_Release(graph);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ref = IBaseFilter_Release(&source.filter.IBaseFilter_iface);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 static void test_overlay(void)
@@ -1620,17 +1640,17 @@ static void test_overlay(void)
     IBaseFilter_FindPin(filter, L"VMR Input0", &pin);
 
     hr = IPin_QueryInterface(pin, &IID_IOverlay, (void **)&overlay);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hwnd = (HWND)0xdeadbeef;
     hr = IOverlay_GetWindowHandle(overlay, &hwnd);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(hwnd && hwnd != (HWND)0xdeadbeef, "Got invalid window %p.\n", hwnd);
 
     IOverlay_Release(overlay);
     IPin_Release(pin);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 /* try to make sure pending X events have been processed before continuing */
@@ -1654,7 +1674,7 @@ static void flush_events(void)
 static LRESULT CALLBACK window_proc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam)
 {
     if (winetest_debug > 1)
-        trace("hwnd %p, msg %#x, wparam %#Ix, lparam %#Ix.\n", hwnd, msg, wparam, lparam);
+        trace("hwnd %p, msg %#x, wparam %#lx, lparam %#lx.\n", hwnd, msg, wparam, lparam);
 
     if (wparam == 0xdeadbeef)
         return 0;
@@ -1669,7 +1689,7 @@ static void test_video_window_caption(IVideoWindow *window, HWND hwnd)
     HRESULT hr;
 
     hr = IVideoWindow_get_Caption(window, &caption);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(!wcscmp(caption, L"ActiveMovie Window"), "Got caption %s.\n", wine_dbgstr_w(caption));
     SysFreeString(caption);
 
@@ -1678,11 +1698,11 @@ static void test_video_window_caption(IVideoWindow *window, HWND hwnd)
 
     caption = SysAllocString(L"foo");
     hr = IVideoWindow_put_Caption(window, caption);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     SysFreeString(caption);
 
     hr = IVideoWindow_get_Caption(window, &caption);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(!wcscmp(caption, L"foo"), "Got caption %s.\n", wine_dbgstr_w(caption));
     SysFreeString(caption);
 
@@ -1696,53 +1716,53 @@ static void test_video_window_style(IVideoWindow *window, HWND hwnd, HWND our_hw
     LONG style;
 
     hr = IVideoWindow_get_WindowStyle(window, &style);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(style == (WS_CLIPSIBLINGS | WS_CLIPCHILDREN | WS_OVERLAPPEDWINDOW),
-            "Got style %#lx.\n", style);
+            "Got style %#x.\n", style);
 
     style = GetWindowLongA(hwnd, GWL_STYLE);
     ok(style == (WS_CLIPSIBLINGS | WS_CLIPCHILDREN | WS_OVERLAPPEDWINDOW),
-            "Got style %#lx.\n", style);
+            "Got style %#x.\n", style);
 
     hr = IVideoWindow_put_WindowStyle(window, style | WS_DISABLED);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
     hr = IVideoWindow_put_WindowStyle(window, style | WS_HSCROLL);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
     hr = IVideoWindow_put_WindowStyle(window, style | WS_VSCROLL);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
     hr = IVideoWindow_put_WindowStyle(window, style | WS_MAXIMIZE);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
     hr = IVideoWindow_put_WindowStyle(window, style | WS_MINIMIZE);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_put_WindowStyle(window, style & ~WS_CLIPCHILDREN);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_get_WindowStyle(window, &style);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(style == (WS_CLIPSIBLINGS | WS_OVERLAPPEDWINDOW), "Got style %#lx.\n", style);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(style == (WS_CLIPSIBLINGS | WS_OVERLAPPEDWINDOW), "Got style %#x.\n", style);
 
     style = GetWindowLongA(hwnd, GWL_STYLE);
-    ok(style == (WS_CLIPSIBLINGS | WS_OVERLAPPEDWINDOW), "Got style %#lx.\n", style);
+    ok(style == (WS_CLIPSIBLINGS | WS_OVERLAPPEDWINDOW), "Got style %#x.\n", style);
 
     ok(GetActiveWindow() == our_hwnd, "Got active window %p.\n", GetActiveWindow());
 
     hr = IVideoWindow_get_WindowStyleEx(window, &style);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(style == WS_EX_WINDOWEDGE, "Got style %#lx.\n", style);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(style == WS_EX_WINDOWEDGE, "Got style %#x.\n", style);
 
     style = GetWindowLongA(hwnd, GWL_EXSTYLE);
-    ok(style == WS_EX_WINDOWEDGE, "Got style %#lx.\n", style);
+    ok(style == WS_EX_WINDOWEDGE, "Got style %#x.\n", style);
 
     hr = IVideoWindow_put_WindowStyleEx(window, style | WS_EX_TRANSPARENT);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_get_WindowStyleEx(window, &style);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(style == (WS_EX_WINDOWEDGE | WS_EX_TRANSPARENT), "Got style %#lx.\n", style);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(style == (WS_EX_WINDOWEDGE | WS_EX_TRANSPARENT), "Got style %#x.\n", style);
 
     style = GetWindowLongA(hwnd, GWL_EXSTYLE);
-    ok(style == (WS_EX_WINDOWEDGE | WS_EX_TRANSPARENT), "Got style %#lx.\n", style);
+    ok(style == (WS_EX_WINDOWEDGE | WS_EX_TRANSPARENT), "Got style %#x.\n", style);
 }
 
 static BOOL CALLBACK top_window_cb(HWND hwnd, LPARAM ctx)
@@ -1773,25 +1793,25 @@ static void test_video_window_state(IVideoWindow *window, HWND hwnd, HWND our_hw
     SetWindowPos(our_hwnd, HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);
 
     hr = IVideoWindow_get_WindowState(window, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(state == SW_HIDE, "Got state %ld.\n", state);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(state == SW_HIDE, "Got state %d.\n", state);
 
     hr = IVideoWindow_get_Visible(window, &state);
-    ok(state == OAFALSE, "Got state %ld.\n", state);
+    ok(state == OAFALSE, "Got state %d.\n", state);
 
     ok(!IsWindowVisible(hwnd), "Window should not be visible.\n");
     ok(!IsIconic(hwnd), "Window should not be minimized.\n");
     ok(!IsZoomed(hwnd), "Window should not be maximized.\n");
 
     hr = IVideoWindow_put_WindowState(window, SW_SHOWNA);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_get_WindowState(window, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(state == SW_SHOW, "Got state %ld.\n", state);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(state == SW_SHOW, "Got state %d.\n", state);
 
     hr = IVideoWindow_get_Visible(window, &state);
-    ok(state == OATRUE, "Got state %ld.\n", state);
+    ok(state == OATRUE, "Got state %d.\n", state);
 
     ok(IsWindowVisible(hwnd), "Window should be visible.\n");
     ok(!IsIconic(hwnd), "Window should not be minimized.\n");
@@ -1801,14 +1821,14 @@ static void test_video_window_state(IVideoWindow *window, HWND hwnd, HWND our_hw
     ok(top == hwnd, "Got top window %p.\n", top);
 
     hr = IVideoWindow_put_WindowState(window, SW_MINIMIZE);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_get_WindowState(window, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(state == SW_MINIMIZE, "Got state %ld.\n", state);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(state == SW_MINIMIZE, "Got state %d.\n", state);
 
     hr = IVideoWindow_get_Visible(window, &state);
-    ok(state == OATRUE, "Got state %ld.\n", state);
+    ok(state == OATRUE, "Got state %d.\n", state);
 
     ok(IsWindowVisible(hwnd), "Window should be visible.\n");
     ok(IsIconic(hwnd), "Window should be minimized.\n");
@@ -1816,14 +1836,14 @@ static void test_video_window_state(IVideoWindow *window, HWND hwnd, HWND our_hw
     ok(GetActiveWindow() == our_hwnd, "Got active window %p.\n", GetActiveWindow());
 
     hr = IVideoWindow_put_WindowState(window, SW_RESTORE);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_get_WindowState(window, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(state == SW_SHOW, "Got state %ld.\n", state);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(state == SW_SHOW, "Got state %d.\n", state);
 
     hr = IVideoWindow_get_Visible(window, &state);
-    ok(state == OATRUE, "Got state %ld.\n", state);
+    ok(state == OATRUE, "Got state %d.\n", state);
 
     ok(IsWindowVisible(hwnd), "Window should be visible.\n");
     ok(!IsIconic(hwnd), "Window should not be minimized.\n");
@@ -1831,14 +1851,14 @@ static void test_video_window_state(IVideoWindow *window, HWND hwnd, HWND our_hw
     ok(GetActiveWindow() == hwnd, "Got active window %p.\n", GetActiveWindow());
 
     hr = IVideoWindow_put_WindowState(window, SW_MAXIMIZE);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_get_WindowState(window, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(state == SW_MAXIMIZE, "Got state %ld.\n", state);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(state == SW_MAXIMIZE, "Got state %d.\n", state);
 
     hr = IVideoWindow_get_Visible(window, &state);
-    ok(state == OATRUE, "Got state %ld.\n", state);
+    ok(state == OATRUE, "Got state %d.\n", state);
 
     ok(IsWindowVisible(hwnd), "Window should be visible.\n");
     ok(!IsIconic(hwnd), "Window should be minimized.\n");
@@ -1846,17 +1866,17 @@ static void test_video_window_state(IVideoWindow *window, HWND hwnd, HWND our_hw
     ok(GetActiveWindow() == hwnd, "Got active window %p.\n", GetActiveWindow());
 
     hr = IVideoWindow_put_WindowState(window, SW_RESTORE);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_put_WindowState(window, SW_HIDE);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_get_WindowState(window, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(state == SW_HIDE, "Got state %ld.\n", state);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(state == SW_HIDE, "Got state %d.\n", state);
 
     hr = IVideoWindow_get_Visible(window, &state);
-    ok(state == OAFALSE, "Got state %ld.\n", state);
+    ok(state == OAFALSE, "Got state %d.\n", state);
 
     ok(!IsWindowVisible(hwnd), "Window should not be visible.\n");
     ok(!IsIconic(hwnd), "Window should not be minimized.\n");
@@ -1864,14 +1884,14 @@ static void test_video_window_state(IVideoWindow *window, HWND hwnd, HWND our_hw
     ok(GetActiveWindow() == our_hwnd, "Got active window %p.\n", GetActiveWindow());
 
     hr = IVideoWindow_put_Visible(window, OATRUE);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_get_WindowState(window, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(state == SW_SHOW, "Got state %ld.\n", state);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(state == SW_SHOW, "Got state %d.\n", state);
 
     hr = IVideoWindow_get_Visible(window, &state);
-    ok(state == OATRUE, "Got state %ld.\n", state);
+    ok(state == OATRUE, "Got state %d.\n", state);
 
     ok(IsWindowVisible(hwnd), "Window should be visible.\n");
     ok(!IsIconic(hwnd), "Window should not be minimized.\n");
@@ -1879,14 +1899,14 @@ static void test_video_window_state(IVideoWindow *window, HWND hwnd, HWND our_hw
     ok(GetActiveWindow() == hwnd, "Got active window %p.\n", GetActiveWindow());
 
     hr = IVideoWindow_put_Visible(window, OAFALSE);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_get_WindowState(window, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(state == SW_HIDE, "Got state %ld.\n", state);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(state == SW_HIDE, "Got state %d.\n", state);
 
     hr = IVideoWindow_get_Visible(window, &state);
-    ok(state == OAFALSE, "Got state %ld.\n", state);
+    ok(state == OAFALSE, "Got state %d.\n", state);
 
     ok(!IsWindowVisible(hwnd), "Window should not be visible.\n");
     ok(!IsIconic(hwnd), "Window should not be minimized.\n");
@@ -1894,14 +1914,14 @@ static void test_video_window_state(IVideoWindow *window, HWND hwnd, HWND our_hw
     ok(GetActiveWindow() == our_hwnd, "Got active window %p.\n", GetActiveWindow());
 
     hr = IVideoWindow_put_WindowState(window, SW_SHOWNA);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_SetWindowForeground(window, TRUE);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
 
     SetWindowPos(our_hwnd, HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);
     hr = IVideoWindow_SetWindowForeground(window, OATRUE);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(GetActiveWindow() == hwnd, "Got active window %p.\n", GetActiveWindow());
     ok(GetFocus() == hwnd, "Got focus window %p.\n", GetFocus());
     ok(GetForegroundWindow() == hwnd, "Got foreground window %p.\n", GetForegroundWindow());
@@ -1909,7 +1929,7 @@ static void test_video_window_state(IVideoWindow *window, HWND hwnd, HWND our_hw
     ok(top == hwnd, "Got top window %p.\n", top);
 
     hr = IVideoWindow_SetWindowForeground(window, OAFALSE);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(GetActiveWindow() == hwnd, "Got active window %p.\n", GetActiveWindow());
     ok(GetFocus() == hwnd, "Got focus window %p.\n", GetFocus());
     ok(GetForegroundWindow() == hwnd, "Got foreground window %p.\n", GetForegroundWindow());
@@ -1918,7 +1938,7 @@ static void test_video_window_state(IVideoWindow *window, HWND hwnd, HWND our_hw
 
     SetWindowPos(our_hwnd, HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);
     hr = IVideoWindow_SetWindowForeground(window, OAFALSE);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(GetActiveWindow() == our_hwnd, "Got active window %p.\n", GetActiveWindow());
     ok(GetFocus() == our_hwnd, "Got focus window %p.\n", GetFocus());
     ok(GetForegroundWindow() == our_hwnd, "Got foreground window %p.\n", GetForegroundWindow());
@@ -1940,114 +1960,114 @@ static void test_video_window_position(IVideoWindow *window, HWND hwnd, HWND our
     expect_height = rect.bottom - rect.top;
 
     hr = IVideoWindow_put_Left(window, 0);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IVideoWindow_put_Top(window, 0);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_get_Left(window, &left);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(left == 0, "Got left %ld.\n", left);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(left == 0, "Got left %d.\n", left);
     hr = IVideoWindow_get_Top(window, &top);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(top == 0, "Got top %ld.\n", top);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(top == 0, "Got top %d.\n", top);
     hr = IVideoWindow_get_Width(window, &width);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(width == expect_width, "Got width %ld.\n", width);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(width == expect_width, "Got width %d.\n", width);
     hr = IVideoWindow_get_Height(window, &height);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(height == expect_height, "Got height %ld.\n", height);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(height == expect_height, "Got height %d.\n", height);
     hr = IVideoWindow_GetWindowPosition(window, &left, &top, &width, &height);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(left == 0, "Got left %ld.\n", left);
-    ok(top == 0, "Got top %ld.\n", top);
-    ok(width == expect_width, "Got width %ld.\n", width);
-    ok(height == expect_height, "Got height %ld.\n", height);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(left == 0, "Got left %d.\n", left);
+    ok(top == 0, "Got top %d.\n", top);
+    ok(width == expect_width, "Got width %d.\n", width);
+    ok(height == expect_height, "Got height %d.\n", height);
     GetWindowRect(hwnd, &rect);
-    ok(rect.left == 0, "Got window left %ld.\n", rect.left);
-    ok(rect.top == 0, "Got window top %ld.\n", rect.top);
-    ok(rect.right == expect_width, "Got window right %ld.\n", rect.right);
-    ok(rect.bottom == expect_height, "Got window bottom %ld.\n", rect.bottom);
+    ok(rect.left == 0, "Got window left %d.\n", rect.left);
+    ok(rect.top == 0, "Got window top %d.\n", rect.top);
+    ok(rect.right == expect_width, "Got window right %d.\n", rect.right);
+    ok(rect.bottom == expect_height, "Got window bottom %d.\n", rect.bottom);
 
     hr = IVideoWindow_put_Left(window, 10);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_get_Left(window, &left);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(left == 10, "Got left %ld.\n", left);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(left == 10, "Got left %d.\n", left);
     hr = IVideoWindow_get_Top(window, &top);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(top == 0, "Got top %ld.\n", top);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(top == 0, "Got top %d.\n", top);
     hr = IVideoWindow_get_Width(window, &width);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(width == expect_width, "Got width %ld.\n", width);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(width == expect_width, "Got width %d.\n", width);
     hr = IVideoWindow_get_Height(window, &height);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(height == expect_height, "Got height %ld.\n", height);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(height == expect_height, "Got height %d.\n", height);
     hr = IVideoWindow_GetWindowPosition(window, &left, &top, &width, &height);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(left == 10, "Got left %ld.\n", left);
-    ok(top == 0, "Got top %ld.\n", top);
-    ok(width == expect_width, "Got width %ld.\n", width);
-    ok(height == expect_height, "Got height %ld.\n", height);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(left == 10, "Got left %d.\n", left);
+    ok(top == 0, "Got top %d.\n", top);
+    ok(width == expect_width, "Got width %d.\n", width);
+    ok(height == expect_height, "Got height %d.\n", height);
     GetWindowRect(hwnd, &rect);
-    ok(rect.left == 10, "Got window left %ld.\n", rect.left);
-    ok(rect.top == 0, "Got window top %ld.\n", rect.top);
-    ok(rect.right == 10 + expect_width, "Got window right %ld.\n", rect.right);
-    ok(rect.bottom == expect_height, "Got window bottom %ld.\n", rect.bottom);
+    ok(rect.left == 10, "Got window left %d.\n", rect.left);
+    ok(rect.top == 0, "Got window top %d.\n", rect.top);
+    ok(rect.right == 10 + expect_width, "Got window right %d.\n", rect.right);
+    ok(rect.bottom == expect_height, "Got window bottom %d.\n", rect.bottom);
 
     hr = IVideoWindow_put_Height(window, 200);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_get_Left(window, &left);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(left == 10, "Got left %ld.\n", left);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(left == 10, "Got left %d.\n", left);
     hr = IVideoWindow_get_Top(window, &top);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(top == 0, "Got top %ld.\n", top);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(top == 0, "Got top %d.\n", top);
     hr = IVideoWindow_get_Width(window, &width);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(width == expect_width, "Got width %ld.\n", width);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(width == expect_width, "Got width %d.\n", width);
     hr = IVideoWindow_get_Height(window, &height);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(height == 200, "Got height %ld.\n", height);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(height == 200, "Got height %d.\n", height);
     hr = IVideoWindow_GetWindowPosition(window, &left, &top, &width, &height);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(left == 10, "Got left %ld.\n", left);
-    ok(top == 0, "Got top %ld.\n", top);
-    ok(width == expect_width, "Got width %ld.\n", width);
-    ok(height == 200, "Got height %ld.\n", height);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(left == 10, "Got left %d.\n", left);
+    ok(top == 0, "Got top %d.\n", top);
+    ok(width == expect_width, "Got width %d.\n", width);
+    ok(height == 200, "Got height %d.\n", height);
     GetWindowRect(hwnd, &rect);
-    ok(rect.left == 10, "Got window left %ld.\n", rect.left);
-    ok(rect.top == 0, "Got window top %ld.\n", rect.top);
-    ok(rect.right == 10 + expect_width, "Got window right %ld.\n", rect.right);
-    ok(rect.bottom == 200, "Got window bottom %ld.\n", rect.bottom);
+    ok(rect.left == 10, "Got window left %d.\n", rect.left);
+    ok(rect.top == 0, "Got window top %d.\n", rect.top);
+    ok(rect.right == 10 + expect_width, "Got window right %d.\n", rect.right);
+    ok(rect.bottom == 200, "Got window bottom %d.\n", rect.bottom);
 
     hr = IVideoWindow_SetWindowPosition(window, 100, 200, 300, 400);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_get_Left(window, &left);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(left == 100, "Got left %ld.\n", left);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(left == 100, "Got left %d.\n", left);
     hr = IVideoWindow_get_Top(window, &top);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(top == 200, "Got top %ld.\n", top);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(top == 200, "Got top %d.\n", top);
     hr = IVideoWindow_get_Width(window, &width);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(width == 300, "Got width %ld.\n", width);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(width == 300, "Got width %d.\n", width);
     hr = IVideoWindow_get_Height(window, &height);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(height == 400, "Got height %ld.\n", height);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(height == 400, "Got height %d.\n", height);
     hr = IVideoWindow_GetWindowPosition(window, &left, &top, &width, &height);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(left == 100, "Got left %ld.\n", left);
-    ok(top == 200, "Got top %ld.\n", top);
-    ok(width == 300, "Got width %ld.\n", width);
-    ok(height == 400, "Got height %ld.\n", height);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(left == 100, "Got left %d.\n", left);
+    ok(top == 200, "Got top %d.\n", top);
+    ok(width == 300, "Got width %d.\n", width);
+    ok(height == 400, "Got height %d.\n", height);
     GetWindowRect(hwnd, &rect);
-    ok(rect.left == 100, "Got window left %ld.\n", rect.left);
-    ok(rect.top == 200, "Got window top %ld.\n", rect.top);
-    ok(rect.right == 400, "Got window right %ld.\n", rect.right);
-    ok(rect.bottom == 600, "Got window bottom %ld.\n", rect.bottom);
+    ok(rect.left == 100, "Got window left %d.\n", rect.left);
+    ok(rect.top == 200, "Got window top %d.\n", rect.top);
+    ok(rect.right == 400, "Got window right %d.\n", rect.right);
+    ok(rect.bottom == 600, "Got window bottom %d.\n", rect.bottom);
 
     ok(GetActiveWindow() == our_hwnd, "Got active window %p.\n", GetActiveWindow());
     top_hwnd = get_top_window();
@@ -2064,25 +2084,25 @@ static void test_video_window_owner(IVideoWindow *window, HWND hwnd, HWND our_hw
     SetWindowPos(our_hwnd, HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);
 
     hr = IVideoWindow_get_Owner(window, &oahwnd);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(!oahwnd, "Got owner %#Ix.\n", oahwnd);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(!oahwnd, "Got owner %#lx.\n", oahwnd);
 
     parent = GetAncestor(hwnd, GA_PARENT);
     ok(parent == GetDesktopWindow(), "Got parent %p.\n", parent);
     style = GetWindowLongA(hwnd, GWL_STYLE);
-    ok(!(style & WS_CHILD), "Got style %#lx.\n", style);
+    ok(!(style & WS_CHILD), "Got style %#x.\n", style);
 
     hr = IVideoWindow_put_Owner(window, (OAHWND)our_hwnd);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_get_Owner(window, &oahwnd);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(oahwnd == (OAHWND)our_hwnd, "Got owner %#Ix.\n", oahwnd);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(oahwnd == (OAHWND)our_hwnd, "Got owner %#lx.\n", oahwnd);
 
     parent = GetAncestor(hwnd, GA_PARENT);
     ok(parent == our_hwnd, "Got parent %p.\n", parent);
     style = GetWindowLongA(hwnd, GWL_STYLE);
-    ok((style & WS_CHILD), "Got style %#lx.\n", style);
+    ok((style & WS_CHILD), "Got style %#x.\n", style);
 
     ok(GetActiveWindow() == our_hwnd, "Got active window %p.\n", GetActiveWindow());
     top_hwnd = get_top_window();
@@ -2091,31 +2111,31 @@ static void test_video_window_owner(IVideoWindow *window, HWND hwnd, HWND our_hw
     ShowWindow(our_hwnd, SW_HIDE);
 
     hr = IVideoWindow_put_Visible(window, OATRUE);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_get_Visible(window, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(state == OAFALSE, "Got state %ld.\n", state);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(state == OAFALSE, "Got state %d.\n", state);
 
     hr = IVideoWindow_put_Owner(window, 0);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_get_Owner(window, &oahwnd);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(!oahwnd, "Got owner %#Ix.\n", oahwnd);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(!oahwnd, "Got owner %#lx.\n", oahwnd);
 
     parent = GetAncestor(hwnd, GA_PARENT);
     ok(parent == GetDesktopWindow(), "Got parent %p.\n", parent);
     style = GetWindowLongA(hwnd, GWL_STYLE);
-    ok(!(style & WS_CHILD), "Got style %#lx.\n", style);
+    ok(!(style & WS_CHILD), "Got style %#x.\n", style);
 
     ok(GetActiveWindow() == hwnd, "Got active window %p.\n", GetActiveWindow());
     top_hwnd = get_top_window();
     ok(top_hwnd == hwnd, "Got top window %p.\n", top_hwnd);
 
     hr = IVideoWindow_get_Visible(window, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(state == OATRUE, "Got state %ld.\n", state);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(state == OATRUE, "Got state %d.\n", state);
 }
 
 struct notify_message_params
@@ -2129,7 +2149,7 @@ static DWORD CALLBACK notify_message_proc(void *arg)
 {
     const struct notify_message_params *params = arg;
     HRESULT hr = IVideoWindow_NotifyOwnerMessage(params->window, (OAHWND)params->hwnd, params->message, 0, 0);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     return 0;
 }
 
@@ -2172,15 +2192,15 @@ static void test_video_window_messages(IVideoWindow *window, HWND hwnd, HWND our
     flush_events();
 
     hr = IVideoWindow_get_MessageDrain(window, &oahwnd);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(!oahwnd, "Got window %#Ix.\n", oahwnd);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(!oahwnd, "Got window %#lx.\n", oahwnd);
 
     hr = IVideoWindow_put_MessageDrain(window, (OAHWND)our_hwnd);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_get_MessageDrain(window, &oahwnd);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(oahwnd == (OAHWND)our_hwnd, "Got window %#Ix.\n", oahwnd);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(oahwnd == (OAHWND)our_hwnd, "Got window %#lx.\n", oahwnd);
 
     for (i = 0; i < ARRAY_SIZE(drain_tests); ++i)
     {
@@ -2189,8 +2209,8 @@ static void test_video_window_messages(IVideoWindow *window, HWND hwnd, HWND our
         ok(ret, "Expected a message.\n");
         ok(msg.hwnd == our_hwnd, "Got hwnd %p.\n", msg.hwnd);
         ok(msg.message == drain_tests[i], "Got message %#x.\n", msg.message);
-        ok(msg.wParam == 0xdeadbeef, "Got wparam %#Ix.\n", msg.wParam);
-        ok(!msg.lParam, "Got lparam %#Ix.\n", msg.lParam);
+        ok(msg.wParam == 0xdeadbeef, "Got wparam %#lx.\n", msg.wParam);
+        ok(!msg.lParam, "Got lparam %#lx.\n", msg.lParam);
         DispatchMessageA(&msg);
 
         ret = PeekMessageA(&msg, 0, drain_tests[i], drain_tests[i], PM_REMOVE);
@@ -2198,10 +2218,10 @@ static void test_video_window_messages(IVideoWindow *window, HWND hwnd, HWND our
     }
 
     hr = IVideoWindow_put_MessageDrain(window, 0);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_put_Owner(window, (OAHWND)our_hwnd);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     flush_events();
 
@@ -2210,7 +2230,7 @@ static void test_video_window_messages(IVideoWindow *window, HWND hwnd, HWND our
      * posted all messages. */
 
     hr = IVideoWindow_NotifyOwnerMessage(window, (OAHWND)our_hwnd, WM_SYSCOLORCHANGE, 0, 0);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     while (PeekMessageA(&msg, 0, 0, 0, PM_REMOVE))
     {
@@ -2219,7 +2239,7 @@ static void test_video_window_messages(IVideoWindow *window, HWND hwnd, HWND our
     }
 
     hr = IVideoWindow_NotifyOwnerMessage(window, (OAHWND)our_hwnd, WM_FONTCHANGE, 0, 0);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     while (PeekMessageA(&msg, 0, 0, 0, PM_REMOVE))
     {
@@ -2256,7 +2276,7 @@ static void test_video_window_messages(IVideoWindow *window, HWND hwnd, HWND our
     }
 
     hr = IVideoWindow_put_Owner(window, 0);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 }
 
 static void test_video_window_autoshow(IVideoWindow *window, IFilterGraph2 *graph, HWND hwnd)
@@ -2268,41 +2288,41 @@ static void test_video_window_autoshow(IVideoWindow *window, IFilterGraph2 *grap
     IFilterGraph2_QueryInterface(graph, &IID_IMediaControl, (void **)&control);
 
     hr = IVideoWindow_get_AutoShow(window, &l);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(l == OATRUE, "Got %ld.\n", l);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(l == OATRUE, "Got %d.\n", l);
 
     hr = IVideoWindow_put_Visible(window, OAFALSE);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_Pause(control);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_get_Visible(window, &l);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(l == OATRUE, "Got %ld.\n", l);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(l == OATRUE, "Got %d.\n", l);
 
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_get_Visible(window, &l);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(l == OATRUE, "Got %ld.\n", l);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(l == OATRUE, "Got %d.\n", l);
 
     hr = IVideoWindow_put_AutoShow(window, OAFALSE);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_put_Visible(window, OAFALSE);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_Pause(control);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_get_Visible(window, &l);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(l == OAFALSE, "Got %ld.\n", l);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(l == OAFALSE, "Got %d.\n", l);
 
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     IMediaControl_Release(control);
 }
@@ -2360,27 +2380,27 @@ static void test_video_window(void)
     IPin_QueryInterface(pin, &IID_IMemInputPin, (void **)&input);
 
     hr = IPin_QueryInterface(pin, &IID_IOverlay, (void **)&overlay);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IOverlay_GetWindowHandle(overlay, &hwnd);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     if (winetest_debug > 1) trace("ours %p, theirs %p\n", our_hwnd, hwnd);
     GetWindowRect(hwnd, &rect);
 
     tid = GetWindowThreadProcessId(hwnd, NULL);
-    ok(tid == GetCurrentThreadId(), "Expected tid %#lx, got %#lx.\n", GetCurrentThreadId(), tid);
+    ok(tid == GetCurrentThreadId(), "Expected tid %#x, got %#x.\n", GetCurrentThreadId(), tid);
 
     hr = IBaseFilter_QueryInterface(filter, &IID_IVideoWindow, (void **)&window);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_get_Caption(window, &caption);
-    todo_wine ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_get_WindowStyle(window, &l);
-    todo_wine ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_get_AutoShow(window, &l);
-    todo_wine ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#x.\n", hr);
 
     testfilter_init(&source);
     IFilterGraph2_AddFilter(graph, &source.filter.IBaseFilter_iface, NULL);
@@ -2393,17 +2413,17 @@ static void test_video_window(void)
         req_props.cbBuffer = 32 * 16 * 3;
         hr = IFilterGraph2_ConnectDirect(graph, &source.source.pin.IPin_iface, pin, &req_mt);
     }
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMemInputPin_GetAllocator(input, &allocator);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
     if (hr == S_OK)
     {
         hr = IMemAllocator_SetProperties(allocator, &req_props, &ret_props);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
         ok(!memcmp(&ret_props, &req_props, sizeof(req_props)), "Properties did not match.\n");
         hr = IMemAllocator_Commit(allocator);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
         IMemAllocator_Release(allocator);
     }
 
@@ -2418,14 +2438,14 @@ static void test_video_window(void)
     test_video_window_messages(window, hwnd, our_hwnd);
 
     hr = IVideoWindow_put_FullScreenMode(window, OATRUE);
-    ok(hr == E_NOTIMPL, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOTIMPL, "Got hr %#x.\n", hr);
     hr = IVideoWindow_get_FullScreenMode(window, &l);
-    ok(hr == E_NOTIMPL, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOTIMPL, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_GetMinIdealImageSize(window, &width, &height);
-    todo_wine ok(hr == VFW_E_WRONG_STATE, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == VFW_E_WRONG_STATE, "Got hr %#x.\n", hr);
     hr = IVideoWindow_GetMaxIdealImageSize(window, &width, &height);
-    todo_wine ok(hr == VFW_E_WRONG_STATE, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == VFW_E_WRONG_STATE, "Got hr %#x.\n", hr);
 
     IFilterGraph2_Release(graph);
     IVideoWindow_Release(window);
@@ -2433,9 +2453,9 @@ static void test_video_window(void)
     IMemInputPin_Release(input);
     IPin_Release(pin);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ref = IBaseFilter_Release(&source.filter.IBaseFilter_iface);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     DestroyWindow(our_hwnd);
 }
 
@@ -2447,31 +2467,31 @@ static void check_source_position_(int line, IBasicVideo *video,
 
     left = top = width = height = 0xdeadbeef;
     hr = IBasicVideo_GetSourcePosition(video, &left, &top, &width, &height);
-    ok_(__FILE__,line)(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok_(__FILE__,line)(left == expect_left, "Got left %ld.\n", left);
-    ok_(__FILE__,line)(top == expect_top, "Got top %ld.\n", top);
-    ok_(__FILE__,line)(width == expect_width, "Got width %ld.\n", width);
-    ok_(__FILE__,line)(height == expect_height, "Got height %ld.\n", height);
+    ok_(__FILE__,line)(hr == S_OK, "Got hr %#x.\n", hr);
+    ok_(__FILE__,line)(left == expect_left, "Got left %d.\n", left);
+    ok_(__FILE__,line)(top == expect_top, "Got top %d.\n", top);
+    ok_(__FILE__,line)(width == expect_width, "Got width %d.\n", width);
+    ok_(__FILE__,line)(height == expect_height, "Got height %d.\n", height);
 
     l = 0xdeadbeef;
     hr = IBasicVideo_get_SourceLeft(video, &l);
-    ok_(__FILE__,line)(hr == S_OK, "Failed to get left, hr %#lx.\n", hr);
-    ok_(__FILE__,line)(l == left, "Got left %ld.\n", l);
+    ok_(__FILE__,line)(hr == S_OK, "Failed to get left, hr %#x.\n", hr);
+    ok_(__FILE__,line)(l == left, "Got left %d.\n", l);
 
     l = 0xdeadbeef;
     hr = IBasicVideo_get_SourceTop(video, &l);
-    ok_(__FILE__,line)(hr == S_OK, "Failed to get top, hr %#lx.\n", hr);
-    ok_(__FILE__,line)(l == top, "Got top %ld.\n", l);
+    ok_(__FILE__,line)(hr == S_OK, "Failed to get top, hr %#x.\n", hr);
+    ok_(__FILE__,line)(l == top, "Got top %d.\n", l);
 
     l = 0xdeadbeef;
     hr = IBasicVideo_get_SourceWidth(video, &l);
-    ok_(__FILE__,line)(hr == S_OK, "Failed to get width, hr %#lx.\n", hr);
-    ok_(__FILE__,line)(l == width, "Got width %ld.\n", l);
+    ok_(__FILE__,line)(hr == S_OK, "Failed to get width, hr %#x.\n", hr);
+    ok_(__FILE__,line)(l == width, "Got width %d.\n", l);
 
     l = 0xdeadbeef;
     hr = IBasicVideo_get_SourceHeight(video, &l);
-    ok_(__FILE__,line)(hr == S_OK, "Failed to get height, hr %#lx.\n", hr);
-    ok_(__FILE__,line)(l == height, "Got height %ld.\n", l);
+    ok_(__FILE__,line)(hr == S_OK, "Failed to get height, hr %#x.\n", hr);
+    ok_(__FILE__,line)(l == height, "Got height %d.\n", l);
 }
 #define check_source_position(a,b,c,d,e) check_source_position_(__LINE__,a,b,c,d,e)
 
@@ -2481,77 +2501,77 @@ static void test_basic_video_source(IBasicVideo *video)
 
     check_source_position(video, 0, 0, 600, 400);
     hr = IBasicVideo_IsUsingDefaultSource(video);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_put_SourceLeft(video, -10);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
     hr = IBasicVideo_put_SourceLeft(video, 10);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_put_SourceTop(video, -10);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
     hr = IBasicVideo_put_SourceTop(video, 10);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_put_SourceWidth(video, -500);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
     hr = IBasicVideo_put_SourceWidth(video, 0);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
     hr = IBasicVideo_put_SourceWidth(video, 700);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
     hr = IBasicVideo_put_SourceWidth(video, 500);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_source_position(video, 0, 0, 500, 400);
     hr = IBasicVideo_IsUsingDefaultSource(video);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_put_SourceHeight(video, -300);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
     hr = IBasicVideo_put_SourceHeight(video, 0);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
     hr = IBasicVideo_put_SourceHeight(video, 600);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
     hr = IBasicVideo_put_SourceHeight(video, 300);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_source_position(video, 0, 0, 500, 300);
     hr = IBasicVideo_IsUsingDefaultSource(video);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_put_SourceLeft(video, -10);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
     hr = IBasicVideo_put_SourceLeft(video, 10);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_source_position(video, 10, 0, 500, 300);
     hr = IBasicVideo_IsUsingDefaultSource(video);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_put_SourceTop(video, -10);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
     hr = IBasicVideo_put_SourceTop(video, 20);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_source_position(video, 10, 20, 500, 300);
     hr = IBasicVideo_IsUsingDefaultSource(video);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_SetSourcePosition(video, 4, 5, 60, 40);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_source_position(video, 4, 5, 60, 40);
     hr = IBasicVideo_IsUsingDefaultSource(video);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_SetSourcePosition(video, 0, 0, 600, 400);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_source_position(video, 0, 0, 600, 400);
     hr = IBasicVideo_IsUsingDefaultSource(video);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_SetSourcePosition(video, 4, 5, 60, 40);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IBasicVideo_SetDefaultSourcePosition(video);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_source_position(video, 0, 0, 600, 400);
     hr = IBasicVideo_IsUsingDefaultSource(video);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 }
 
 static void check_destination_position_(int line, IBasicVideo *video,
@@ -2562,31 +2582,31 @@ static void check_destination_position_(int line, IBasicVideo *video,
 
     left = top = width = height = 0xdeadbeef;
     hr = IBasicVideo_GetDestinationPosition(video, &left, &top, &width, &height);
-    ok_(__FILE__,line)(hr == S_OK, "Failed to get position, hr %#lx.\n", hr);
-    ok_(__FILE__,line)(left == expect_left, "Got left %ld.\n", left);
-    ok_(__FILE__,line)(top == expect_top, "Got top %ld.\n", top);
-    ok_(__FILE__,line)(width == expect_width, "Got width %ld.\n", width);
-    ok_(__FILE__,line)(height == expect_height, "Got height %ld.\n", height);
+    ok_(__FILE__,line)(hr == S_OK, "Failed to get position, hr %#x.\n", hr);
+    ok_(__FILE__,line)(left == expect_left, "Got left %d.\n", left);
+    ok_(__FILE__,line)(top == expect_top, "Got top %d.\n", top);
+    ok_(__FILE__,line)(width == expect_width, "Got width %d.\n", width);
+    ok_(__FILE__,line)(height == expect_height, "Got height %d.\n", height);
 
     l = 0xdeadbeef;
     hr = IBasicVideo_get_DestinationLeft(video, &l);
-    ok_(__FILE__,line)(hr == S_OK, "Failed to get left, hr %#lx.\n", hr);
-    ok_(__FILE__,line)(l == left, "Got left %ld.\n", l);
+    ok_(__FILE__,line)(hr == S_OK, "Failed to get left, hr %#x.\n", hr);
+    ok_(__FILE__,line)(l == left, "Got left %d.\n", l);
 
     l = 0xdeadbeef;
     hr = IBasicVideo_get_DestinationTop(video, &l);
-    ok_(__FILE__,line)(hr == S_OK, "Failed to get top, hr %#lx.\n", hr);
-    ok_(__FILE__,line)(l == top, "Got top %ld.\n", l);
+    ok_(__FILE__,line)(hr == S_OK, "Failed to get top, hr %#x.\n", hr);
+    ok_(__FILE__,line)(l == top, "Got top %d.\n", l);
 
     l = 0xdeadbeef;
     hr = IBasicVideo_get_DestinationWidth(video, &l);
-    ok_(__FILE__,line)(hr == S_OK, "Failed to get width, hr %#lx.\n", hr);
-    ok_(__FILE__,line)(l == width, "Got width %ld.\n", l);
+    ok_(__FILE__,line)(hr == S_OK, "Failed to get width, hr %#x.\n", hr);
+    ok_(__FILE__,line)(l == width, "Got width %d.\n", l);
 
     l = 0xdeadbeef;
     hr = IBasicVideo_get_DestinationHeight(video, &l);
-    ok_(__FILE__,line)(hr == S_OK, "Failed to get height, hr %#lx.\n", hr);
-    ok_(__FILE__,line)(l == height, "Got height %ld.\n", l);
+    ok_(__FILE__,line)(hr == S_OK, "Failed to get height, hr %#x.\n", hr);
+    ok_(__FILE__,line)(l == height, "Got height %d.\n", l);
 }
 #define check_destination_position(a,b,c,d,e) check_destination_position_(__LINE__,a,b,c,d,e)
 
@@ -2600,107 +2620,107 @@ static void test_basic_video_destination(IBasicVideo *video)
 
     check_destination_position(video, 0, 0, 600, 400);
     hr = IBasicVideo_IsUsingDefaultDestination(video);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_put_DestinationLeft(video, -10);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_destination_position(video, -10, 0, 600, 400);
     hr = IBasicVideo_IsUsingDefaultDestination(video);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_put_DestinationLeft(video, 10);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_destination_position(video, 10, 0, 600, 400);
     hr = IBasicVideo_IsUsingDefaultDestination(video);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_put_DestinationTop(video, -20);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_destination_position(video, 10, -20, 600, 400);
     hr = IBasicVideo_IsUsingDefaultDestination(video);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_put_DestinationTop(video, 20);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_destination_position(video, 10, 20, 600, 400);
     hr = IBasicVideo_IsUsingDefaultDestination(video);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_put_DestinationWidth(video, -700);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
     hr = IBasicVideo_put_DestinationWidth(video, 0);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
     hr = IBasicVideo_put_DestinationWidth(video, 700);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_destination_position(video, 10, 20, 700, 400);
     hr = IBasicVideo_IsUsingDefaultDestination(video);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_put_DestinationWidth(video, 500);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_destination_position(video, 10, 20, 500, 400);
     hr = IBasicVideo_IsUsingDefaultDestination(video);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_put_DestinationHeight(video, -500);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
     hr = IBasicVideo_put_DestinationHeight(video, 0);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
     hr = IBasicVideo_put_DestinationHeight(video, 500);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_destination_position(video, 10, 20, 500, 500);
     hr = IBasicVideo_IsUsingDefaultDestination(video);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_put_DestinationHeight(video, 300);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_destination_position(video, 10, 20, 500, 300);
     hr = IBasicVideo_IsUsingDefaultDestination(video);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_SetDestinationPosition(video, 4, 5, 60, 40);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_destination_position(video, 4, 5, 60, 40);
     hr = IBasicVideo_IsUsingDefaultDestination(video);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_SetDestinationPosition(video, 0, 0, 600, 400);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_destination_position(video, 0, 0, 600, 400);
     hr = IBasicVideo_IsUsingDefaultDestination(video);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_SetDestinationPosition(video, 4, 5, 60, 40);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IBasicVideo_SetDefaultDestinationPosition(video);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_destination_position(video, 0, 0, 600, 400);
     hr = IBasicVideo_IsUsingDefaultDestination(video);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     SetRect(&rect, 100, 200, 500, 500);
     AdjustWindowRect(&rect, WS_OVERLAPPEDWINDOW, FALSE);
     hr = IVideoWindow_SetWindowPosition(window, rect.left, rect.top,
             rect.right - rect.left, rect.bottom - rect.top);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_destination_position(video, 0, 0, 400, 300);
     hr = IBasicVideo_IsUsingDefaultDestination(video);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_SetDestinationPosition(video, 0, 0, 400, 300);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_destination_position(video, 0, 0, 400, 300);
     hr = IBasicVideo_IsUsingDefaultDestination(video);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     SetRect(&rect, 100, 200, 600, 600);
     AdjustWindowRect(&rect, WS_OVERLAPPEDWINDOW, FALSE);
     hr = IVideoWindow_SetWindowPosition(window, rect.left, rect.top,
             rect.right - rect.left, rect.bottom - rect.top);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_destination_position(video, 0, 0, 400, 300);
     hr = IBasicVideo_IsUsingDefaultDestination(video);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     IVideoWindow_Release(window);
 }
@@ -2749,83 +2769,83 @@ static void test_basic_video(void)
     IPin_QueryInterface(pin, &IID_IMemInputPin, (void **)&input);
 
     hr = IBasicVideo_GetTypeInfoCount(video, &count);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(count == 1, "Got count %u.\n", count);
 
     hr = IBasicVideo_GetTypeInfo(video, 0, 0, &typeinfo);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = ITypeInfo_GetTypeAttr(typeinfo, &typeattr);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(typeattr->typekind == TKIND_DISPATCH, "Got kind %u.\n", typeattr->typekind);
     ok(IsEqualGUID(&typeattr->guid, &IID_IBasicVideo), "Got IID %s.\n", wine_dbgstr_guid(&typeattr->guid));
     ITypeInfo_ReleaseTypeAttr(typeinfo, typeattr);
     ITypeInfo_Release(typeinfo);
 
     hr = IBasicVideo_get_AvgTimePerFrame(video, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
     hr = IBasicVideo_get_AvgTimePerFrame(video, &reftime);
-    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_get_BitRate(video, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
     hr = IBasicVideo_get_BitRate(video, &l);
-    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_get_BitErrorRate(video, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
     hr = IBasicVideo_get_BitErrorRate(video, &l);
-    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_get_VideoWidth(video, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
     hr = IBasicVideo_get_VideoHeight(video, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_get_SourceLeft(video, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
     hr = IBasicVideo_get_SourceWidth(video, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
     hr = IBasicVideo_get_SourceTop(video, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
     hr = IBasicVideo_get_SourceHeight(video, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_get_DestinationLeft(video, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
     hr = IBasicVideo_get_DestinationWidth(video, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
     hr = IBasicVideo_get_DestinationTop(video, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
     hr = IBasicVideo_get_DestinationHeight(video, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_GetSourcePosition(video, NULL, &top, &width, &height);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
     hr = IBasicVideo_GetSourcePosition(video, &left, NULL, &width, &height);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
     hr = IBasicVideo_GetSourcePosition(video, &left, &top, NULL, &height);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
     hr = IBasicVideo_GetSourcePosition(video, &left, &top, &width, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_GetDestinationPosition(video, NULL, &top, &width, &height);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
     hr = IBasicVideo_GetDestinationPosition(video, &left, NULL, &width, &height);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
     hr = IBasicVideo_GetDestinationPosition(video, &left, &top, NULL, &height);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
     hr = IBasicVideo_GetDestinationPosition(video, &left, &top, &width, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_GetVideoSize(video, &width, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
     hr = IBasicVideo_GetVideoSize(video, NULL, &height);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_GetVideoPaletteEntries(video, 0, 1, NULL, &l);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
     hr = IBasicVideo_GetVideoPaletteEntries(video, 0, 1, &l, NULL);
-    todo_wine ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#x.\n", hr);
 
     testfilter_init(&source);
     IFilterGraph2_AddFilter(graph, &source.filter.IBaseFilter_iface, L"vmr9");
@@ -2836,66 +2856,66 @@ static void test_basic_video(void)
         skip("Got E_FAIL when connecting.\n");
         goto out;
     }
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMemInputPin_GetAllocator(input, &allocator);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
     if (hr == S_OK)
     {
         hr = IMemAllocator_SetProperties(allocator, &req_props, &ret_props);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
         ok(!memcmp(&ret_props, &req_props, sizeof(req_props)), "Properties did not match.\n");
         hr = IMemAllocator_Commit(allocator);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
         IMemAllocator_Release(allocator);
     }
 
     reftime = 0.0;
     hr = IBasicVideo_get_AvgTimePerFrame(video, &reftime);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(compare_double(reftime, 0.02, 1 << 28), "Got frame rate %.16e.\n", reftime);
 
     l = 0xdeadbeef;
     hr = IBasicVideo_get_BitRate(video, &l);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(!l, "Got bit rate %ld.\n", l);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(!l, "Got bit rate %d.\n", l);
 
     l = 0xdeadbeef;
     hr = IBasicVideo_get_BitErrorRate(video, &l);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(!l, "Got bit rate %ld.\n", l);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(!l, "Got bit rate %d.\n", l);
 
     hr = IBasicVideo_GetVideoPaletteEntries(video, 0, 1, &l, NULL);
-    todo_wine ok(hr == VFW_E_NO_PALETTE_AVAILABLE, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == VFW_E_NO_PALETTE_AVAILABLE, "Got hr %#x.\n", hr);
 
     width = height = 0xdeadbeef;
     hr = IBasicVideo_GetVideoSize(video, &width, &height);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(width == 600, "Got width %ld.\n", width);
-    ok(height == 400, "Got height %ld.\n", height);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(width == 600, "Got width %d.\n", width);
+    ok(height == 400, "Got height %d.\n", height);
 
     test_basic_video_source(video);
     test_basic_video_destination(video);
 
     hr = IFilterGraph2_Disconnect(graph, &source.source.pin.IPin_iface);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IFilterGraph2_Disconnect(graph, pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     vih.bmiHeader.biWidth = 16;
     vih.bmiHeader.biHeight = 16;
     hr = IFilterGraph2_ConnectDirect(graph, &source.source.pin.IPin_iface, pin, &req_mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMemInputPin_GetAllocator(input, &allocator);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
     if (hr == S_OK)
     {
         hr = IMemAllocator_SetProperties(allocator, &req_props, &ret_props);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
         ok(!memcmp(&ret_props, &req_props, sizeof(req_props)), "Properties did not match.\n");
         hr = IMemAllocator_Commit(allocator);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
         IMemAllocator_Release(allocator);
     }
 
@@ -2908,14 +2928,14 @@ static void test_basic_video(void)
 
 out:
     ref = IFilterGraph2_Release(graph);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     IBasicVideo_Release(video);
     IMemInputPin_Release(input);
     IPin_Release(pin);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ref = IBaseFilter_Release(&source.filter.IBaseFilter_iface);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 static void test_windowless_size(void)
@@ -2960,12 +2980,12 @@ static void test_windowless_size(void)
     ok(!!window, "Failed to create a window.\n");
 
     hr = IVMRWindowlessControl_SetVideoClippingWindow(windowless_control, window);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IFilterGraph2_ConnectDirect(graph, &source.source.pin.IPin_iface, pin, &mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMemInputPin_GetAllocator(input, &allocator);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
     if (hr == S_OK)
     {
         hr = IMemAllocator_SetProperties(allocator, &req_props, &ret_props);
@@ -2975,47 +2995,47 @@ static void test_windowless_size(void)
             skip("Got E_FAIL when setting allocator properties.\n");
             goto out;
         }
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
         ok(!memcmp(&ret_props, &req_props, sizeof(req_props)), "Properties did not match.\n");
     }
 
     hr = IVMRWindowlessControl_GetNativeVideoSize(windowless_control, NULL, &height, &aspect_width, &aspect_height);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
     hr = IVMRWindowlessControl_GetNativeVideoSize(windowless_control, &width, NULL, &aspect_width, &aspect_height);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
 
     width = height = 0xdeadbeef;
     hr = IVMRWindowlessControl_GetNativeVideoSize(windowless_control, &width, &height, NULL, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(width == 32, "Got width %ld.\n", width);
-    ok(height == 16, "Got height %ld.\n", height);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(width == 32, "Got width %d.\n", width);
+    ok(height == 16, "Got height %d.\n", height);
 
     aspect_width = aspect_height = 0xdeadbeef;
     hr = IVMRWindowlessControl_GetNativeVideoSize(windowless_control, &width, &height, &aspect_width, &aspect_height);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(aspect_width == 32, "Got width %ld.\n", aspect_width);
-    ok(aspect_height == 16, "Got height %ld.\n", aspect_height);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(aspect_width == 32, "Got width %d.\n", aspect_width);
+    ok(aspect_height == 16, "Got height %d.\n", aspect_height);
 
     memset(&src, 0xcc, sizeof(src));
     hr = IVMRWindowlessControl_GetVideoPosition(windowless_control, &src, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     SetRect(&expect, 0, 0, 32, 16);
     ok(EqualRect(&src, &expect), "Got source rect %s.\n", wine_dbgstr_rect(&src));
 
     memset(&dst, 0xcc, sizeof(dst));
     hr = IVMRWindowlessControl_GetVideoPosition(windowless_control, NULL, &dst);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     SetRect(&expect, 0, 0, 0, 0);
     ok(EqualRect(&dst, &expect), "Got dest rect %s.\n", wine_dbgstr_rect(&dst));
 
     SetRect(&src, 4, 6, 16, 12);
     hr = IVMRWindowlessControl_SetVideoPosition(windowless_control, &src, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     memset(&src, 0xcc, sizeof(src));
     memset(&dst, 0xcc, sizeof(dst));
     hr = IVMRWindowlessControl_GetVideoPosition(windowless_control, &src, &dst);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     SetRect(&expect, 4, 6, 16, 12);
     ok(EqualRect(&src, &expect), "Got source rect %s.\n", wine_dbgstr_rect(&src));
     SetRect(&expect, 0, 0, 0, 0);
@@ -3023,12 +3043,12 @@ static void test_windowless_size(void)
 
     SetRect(&dst, 40, 60, 120, 160);
     hr = IVMRWindowlessControl_SetVideoPosition(windowless_control, NULL, &dst);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     memset(&src, 0xcc, sizeof(src));
     memset(&dst, 0xcc, sizeof(dst));
     hr = IVMRWindowlessControl_GetVideoPosition(windowless_control, &src, &dst);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     SetRect(&expect, 4, 6, 16, 12);
     ok(EqualRect(&src, &expect), "Got source rect %s.\n", wine_dbgstr_rect(&src));
     SetRect(&expect, 40, 60, 120, 160);
@@ -3040,12 +3060,12 @@ static void test_windowless_size(void)
 
 out:
     ref = IFilterGraph2_Release(graph);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     IMemInputPin_Release(input);
     IPin_Release(pin);
     IVMRWindowlessControl_Release(windowless_control);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     DestroyWindow(window);
 }
 
@@ -3060,49 +3080,49 @@ static void test_unconnected_eos(void)
     ULONG ref;
 
     hr = IFilterGraph2_AddFilter(graph, filter, L"renderer");
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IFilterGraph2_QueryInterface(graph, &IID_IMediaControl, (void **)&control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IFilterGraph2_QueryInterface(graph, &IID_IMediaEvent, (void **)&eventsrc);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     ret = check_ec_complete(eventsrc, 0);
     ok(!ret, "Got %u EC_COMPLETE events.\n", ret);
 
     hr = IMediaControl_Pause(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     ret = check_ec_complete(eventsrc, 0);
     ok(!ret, "Got %u EC_COMPLETE events.\n", ret);
 
     hr = IMediaControl_Run(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     ret = check_ec_complete(eventsrc, 0);
     ok(ret == 1, "Got %u EC_COMPLETE events.\n", ret);
 
     hr = IMediaControl_Pause(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     ret = check_ec_complete(eventsrc, 0);
     ok(!ret, "Got %u EC_COMPLETE events.\n", ret);
 
     hr = IMediaControl_Run(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     ret = check_ec_complete(eventsrc, 0);
     ok(ret == 1, "Got %u EC_COMPLETE events.\n", ret);
 
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     ret = check_ec_complete(eventsrc, 0);
     ok(!ret, "Got %u EC_COMPLETE events.\n", ret);
 
     hr = IMediaControl_Run(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     ret = check_ec_complete(eventsrc, 0);
     ok(ret == 1, "Got %u EC_COMPLETE events.\n", ret);
@@ -3110,9 +3130,9 @@ static void test_unconnected_eos(void)
     IMediaControl_Release(control);
     IMediaEvent_Release(eventsrc);
     ref = IFilterGraph2_Release(graph);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 START_TEST(vmr7)
diff --git a/dlls/quartz/tests/vmr9.c b/dlls/quartz/tests/vmr9.c
index 405f7ee89ba..a0ccb4898a9 100644
--- wine/dlls/quartz/tests/vmr9.c
+++ wine/dlls/quartz/tests/vmr9.c
@@ -27,7 +27,6 @@
 #include "qedit.h"
 #include "d3d9.h"
 #include "vmr9.h"
-#include "videoacc.h"
 #include "wmcodecdsp.h"
 #include "wine/strmbase.h"
 #include "wine/test.h"
@@ -38,13 +37,13 @@ static IBaseFilter *create_vmr9(DWORD mode)
     IVMRFilterConfig9 *config;
     HRESULT hr = CoCreateInstance(&CLSID_VideoMixingRenderer9, NULL, CLSCTX_INPROC_SERVER,
             &IID_IBaseFilter, (void **)&filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     if (mode)
     {
         hr = IBaseFilter_QueryInterface(filter, &IID_IVMRFilterConfig9, (void **)&config);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
         hr = IVMRFilterConfig9_SetRenderingMode(config, mode);
-        ok(hr == S_OK || broken(hr == E_FAIL), "Got hr %#lx.\n", hr);
+        ok(hr == S_OK || broken(hr == E_FAIL), "Got hr %#x.\n", hr);
         IVMRFilterConfig9_Release(config);
     }
     return filter;
@@ -56,10 +55,10 @@ static HRESULT set_mixing_mode(IBaseFilter *filter, DWORD count)
     HRESULT hr;
 
     hr = IBaseFilter_QueryInterface(filter, &IID_IVMRFilterConfig9, (void **)&config);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVMRFilterConfig9_SetNumberOfStreams(config, count);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     IVMRFilterConfig9_Release(config);
     return hr;
@@ -93,7 +92,7 @@ static IFilterGraph2 *create_graph(void)
     IFilterGraph2 *ret;
     HRESULT hr;
     hr = CoCreateInstance(&CLSID_FilterGraph, NULL, CLSCTX_INPROC_SERVER, &IID_IFilterGraph2, (void **)&ret);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Failed to create FilterGraph: %#x\n", hr);
     return ret;
 }
 
@@ -113,92 +112,92 @@ static void test_filter_config(void)
 
     hr = CoCreateInstance(&CLSID_VideoMixingRenderer9, NULL, CLSCTX_INPROC_SERVER,
             &IID_IVMRFilterConfig9, (void **)&config);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVMRFilterConfig9_GetRenderingMode(config, &mode);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(mode == VMRMode_Windowed, "Got mode %#lx.\n", mode);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(mode == VMRMode_Windowed, "Got mode %#x.\n", mode);
 
     hr = IVMRFilterConfig9_SetRenderingMode(config, VMR9Mode_Windowed);
-    ok(hr == S_OK || broken(hr == E_FAIL), "Got hr %#lx.\n", hr);
+    ok(hr == S_OK || broken(hr == E_FAIL), "Got hr %#x.\n", hr);
 
     hr = IVMRFilterConfig9_GetRenderingMode(config, &mode);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(mode == VMR9Mode_Windowed, "Got mode %#lx.\n", mode);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(mode == VMR9Mode_Windowed, "Got mode %#x.\n", mode);
 
     hr = IVMRFilterConfig9_SetRenderingMode(config, VMR9Mode_Windowed);
-    ok(hr == VFW_E_WRONG_STATE, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_WRONG_STATE, "Got hr %#x.\n", hr);
 
     ref = IVMRFilterConfig9_Release(config);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 
     hr = CoCreateInstance(&CLSID_VideoMixingRenderer9, NULL, CLSCTX_INPROC_SERVER,
             &IID_IVMRFilterConfig9, (void **)&config);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVMRFilterConfig9_SetRenderingMode(config, VMR9Mode_Windowless);
-    ok(hr == S_OK || broken(hr == E_FAIL), "Got hr %#lx.\n", hr);
+    ok(hr == S_OK || broken(hr == E_FAIL), "Got hr %#x.\n", hr);
 
     hr = IVMRFilterConfig9_GetRenderingMode(config, &mode);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(mode == VMR9Mode_Windowless, "Got mode %#lx.\n", mode);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(mode == VMR9Mode_Windowless, "Got mode %#x.\n", mode);
 
     hr = IVMRFilterConfig9_SetRenderingMode(config, VMR9Mode_Windowed);
-    ok(hr == VFW_E_WRONG_STATE, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_WRONG_STATE, "Got hr %#x.\n", hr);
 
     ref = IVMRFilterConfig9_Release(config);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 
     hr = CoCreateInstance(&CLSID_VideoMixingRenderer9, NULL, CLSCTX_INPROC_SERVER,
             &IID_IVMRFilterConfig9, (void **)&config);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVMRFilterConfig9_SetRenderingMode(config, VMR9Mode_Renderless);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVMRFilterConfig9_GetRenderingMode(config, &mode);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(mode == VMR9Mode_Renderless, "Got mode %#lx.\n", mode);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(mode == VMR9Mode_Renderless, "Got mode %#x.\n", mode);
 
     hr = IVMRFilterConfig9_SetRenderingMode(config, VMR9Mode_Windowless);
-    ok(hr == VFW_E_WRONG_STATE, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_WRONG_STATE, "Got hr %#x.\n", hr);
 
     ref = IVMRFilterConfig9_Release(config);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 
     hr = CoCreateInstance(&CLSID_VideoMixingRenderer9, NULL, CLSCTX_INPROC_SERVER,
             &IID_IVMRFilterConfig9, (void **)&config);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVMRFilterConfig9_GetNumberOfStreams(config, &count);
-    ok(hr == VFW_E_VMR_NOT_IN_MIXER_MODE, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_VMR_NOT_IN_MIXER_MODE, "Got hr %#x.\n", hr);
 
     hr = IVMRFilterConfig9_SetNumberOfStreams(config, 3);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVMRFilterConfig9_GetNumberOfStreams(config, &count);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(count == 3, "Got count %lu.\n", count);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(count == 3, "Got count %u.\n", count);
 
     hr = IVMRFilterConfig9_GetRenderingMode(config, &mode);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(mode == VMR9Mode_Windowed, "Got mode %#lx.\n", mode);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(mode == VMR9Mode_Windowed, "Got mode %#x.\n", mode);
 
     /* Despite MSDN, you can still change the rendering mode after setting the
      * stream count. */
     hr = IVMRFilterConfig9_SetRenderingMode(config, VMR9Mode_Windowless);
-    ok(hr == S_OK || broken(hr == E_FAIL), "Got hr %#lx.\n", hr);
+    ok(hr == S_OK || broken(hr == E_FAIL), "Got hr %#x.\n", hr);
 
     hr = IVMRFilterConfig9_GetRenderingMode(config, &mode);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(mode == VMR9Mode_Windowless, "Got mode %#lx.\n", mode);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(mode == VMR9Mode_Windowless, "Got mode %#x.\n", mode);
 
     hr = IVMRFilterConfig9_GetNumberOfStreams(config, &count);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(count == 3, "Got count %lu.\n", count);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(count == 3, "Got count %u.\n", count);
 
     ref = IVMRFilterConfig9_Release(config);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 #define check_interface_broken(a, b, c) check_interface_(__LINE__, a, b, c, TRUE)
@@ -221,7 +220,7 @@ static HRESULT check_interface_(unsigned int line, void *iface, REFIID riid, BOO
 
     hr = IUnknown_QueryInterface(unknown, riid, (void **)&out);
     ok_(__FILE__, line)(hr == expected_hr || broken(is_broken && hr == broken_hr),
-            "Got hr %#lx, expected %#lx.\n", hr, expected_hr);
+            "Got hr %#x, expected %#x.\n", hr, expected_hr);
     if (SUCCEEDED(hr))
         IUnknown_Release(out);
     return hr;
@@ -247,7 +246,6 @@ static void test_common_interfaces(IBaseFilter *filter)
     check_interface(filter, &IID_IVMRFilterConfig9, TRUE);
     check_interface(filter, &IID_IVMRMixerBitmap9, TRUE);
 
-    check_interface(filter, &IID_IAMVideoAccelerator, FALSE);
     check_interface(filter, &IID_IBasicAudio, FALSE);
     check_interface(filter, &IID_IDirectDrawVideo, FALSE);
     check_interface(filter, &IID_IPersistPropertyBag, FALSE);
@@ -264,7 +262,6 @@ static void test_common_interfaces(IBaseFilter *filter)
 
     IBaseFilter_FindPin(filter, L"VMR Input0", &pin);
 
-    check_interface(pin, &IID_IAMVideoAccelerator, TRUE);
     check_interface(pin, &IID_IMemInputPin, TRUE);
     check_interface(pin, &IID_IOverlay, TRUE);
     check_interface(pin, &IID_IPin, TRUE);
@@ -297,7 +294,7 @@ static void test_interfaces(void)
     check_interface(filter, &IID_IVMRWindowlessControl9, FALSE);
 
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 
     filter = create_vmr9(VMR9Mode_Windowless);
     test_common_interfaces(filter);
@@ -314,7 +311,7 @@ static void test_interfaces(void)
     check_interface(filter, &IID_IVMRSurfaceAllocatorNotify9, FALSE);
 
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 
     filter = create_vmr9(VMR9Mode_Renderless);
     test_common_interfaces(filter);
@@ -328,7 +325,7 @@ static void test_interfaces(void)
     check_interface(filter, &IID_IVMRWindowlessControl9, FALSE);
 
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 
     filter = create_vmr9(VMR9Mode_Windowed);
     set_mixing_mode(filter, 1);
@@ -346,7 +343,7 @@ static void test_interfaces(void)
     check_interface(filter, &IID_IVMRWindowlessControl9, FALSE);
 
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 static const GUID test_iid = {0x33333333};
@@ -394,53 +391,53 @@ static void test_aggregation(void)
     filter = (IBaseFilter *)0xdeadbeef;
     hr = CoCreateInstance(&CLSID_VideoMixingRenderer9, &test_outer, CLSCTX_INPROC_SERVER,
             &IID_IBaseFilter, (void **)&filter);
-    ok(hr == E_NOINTERFACE, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOINTERFACE, "Got hr %#x.\n", hr);
     ok(!filter, "Got interface %p.\n", filter);
 
     hr = CoCreateInstance(&CLSID_VideoMixingRenderer9, &test_outer, CLSCTX_INPROC_SERVER,
             &IID_IUnknown, (void **)&unk);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(outer_ref == 1, "Got unexpected refcount %ld.\n", outer_ref);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
     ok(unk != &test_outer, "Returned IUnknown should not be outer IUnknown.\n");
     ref = get_refcount(unk);
-    ok(ref == 1, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
 
     ref = IUnknown_AddRef(unk);
-    ok(ref == 2, "Got unexpected refcount %ld.\n", ref);
-    ok(outer_ref == 1, "Got unexpected refcount %ld.\n", outer_ref);
+    ok(ref == 2, "Got unexpected refcount %d.\n", ref);
+    ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
 
     ref = IUnknown_Release(unk);
-    ok(ref == 1, "Got unexpected refcount %ld.\n", ref);
-    ok(outer_ref == 1, "Got unexpected refcount %ld.\n", outer_ref);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
+    ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
 
     hr = IUnknown_QueryInterface(unk, &IID_IUnknown, (void **)&unk2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(unk2 == unk, "Got unexpected IUnknown %p.\n", unk2);
     IUnknown_Release(unk2);
 
     hr = IUnknown_QueryInterface(unk, &IID_IBaseFilter, (void **)&filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_QueryInterface(filter, &IID_IUnknown, (void **)&unk2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(unk2 == (IUnknown *)0xdeadbeef, "Got unexpected IUnknown %p.\n", unk2);
 
     hr = IBaseFilter_QueryInterface(filter, &IID_IBaseFilter, (void **)&filter2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(filter2 == (IBaseFilter *)0xdeadbeef, "Got unexpected IBaseFilter %p.\n", filter2);
 
     hr = IUnknown_QueryInterface(unk, &test_iid, (void **)&unk2);
-    ok(hr == E_NOINTERFACE, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOINTERFACE, "Got hr %#x.\n", hr);
     ok(!unk2, "Got unexpected IUnknown %p.\n", unk2);
 
     hr = IBaseFilter_QueryInterface(filter, &test_iid, (void **)&unk2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(unk2 == (IUnknown *)0xdeadbeef, "Got unexpected IUnknown %p.\n", unk2);
 
     IBaseFilter_Release(filter);
     ref = IUnknown_Release(unk);
-    ok(!ref, "Got unexpected refcount %ld.\n", ref);
-    ok(outer_ref == 1, "Got unexpected refcount %ld.\n", outer_ref);
+    ok(!ref, "Got unexpected refcount %d.\n", ref);
+    ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
 }
 
 static void test_enum_pins(void)
@@ -452,79 +449,79 @@ static void test_enum_pins(void)
     HRESULT hr;
 
     ref = get_refcount(filter);
-    ok(ref == 1, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
 
     hr = IBaseFilter_EnumPins(filter, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_EnumPins(filter, &enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ref = get_refcount(filter);
-    ok(ref == 2, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 2, "Got unexpected refcount %d.\n", ref);
     ref = get_refcount(enum1);
-    ok(ref == 1, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
 
     hr = IEnumPins_Next(enum1, 1, NULL, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum1, 1, pins, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ref = get_refcount(filter);
-    ok(ref == 3, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 3, "Got unexpected refcount %d.\n", ref);
     ref = get_refcount(pins[0]);
-    ok(ref == 3, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 3, "Got unexpected refcount %d.\n", ref);
     ref = get_refcount(enum1);
-    ok(ref == 1, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
     IPin_Release(pins[0]);
     ref = get_refcount(filter);
-    ok(ref == 2, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 2, "Got unexpected refcount %d.\n", ref);
 
     hr = IEnumPins_Next(enum1, 1, pins, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum1, 1, pins, &count);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(count == 1, "Got count %lu.\n", count);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(count == 1, "Got count %u.\n", count);
     IPin_Release(pins[0]);
 
     hr = IEnumPins_Next(enum1, 1, pins, &count);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
-    ok(!count, "Got count %lu.\n", count);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    ok(!count, "Got count %u.\n", count);
 
     hr = IEnumPins_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum1, 2, pins, NULL);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum1, 2, pins, &count);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
-    ok(count == 1, "Got count %lu.\n", count);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    ok(count == 1, "Got count %u.\n", count);
     IPin_Release(pins[0]);
 
     hr = IEnumPins_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Clone(enum1, &enum2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Skip(enum1, 2);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Skip(enum1, 1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Skip(enum1, 1);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum1, 1, pins, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum2, 1, pins, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     IPin_Release(pins[0]);
 
     IEnumPins_Release(enum2);
@@ -532,43 +529,43 @@ static void test_enum_pins(void)
     set_mixing_mode(filter, 2);
 
     hr = IEnumPins_Next(enum1, 1, pins, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum1, 1, pins, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     IPin_Release(pins[0]);
 
     hr = IEnumPins_Next(enum1, 1, pins, NULL);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
     if (hr == S_OK) IPin_Release(pins[0]);
 
     hr = IEnumPins_Next(enum1, 1, pins, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum1, 2, pins, &count);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    todo_wine ok(count == 2, "Got count %lu.\n", count);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
+    todo_wine ok(count == 2, "Got count %u.\n", count);
     IPin_Release(pins[0]);
     if (count > 1) IPin_Release(pins[1]);
 
     hr = IEnumPins_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum1, 3, pins, &count);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
-    todo_wine ok(count == 2, "Got count %lu.\n", count);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    todo_wine ok(count == 2, "Got count %u.\n", count);
     IPin_Release(pins[0]);
     if (count > 1) IPin_Release(pins[1]);
 
     IEnumPins_Release(enum1);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 static void test_find_pin(void)
@@ -582,51 +579,51 @@ static void test_find_pin(void)
     IBaseFilter_EnumPins(filter, &enum_pins);
 
     hr = IBaseFilter_FindPin(filter, L"input pin", &pin);
-    ok(hr == VFW_E_NOT_FOUND, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_FOUND, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_FindPin(filter, L"In", &pin);
-    ok(hr == VFW_E_NOT_FOUND, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_FOUND, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_FindPin(filter, L"VMR Input0", &pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IEnumPins_Next(enum_pins, 1, &pin2, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(pin == pin2, "Pins did not match.\n");
     IPin_Release(pin);
     IPin_Release(pin2);
 
     hr = IBaseFilter_FindPin(filter, L"VMR Input1", &pin);
-    ok(hr == VFW_E_NOT_FOUND, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_FOUND, "Got hr %#x.\n", hr);
 
     set_mixing_mode(filter, 2);
 
     IEnumPins_Reset(enum_pins);
 
     hr = IBaseFilter_FindPin(filter, L"VMR Input0", &pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IEnumPins_Next(enum_pins, 1, &pin2, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(pin == pin2, "Pins did not match.\n");
     IPin_Release(pin);
     IPin_Release(pin2);
 
     hr = IBaseFilter_FindPin(filter, L"VMR Input1", &pin);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
     if (hr == S_OK)
     {
         hr = IEnumPins_Next(enum_pins, 1, &pin2, NULL);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
         ok(pin == pin2, "Pins did not match.\n");
         IPin_Release(pin);
         IPin_Release(pin2);
     }
 
     hr = IBaseFilter_FindPin(filter, L"VMR Input2", &pin);
-    ok(hr == VFW_E_NOT_FOUND, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_FOUND, "Got hr %#x.\n", hr);
 
     IEnumPins_Release(enum_pins);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 static void test_pin_info(void)
@@ -647,23 +644,23 @@ static void test_pin_info(void)
     IBaseFilter_Release(info.pFilter);
 
     hr = IPin_QueryDirection(pin, &dir);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(dir == PINDIR_INPUT, "Got direction %d.\n", dir);
 
     hr = IPin_QueryId(pin, &id);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(!wcscmp(id, L"VMR Input0"), "Got id %s.\n", wine_dbgstr_w(id));
     CoTaskMemFree(id);
 
     hr = IPin_QueryInternalConnections(pin, NULL, &count);
-    ok(hr == E_NOTIMPL, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOTIMPL, "Got hr %#x.\n", hr);
 
     IPin_Release(pin);
 
     set_mixing_mode(filter, 2);
 
     hr = IBaseFilter_FindPin(filter, L"VMR Input1", &pin);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
     if (hr == S_OK)
     {
         hr = IPin_QueryPinInfo(pin, &info);
@@ -673,22 +670,22 @@ static void test_pin_info(void)
         IBaseFilter_Release(info.pFilter);
 
         hr = IPin_QueryDirection(pin, &dir);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
         ok(dir == PINDIR_INPUT, "Got direction %d.\n", dir);
 
         hr = IPin_QueryId(pin, &id);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
         ok(!wcscmp(id, L"VMR Input1"), "Got id %s.\n", wine_dbgstr_w(id));
         CoTaskMemFree(id);
 
         hr = IPin_QueryInternalConnections(pin, NULL, &count);
-        ok(hr == E_NOTIMPL, "Got hr %#lx.\n", hr);
+        ok(hr == E_NOTIMPL, "Got hr %#x.\n", hr);
 
         IPin_Release(pin);
     }
 
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 static void test_media_types(void)
@@ -716,10 +713,10 @@ static void test_media_types(void)
     IBaseFilter_FindPin(filter, L"VMR Input0", &pin);
 
     hr = IPin_EnumMediaTypes(pin, &enummt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enummt, 1, &mt, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     IEnumMediaTypes_Release(enummt);
 
@@ -732,33 +729,33 @@ static void test_media_types(void)
     {
         req_mt.subtype = *subtype_tests[i];
         hr = IPin_QueryAccept(pin, &req_mt);
-        ok(hr == S_OK, "Got hr %#lx for subtype %s.\n", hr, wine_dbgstr_guid(subtype_tests[i]));
+        ok(hr == S_OK, "Got hr %#x for subtype %s.\n", hr, wine_dbgstr_guid(subtype_tests[i]));
     }
 
     req_mt.subtype = MEDIASUBTYPE_RGB8;
     hr = IPin_QueryAccept(pin, &req_mt);
-    todo_wine ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     req_mt.subtype = MEDIASUBTYPE_NULL;
     hr = IPin_QueryAccept(pin, &req_mt);
-    todo_wine ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     req_mt.subtype = MEDIASUBTYPE_RGB24;
 
     req_mt.majortype = MEDIATYPE_NULL;
     hr = IPin_QueryAccept(pin, &req_mt);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     req_mt.majortype = MEDIATYPE_Video;
 
     req_mt.formattype = FORMAT_None;
     hr = IPin_QueryAccept(pin, &req_mt);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     req_mt.formattype = GUID_NULL;
     hr = IPin_QueryAccept(pin, &req_mt);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     IPin_Release(pin);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 static void test_enum_media_types(void)
@@ -773,36 +770,36 @@ static void test_enum_media_types(void)
     IBaseFilter_FindPin(filter, L"VMR Input0", &pin);
 
     hr = IPin_EnumMediaTypes(pin, &enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enum1, 1, mts, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enum1, 1, mts, &count);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
-    ok(!count, "Got count %lu.\n", count);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    ok(!count, "Got count %u.\n", count);
 
     hr = IEnumMediaTypes_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enum1, 1, mts, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Clone(enum1, &enum2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Skip(enum1, 1);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enum2, 1, mts, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     IEnumMediaTypes_Release(enum1);
     IEnumMediaTypes_Release(enum2);
     IPin_Release(pin);
 
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 static void test_unconnected_filter_state(void)
@@ -813,53 +810,53 @@ static void test_unconnected_filter_state(void)
     ULONG ref;
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(state == State_Stopped, "Got state %u.\n", state);
 
     hr = IBaseFilter_Pause(filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(state == State_Paused, "Got state %u.\n", state);
 
     hr = IBaseFilter_Run(filter, 0);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(state == State_Running, "Got state %u.\n", state);
 
     hr = IBaseFilter_Pause(filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(state == State_Paused, "Got state %u.\n", state);
 
     hr = IBaseFilter_Stop(filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(state == State_Stopped, "Got state %u.\n", state);
 
     hr = IBaseFilter_Run(filter, 0);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(state == State_Running, "Got state %u.\n", state);
 
     hr = IBaseFilter_Stop(filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(state == State_Stopped, "Got state %u.\n", state);
 
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 struct testfilter
@@ -920,45 +917,45 @@ static void test_allocator(IMemInputPin *input)
     HRESULT hr;
 
     hr = IMemInputPin_GetAllocatorRequirements(input, &props);
-    ok(hr == E_NOTIMPL, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOTIMPL, "Got hr %#x.\n", hr);
 
     hr = IMemInputPin_GetAllocator(input, &ret_allocator);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     if (hr == S_OK)
     {
         hr = IMemAllocator_GetProperties(ret_allocator, &props);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
-        ok(!props.cBuffers, "Got %ld buffers.\n", props.cBuffers);
-        ok(!props.cbBuffer, "Got size %ld.\n", props.cbBuffer);
-        ok(!props.cbAlign, "Got alignment %ld.\n", props.cbAlign);
-        ok(!props.cbPrefix, "Got prefix %ld.\n", props.cbPrefix);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
+        ok(!props.cBuffers, "Got %d buffers.\n", props.cBuffers);
+        ok(!props.cbBuffer, "Got size %d.\n", props.cbBuffer);
+        ok(!props.cbAlign, "Got alignment %d.\n", props.cbAlign);
+        ok(!props.cbPrefix, "Got prefix %d.\n", props.cbPrefix);
 
         hr = IMemInputPin_NotifyAllocator(input, ret_allocator, TRUE);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
 
         req_props.cBuffers = 1;
         req_props.cbBuffer = 32 * 16 * 4;
         req_props.cbAlign = 1;
         req_props.cbPrefix = 0;
         hr = IMemAllocator_SetProperties(ret_allocator, &req_props, &props);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
-        ok(props.cBuffers == 1, "Got %ld buffers.\n", props.cBuffers);
-        ok(props.cbBuffer == 32 * 16 * 4, "Got size %ld.\n", props.cbBuffer);
-        ok(props.cbAlign == 1, "Got alignment %ld.\n", props.cbAlign);
-        ok(!props.cbPrefix, "Got prefix %ld.\n", props.cbPrefix);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
+        ok(props.cBuffers == 1, "Got %d buffers.\n", props.cBuffers);
+        ok(props.cbBuffer == 32 * 16 * 4, "Got size %d.\n", props.cbBuffer);
+        ok(props.cbAlign == 1, "Got alignment %d.\n", props.cbAlign);
+        ok(!props.cbPrefix, "Got prefix %d.\n", props.cbPrefix);
 
         IMemAllocator_Release(ret_allocator);
     }
 
     hr = IMemInputPin_NotifyAllocator(input, NULL, TRUE);
-    todo_wine ok(hr == E_FAIL, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == E_FAIL, "Got hr %#x.\n", hr);
 
     CoCreateInstance(&CLSID_MemoryAllocator, NULL, CLSCTX_INPROC_SERVER,
             &IID_IMemAllocator, (void **)&req_allocator);
 
     hr = IMemInputPin_NotifyAllocator(input, req_allocator, TRUE);
-    todo_wine ok(hr == E_FAIL, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == E_FAIL, "Got hr %#x.\n", hr);
 
     IMemAllocator_Release(req_allocator);
 }
@@ -974,9 +971,9 @@ static DWORD WINAPI frame_thread(void *arg)
     struct frame_thread_params *params = arg;
     HRESULT hr;
 
-    if (winetest_debug > 1) trace("%04lx: Sending frame.\n", GetCurrentThreadId());
+    if (winetest_debug > 1) trace("%04x: Sending frame.\n", GetCurrentThreadId());
     hr = IMemInputPin_Receive(params->sink, params->sample);
-    if (winetest_debug > 1) trace("%04lx: Returned %#lx.\n", GetCurrentThreadId(), hr);
+    if (winetest_debug > 1) trace("%04x: Returned %#x.\n", GetCurrentThreadId(), hr);
     IMediaSample_Release(params->sample);
     free(params);
     return hr;
@@ -994,27 +991,27 @@ static HANDLE send_frame_time(IMemInputPin *sink, REFERENCE_TIME start_time, DWO
     BYTE *data;
 
     hr = IMemInputPin_GetAllocator(sink, &allocator);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMemAllocator_GetBuffer(allocator, &sample, NULL, NULL, 0);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     size = IMediaSample_GetSize(sample);
     hr = IMediaSample_GetPointer(sample, &data);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     for (i = 0; i < size / sizeof(DWORD); ++i)
         ((DWORD *)data)[i] = color;
 
     hr = IMediaSample_SetActualDataLength(sample, size);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     start_time *= 10000000;
     end_time = start_time + 10000000;
     hr = IMediaSample_SetTime(sample, &start_time, &end_time);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaSample_SetPreroll(sample, TRUE);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     params->sink = sink;
     params->sample = sample;
@@ -1045,9 +1042,9 @@ static void commit_allocator(IMemInputPin *input)
     HRESULT hr;
 
     hr = IMemInputPin_GetAllocator(input, &allocator);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMemAllocator_Commit(allocator);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     IMemAllocator_Release(allocator);
 }
 
@@ -1061,130 +1058,130 @@ static void test_filter_state(IMemInputPin *input, IMediaControl *control)
 
     thread = send_frame(input);
     hr = join_thread(thread);
-    ok(hr == VFW_E_WRONG_STATE, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_WRONG_STATE, "Got hr %#x.\n", hr);
 
     /* The renderer is not fully paused until it receives a sample. The thread
      * sending the sample blocks in IMemInputPin_Receive() until the filter is
      * stopped or run. */
 
     hr = IMediaControl_Pause(control);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_GetState(control, 0, &state);
-    ok(hr == VFW_S_STATE_INTERMEDIATE, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_S_STATE_INTERMEDIATE, "Got hr %#x.\n", hr);
 
     thread = send_frame(input);
 
     hr = IMediaControl_GetState(control, 1000, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     ok(WaitForSingleObject(thread, 100) == WAIT_TIMEOUT, "Thread should block in Receive().\n");
 
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = join_thread(thread);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     /* The sink will decommit our allocator for us when stopping, however it
      * will not recommit it when pausing. */
     hr = IMemInputPin_GetAllocator(input, &allocator);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMemAllocator_GetBuffer(allocator, &sample, NULL, NULL, 0);
-    todo_wine ok(hr == VFW_E_NOT_COMMITTED, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == VFW_E_NOT_COMMITTED, "Got hr %#x.\n", hr);
     if (hr == S_OK) IMediaSample_Release(sample);
 
     hr = IMemAllocator_Commit(allocator);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     thread = send_frame(input);
     hr = join_thread(thread);
-    ok(hr == VFW_E_WRONG_STATE, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_WRONG_STATE, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_Pause(control);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_GetState(control, 0, &state);
-    ok(hr == VFW_S_STATE_INTERMEDIATE, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_S_STATE_INTERMEDIATE, "Got hr %#x.\n", hr);
 
     thread = send_frame(input);
 
     hr = IMediaControl_GetState(control, 1000, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     ok(WaitForSingleObject(thread, 100) == WAIT_TIMEOUT, "Thread should block in Receive().\n");
 
     hr = IMediaControl_Run(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_GetState(control, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = join_thread(thread);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     thread = send_frame(input);
     hr = join_thread(thread);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_Pause(control);
-    todo_wine ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_GetState(control, 0, &state);
-    todo_wine ok(hr == VFW_S_STATE_INTERMEDIATE, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == VFW_S_STATE_INTERMEDIATE, "Got hr %#x.\n", hr);
 
     thread = send_frame(input);
 
     hr = IMediaControl_GetState(control, 1000, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     ok(WaitForSingleObject(thread, 100) == WAIT_TIMEOUT, "Thread should block in Receive().\n");
 
     hr = IMediaControl_Run(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_GetState(control, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = join_thread(thread);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_Pause(control);
-    todo_wine ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_GetState(control, 0, &state);
-    todo_wine ok(hr == VFW_S_STATE_INTERMEDIATE, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == VFW_S_STATE_INTERMEDIATE, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_GetState(control, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     commit_allocator(input);
     hr = IMediaControl_Pause(control);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_GetState(control, 0, &state);
-    ok(hr == VFW_S_STATE_INTERMEDIATE, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_S_STATE_INTERMEDIATE, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_Run(control);
-    todo_wine ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_GetState(control, 0, &state);
-    todo_wine ok(hr == VFW_S_STATE_INTERMEDIATE, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == VFW_S_STATE_INTERMEDIATE, "Got hr %#x.\n", hr);
 
     thread = send_frame(input);
     hr = join_thread(thread);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_GetState(control, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_GetState(control, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     IMemAllocator_Release(allocator);
 }
@@ -1197,61 +1194,61 @@ static void test_flushing(IPin *pin, IMemInputPin *input, IMediaControl *control
 
     commit_allocator(input);
     hr = IMediaControl_Pause(control);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     thread = send_frame(input);
     ok(WaitForSingleObject(thread, 100) == WAIT_TIMEOUT, "Thread should block in Receive().\n");
 
     hr = IMediaControl_GetState(control, 1000, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IPin_BeginFlush(pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = join_thread(thread);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     thread = send_frame(input);
     hr = join_thread(thread);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IPin_EndFlush(pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     /* We dropped the sample we were holding, so now we need a new one... */
 
     hr = IMediaControl_GetState(control, 0, &state);
-    todo_wine ok(hr == VFW_S_STATE_INTERMEDIATE, "Got hr %#lx.\n", hr);
-    ok(state == State_Paused, "Got state %#lx.\n", state);
+    todo_wine ok(hr == VFW_S_STATE_INTERMEDIATE, "Got hr %#x.\n", hr);
+    ok(state == State_Paused, "Got state %#x.\n", state);
 
     thread = send_frame(input);
     ok(WaitForSingleObject(thread, 100) == WAIT_TIMEOUT, "Thread should block in Receive().\n");
 
     hr = IMediaControl_GetState(control, 1000, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(state == State_Paused, "Got state %#lx.\n", state);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(state == State_Paused, "Got state %#x.\n", state);
 
     hr = IMediaControl_Run(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = join_thread(thread);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IPin_BeginFlush(pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     thread = send_frame(input);
     hr = join_thread(thread);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IPin_EndFlush(pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     thread = send_frame(input);
     hr = join_thread(thread);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 }
 
 static unsigned int check_event_code(IMediaEvent *eventsrc, DWORD timeout, LONG expected_code, LONG_PTR expected1, LONG_PTR expected2)
@@ -1265,14 +1262,14 @@ static unsigned int check_event_code(IMediaEvent *eventsrc, DWORD timeout, LONG
     {
         if (code == expected_code)
         {
-            ok(param1 == expected1, "Got param1 %#Ix.\n", param1);
-            ok(param2 == expected2, "Got param2 %#Ix.\n", param2);
+            ok(param1 == expected1, "Got param1 %#lx.\n", param1);
+            ok(param2 == expected2, "Got param2 %#lx.\n", param2);
             ret++;
         }
         IMediaEvent_FreeEventParams(eventsrc, code, param1, param2);
         timeout = 0;
     }
-    ok(hr == E_ABORT, "Got hr %#lx.\n", hr);
+    ok(hr == E_ABORT, "Got hr %#x.\n", hr);
 
     return ret;
 }
@@ -1293,28 +1290,28 @@ static void test_eos(IPin *pin, IMemInputPin *input, IMediaControl *control)
 
     commit_allocator(input);
     hr = IMediaControl_Pause(control);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     ret = check_ec_complete(eventsrc, 0);
     ok(!ret, "Got unexpected EC_COMPLETE.\n");
 
     hr = IPin_EndOfStream(pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_GetState(control, 1000, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ret = check_ec_complete(eventsrc, 0);
     ok(!ret, "Got unexpected EC_COMPLETE.\n");
 
     hr = join_thread(send_frame(input));
-    todo_wine ok(hr == E_UNEXPECTED, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == E_UNEXPECTED, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_Run(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ret = check_ec_complete(eventsrc, 0);
     ok(ret == 1, "Expected EC_COMPLETE.\n");
 
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ret = check_ec_complete(eventsrc, 0);
     ok(!ret, "Got unexpected EC_COMPLETE.\n");
 
@@ -1323,23 +1320,23 @@ static void test_eos(IPin *pin, IMemInputPin *input, IMediaControl *control)
 
     commit_allocator(input);
     hr = IMediaControl_Run(control);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     hr = join_thread(send_frame(input));
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMediaControl_GetState(control, 1000, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ret = check_ec_complete(eventsrc, 0);
     ok(!ret, "Got unexpected EC_COMPLETE.\n");
 
     hr = IPin_EndOfStream(pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ret = check_ec_complete(eventsrc, 0);
     todo_wine ok(!ret, "Got unexpected EC_COMPLETE.\n");
     ret = check_ec_complete(eventsrc, 1600);
     todo_wine ok(ret == 1, "Expected EC_COMPLETE.\n");
 
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ret = check_ec_complete(eventsrc, 0);
     ok(!ret, "Got unexpected EC_COMPLETE.\n");
 
@@ -1347,19 +1344,19 @@ static void test_eos(IPin *pin, IMemInputPin *input, IMediaControl *control)
 
     commit_allocator(input);
     hr = IMediaControl_Run(control);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     hr = join_thread(send_frame(input));
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IPin_BeginFlush(pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IPin_EndOfStream(pin);
-    todo_wine ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     hr = IPin_EndFlush(pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ret = check_ec_complete(eventsrc, 0);
     todo_wine ok(!ret, "Got unexpected EC_COMPLETE.\n");
 
@@ -1367,31 +1364,31 @@ static void test_eos(IPin *pin, IMemInputPin *input, IMediaControl *control)
 
     commit_allocator(input);
     hr = IMediaControl_Run(control);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     hr = join_thread(send_frame(input));
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMediaControl_GetState(control, 1000, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IPin_EndOfStream(pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ret = check_ec_complete(eventsrc, 0);
     todo_wine ok(!ret, "Got unexpected EC_COMPLETE.\n");
 
     hr = IPin_BeginFlush(pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IPin_EndFlush(pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = join_thread(send_frame(input));
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IPin_EndOfStream(pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ret = check_ec_complete(eventsrc, 0);
     ok(!ret, "Got unexpected EC_COMPLETE.\n");
 
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ret = check_ec_complete(eventsrc, 0);
     ok(!ret, "Got unexpected EC_COMPLETE.\n");
 
@@ -1406,25 +1403,25 @@ static void test_sample_time(IPin *pin, IMemInputPin *input, IMediaControl *cont
 
     commit_allocator(input);
     hr = IMediaControl_Pause(control);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_GetState(control, 0, &state);
-    ok(hr == VFW_S_STATE_INTERMEDIATE, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_S_STATE_INTERMEDIATE, "Got hr %#x.\n", hr);
 
     thread = send_frame_time(input, 1, 0x000000ff); /* blue */
 
     hr = IMediaControl_GetState(control, 1000, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     ok(WaitForSingleObject(thread, 100) == WAIT_TIMEOUT, "Thread should block in Receive().\n");
 
     hr = IMediaControl_Run(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     ok(WaitForSingleObject(thread, 500) == WAIT_TIMEOUT, "Thread should block in Receive().\n");
 
     hr = join_thread(thread);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     /* Sample time is relative to the time passed to Run(). Thus a sample
      * stamped at or earlier than 1s will now be displayed immediately, because
@@ -1436,33 +1433,33 @@ static void test_sample_time(IPin *pin, IMemInputPin *input, IMediaControl *cont
      * discontinuous. */
 
     hr = join_thread(send_frame_time(input, 1, 0x0000ffff)); /* cyan */
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = join_thread(send_frame_time(input, 0, 0x0000ff00)); /* green */
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = join_thread(send_frame_time(input, -2, 0x00ff0000)); /* red */
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     thread = send_frame_time(input, 1000000, 0x00ffffff); /* white */
     ok(WaitForSingleObject(thread, 100) == WAIT_TIMEOUT, "Thread should block in Receive().\n");
 
     hr = IPin_BeginFlush(pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = join_thread(thread);
     /* If the frame makes it to Receive() in time to be rendered, we get S_OK. */
-    ok(hr == S_OK || hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK || hr == S_FALSE, "Got hr %#x.\n", hr);
     hr = IPin_EndFlush(pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     thread = send_frame_time(input, 1000000, 0x00ffff00); /* yellow */
     ok(WaitForSingleObject(thread, 100) == WAIT_TIMEOUT, "Thread should block in Receive().\n");
 
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = join_thread(thread);
     /* If the frame makes it to Receive() in time to be rendered, we get S_OK. */
-    ok(hr == S_OK || hr == VFW_E_WRONG_STATE, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK || hr == VFW_E_WRONG_STATE, "Got hr %#x.\n", hr);
 }
 
 static void test_current_image(IBaseFilter *filter, IMemInputPin *input,
@@ -1484,68 +1481,68 @@ static void test_current_image(IBaseFilter *filter, IMemInputPin *input,
     IBaseFilter_QueryInterface(filter, &IID_IBasicVideo, (void **)&video);
 
     hr = IBasicVideo_GetCurrentImage(video, NULL, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_GetCurrentImage(video, NULL, buffer);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
 
     size = 0xdeadbeef;
     hr = IBasicVideo_GetCurrentImage(video, &size, NULL);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    todo_wine ok(size == sizeof(BITMAPINFOHEADER) + 32 * 16 * 4, "Got size %ld.\n", size);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
+    todo_wine ok(size == sizeof(BITMAPINFOHEADER) + 32 * 16 * 4, "Got size %d.\n", size);
 
     size = sizeof(buffer);
     hr = IBasicVideo_GetCurrentImage(video, &size, buffer);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(size == sizeof(buffer), "Got size %ld.\n", size);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(size == sizeof(buffer), "Got size %d.\n", size);
     ok(!memcmp(bih, &expect_bih, sizeof(BITMAPINFOHEADER)), "Bitmap headers didn't match.\n");
     /* The contents seem to reflect the last frame rendered. */
 
     commit_allocator(input);
     hr = IMediaControl_Pause(control);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     size = sizeof(buffer);
     hr = IBasicVideo_GetCurrentImage(video, &size, buffer);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(size == sizeof(buffer), "Got size %ld.\n", size);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(size == sizeof(buffer), "Got size %d.\n", size);
     ok(!memcmp(bih, &expect_bih, sizeof(BITMAPINFOHEADER)), "Bitmap headers didn't match.\n");
     /* The contents seem to reflect the last frame rendered. */
 
     thread = send_frame(input);
     hr = IMediaControl_GetState(control, 1000, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     size = 1;
     memset(buffer, 0xcc, sizeof(buffer));
     hr = IBasicVideo_GetCurrentImage(video, &size, buffer);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(size == 1, "Got size %ld.\n", size);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(size == 1, "Got size %d.\n", size);
 
     size = sizeof(buffer);
     memset(buffer, 0xcc, sizeof(buffer));
     hr = IBasicVideo_GetCurrentImage(video, &size, buffer);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(size == sizeof(buffer), "Got size %ld.\n", size);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(size == sizeof(buffer), "Got size %d.\n", size);
     ok(!memcmp(bih, &expect_bih, sizeof(BITMAPINFOHEADER)), "Bitmap headers didn't match.\n");
     for (i = 0; i < 32 * 16; ++i)
-        ok((data[i] & 0xffffff) == 0x7f007f, "Got unexpected color %08lx at %u.\n", data[i], i);
+        ok((data[i] & 0xffffff) == 0x7f007f, "Got unexpected color %08x at %u.\n", data[i], i);
 
     hr = IMediaControl_Run(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     join_thread(thread);
 
     size = sizeof(buffer);
     memset(buffer, 0xcc, sizeof(buffer));
     hr = IBasicVideo_GetCurrentImage(video, &size, buffer);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(size == sizeof(buffer), "Got size %ld.\n", size);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(size == sizeof(buffer), "Got size %d.\n", size);
     ok(!memcmp(bih, &expect_bih, sizeof(BITMAPINFOHEADER)), "Bitmap headers didn't match.\n");
     for (i = 0; i < 32 * 16; ++i)
-        ok((data[i] & 0xffffff) == 0x7f007f, "Got unexpected color %08lx at %u.\n", data[i], i);
+        ok((data[i] & 0xffffff) == 0x7f007f, "Got unexpected color %08x at %u.\n", data[i], i);
 
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     IBasicVideo_Release(video);
 }
@@ -1569,19 +1566,19 @@ static void test_window_close(IPin *pin, IMemInputPin *input, IMediaControl *con
     IPin_QueryInterface(pin, &IID_IOverlay, (void **)&overlay);
 
     hr = IOverlay_GetWindowHandle(overlay, &hwnd);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     IOverlay_Release(overlay);
 
     commit_allocator(input);
     hr = IMediaControl_Pause(control);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     ret = check_ec_userabort(eventsrc, 0);
     ok(!ret, "Got unexpected EC_USERABORT.\n");
 
     SendMessageW(hwnd, WM_CLOSE, 0, 0);
 
     hr = IMediaControl_GetState(control, 1000, &state);
-    ok(hr == VFW_S_STATE_INTERMEDIATE, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_S_STATE_INTERMEDIATE, "Got hr %#x.\n", hr);
     ret = check_ec_userabort(eventsrc, 0);
     ok(ret == 1, "Expected EC_USERABORT.\n");
 
@@ -1594,17 +1591,17 @@ static void test_window_close(IPin *pin, IMemInputPin *input, IMediaControl *con
     if (ret == WAIT_OBJECT_0)
     {
         GetExitCodeThread(thread, (DWORD *)&hr);
-        ok(hr == E_UNEXPECTED, "Got hr %#lx.\n", hr);
+        ok(hr == E_UNEXPECTED, "Got hr %#x.\n", hr);
     }
     CloseHandle(thread);
 
     hr = IMediaControl_Run(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ret = check_ec_userabort(eventsrc, 0);
     ok(!ret, "Got unexpected EC_USERABORT.\n");
 
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ret = check_ec_userabort(eventsrc, 0);
     ok(!ret, "Got unexpected EC_USERABORT.\n");
 
@@ -1612,11 +1609,11 @@ static void test_window_close(IPin *pin, IMemInputPin *input, IMediaControl *con
 
     commit_allocator(input);
     hr = IMediaControl_Run(control);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     hr = join_thread(send_frame(input));
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMediaControl_GetState(control, 1000, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ret = check_ec_userabort(eventsrc, 0);
     ok(!ret, "Got unexpected EC_USERABORT.\n");
 
@@ -1629,7 +1626,7 @@ static void test_window_close(IPin *pin, IMemInputPin *input, IMediaControl *con
     ok(!IsWindowVisible(hwnd), "Window should be visible.\n");
 
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ret = check_ec_userabort(eventsrc, 0);
     ok(!ret, "Got unexpected EC_USERABORT.\n");
 
@@ -1699,54 +1696,54 @@ static void test_connect_pin(void)
                 skip("Got E_FAIL when connecting.\n");
                 goto out;
             }
-            ok(hr == S_OK, "Got hr %#lx for subtype %s and bpp %u.\n", hr,
+            ok(hr == S_OK, "Got hr %#x for subtype %s and bpp %u.\n", hr,
                     wine_dbgstr_guid(subtype_tests[i]), bpp_tests[j]);
 
             hr = IFilterGraph2_Disconnect(graph, &source.source.pin.IPin_iface);
-            ok(hr == S_OK, "Got hr %#lx.\n", hr);
+            ok(hr == S_OK, "Got hr %#x.\n", hr);
             hr = IFilterGraph2_Disconnect(graph, pin);
-            ok(hr == S_OK, "Got hr %#lx.\n", hr);
+            ok(hr == S_OK, "Got hr %#x.\n", hr);
         }
     }
 
     req_mt.formattype = FORMAT_None;
     hr = IFilterGraph2_ConnectDirect(graph, &source.source.pin.IPin_iface, pin, &req_mt);
-    ok(hr == VFW_E_TYPE_NOT_ACCEPTED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_TYPE_NOT_ACCEPTED, "Got hr %#x.\n", hr);
     req_mt.formattype = FORMAT_VideoInfo;
 
     req_mt.subtype = MEDIASUBTYPE_RGB8;
     hr = IFilterGraph2_ConnectDirect(graph, &source.source.pin.IPin_iface, pin, &req_mt);
-    ok(hr == VFW_E_TYPE_NOT_ACCEPTED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_TYPE_NOT_ACCEPTED, "Got hr %#x.\n", hr);
     req_mt.subtype = MEDIASUBTYPE_WAVE;
     hr = IFilterGraph2_ConnectDirect(graph, &source.source.pin.IPin_iface, pin, &req_mt);
-    ok(hr == VFW_E_TYPE_NOT_ACCEPTED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_TYPE_NOT_ACCEPTED, "Got hr %#x.\n", hr);
     req_mt.subtype = MEDIASUBTYPE_RGB32;
 
     peer = (IPin *)0xdeadbeef;
     hr = IPin_ConnectedTo(pin, &peer);
-    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#x.\n", hr);
     ok(!peer, "Got peer %p.\n", peer);
 
     hr = IPin_ConnectionMediaType(pin, &mt);
-    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_Pause(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IFilterGraph2_ConnectDirect(graph, &source.source.pin.IPin_iface, pin, &req_mt);
-    ok(hr == VFW_E_NOT_STOPPED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_STOPPED, "Got hr %#x.\n", hr);
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IFilterGraph2_ConnectDirect(graph, &source.source.pin.IPin_iface, pin, &req_mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IPin_ConnectedTo(pin, &peer);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(peer == &source.source.pin.IPin_iface, "Got peer %p.\n", peer);
     IPin_Release(peer);
 
     hr = IPin_ConnectionMediaType(pin, &mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(compare_media_types(&mt, &req_mt), "Media types didn't match.\n");
 
     /* Disconnecting while not stopped is broken: it returns S_OK, but
@@ -1755,16 +1752,16 @@ static void test_connect_pin(void)
     test_allocator(input);
 
     hr = IMemInputPin_GetAllocator(input, &allocator);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMemAllocator_SetProperties(allocator, &req_props, &ret_props);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(!memcmp(&ret_props, &req_props, sizeof(req_props)), "Properties did not match.\n");
     hr = IMemAllocator_Commit(allocator);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     IMemAllocator_Release(allocator);
 
     hr = IMemInputPin_ReceiveCanBlock(input);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     test_filter_state(input, control);
     test_flushing(pin, input, control);
@@ -1774,30 +1771,30 @@ static void test_connect_pin(void)
     test_window_close(pin, input, control);
 
     hr = IFilterGraph2_Disconnect(graph, pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IFilterGraph2_Disconnect(graph, pin);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     ok(source.source.pin.peer == pin, "Got peer %p.\n", source.source.pin.peer);
     IFilterGraph2_Disconnect(graph, &source.source.pin.IPin_iface);
 
     peer = (IPin *)0xdeadbeef;
     hr = IPin_ConnectedTo(pin, &peer);
-    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#x.\n", hr);
     ok(!peer, "Got peer %p.\n", peer);
 
     hr = IPin_ConnectionMediaType(pin, &mt);
-    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#x.\n", hr);
 
 out:
     IMediaControl_Release(control);
     ref = IFilterGraph2_Release(graph);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     IMemInputPin_Release(input);
     IPin_Release(pin);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ref = IBaseFilter_Release(&source.filter.IBaseFilter_iface);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 static void test_overlay(void)
@@ -1812,49 +1809,49 @@ static void test_overlay(void)
     IBaseFilter_FindPin(filter, L"VMR Input0", &pin);
 
     hr = IPin_QueryInterface(pin, &IID_IOverlay, (void **)&overlay);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hwnd = (HWND)0xdeadbeef;
     hr = IOverlay_GetWindowHandle(overlay, &hwnd);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(hwnd && hwnd != (HWND)0xdeadbeef, "Got invalid window %p.\n", hwnd);
 
     IOverlay_Release(overlay);
     IPin_Release(pin);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 
     filter = create_vmr9(VMR9Mode_Windowless);
     IBaseFilter_FindPin(filter, L"VMR Input0", &pin);
 
     hr = IPin_QueryInterface(pin, &IID_IOverlay, (void **)&overlay);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hwnd = (HWND)0xdeadbeef;
     hr = IOverlay_GetWindowHandle(overlay, &hwnd);
-    ok(hr == VFW_E_WRONG_STATE, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_WRONG_STATE, "Got hr %#x.\n", hr);
     ok(hwnd == (HWND)0xdeadbeef, "Got window %p.\n", hwnd);
 
     IOverlay_Release(overlay);
     IPin_Release(pin);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 
     filter = create_vmr9(VMR9Mode_Renderless);
     IBaseFilter_FindPin(filter, L"VMR Input0", &pin);
 
     hr = IPin_QueryInterface(pin, &IID_IOverlay, (void **)&overlay);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hwnd = (HWND)0xdeadbeef;
     hr = IOverlay_GetWindowHandle(overlay, &hwnd);
-    ok(hr == VFW_E_WRONG_STATE, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_WRONG_STATE, "Got hr %#x.\n", hr);
     ok(hwnd == (HWND)0xdeadbeef, "Got window %p.\n", hwnd);
 
     IOverlay_Release(overlay);
     IPin_Release(pin);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 /* try to make sure pending X events have been processed before continuing */
@@ -1878,7 +1875,7 @@ static void flush_events(void)
 static LRESULT CALLBACK window_proc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam)
 {
     if (winetest_debug > 1)
-        trace("hwnd %p, msg %#x, wparam %#Ix, lparam %#Ix.\n", hwnd, msg, wparam, lparam);
+        trace("hwnd %p, msg %#x, wparam %#lx, lparam %#lx.\n", hwnd, msg, wparam, lparam);
 
     if (wparam == 0xdeadbeef)
         return 0;
@@ -1893,7 +1890,7 @@ static void test_video_window_caption(IVideoWindow *window, HWND hwnd)
     HRESULT hr;
 
     hr = IVideoWindow_get_Caption(window, &caption);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(!wcscmp(caption, L"ActiveMovie Window"), "Got caption %s.\n", wine_dbgstr_w(caption));
     SysFreeString(caption);
 
@@ -1902,11 +1899,11 @@ static void test_video_window_caption(IVideoWindow *window, HWND hwnd)
 
     caption = SysAllocString(L"foo");
     hr = IVideoWindow_put_Caption(window, caption);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     SysFreeString(caption);
 
     hr = IVideoWindow_get_Caption(window, &caption);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(!wcscmp(caption, L"foo"), "Got caption %s.\n", wine_dbgstr_w(caption));
     SysFreeString(caption);
 
@@ -1920,53 +1917,53 @@ static void test_video_window_style(IVideoWindow *window, HWND hwnd, HWND our_hw
     LONG style;
 
     hr = IVideoWindow_get_WindowStyle(window, &style);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(style == (WS_CLIPSIBLINGS | WS_CLIPCHILDREN | WS_OVERLAPPEDWINDOW),
-            "Got style %#lx.\n", style);
+            "Got style %#x.\n", style);
 
     style = GetWindowLongA(hwnd, GWL_STYLE);
     ok(style == (WS_CLIPSIBLINGS | WS_CLIPCHILDREN | WS_OVERLAPPEDWINDOW),
-            "Got style %#lx.\n", style);
+            "Got style %#x.\n", style);
 
     hr = IVideoWindow_put_WindowStyle(window, style | WS_DISABLED);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
     hr = IVideoWindow_put_WindowStyle(window, style | WS_HSCROLL);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
     hr = IVideoWindow_put_WindowStyle(window, style | WS_VSCROLL);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
     hr = IVideoWindow_put_WindowStyle(window, style | WS_MAXIMIZE);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
     hr = IVideoWindow_put_WindowStyle(window, style | WS_MINIMIZE);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_put_WindowStyle(window, style & ~WS_CLIPCHILDREN);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_get_WindowStyle(window, &style);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(style == (WS_CLIPSIBLINGS | WS_OVERLAPPEDWINDOW), "Got style %#lx.\n", style);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(style == (WS_CLIPSIBLINGS | WS_OVERLAPPEDWINDOW), "Got style %#x.\n", style);
 
     style = GetWindowLongA(hwnd, GWL_STYLE);
-    ok(style == (WS_CLIPSIBLINGS | WS_OVERLAPPEDWINDOW), "Got style %#lx.\n", style);
+    ok(style == (WS_CLIPSIBLINGS | WS_OVERLAPPEDWINDOW), "Got style %#x.\n", style);
 
     ok(GetActiveWindow() == our_hwnd, "Got active window %p.\n", GetActiveWindow());
 
     hr = IVideoWindow_get_WindowStyleEx(window, &style);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(style == WS_EX_WINDOWEDGE, "Got style %#lx.\n", style);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(style == WS_EX_WINDOWEDGE, "Got style %#x.\n", style);
 
     style = GetWindowLongA(hwnd, GWL_EXSTYLE);
-    ok(style == WS_EX_WINDOWEDGE, "Got style %#lx.\n", style);
+    ok(style == WS_EX_WINDOWEDGE, "Got style %#x.\n", style);
 
     hr = IVideoWindow_put_WindowStyleEx(window, style | WS_EX_TRANSPARENT);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_get_WindowStyleEx(window, &style);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(style == (WS_EX_WINDOWEDGE | WS_EX_TRANSPARENT), "Got style %#lx.\n", style);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(style == (WS_EX_WINDOWEDGE | WS_EX_TRANSPARENT), "Got style %#x.\n", style);
 
     style = GetWindowLongA(hwnd, GWL_EXSTYLE);
-    ok(style == (WS_EX_WINDOWEDGE | WS_EX_TRANSPARENT), "Got style %#lx.\n", style);
+    ok(style == (WS_EX_WINDOWEDGE | WS_EX_TRANSPARENT), "Got style %#x.\n", style);
 }
 
 static BOOL CALLBACK top_window_cb(HWND hwnd, LPARAM ctx)
@@ -1997,25 +1994,25 @@ static void test_video_window_state(IVideoWindow *window, HWND hwnd, HWND our_hw
     SetWindowPos(our_hwnd, HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);
 
     hr = IVideoWindow_get_WindowState(window, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(state == SW_HIDE, "Got state %ld.\n", state);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(state == SW_HIDE, "Got state %d.\n", state);
 
     hr = IVideoWindow_get_Visible(window, &state);
-    ok(state == OAFALSE, "Got state %ld.\n", state);
+    ok(state == OAFALSE, "Got state %d.\n", state);
 
     ok(!IsWindowVisible(hwnd), "Window should not be visible.\n");
     ok(!IsIconic(hwnd), "Window should not be minimized.\n");
     ok(!IsZoomed(hwnd), "Window should not be maximized.\n");
 
     hr = IVideoWindow_put_WindowState(window, SW_SHOWNA);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_get_WindowState(window, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(state == SW_SHOW, "Got state %ld.\n", state);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(state == SW_SHOW, "Got state %d.\n", state);
 
     hr = IVideoWindow_get_Visible(window, &state);
-    ok(state == OATRUE, "Got state %ld.\n", state);
+    ok(state == OATRUE, "Got state %d.\n", state);
 
     ok(IsWindowVisible(hwnd), "Window should be visible.\n");
     ok(!IsIconic(hwnd), "Window should not be minimized.\n");
@@ -2025,14 +2022,14 @@ static void test_video_window_state(IVideoWindow *window, HWND hwnd, HWND our_hw
     ok(top == hwnd, "Got top window %p.\n", top);
 
     hr = IVideoWindow_put_WindowState(window, SW_MINIMIZE);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_get_WindowState(window, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(state == SW_MINIMIZE, "Got state %ld.\n", state);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(state == SW_MINIMIZE, "Got state %d.\n", state);
 
     hr = IVideoWindow_get_Visible(window, &state);
-    ok(state == OATRUE, "Got state %ld.\n", state);
+    ok(state == OATRUE, "Got state %d.\n", state);
 
     ok(IsWindowVisible(hwnd), "Window should be visible.\n");
     ok(IsIconic(hwnd), "Window should be minimized.\n");
@@ -2040,14 +2037,14 @@ static void test_video_window_state(IVideoWindow *window, HWND hwnd, HWND our_hw
     ok(GetActiveWindow() == our_hwnd, "Got active window %p.\n", GetActiveWindow());
 
     hr = IVideoWindow_put_WindowState(window, SW_RESTORE);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_get_WindowState(window, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(state == SW_SHOW, "Got state %ld.\n", state);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(state == SW_SHOW, "Got state %d.\n", state);
 
     hr = IVideoWindow_get_Visible(window, &state);
-    ok(state == OATRUE, "Got state %ld.\n", state);
+    ok(state == OATRUE, "Got state %d.\n", state);
 
     ok(IsWindowVisible(hwnd), "Window should be visible.\n");
     ok(!IsIconic(hwnd), "Window should not be minimized.\n");
@@ -2055,14 +2052,14 @@ static void test_video_window_state(IVideoWindow *window, HWND hwnd, HWND our_hw
     ok(GetActiveWindow() == hwnd, "Got active window %p.\n", GetActiveWindow());
 
     hr = IVideoWindow_put_WindowState(window, SW_MAXIMIZE);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_get_WindowState(window, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(state == SW_MAXIMIZE, "Got state %ld.\n", state);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(state == SW_MAXIMIZE, "Got state %d.\n", state);
 
     hr = IVideoWindow_get_Visible(window, &state);
-    ok(state == OATRUE, "Got state %ld.\n", state);
+    ok(state == OATRUE, "Got state %d.\n", state);
 
     ok(IsWindowVisible(hwnd), "Window should be visible.\n");
     ok(!IsIconic(hwnd), "Window should be minimized.\n");
@@ -2070,17 +2067,17 @@ static void test_video_window_state(IVideoWindow *window, HWND hwnd, HWND our_hw
     ok(GetActiveWindow() == hwnd, "Got active window %p.\n", GetActiveWindow());
 
     hr = IVideoWindow_put_WindowState(window, SW_RESTORE);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_put_WindowState(window, SW_HIDE);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_get_WindowState(window, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(state == SW_HIDE, "Got state %ld.\n", state);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(state == SW_HIDE, "Got state %d.\n", state);
 
     hr = IVideoWindow_get_Visible(window, &state);
-    ok(state == OAFALSE, "Got state %ld.\n", state);
+    ok(state == OAFALSE, "Got state %d.\n", state);
 
     ok(!IsWindowVisible(hwnd), "Window should not be visible.\n");
     ok(!IsIconic(hwnd), "Window should not be minimized.\n");
@@ -2088,14 +2085,14 @@ static void test_video_window_state(IVideoWindow *window, HWND hwnd, HWND our_hw
     ok(GetActiveWindow() == our_hwnd, "Got active window %p.\n", GetActiveWindow());
 
     hr = IVideoWindow_put_Visible(window, OATRUE);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_get_WindowState(window, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(state == SW_SHOW, "Got state %ld.\n", state);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(state == SW_SHOW, "Got state %d.\n", state);
 
     hr = IVideoWindow_get_Visible(window, &state);
-    ok(state == OATRUE, "Got state %ld.\n", state);
+    ok(state == OATRUE, "Got state %d.\n", state);
 
     ok(IsWindowVisible(hwnd), "Window should be visible.\n");
     ok(!IsIconic(hwnd), "Window should not be minimized.\n");
@@ -2103,14 +2100,14 @@ static void test_video_window_state(IVideoWindow *window, HWND hwnd, HWND our_hw
     ok(GetActiveWindow() == hwnd, "Got active window %p.\n", GetActiveWindow());
 
     hr = IVideoWindow_put_Visible(window, OAFALSE);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_get_WindowState(window, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(state == SW_HIDE, "Got state %ld.\n", state);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(state == SW_HIDE, "Got state %d.\n", state);
 
     hr = IVideoWindow_get_Visible(window, &state);
-    ok(state == OAFALSE, "Got state %ld.\n", state);
+    ok(state == OAFALSE, "Got state %d.\n", state);
 
     ok(!IsWindowVisible(hwnd), "Window should not be visible.\n");
     ok(!IsIconic(hwnd), "Window should not be minimized.\n");
@@ -2118,14 +2115,14 @@ static void test_video_window_state(IVideoWindow *window, HWND hwnd, HWND our_hw
     ok(GetActiveWindow() == our_hwnd, "Got active window %p.\n", GetActiveWindow());
 
     hr = IVideoWindow_put_WindowState(window, SW_SHOWNA);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_SetWindowForeground(window, TRUE);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
 
     SetWindowPos(our_hwnd, HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);
     hr = IVideoWindow_SetWindowForeground(window, OATRUE);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(GetActiveWindow() == hwnd, "Got active window %p.\n", GetActiveWindow());
     ok(GetFocus() == hwnd, "Got focus window %p.\n", GetFocus());
     ok(GetForegroundWindow() == hwnd, "Got foreground window %p.\n", GetForegroundWindow());
@@ -2133,7 +2130,7 @@ static void test_video_window_state(IVideoWindow *window, HWND hwnd, HWND our_hw
     ok(top == hwnd, "Got top window %p.\n", top);
 
     hr = IVideoWindow_SetWindowForeground(window, OAFALSE);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(GetActiveWindow() == hwnd, "Got active window %p.\n", GetActiveWindow());
     ok(GetFocus() == hwnd, "Got focus window %p.\n", GetFocus());
     ok(GetForegroundWindow() == hwnd, "Got foreground window %p.\n", GetForegroundWindow());
@@ -2142,7 +2139,7 @@ static void test_video_window_state(IVideoWindow *window, HWND hwnd, HWND our_hw
 
     SetWindowPos(our_hwnd, HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);
     hr = IVideoWindow_SetWindowForeground(window, OAFALSE);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(GetActiveWindow() == our_hwnd, "Got active window %p.\n", GetActiveWindow());
     ok(GetFocus() == our_hwnd, "Got focus window %p.\n", GetFocus());
     ok(GetForegroundWindow() == our_hwnd, "Got foreground window %p.\n", GetForegroundWindow());
@@ -2164,114 +2161,114 @@ static void test_video_window_position(IVideoWindow *window, HWND hwnd, HWND our
     expect_height = rect.bottom - rect.top;
 
     hr = IVideoWindow_put_Left(window, 0);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IVideoWindow_put_Top(window, 0);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_get_Left(window, &left);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(left == 0, "Got left %ld.\n", left);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(left == 0, "Got left %d.\n", left);
     hr = IVideoWindow_get_Top(window, &top);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(top == 0, "Got top %ld.\n", top);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(top == 0, "Got top %d.\n", top);
     hr = IVideoWindow_get_Width(window, &width);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(width == expect_width, "Got width %ld.\n", width);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(width == expect_width, "Got width %d.\n", width);
     hr = IVideoWindow_get_Height(window, &height);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(height == expect_height, "Got height %ld.\n", height);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(height == expect_height, "Got height %d.\n", height);
     hr = IVideoWindow_GetWindowPosition(window, &left, &top, &width, &height);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(left == 0, "Got left %ld.\n", left);
-    ok(top == 0, "Got top %ld.\n", top);
-    ok(width == expect_width, "Got width %ld.\n", width);
-    ok(height == expect_height, "Got height %ld.\n", height);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(left == 0, "Got left %d.\n", left);
+    ok(top == 0, "Got top %d.\n", top);
+    ok(width == expect_width, "Got width %d.\n", width);
+    ok(height == expect_height, "Got height %d.\n", height);
     GetWindowRect(hwnd, &rect);
-    ok(rect.left == 0, "Got window left %ld.\n", rect.left);
-    ok(rect.top == 0, "Got window top %ld.\n", rect.top);
-    ok(rect.right == expect_width, "Got window right %ld.\n", rect.right);
-    ok(rect.bottom == expect_height, "Got window bottom %ld.\n", rect.bottom);
+    ok(rect.left == 0, "Got window left %d.\n", rect.left);
+    ok(rect.top == 0, "Got window top %d.\n", rect.top);
+    ok(rect.right == expect_width, "Got window right %d.\n", rect.right);
+    ok(rect.bottom == expect_height, "Got window bottom %d.\n", rect.bottom);
 
     hr = IVideoWindow_put_Left(window, 10);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_get_Left(window, &left);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(left == 10, "Got left %ld.\n", left);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(left == 10, "Got left %d.\n", left);
     hr = IVideoWindow_get_Top(window, &top);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(top == 0, "Got top %ld.\n", top);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(top == 0, "Got top %d.\n", top);
     hr = IVideoWindow_get_Width(window, &width);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(width == expect_width, "Got width %ld.\n", width);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(width == expect_width, "Got width %d.\n", width);
     hr = IVideoWindow_get_Height(window, &height);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(height == expect_height, "Got height %ld.\n", height);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(height == expect_height, "Got height %d.\n", height);
     hr = IVideoWindow_GetWindowPosition(window, &left, &top, &width, &height);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(left == 10, "Got left %ld.\n", left);
-    ok(top == 0, "Got top %ld.\n", top);
-    ok(width == expect_width, "Got width %ld.\n", width);
-    ok(height == expect_height, "Got height %ld.\n", height);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(left == 10, "Got left %d.\n", left);
+    ok(top == 0, "Got top %d.\n", top);
+    ok(width == expect_width, "Got width %d.\n", width);
+    ok(height == expect_height, "Got height %d.\n", height);
     GetWindowRect(hwnd, &rect);
-    ok(rect.left == 10, "Got window left %ld.\n", rect.left);
-    ok(rect.top == 0, "Got window top %ld.\n", rect.top);
-    ok(rect.right == 10 + expect_width, "Got window right %ld.\n", rect.right);
-    ok(rect.bottom == expect_height, "Got window bottom %ld.\n", rect.bottom);
+    ok(rect.left == 10, "Got window left %d.\n", rect.left);
+    ok(rect.top == 0, "Got window top %d.\n", rect.top);
+    ok(rect.right == 10 + expect_width, "Got window right %d.\n", rect.right);
+    ok(rect.bottom == expect_height, "Got window bottom %d.\n", rect.bottom);
 
     hr = IVideoWindow_put_Height(window, 200);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_get_Left(window, &left);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(left == 10, "Got left %ld.\n", left);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(left == 10, "Got left %d.\n", left);
     hr = IVideoWindow_get_Top(window, &top);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(top == 0, "Got top %ld.\n", top);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(top == 0, "Got top %d.\n", top);
     hr = IVideoWindow_get_Width(window, &width);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(width == expect_width, "Got width %ld.\n", width);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(width == expect_width, "Got width %d.\n", width);
     hr = IVideoWindow_get_Height(window, &height);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(height == 200, "Got height %ld.\n", height);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(height == 200, "Got height %d.\n", height);
     hr = IVideoWindow_GetWindowPosition(window, &left, &top, &width, &height);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(left == 10, "Got left %ld.\n", left);
-    ok(top == 0, "Got top %ld.\n", top);
-    ok(width == expect_width, "Got width %ld.\n", width);
-    ok(height == 200, "Got height %ld.\n", height);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(left == 10, "Got left %d.\n", left);
+    ok(top == 0, "Got top %d.\n", top);
+    ok(width == expect_width, "Got width %d.\n", width);
+    ok(height == 200, "Got height %d.\n", height);
     GetWindowRect(hwnd, &rect);
-    ok(rect.left == 10, "Got window left %ld.\n", rect.left);
-    ok(rect.top == 0, "Got window top %ld.\n", rect.top);
-    ok(rect.right == 10 + expect_width, "Got window right %ld.\n", rect.right);
-    ok(rect.bottom == 200, "Got window bottom %ld.\n", rect.bottom);
+    ok(rect.left == 10, "Got window left %d.\n", rect.left);
+    ok(rect.top == 0, "Got window top %d.\n", rect.top);
+    ok(rect.right == 10 + expect_width, "Got window right %d.\n", rect.right);
+    ok(rect.bottom == 200, "Got window bottom %d.\n", rect.bottom);
 
     hr = IVideoWindow_SetWindowPosition(window, 100, 200, 300, 400);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_get_Left(window, &left);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(left == 100, "Got left %ld.\n", left);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(left == 100, "Got left %d.\n", left);
     hr = IVideoWindow_get_Top(window, &top);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(top == 200, "Got top %ld.\n", top);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(top == 200, "Got top %d.\n", top);
     hr = IVideoWindow_get_Width(window, &width);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(width == 300, "Got width %ld.\n", width);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(width == 300, "Got width %d.\n", width);
     hr = IVideoWindow_get_Height(window, &height);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(height == 400, "Got height %ld.\n", height);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(height == 400, "Got height %d.\n", height);
     hr = IVideoWindow_GetWindowPosition(window, &left, &top, &width, &height);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(left == 100, "Got left %ld.\n", left);
-    ok(top == 200, "Got top %ld.\n", top);
-    ok(width == 300, "Got width %ld.\n", width);
-    ok(height == 400, "Got height %ld.\n", height);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(left == 100, "Got left %d.\n", left);
+    ok(top == 200, "Got top %d.\n", top);
+    ok(width == 300, "Got width %d.\n", width);
+    ok(height == 400, "Got height %d.\n", height);
     GetWindowRect(hwnd, &rect);
-    ok(rect.left == 100, "Got window left %ld.\n", rect.left);
-    ok(rect.top == 200, "Got window top %ld.\n", rect.top);
-    ok(rect.right == 400, "Got window right %ld.\n", rect.right);
-    ok(rect.bottom == 600, "Got window bottom %ld.\n", rect.bottom);
+    ok(rect.left == 100, "Got window left %d.\n", rect.left);
+    ok(rect.top == 200, "Got window top %d.\n", rect.top);
+    ok(rect.right == 400, "Got window right %d.\n", rect.right);
+    ok(rect.bottom == 600, "Got window bottom %d.\n", rect.bottom);
 
     ok(GetActiveWindow() == our_hwnd, "Got active window %p.\n", GetActiveWindow());
     top_hwnd = get_top_window();
@@ -2288,25 +2285,25 @@ static void test_video_window_owner(IVideoWindow *window, HWND hwnd, HWND our_hw
     SetWindowPos(our_hwnd, HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);
 
     hr = IVideoWindow_get_Owner(window, &oahwnd);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(!oahwnd, "Got owner %#Ix.\n", oahwnd);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(!oahwnd, "Got owner %#lx.\n", oahwnd);
 
     parent = GetAncestor(hwnd, GA_PARENT);
     ok(parent == GetDesktopWindow(), "Got parent %p.\n", parent);
     style = GetWindowLongA(hwnd, GWL_STYLE);
-    ok(!(style & WS_CHILD), "Got style %#lx.\n", style);
+    ok(!(style & WS_CHILD), "Got style %#x.\n", style);
 
     hr = IVideoWindow_put_Owner(window, (OAHWND)our_hwnd);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_get_Owner(window, &oahwnd);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(oahwnd == (OAHWND)our_hwnd, "Got owner %#Ix.\n", oahwnd);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(oahwnd == (OAHWND)our_hwnd, "Got owner %#lx.\n", oahwnd);
 
     parent = GetAncestor(hwnd, GA_PARENT);
     ok(parent == our_hwnd, "Got parent %p.\n", parent);
     style = GetWindowLongA(hwnd, GWL_STYLE);
-    ok((style & WS_CHILD), "Got style %#lx.\n", style);
+    ok((style & WS_CHILD), "Got style %#x.\n", style);
 
     ok(GetActiveWindow() == our_hwnd, "Got active window %p.\n", GetActiveWindow());
     top_hwnd = get_top_window();
@@ -2315,31 +2312,31 @@ static void test_video_window_owner(IVideoWindow *window, HWND hwnd, HWND our_hw
     ShowWindow(our_hwnd, SW_HIDE);
 
     hr = IVideoWindow_put_Visible(window, OATRUE);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_get_Visible(window, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(state == OAFALSE, "Got state %ld.\n", state);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(state == OAFALSE, "Got state %d.\n", state);
 
     hr = IVideoWindow_put_Owner(window, 0);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_get_Owner(window, &oahwnd);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(!oahwnd, "Got owner %#Ix.\n", oahwnd);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(!oahwnd, "Got owner %#lx.\n", oahwnd);
 
     parent = GetAncestor(hwnd, GA_PARENT);
     ok(parent == GetDesktopWindow(), "Got parent %p.\n", parent);
     style = GetWindowLongA(hwnd, GWL_STYLE);
-    ok(!(style & WS_CHILD), "Got style %#lx.\n", style);
+    ok(!(style & WS_CHILD), "Got style %#x.\n", style);
 
     ok(GetActiveWindow() == hwnd, "Got active window %p.\n", GetActiveWindow());
     top_hwnd = get_top_window();
     ok(top_hwnd == hwnd, "Got top window %p.\n", top_hwnd);
 
     hr = IVideoWindow_get_Visible(window, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(state == OATRUE, "Got state %ld.\n", state);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(state == OATRUE, "Got state %d.\n", state);
 }
 
 struct notify_message_params
@@ -2353,7 +2350,7 @@ static DWORD CALLBACK notify_message_proc(void *arg)
 {
     const struct notify_message_params *params = arg;
     HRESULT hr = IVideoWindow_NotifyOwnerMessage(params->window, (OAHWND)params->hwnd, params->message, 0, 0);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     return 0;
 }
 
@@ -2396,15 +2393,15 @@ static void test_video_window_messages(IVideoWindow *window, HWND hwnd, HWND our
     flush_events();
 
     hr = IVideoWindow_get_MessageDrain(window, &oahwnd);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(!oahwnd, "Got window %#Ix.\n", oahwnd);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(!oahwnd, "Got window %#lx.\n", oahwnd);
 
     hr = IVideoWindow_put_MessageDrain(window, (OAHWND)our_hwnd);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_get_MessageDrain(window, &oahwnd);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(oahwnd == (OAHWND)our_hwnd, "Got window %#Ix.\n", oahwnd);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(oahwnd == (OAHWND)our_hwnd, "Got window %#lx.\n", oahwnd);
 
     for (i = 0; i < ARRAY_SIZE(drain_tests); ++i)
     {
@@ -2413,8 +2410,8 @@ static void test_video_window_messages(IVideoWindow *window, HWND hwnd, HWND our
         ok(ret, "Expected a message.\n");
         ok(msg.hwnd == our_hwnd, "Got hwnd %p.\n", msg.hwnd);
         ok(msg.message == drain_tests[i], "Got message %#x.\n", msg.message);
-        ok(msg.wParam == 0xdeadbeef, "Got wparam %#Ix.\n", msg.wParam);
-        ok(!msg.lParam, "Got lparam %#Ix.\n", msg.lParam);
+        ok(msg.wParam == 0xdeadbeef, "Got wparam %#lx.\n", msg.wParam);
+        ok(!msg.lParam, "Got lparam %#lx.\n", msg.lParam);
         DispatchMessageA(&msg);
 
         ret = PeekMessageA(&msg, 0, drain_tests[i], drain_tests[i], PM_REMOVE);
@@ -2422,10 +2419,10 @@ static void test_video_window_messages(IVideoWindow *window, HWND hwnd, HWND our
     }
 
     hr = IVideoWindow_put_MessageDrain(window, 0);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_put_Owner(window, (OAHWND)our_hwnd);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     flush_events();
 
@@ -2434,7 +2431,7 @@ static void test_video_window_messages(IVideoWindow *window, HWND hwnd, HWND our
      * posted all messages. */
 
     hr = IVideoWindow_NotifyOwnerMessage(window, (OAHWND)our_hwnd, WM_SYSCOLORCHANGE, 0, 0);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     while (PeekMessageA(&msg, 0, 0, 0, PM_REMOVE))
     {
@@ -2443,7 +2440,7 @@ static void test_video_window_messages(IVideoWindow *window, HWND hwnd, HWND our
     }
 
     hr = IVideoWindow_NotifyOwnerMessage(window, (OAHWND)our_hwnd, WM_FONTCHANGE, 0, 0);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     while (PeekMessageA(&msg, 0, 0, 0, PM_REMOVE))
     {
@@ -2480,7 +2477,7 @@ static void test_video_window_messages(IVideoWindow *window, HWND hwnd, HWND our
     }
 
     hr = IVideoWindow_put_Owner(window, 0);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 }
 
 static void test_video_window_autoshow(IVideoWindow *window, IFilterGraph2 *graph, HWND hwnd)
@@ -2492,41 +2489,41 @@ static void test_video_window_autoshow(IVideoWindow *window, IFilterGraph2 *grap
     IFilterGraph2_QueryInterface(graph, &IID_IMediaControl, (void **)&control);
 
     hr = IVideoWindow_get_AutoShow(window, &l);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(l == OATRUE, "Got %ld.\n", l);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(l == OATRUE, "Got %d.\n", l);
 
     hr = IVideoWindow_put_Visible(window, OAFALSE);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_Pause(control);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_get_Visible(window, &l);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(l == OATRUE, "Got %ld.\n", l);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(l == OATRUE, "Got %d.\n", l);
 
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_get_Visible(window, &l);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(l == OATRUE, "Got %ld.\n", l);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(l == OATRUE, "Got %d.\n", l);
 
     hr = IVideoWindow_put_AutoShow(window, OAFALSE);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_put_Visible(window, OAFALSE);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_Pause(control);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_get_Visible(window, &l);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(l == OAFALSE, "Got %ld.\n", l);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(l == OAFALSE, "Got %d.\n", l);
 
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     IMediaControl_Release(control);
 }
@@ -2586,27 +2583,27 @@ static void test_video_window(void)
     IPin_QueryInterface(pin, &IID_IMemInputPin, (void **)&input);
 
     hr = IPin_QueryInterface(pin, &IID_IOverlay, (void **)&overlay);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IOverlay_GetWindowHandle(overlay, &hwnd);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     if (winetest_debug > 1) trace("ours %p, theirs %p\n", our_hwnd, hwnd);
     GetWindowRect(hwnd, &rect);
 
     tid = GetWindowThreadProcessId(hwnd, NULL);
-    ok(tid == GetCurrentThreadId(), "Expected tid %#lx, got %#lx.\n", GetCurrentThreadId(), tid);
+    ok(tid == GetCurrentThreadId(), "Expected tid %#x, got %#x.\n", GetCurrentThreadId(), tid);
 
     hr = IBaseFilter_QueryInterface(filter, &IID_IVideoWindow, (void **)&window);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_get_Caption(window, &caption);
-    todo_wine ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_get_WindowStyle(window, &l);
-    todo_wine ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_get_AutoShow(window, &l);
-    todo_wine ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#x.\n", hr);
 
     testfilter_init(&source);
     IFilterGraph2_AddFilter(graph, &source.filter.IBaseFilter_iface, NULL);
@@ -2618,17 +2615,17 @@ static void test_video_window(void)
         skip("Got E_FAIL when connecting.\n");
         goto out;
     }
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMemInputPin_GetAllocator(input, &allocator);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
     if (hr == S_OK)
     {
         hr = IMemAllocator_SetProperties(allocator, &req_props, &ret_props);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
         ok(!memcmp(&ret_props, &req_props, sizeof(req_props)), "Properties did not match.\n");
         hr = IMemAllocator_Commit(allocator);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
         IMemAllocator_Release(allocator);
     }
 
@@ -2643,34 +2640,34 @@ static void test_video_window(void)
     test_video_window_messages(window, hwnd, our_hwnd);
 
     hr = IVideoWindow_put_FullScreenMode(window, OATRUE);
-    ok(hr == E_NOTIMPL, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOTIMPL, "Got hr %#x.\n", hr);
     hr = IVideoWindow_get_FullScreenMode(window, &l);
-    ok(hr == E_NOTIMPL, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOTIMPL, "Got hr %#x.\n", hr);
 
     hr = IVideoWindow_GetMinIdealImageSize(window, &width, &height);
-    todo_wine ok(hr == VFW_E_WRONG_STATE, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == VFW_E_WRONG_STATE, "Got hr %#x.\n", hr);
     hr = IVideoWindow_GetMaxIdealImageSize(window, &width, &height);
-    todo_wine ok(hr == VFW_E_WRONG_STATE, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == VFW_E_WRONG_STATE, "Got hr %#x.\n", hr);
 
     hr = IMediaControl_Pause(control);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     monitorinfo.cbSize = sizeof(monitorinfo);
     GetMonitorInfoW(MonitorFromWindow(hwnd, MONITOR_DEFAULTTOPRIMARY), &monitorinfo);
 
     hr = IVideoWindow_GetMinIdealImageSize(window, &width, &height);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    todo_wine ok(width == 1, "Got width %ld.\n", width);
-    todo_wine ok(height == 1, "Got height %ld.\n", height);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    todo_wine ok(width == 1, "Got width %d.\n", width);
+    todo_wine ok(height == 1, "Got height %d.\n", height);
     hr = IVideoWindow_GetMaxIdealImageSize(window, &width, &height);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    todo_wine ok(width == monitorinfo.rcMonitor.right + 1, "Expected width %ld, got %ld.\n",
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    todo_wine ok(width == monitorinfo.rcMonitor.right + 1, "Expected width %d, got %d.\n",
             monitorinfo.rcMonitor.right + 1, width);
-    todo_wine ok(height == monitorinfo.rcMonitor.bottom + 1, "Expected height %ld, got %ld.\n",
+    todo_wine ok(height == monitorinfo.rcMonitor.bottom + 1, "Expected height %d, got %d.\n",
             monitorinfo.rcMonitor.bottom + 1, height);
 
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
 out:
     IMediaControl_Release(control);
@@ -2680,9 +2677,9 @@ out:
     IMemInputPin_Release(input);
     IPin_Release(pin);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ref = IBaseFilter_Release(&source.filter.IBaseFilter_iface);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     DestroyWindow(our_hwnd);
 }
 
@@ -2709,7 +2706,7 @@ static IDirect3DDevice9 *create_device(HWND window)
     IDirect3D9_Release(d3d);
     if (FAILED(hr))
     {
-        skip("Failed to create a 3D device, hr %#lx.\n", hr);
+        skip("Failed to create a 3D device, hr %#x.\n", hr);
         return NULL;
     }
     return device;
@@ -2754,7 +2751,7 @@ static void test_allocate_surface_helper(void)
 
     count = 2;
     hr = IVMRSurfaceAllocatorNotify9_AllocateSurfaceHelper(notify, &info, &count, surfaces);
-    todo_wine ok(hr == E_FAIL, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == E_FAIL, "Got hr %#x.\n", hr);
 
     hr = IVMRSurfaceAllocatorNotify9_SetD3DDevice(notify, device, MonitorFromWindow(window, MONITOR_DEFAULTTOPRIMARY));
     if (hr == E_NOINTERFACE)
@@ -2762,42 +2759,42 @@ static void test_allocate_surface_helper(void)
         win_skip("Direct3D does not support video rendering.\n");
         goto out;
     }
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     if (0) /* crashes on Windows */
     {
         hr = IVMRSurfaceAllocatorNotify9_AllocateSurfaceHelper(notify, NULL, &count, surfaces);
-        ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+        ok(hr == E_POINTER, "Got hr %#x.\n", hr);
 
         hr = IVMRSurfaceAllocatorNotify9_AllocateSurfaceHelper(notify, &info, NULL, surfaces);
-        ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+        ok(hr == E_POINTER, "Got hr %#x.\n", hr);
     }
 
     hr = IVMRSurfaceAllocatorNotify9_AllocateSurfaceHelper(notify, &info, &count, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
 
     hr = IVMRSurfaceAllocatorNotify9_AllocateSurfaceHelper(notify, &info, &count, surfaces);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(count == 2, "Got count %lu.\n", count);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(count == 2, "Got count %u.\n", count);
     ok(!!surfaces[0], "Surface 0 was not allocated.\n");
     ok(!!surfaces[1], "Surface 1 was not allocated.\n");
 
     hr = IDirect3DSurface9_GetDevice(surfaces[0], &device2);
-    ok(hr == D3D_OK, "Got hr %#lx.\n", hr);
+    ok(hr == D3D_OK, "Got hr %#x.\n", hr);
     ok(device2 == device, "Devices did not match.\n");
     IDirect3DDevice9_Release(device2);
 
     hr = IDirect3DSurface9_GetContainer(surfaces[0], &IID_IDirect3DTexture9, (void **)&container);
-    ok(hr == E_NOINTERFACE, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOINTERFACE, "Got hr %#x.\n", hr);
 
     hr = IDirect3DSurface9_GetDesc(surfaces[0], &desc);
-    ok(hr == D3D_OK, "Got hr %#lx.\n", hr);
+    ok(hr == D3D_OK, "Got hr %#x.\n", hr);
     ok(desc.Format == info.Format, "Got format %#x.\n", desc.Format);
     ok(desc.Type == D3DRTYPE_SURFACE, "Got type %u.\n", desc.Type);
-    ok(!desc.Usage, "Got usage %#lx.\n", desc.Usage);
+    ok(!desc.Usage, "Got usage %#x.\n", desc.Usage);
     ok(desc.Pool == D3DPOOL_DEFAULT, "Got pool %u.\n", desc.Pool);
     ok(desc.MultiSampleType == D3DMULTISAMPLE_NONE, "Got multisample type %u.\n", desc.MultiSampleType);
-    ok(!desc.MultiSampleQuality, "Got multisample quality %lu.\n", desc.MultiSampleQuality);
+    ok(!desc.MultiSampleQuality, "Got multisample quality %u.\n", desc.MultiSampleQuality);
     ok(desc.Width == 32, "Got width %u.\n", desc.Width);
     ok(desc.Height == 16, "Got height %u.\n", desc.Height);
 
@@ -2807,16 +2804,16 @@ static void test_allocate_surface_helper(void)
     surfaces[0] = surfaces[1] = NULL;
     count = 1;
     hr = IVMRSurfaceAllocatorNotify9_AllocateSurfaceHelper(notify, &info, &count, surfaces);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    todo_wine ok(!count, "Got count %lu.\n", count);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
+    todo_wine ok(!count, "Got count %u.\n", count);
     ok(!surfaces[0], "Surface 0 was allocated.\n");
     ok(!surfaces[1], "Surface 1 was allocated.\n");
 
     count = 2;
     info.MinBuffers = 1;
     hr = IVMRSurfaceAllocatorNotify9_AllocateSurfaceHelper(notify, &info, &count, surfaces);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(count == 2, "Got count %lu.\n", count);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(count == 2, "Got count %u.\n", count);
     ok(!!surfaces[0], "Surface 0 was not allocated.\n");
     ok(!!surfaces[1], "Surface 1 was not allocated.\n");
     IDirect3DSurface9_Release(surfaces[0]);
@@ -2826,28 +2823,28 @@ static void test_allocate_surface_helper(void)
     info.dwFlags = VMR9AllocFlag_TextureSurface;
     surfaces[0] = surfaces[1] = NULL;
     hr = IVMRSurfaceAllocatorNotify9_AllocateSurfaceHelper(notify, &info, &count, surfaces);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(count == 2, "Got count %lu.\n", count);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(count == 2, "Got count %u.\n", count);
     ok(!!surfaces[0], "Surface 0 was not allocated.\n");
     ok(!!surfaces[1], "Surface 1 was not allocated.\n");
 
     hr = IDirect3DSurface9_GetDevice(surfaces[0], &device2);
-    ok(hr == D3D_OK, "Got hr %#lx.\n", hr);
+    ok(hr == D3D_OK, "Got hr %#x.\n", hr);
     ok(device2 == device, "Devices did not match.\n");
     IDirect3DDevice9_Release(device2);
 
     hr = IDirect3DSurface9_GetContainer(surfaces[0], &IID_IDirect3DTexture9, (void **)&container);
-    ok(hr == D3D_OK, "Got hr %#lx.\n", hr);
+    ok(hr == D3D_OK, "Got hr %#x.\n", hr);
     IDirect3DTexture9_Release(container);
 
     hr = IDirect3DSurface9_GetDesc(surfaces[1], &desc);
-    ok(hr == D3D_OK, "Got hr %#lx.\n", hr);
+    ok(hr == D3D_OK, "Got hr %#x.\n", hr);
     ok(desc.Format == info.Format, "Got format %#x.\n", desc.Format);
     ok(desc.Type == D3DRTYPE_SURFACE, "Got type %u.\n", desc.Type);
-    ok(desc.Usage == D3DUSAGE_DYNAMIC, "Got usage %#lx.\n", desc.Usage);
+    ok(desc.Usage == D3DUSAGE_DYNAMIC, "Got usage %#x.\n", desc.Usage);
     ok(desc.Pool == D3DPOOL_DEFAULT, "Got pool %u.\n", desc.Pool);
     ok(desc.MultiSampleType == D3DMULTISAMPLE_NONE, "Got multisample type %u.\n", desc.MultiSampleType);
-    ok(!desc.MultiSampleQuality, "Got multisample quality %lu.\n", desc.MultiSampleQuality);
+    ok(!desc.MultiSampleQuality, "Got multisample quality %u.\n", desc.MultiSampleQuality);
     ok(desc.Width == 32, "Got width %u.\n", desc.Width);
     ok(desc.Height == 16, "Got height %u.\n", desc.Height);
 
@@ -2857,8 +2854,8 @@ static void test_allocate_surface_helper(void)
     info.Format = D3DFMT_R8G8B8;
     surfaces[0] = surfaces[1] = NULL;
     hr = IVMRSurfaceAllocatorNotify9_AllocateSurfaceHelper(notify, &info, &count, surfaces);
-    ok(hr == D3DERR_INVALIDCALL, "Got hr %#lx.\n", hr);
-    ok(!count, "Got count %lu.\n", count);
+    ok(hr == D3DERR_INVALIDCALL, "Got hr %#x.\n", hr);
+    ok(!count, "Got count %u.\n", count);
     ok(!surfaces[0], "Surface 0 was allocated.\n");
     ok(!surfaces[1], "Surface 1 was allocated.\n");
 
@@ -2866,19 +2863,19 @@ static void test_allocate_surface_helper(void)
     info.dwFlags = VMR9AllocFlag_3DRenderTarget;
     count = 1;
     hr = IVMRSurfaceAllocatorNotify9_AllocateSurfaceHelper(notify, &info, &count, surfaces);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(count == 1, "Got count %lu.\n", count);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(count == 1, "Got count %u.\n", count);
     ok(!!surfaces[0], "Surface 0 was not allocated.\n");
     ok(info.Format != 0, "Expected a format.\n");
 
     hr = IDirect3DSurface9_GetDesc(surfaces[0], &desc);
-    ok(hr == D3D_OK, "Got hr %#lx.\n", hr);
+    ok(hr == D3D_OK, "Got hr %#x.\n", hr);
     ok(desc.Format == info.Format, "Expected format %#x, got %#x.\n", info.Format, desc.Format);
     ok(desc.Type == D3DRTYPE_SURFACE, "Got type %u.\n", desc.Type);
-    ok(desc.Usage == D3DUSAGE_RENDERTARGET, "Got usage %#lx.\n", desc.Usage);
+    ok(desc.Usage == D3DUSAGE_RENDERTARGET, "Got usage %#x.\n", desc.Usage);
     ok(desc.Pool == D3DPOOL_DEFAULT, "Got pool %u.\n", desc.Pool);
     ok(desc.MultiSampleType == D3DMULTISAMPLE_NONE, "Got multisample type %u.\n", desc.MultiSampleType);
-    ok(!desc.MultiSampleQuality, "Got multisample quality %lu.\n", desc.MultiSampleQuality);
+    ok(!desc.MultiSampleQuality, "Got multisample quality %u.\n", desc.MultiSampleQuality);
     ok(desc.Width == 32, "Got width %u.\n", desc.Width);
     ok(desc.Height == 16, "Got height %u.\n", desc.Height);
 
@@ -2888,15 +2885,15 @@ static void test_allocate_surface_helper(void)
     info.dwFlags = VMR9AllocFlag_OffscreenSurface | VMR9AllocFlag_TextureSurface;
     count = 1;
     hr = IVMRSurfaceAllocatorNotify9_AllocateSurfaceHelper(notify, &info, &count, surfaces);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
-    ok(count == 1, "Got count %lu.\n", count);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
+    ok(count == 1, "Got count %u.\n", count);
 
 out:
     IVMRSurfaceAllocatorNotify9_Release(notify);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ref = IDirect3DDevice9_Release(device);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     DestroyWindow(window);
 }
 
@@ -2939,14 +2936,14 @@ static ULONG WINAPI presenter_Release(IVMRImagePresenter9 *iface)
 static HRESULT WINAPI presenter_StartPresenting(IVMRImagePresenter9 *iface, DWORD_PTR cookie)
 {
     if (winetest_debug > 1) trace("StartPresenting()\n");
-    ok(cookie == 0xabacab, "Got cookie %#Ix.\n", cookie);
+    ok(cookie == 0xabacab, "Got cookie %#lx.\n", cookie);
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI presenter_StopPresenting(IVMRImagePresenter9 *iface, DWORD_PTR cookie)
 {
     if (winetest_debug > 1) trace("StopPresenting()\n");
-    ok(cookie == 0xabacab, "Got cookie %#Ix.\n", cookie);
+    ok(cookie == 0xabacab, "Got cookie %#lx.\n", cookie);
     return E_NOTIMPL;
 }
 
@@ -2956,16 +2953,16 @@ static HRESULT WINAPI presenter_PresentImage(IVMRImagePresenter9 *iface, DWORD_P
     static const RECT rect;
 
     if (winetest_debug > 1) trace("PresentImage()\n");
-    ok(cookie == 0xabacab, "Got cookie %#Ix.\n", cookie);
-    todo_wine ok(info->dwFlags == VMR9Sample_TimeValid, "Got flags %#lx.\n", info->dwFlags);
+    ok(cookie == 0xabacab, "Got cookie %#lx.\n", cookie);
+    todo_wine ok(info->dwFlags == VMR9Sample_TimeValid, "Got flags %#x.\n", info->dwFlags);
     ok(!info->rtStart, "Got start time %s.\n", wine_dbgstr_longlong(info->rtStart));
     ok(info->rtEnd == 10000000, "Got end time %s.\n", wine_dbgstr_longlong(info->rtEnd));
-    todo_wine ok(info->szAspectRatio.cx == 120, "Got aspect ratio width %ld.\n", info->szAspectRatio.cx);
-    todo_wine ok(info->szAspectRatio.cy == 60, "Got aspect ratio height %ld.\n", info->szAspectRatio.cy);
+    todo_wine ok(info->szAspectRatio.cx == 120, "Got aspect ratio width %d.\n", info->szAspectRatio.cx);
+    todo_wine ok(info->szAspectRatio.cy == 60, "Got aspect ratio height %d.\n", info->szAspectRatio.cy);
     ok(EqualRect(&info->rcSrc, &rect), "Got source rect %s.\n", wine_dbgstr_rect(&info->rcSrc));
     ok(EqualRect(&info->rcDst, &rect), "Got dest rect %s.\n", wine_dbgstr_rect(&info->rcDst));
-    ok(!info->dwReserved1, "Got dwReserved1 %#lx.\n", info->dwReserved1);
-    ok(!info->dwReserved2, "Got dwReserved2 %#lx.\n", info->dwReserved2);
+    ok(!info->dwReserved1, "Got dwReserved1 %#x.\n", info->dwReserved1);
+    ok(!info->dwReserved2, "Got dwReserved2 %#x.\n", info->dwReserved2);
 
     ++presenter->got_PresentImage;
     return S_OK;
@@ -3020,18 +3017,18 @@ static HRESULT WINAPI allocator_InitializeDevice(IVMRSurfaceAllocator9 *iface,
 {
     struct presenter *presenter = impl_from_IVMRSurfaceAllocator9(iface);
 
-    if (winetest_debug > 1) trace("InitializeDevice(flags %#lx, format %u)\n",
+    if (winetest_debug > 1) trace("InitializeDevice(flags %#x, format %u)\n",
             info->dwFlags, info->Format);
-    ok(cookie == 0xabacab, "Got cookie %#Ix.\n", cookie);
-    ok(info->dwWidth == 32, "Got width %lu.\n", info->dwWidth);
-    ok(info->dwHeight == 16, "Got height %lu.\n", info->dwHeight);
-    todo_wine ok(info->MinBuffers == 5, "Got buffer count %lu.\n", info->MinBuffers);
+    ok(cookie == 0xabacab, "Got cookie %#lx.\n", cookie);
+    ok(info->dwWidth == 32, "Got width %u.\n", info->dwWidth);
+    ok(info->dwHeight == 16, "Got height %u.\n", info->dwHeight);
+    todo_wine ok(info->MinBuffers == 5, "Got buffer count %u.\n", info->MinBuffers);
     ok(info->Pool == D3DPOOL_DEFAULT, "Got pool %u\n", info->Pool);
-    todo_wine ok(info->szAspectRatio.cx == 120, "Got aspect ratio width %ld.\n", info->szAspectRatio.cx);
-    todo_wine ok(info->szAspectRatio.cy == 60, "Got aspect ratio height %ld.\n", info->szAspectRatio.cy);
-    ok(info->szNativeSize.cx == 32, "Got native width %ld.\n", info->szNativeSize.cx);
-    ok(info->szNativeSize.cy == 16, "Got native height %ld.\n", info->szNativeSize.cy);
-    todo_wine ok(*buffer_count == 5, "Got buffer count %lu.\n", *buffer_count);
+    todo_wine ok(info->szAspectRatio.cx == 120, "Got aspect ratio width %d.\n", info->szAspectRatio.cx);
+    todo_wine ok(info->szAspectRatio.cy == 60, "Got aspect ratio height %d.\n", info->szAspectRatio.cy);
+    ok(info->szNativeSize.cx == 32, "Got native width %d.\n", info->szNativeSize.cx);
+    ok(info->szNativeSize.cy == 16, "Got native height %d.\n", info->szNativeSize.cy);
+    todo_wine ok(*buffer_count == 5, "Got buffer count %u.\n", *buffer_count);
 
     presenter->format = info->Format;
 
@@ -3046,7 +3043,7 @@ static HRESULT WINAPI allocator_TerminateDevice(IVMRSurfaceAllocator9 *iface, DW
     struct presenter *presenter = impl_from_IVMRSurfaceAllocator9(iface);
 
     if (winetest_debug > 1) trace("TerminateDevice()\n");
-    ok(cookie == 0xabacab, "Got cookie %#Ix.\n", cookie);
+    ok(cookie == 0xabacab, "Got cookie %#lx.\n", cookie);
     /* Don't dereference the surfaces here, to mimic How to Survive. */
     ++presenter->got_TerminateDevice;
     return E_NOTIMPL;
@@ -3057,10 +3054,10 @@ static HRESULT WINAPI allocator_GetSurface(IVMRSurfaceAllocator9 *iface,
 {
     struct presenter *presenter = impl_from_IVMRSurfaceAllocator9(iface);
 
-    if (winetest_debug > 1) trace("GetSurface(index %lu)\n", index);
-    ok(cookie == 0xabacab, "Got cookie %#Ix.\n", cookie);
-    ok(!flags, "Got flags %#lx.\n", flags);
-    ok(index < 5, "Got index %lu.\n", index);
+    if (winetest_debug > 1) trace("GetSurface(index %u)\n", index);
+    ok(cookie == 0xabacab, "Got cookie %#lx.\n", cookie);
+    ok(!flags, "Got flags %#x.\n", flags);
+    ok(index < 5, "Got index %u.\n", index);
 
     /* Don't reference the surface here, to mimic How to Survive. */
     *surface = presenter->surfaces[index];
@@ -3097,10 +3094,10 @@ static void test_renderless_present(struct presenter *presenter,
     presenter->got_PresentImage = 0;
 
     hr = IMediaControl_Pause(control);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     thread = send_frame(input);
     hr = IMediaControl_GetState(control, 1000, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     /* Atelier Sophie uses the VMR in renderless mode, calls
      * IMediaControl::Run() from a stopped state and expects that
      * IMediaControl::GetState() returns S_OK only after PresentImage() has
@@ -3108,13 +3105,13 @@ static void test_renderless_present(struct presenter *presenter,
     ok(presenter->got_PresentImage == 1, "Got %u calls to PresentImage().\n", presenter->got_PresentImage);
 
     hr = IMediaControl_Run(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = join_thread(thread);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(presenter->got_PresentImage == 1, "Got %u calls to PresentImage().\n", presenter->got_PresentImage);
 
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     IMediaControl_Release(control);
 }
@@ -3203,11 +3200,11 @@ static void test_renderless_formats(void)
         win_skip("Direct3D does not support video rendering.\n");
         goto out;
     }
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVMRSurfaceAllocatorNotify9_AdviseSurfaceAllocator(notify, 0xabacab,
             &presenter.IVMRSurfaceAllocator9_iface);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     presenter.notify = notify;
 
@@ -3229,14 +3226,14 @@ static void test_renderless_formats(void)
          * IMemAllocator::SetProperties(), so let that fail here for now. */
         if (hr != S_OK)
         {
-            skip("Format %u (%#x), flags %#lx are not supported, hr %#lx.\n",
+            skip("Format %u (%#x), flags %#x are not supported, hr %#x.\n",
                     tests[i].format, tests[i].format, tests[i].flags, hr);
             continue;
         }
-        ok(hr == S_OK, "Test %u: Got hr %#lx.\n", i, hr);
+        ok(hr == S_OK, "Test %u: Got hr %#x.\n", i, hr);
 
         hr = IMemInputPin_GetAllocator(input, &allocator);
-        todo_wine ok(hr == S_OK, "Test %u: Got hr %#lx.\n", i, hr);
+        todo_wine ok(hr == S_OK, "Test %u: Got hr %#x.\n", i, hr);
         if (hr != S_OK)
         {
             test_allocator(input);
@@ -3246,22 +3243,22 @@ static void test_renderless_formats(void)
         hr = IMemAllocator_SetProperties(allocator, &req_props, &ret_props);
         if (hr != S_OK)
         {
-            skip("Format %u (%#x), flags %#lx are not supported, hr %#lx.\n",
+            skip("Format %u (%#x), flags %#x are not supported, hr %#x.\n",
                     tests[i].format, tests[i].format, tests[i].flags, hr);
             IMemAllocator_Release(allocator);
             hr = IFilterGraph2_Disconnect(graph, &source.source.pin.IPin_iface);
-            ok(hr == S_OK, "Test %u: Got hr %#lx.\n", i, hr);
+            ok(hr == S_OK, "Test %u: Got hr %#x.\n", i, hr);
             hr = IFilterGraph2_Disconnect(graph, pin);
-            ok(hr == S_OK, "Test %u: Got hr %#lx.\n", i, hr);
+            ok(hr == S_OK, "Test %u: Got hr %#x.\n", i, hr);
             continue;
         }
         ok(!memcmp(&ret_props, &req_props, sizeof(req_props)), "Properties did not match.\n");
         hr = IMemAllocator_Commit(allocator);
-        ok(hr == S_OK, "Test %u: Got hr %#lx.\n", i, hr);
+        ok(hr == S_OK, "Test %u: Got hr %#x.\n", i, hr);
 
         hr = IVMRSurfaceAllocatorNotify9_AdviseSurfaceAllocator(notify, 0xabacab,
                 &presenter2.IVMRSurfaceAllocator9_iface);
-        ok(hr == VFW_E_WRONG_STATE, "Got hr %#lx.\n", hr);
+        ok(hr == VFW_E_WRONG_STATE, "Got hr %#x.\n", hr);
 
         ok(presenter.format == tests[i].format, "Test %u: Got format %u (%#x).\n",
                 i, presenter.format, presenter.format);
@@ -3269,31 +3266,31 @@ static void test_renderless_formats(void)
         test_renderless_present(&presenter, graph, input);
 
         hr = IMemAllocator_Decommit(allocator);
-        ok(hr == S_OK, "Test %u: Got hr %#lx.\n", i, hr);
+        ok(hr == S_OK, "Test %u: Got hr %#x.\n", i, hr);
         IMemAllocator_Release(allocator);
 
         hr = IFilterGraph2_Disconnect(graph, &source.source.pin.IPin_iface);
-        ok(hr == S_OK, "Test %u: Got hr %#lx.\n", i, hr);
+        ok(hr == S_OK, "Test %u: Got hr %#x.\n", i, hr);
         hr = IFilterGraph2_Disconnect(graph, pin);
-        ok(hr == S_OK, "Test %u: Got hr %#lx.\n", i, hr);
+        ok(hr == S_OK, "Test %u: Got hr %#x.\n", i, hr);
     }
 
     hr = IVMRSurfaceAllocatorNotify9_AdviseSurfaceAllocator(notify, 0xabacab, &presenter2.IVMRSurfaceAllocator9_iface);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     ref = IFilterGraph2_Release(graph);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     IMemInputPin_Release(input);
     IPin_Release(pin);
 
 out:
     IVMRSurfaceAllocatorNotify9_Release(notify);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
-    ok(presenter.refcount == 1, "Got outstanding refcount %ld.\n", presenter.refcount);
-    ok(presenter2.refcount == 1, "Got outstanding refcount %ld.\n", presenter2.refcount);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
+    ok(presenter.refcount == 1, "Got outstanding refcount %d.\n", presenter.refcount);
+    ok(presenter2.refcount == 1, "Got outstanding refcount %d.\n", presenter2.refcount);
     ref = IDirect3DDevice9_Release(device);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     DestroyWindow(window);
 }
 
@@ -3323,32 +3320,32 @@ static void test_mixing_mode(void)
         IBaseFilter_QueryInterface(filter, &IID_IVMRFilterConfig9, (void **)&config);
 
         hr = IBaseFilter_QueryInterface(filter, &IID_IVMRMixerControl9, (void **)&mixer_control);
-        ok(hr == E_NOINTERFACE, "Got hr %#lx.\n", hr);
+        ok(hr == E_NOINTERFACE, "Got hr %#x.\n", hr);
 
         hr = IVMRFilterConfig9_GetNumberOfStreams(config, &stream_count);
-        ok(hr == VFW_E_VMR_NOT_IN_MIXER_MODE, "Got hr %#lx.\n", hr);
+        ok(hr == VFW_E_VMR_NOT_IN_MIXER_MODE, "Got hr %#x.\n", hr);
 
         hr = IVMRFilterConfig9_SetNumberOfStreams(config, 1);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
 
         hr = IVMRFilterConfig9_GetNumberOfStreams(config, &stream_count);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
-        ok(stream_count == 1, "Got %lu streams.\n", stream_count);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
+        ok(stream_count == 1, "Got %u streams.\n", stream_count);
 
         hr = IBaseFilter_QueryInterface(filter, &IID_IVMRMixerControl9, (void **)&mixer_control);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
         IVMRMixerControl9_Release(mixer_control);
 
         hr = IVMRFilterConfig9_SetNumberOfStreams(config, 2);
-        ok(hr == VFW_E_WRONG_STATE, "Got hr %#lx.\n", hr);
+        ok(hr == VFW_E_WRONG_STATE, "Got hr %#x.\n", hr);
 
         hr = IVMRFilterConfig9_GetNumberOfStreams(config, &stream_count);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
-        ok(stream_count == 1, "Got %lu streams.\n", stream_count);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
+        ok(stream_count == 1, "Got %u streams.\n", stream_count);
 
         IVMRFilterConfig9_Release(config);
         ref = IBaseFilter_Release(filter);
-        ok(!ref, "Got outstanding refcount %ld.\n", ref);
+        ok(!ref, "Got outstanding refcount %d.\n", ref);
     }
 
     filter = create_vmr9(VMR9Mode_Windowless);
@@ -3358,27 +3355,27 @@ static void test_mixing_mode(void)
     window = CreateWindowA("static", "quartz_test", WS_OVERLAPPEDWINDOW, 0, 0, 640, 480, 0, 0, 0, 0);
     ok(!!window, "Failed to create a window.\n");
     hr = IVMRWindowlessControl9_SetVideoClippingWindow(windowless_control, window);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVMRFilterConfig9_GetNumberOfStreams(config, &stream_count);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(stream_count == 4, "Got %lu streams.\n", stream_count);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(stream_count == 4, "Got %u streams.\n", stream_count);
 
     hr = IBaseFilter_QueryInterface(filter, &IID_IVMRMixerControl9, (void **)&mixer_control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     IVMRMixerControl9_Release(mixer_control);
 
     hr = IVMRFilterConfig9_SetNumberOfStreams(config, 2);
-    ok(hr == VFW_E_WRONG_STATE, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_WRONG_STATE, "Got hr %#x.\n", hr);
 
     hr = IVMRFilterConfig9_GetNumberOfStreams(config, &stream_count);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(stream_count == 4, "Got %lu streams.\n", stream_count);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(stream_count == 4, "Got %u streams.\n", stream_count);
 
     IVMRWindowlessControl9_Release(windowless_control);
     IVMRFilterConfig9_Release(config);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     DestroyWindow(window);
 }
 
@@ -3417,30 +3414,30 @@ static void test_clipping_window(void)
     ok(!!window, "Failed to create a window.\n");
 
     hr = IVMRWindowlessControl9_SetVideoClippingWindow(windowless_control, NULL);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
     hr = IVMRWindowlessControl9_SetVideoClippingWindow(windowless_control, (HWND)0xdeadbeef);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
 
     hr = IFilterGraph2_ConnectDirect(graph, &source.source.pin.IPin_iface, pin, &mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVMRWindowlessControl9_SetVideoClippingWindow(windowless_control, window);
-    ok(hr == VFW_E_WRONG_STATE, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_WRONG_STATE, "Got hr %#x.\n", hr);
 
     hr = IFilterGraph2_Disconnect(graph, &source.source.pin.IPin_iface);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IFilterGraph2_Disconnect(graph, pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVMRWindowlessControl9_SetVideoClippingWindow(windowless_control, window);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     ref = IFilterGraph2_Release(graph);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     IPin_Release(pin);
     IVMRWindowlessControl9_Release(windowless_control);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     DestroyWindow(window);
 }
 
@@ -3463,16 +3460,16 @@ static void test_surface_allocator_notify_refcount(void)
 
     hr = IVMRSurfaceAllocatorNotify9_AdviseSurfaceAllocator(notify, 0xabacab,
             &presenter.IVMRSurfaceAllocator9_iface);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ok(presenter.got_TerminateDevice == 1, "Got %u calls to TerminateDevice().\n",
             presenter.got_TerminateDevice);
-    ok(presenter.refcount == 1, "Got outstanding refcount %ld.\n", presenter.refcount);
+    ok(presenter.refcount == 1, "Got outstanding refcount %d.\n", presenter.refcount);
 
     ref = IVMRSurfaceAllocatorNotify9_Release(notify);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 static void check_source_position_(int line, IBasicVideo *video,
@@ -3483,31 +3480,31 @@ static void check_source_position_(int line, IBasicVideo *video,
 
     left = top = width = height = 0xdeadbeef;
     hr = IBasicVideo_GetSourcePosition(video, &left, &top, &width, &height);
-    ok_(__FILE__,line)(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok_(__FILE__,line)(left == expect_left, "Got left %ld.\n", left);
-    ok_(__FILE__,line)(top == expect_top, "Got top %ld.\n", top);
-    ok_(__FILE__,line)(width == expect_width, "Got width %ld.\n", width);
-    ok_(__FILE__,line)(height == expect_height, "Got height %ld.\n", height);
+    ok_(__FILE__,line)(hr == S_OK, "Got hr %#x.\n", hr);
+    ok_(__FILE__,line)(left == expect_left, "Got left %d.\n", left);
+    ok_(__FILE__,line)(top == expect_top, "Got top %d.\n", top);
+    ok_(__FILE__,line)(width == expect_width, "Got width %d.\n", width);
+    ok_(__FILE__,line)(height == expect_height, "Got height %d.\n", height);
 
     l = 0xdeadbeef;
     hr = IBasicVideo_get_SourceLeft(video, &l);
-    ok_(__FILE__,line)(hr == S_OK, "Failed to get left, hr %#lx.\n", hr);
-    ok_(__FILE__,line)(l == left, "Got left %ld.\n", l);
+    ok_(__FILE__,line)(hr == S_OK, "Failed to get left, hr %#x.\n", hr);
+    ok_(__FILE__,line)(l == left, "Got left %d.\n", l);
 
     l = 0xdeadbeef;
     hr = IBasicVideo_get_SourceTop(video, &l);
-    ok_(__FILE__,line)(hr == S_OK, "Failed to get top, hr %#lx.\n", hr);
-    ok_(__FILE__,line)(l == top, "Got top %ld.\n", l);
+    ok_(__FILE__,line)(hr == S_OK, "Failed to get top, hr %#x.\n", hr);
+    ok_(__FILE__,line)(l == top, "Got top %d.\n", l);
 
     l = 0xdeadbeef;
     hr = IBasicVideo_get_SourceWidth(video, &l);
-    ok_(__FILE__,line)(hr == S_OK, "Failed to get width, hr %#lx.\n", hr);
-    ok_(__FILE__,line)(l == width, "Got width %ld.\n", l);
+    ok_(__FILE__,line)(hr == S_OK, "Failed to get width, hr %#x.\n", hr);
+    ok_(__FILE__,line)(l == width, "Got width %d.\n", l);
 
     l = 0xdeadbeef;
     hr = IBasicVideo_get_SourceHeight(video, &l);
-    ok_(__FILE__,line)(hr == S_OK, "Failed to get height, hr %#lx.\n", hr);
-    ok_(__FILE__,line)(l == height, "Got height %ld.\n", l);
+    ok_(__FILE__,line)(hr == S_OK, "Failed to get height, hr %#x.\n", hr);
+    ok_(__FILE__,line)(l == height, "Got height %d.\n", l);
 }
 #define check_source_position(a,b,c,d,e) check_source_position_(__LINE__,a,b,c,d,e)
 
@@ -3517,77 +3514,77 @@ static void test_basic_video_source(IBasicVideo *video)
 
     check_source_position(video, 0, 0, 600, 400);
     hr = IBasicVideo_IsUsingDefaultSource(video);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_put_SourceLeft(video, -10);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
     hr = IBasicVideo_put_SourceLeft(video, 10);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_put_SourceTop(video, -10);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
     hr = IBasicVideo_put_SourceTop(video, 10);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_put_SourceWidth(video, -500);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
     hr = IBasicVideo_put_SourceWidth(video, 0);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
     hr = IBasicVideo_put_SourceWidth(video, 700);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
     hr = IBasicVideo_put_SourceWidth(video, 500);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_source_position(video, 0, 0, 500, 400);
     hr = IBasicVideo_IsUsingDefaultSource(video);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_put_SourceHeight(video, -300);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
     hr = IBasicVideo_put_SourceHeight(video, 0);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
     hr = IBasicVideo_put_SourceHeight(video, 600);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
     hr = IBasicVideo_put_SourceHeight(video, 300);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_source_position(video, 0, 0, 500, 300);
     hr = IBasicVideo_IsUsingDefaultSource(video);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_put_SourceLeft(video, -10);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
     hr = IBasicVideo_put_SourceLeft(video, 10);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_source_position(video, 10, 0, 500, 300);
     hr = IBasicVideo_IsUsingDefaultSource(video);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_put_SourceTop(video, -10);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
     hr = IBasicVideo_put_SourceTop(video, 20);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_source_position(video, 10, 20, 500, 300);
     hr = IBasicVideo_IsUsingDefaultSource(video);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_SetSourcePosition(video, 4, 5, 60, 40);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_source_position(video, 4, 5, 60, 40);
     hr = IBasicVideo_IsUsingDefaultSource(video);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_SetSourcePosition(video, 0, 0, 600, 400);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_source_position(video, 0, 0, 600, 400);
     hr = IBasicVideo_IsUsingDefaultSource(video);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_SetSourcePosition(video, 4, 5, 60, 40);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IBasicVideo_SetDefaultSourcePosition(video);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_source_position(video, 0, 0, 600, 400);
     hr = IBasicVideo_IsUsingDefaultSource(video);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 }
 
 static void check_destination_position_(int line, IBasicVideo *video,
@@ -3598,31 +3595,31 @@ static void check_destination_position_(int line, IBasicVideo *video,
 
     left = top = width = height = 0xdeadbeef;
     hr = IBasicVideo_GetDestinationPosition(video, &left, &top, &width, &height);
-    ok_(__FILE__,line)(hr == S_OK, "Failed to get position, hr %#lx.\n", hr);
-    ok_(__FILE__,line)(left == expect_left, "Got left %ld.\n", left);
-    ok_(__FILE__,line)(top == expect_top, "Got top %ld.\n", top);
-    ok_(__FILE__,line)(width == expect_width, "Got width %ld.\n", width);
-    ok_(__FILE__,line)(height == expect_height, "Got height %ld.\n", height);
+    ok_(__FILE__,line)(hr == S_OK, "Failed to get position, hr %#x.\n", hr);
+    ok_(__FILE__,line)(left == expect_left, "Got left %d.\n", left);
+    ok_(__FILE__,line)(top == expect_top, "Got top %d.\n", top);
+    ok_(__FILE__,line)(width == expect_width, "Got width %d.\n", width);
+    ok_(__FILE__,line)(height == expect_height, "Got height %d.\n", height);
 
     l = 0xdeadbeef;
     hr = IBasicVideo_get_DestinationLeft(video, &l);
-    ok_(__FILE__,line)(hr == S_OK, "Failed to get left, hr %#lx.\n", hr);
-    ok_(__FILE__,line)(l == left, "Got left %ld.\n", l);
+    ok_(__FILE__,line)(hr == S_OK, "Failed to get left, hr %#x.\n", hr);
+    ok_(__FILE__,line)(l == left, "Got left %d.\n", l);
 
     l = 0xdeadbeef;
     hr = IBasicVideo_get_DestinationTop(video, &l);
-    ok_(__FILE__,line)(hr == S_OK, "Failed to get top, hr %#lx.\n", hr);
-    ok_(__FILE__,line)(l == top, "Got top %ld.\n", l);
+    ok_(__FILE__,line)(hr == S_OK, "Failed to get top, hr %#x.\n", hr);
+    ok_(__FILE__,line)(l == top, "Got top %d.\n", l);
 
     l = 0xdeadbeef;
     hr = IBasicVideo_get_DestinationWidth(video, &l);
-    ok_(__FILE__,line)(hr == S_OK, "Failed to get width, hr %#lx.\n", hr);
-    ok_(__FILE__,line)(l == width, "Got width %ld.\n", l);
+    ok_(__FILE__,line)(hr == S_OK, "Failed to get width, hr %#x.\n", hr);
+    ok_(__FILE__,line)(l == width, "Got width %d.\n", l);
 
     l = 0xdeadbeef;
     hr = IBasicVideo_get_DestinationHeight(video, &l);
-    ok_(__FILE__,line)(hr == S_OK, "Failed to get height, hr %#lx.\n", hr);
-    ok_(__FILE__,line)(l == height, "Got height %ld.\n", l);
+    ok_(__FILE__,line)(hr == S_OK, "Failed to get height, hr %#x.\n", hr);
+    ok_(__FILE__,line)(l == height, "Got height %d.\n", l);
 }
 #define check_destination_position(a,b,c,d,e) check_destination_position_(__LINE__,a,b,c,d,e)
 
@@ -3636,107 +3633,107 @@ static void test_basic_video_destination(IBasicVideo *video)
 
     check_destination_position(video, 0, 0, 600, 400);
     hr = IBasicVideo_IsUsingDefaultDestination(video);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_put_DestinationLeft(video, -10);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_destination_position(video, -10, 0, 600, 400);
     hr = IBasicVideo_IsUsingDefaultDestination(video);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_put_DestinationLeft(video, 10);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_destination_position(video, 10, 0, 600, 400);
     hr = IBasicVideo_IsUsingDefaultDestination(video);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_put_DestinationTop(video, -20);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_destination_position(video, 10, -20, 600, 400);
     hr = IBasicVideo_IsUsingDefaultDestination(video);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_put_DestinationTop(video, 20);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_destination_position(video, 10, 20, 600, 400);
     hr = IBasicVideo_IsUsingDefaultDestination(video);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_put_DestinationWidth(video, -700);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
     hr = IBasicVideo_put_DestinationWidth(video, 0);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
     hr = IBasicVideo_put_DestinationWidth(video, 700);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_destination_position(video, 10, 20, 700, 400);
     hr = IBasicVideo_IsUsingDefaultDestination(video);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_put_DestinationWidth(video, 500);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_destination_position(video, 10, 20, 500, 400);
     hr = IBasicVideo_IsUsingDefaultDestination(video);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_put_DestinationHeight(video, -500);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
     hr = IBasicVideo_put_DestinationHeight(video, 0);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
     hr = IBasicVideo_put_DestinationHeight(video, 500);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_destination_position(video, 10, 20, 500, 500);
     hr = IBasicVideo_IsUsingDefaultDestination(video);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_put_DestinationHeight(video, 300);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_destination_position(video, 10, 20, 500, 300);
     hr = IBasicVideo_IsUsingDefaultDestination(video);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_SetDestinationPosition(video, 4, 5, 60, 40);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_destination_position(video, 4, 5, 60, 40);
     hr = IBasicVideo_IsUsingDefaultDestination(video);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_SetDestinationPosition(video, 0, 0, 600, 400);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_destination_position(video, 0, 0, 600, 400);
     hr = IBasicVideo_IsUsingDefaultDestination(video);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_SetDestinationPosition(video, 4, 5, 60, 40);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IBasicVideo_SetDefaultDestinationPosition(video);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_destination_position(video, 0, 0, 600, 400);
     hr = IBasicVideo_IsUsingDefaultDestination(video);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     SetRect(&rect, 100, 200, 500, 500);
     AdjustWindowRect(&rect, WS_OVERLAPPEDWINDOW, FALSE);
     hr = IVideoWindow_SetWindowPosition(window, rect.left, rect.top,
             rect.right - rect.left, rect.bottom - rect.top);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_destination_position(video, 0, 0, 400, 300);
     hr = IBasicVideo_IsUsingDefaultDestination(video);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_SetDestinationPosition(video, 0, 0, 400, 300);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_destination_position(video, 0, 0, 400, 300);
     hr = IBasicVideo_IsUsingDefaultDestination(video);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     SetRect(&rect, 100, 200, 600, 600);
     AdjustWindowRect(&rect, WS_OVERLAPPEDWINDOW, FALSE);
     hr = IVideoWindow_SetWindowPosition(window, rect.left, rect.top,
             rect.right - rect.left, rect.bottom - rect.top);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     check_destination_position(video, 0, 0, 400, 300);
     hr = IBasicVideo_IsUsingDefaultDestination(video);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     IVideoWindow_Release(window);
 }
@@ -3785,83 +3782,83 @@ static void test_basic_video(void)
     IPin_QueryInterface(pin, &IID_IMemInputPin, (void **)&input);
 
     hr = IBasicVideo_GetTypeInfoCount(video, &count);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(count == 1, "Got count %u.\n", count);
 
     hr = IBasicVideo_GetTypeInfo(video, 0, 0, &typeinfo);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = ITypeInfo_GetTypeAttr(typeinfo, &typeattr);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(typeattr->typekind == TKIND_DISPATCH, "Got kind %u.\n", typeattr->typekind);
     ok(IsEqualGUID(&typeattr->guid, &IID_IBasicVideo), "Got IID %s.\n", wine_dbgstr_guid(&typeattr->guid));
     ITypeInfo_ReleaseTypeAttr(typeinfo, typeattr);
     ITypeInfo_Release(typeinfo);
 
     hr = IBasicVideo_get_AvgTimePerFrame(video, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
     hr = IBasicVideo_get_AvgTimePerFrame(video, &reftime);
-    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_get_BitRate(video, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
     hr = IBasicVideo_get_BitRate(video, &l);
-    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_get_BitErrorRate(video, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
     hr = IBasicVideo_get_BitErrorRate(video, &l);
-    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_get_VideoWidth(video, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
     hr = IBasicVideo_get_VideoHeight(video, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_get_SourceLeft(video, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
     hr = IBasicVideo_get_SourceWidth(video, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
     hr = IBasicVideo_get_SourceTop(video, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
     hr = IBasicVideo_get_SourceHeight(video, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_get_DestinationLeft(video, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
     hr = IBasicVideo_get_DestinationWidth(video, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
     hr = IBasicVideo_get_DestinationTop(video, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
     hr = IBasicVideo_get_DestinationHeight(video, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_GetSourcePosition(video, NULL, &top, &width, &height);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
     hr = IBasicVideo_GetSourcePosition(video, &left, NULL, &width, &height);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
     hr = IBasicVideo_GetSourcePosition(video, &left, &top, NULL, &height);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
     hr = IBasicVideo_GetSourcePosition(video, &left, &top, &width, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_GetDestinationPosition(video, NULL, &top, &width, &height);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
     hr = IBasicVideo_GetDestinationPosition(video, &left, NULL, &width, &height);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
     hr = IBasicVideo_GetDestinationPosition(video, &left, &top, NULL, &height);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
     hr = IBasicVideo_GetDestinationPosition(video, &left, &top, &width, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_GetVideoSize(video, &width, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
     hr = IBasicVideo_GetVideoSize(video, NULL, &height);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
 
     hr = IBasicVideo_GetVideoPaletteEntries(video, 0, 1, NULL, &l);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
     hr = IBasicVideo_GetVideoPaletteEntries(video, 0, 1, &l, NULL);
-    todo_wine ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == VFW_E_NOT_CONNECTED, "Got hr %#x.\n", hr);
 
     testfilter_init(&source);
     IFilterGraph2_AddFilter(graph, &source.filter.IBaseFilter_iface, L"vmr9");
@@ -3872,66 +3869,66 @@ static void test_basic_video(void)
         skip("Got E_FAIL when connecting.\n");
         goto out;
     }
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMemInputPin_GetAllocator(input, &allocator);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
     if (hr == S_OK)
     {
         hr = IMemAllocator_SetProperties(allocator, &req_props, &ret_props);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
         ok(!memcmp(&ret_props, &req_props, sizeof(req_props)), "Properties did not match.\n");
         hr = IMemAllocator_Commit(allocator);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
         IMemAllocator_Release(allocator);
     }
 
     reftime = 0.0;
     hr = IBasicVideo_get_AvgTimePerFrame(video, &reftime);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(compare_double(reftime, 0.02, 1 << 28), "Got frame rate %.16e.\n", reftime);
 
     l = 0xdeadbeef;
     hr = IBasicVideo_get_BitRate(video, &l);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(!l, "Got bit rate %ld.\n", l);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(!l, "Got bit rate %d.\n", l);
 
     l = 0xdeadbeef;
     hr = IBasicVideo_get_BitErrorRate(video, &l);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(!l, "Got bit rate %ld.\n", l);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(!l, "Got bit rate %d.\n", l);
 
     hr = IBasicVideo_GetVideoPaletteEntries(video, 0, 1, &l, NULL);
-    todo_wine ok(hr == VFW_E_NO_PALETTE_AVAILABLE, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == VFW_E_NO_PALETTE_AVAILABLE, "Got hr %#x.\n", hr);
 
     width = height = 0xdeadbeef;
     hr = IBasicVideo_GetVideoSize(video, &width, &height);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(width == 600, "Got width %ld.\n", width);
-    ok(height == 400, "Got height %ld.\n", height);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(width == 600, "Got width %d.\n", width);
+    ok(height == 400, "Got height %d.\n", height);
 
     test_basic_video_source(video);
     test_basic_video_destination(video);
 
     hr = IFilterGraph2_Disconnect(graph, &source.source.pin.IPin_iface);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IFilterGraph2_Disconnect(graph, pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     vih.bmiHeader.biWidth = 16;
     vih.bmiHeader.biHeight = 16;
     hr = IFilterGraph2_ConnectDirect(graph, &source.source.pin.IPin_iface, pin, &req_mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMemInputPin_GetAllocator(input, &allocator);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
     if (hr == S_OK)
     {
         hr = IMemAllocator_SetProperties(allocator, &req_props, &ret_props);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
         ok(!memcmp(&ret_props, &req_props, sizeof(req_props)), "Properties did not match.\n");
         hr = IMemAllocator_Commit(allocator);
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
         IMemAllocator_Release(allocator);
     }
 
@@ -3944,14 +3941,14 @@ static void test_basic_video(void)
 
 out:
     ref = IFilterGraph2_Release(graph);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     IBasicVideo_Release(video);
     IMemInputPin_Release(input);
     IPin_Release(pin);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ref = IBaseFilter_Release(&source.filter.IBaseFilter_iface);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 static void test_windowless_size(void)
@@ -3978,11 +3975,11 @@ static void test_windowless_size(void)
     IVMRAspectRatioControl9 *aspect_ratio_control;
     IVMRWindowlessControl9 *windowless_control;
     IFilterGraph2 *graph = create_graph();
+    VMR9AspectRatioMode aspect_mode;
     struct testfilter source;
     IMemAllocator *allocator;
     RECT src, dst, expect;
     IMemInputPin *input;
-    DWORD aspect_mode;
     HWND window;
     HRESULT hr;
     ULONG ref;
@@ -3999,12 +3996,12 @@ static void test_windowless_size(void)
     ok(!!window, "Failed to create a window.\n");
 
     hr = IVMRWindowlessControl9_SetVideoClippingWindow(windowless_control, window);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IFilterGraph2_ConnectDirect(graph, &source.source.pin.IPin_iface, pin, &mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMemInputPin_GetAllocator(input, &allocator);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
     if (hr == S_OK)
     {
         hr = IMemAllocator_SetProperties(allocator, &req_props, &ret_props);
@@ -4014,57 +4011,57 @@ static void test_windowless_size(void)
             skip("Got E_FAIL when setting allocator properties.\n");
             goto out;
         }
-        ok(hr == S_OK, "Got hr %#lx.\n", hr);
+        ok(hr == S_OK, "Got hr %#x.\n", hr);
         ok(!memcmp(&ret_props, &req_props, sizeof(req_props)), "Properties did not match.\n");
     }
 
     hr = IVMRWindowlessControl9_GetNativeVideoSize(windowless_control, NULL, &height, &aspect_width, &aspect_height);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
     hr = IVMRWindowlessControl9_GetNativeVideoSize(windowless_control, &width, NULL, &aspect_width, &aspect_height);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
 
     aspect_mode = 0xdeadbeef;
     hr = IVMRWindowlessControl9_GetAspectRatioMode(windowless_control, &aspect_mode);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(aspect_mode == VMR9ARMode_None, "Got mode %lu.\n", aspect_mode);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(aspect_mode == VMR9ARMode_None, "Got mode %u.\n", aspect_mode);
 
     aspect_mode = 0xdeadbeef;
     hr = IVMRAspectRatioControl9_GetAspectRatioMode(aspect_ratio_control, &aspect_mode);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(aspect_mode == VMR9ARMode_None, "Got mode %lu.\n", aspect_mode);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(aspect_mode == VMR9ARMode_None, "Got mode %u.\n", aspect_mode);
 
     width = height = 0xdeadbeef;
     hr = IVMRWindowlessControl9_GetNativeVideoSize(windowless_control, &width, &height, NULL, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(width == 32, "Got width %ld.\n", width);
-    ok(height == 16, "Got height %ld.\n", height);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(width == 32, "Got width %d.\n", width);
+    ok(height == 16, "Got height %d.\n", height);
 
     aspect_width = aspect_height = 0xdeadbeef;
     hr = IVMRWindowlessControl9_GetNativeVideoSize(windowless_control, &width, &height, &aspect_width, &aspect_height);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(aspect_width == 32, "Got width %ld.\n", aspect_width);
-    ok(aspect_height == 16, "Got height %ld.\n", aspect_height);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(aspect_width == 32, "Got width %d.\n", aspect_width);
+    ok(aspect_height == 16, "Got height %d.\n", aspect_height);
 
     memset(&src, 0xcc, sizeof(src));
     hr = IVMRWindowlessControl9_GetVideoPosition(windowless_control, &src, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     SetRect(&expect, 0, 0, 32, 16);
     ok(EqualRect(&src, &expect), "Got source rect %s.\n", wine_dbgstr_rect(&src));
 
     memset(&dst, 0xcc, sizeof(dst));
     hr = IVMRWindowlessControl9_GetVideoPosition(windowless_control, NULL, &dst);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     SetRect(&expect, 0, 0, 0, 0);
     ok(EqualRect(&dst, &expect), "Got dest rect %s.\n", wine_dbgstr_rect(&dst));
 
     SetRect(&src, 4, 6, 16, 12);
     hr = IVMRWindowlessControl9_SetVideoPosition(windowless_control, &src, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     memset(&src, 0xcc, sizeof(src));
     memset(&dst, 0xcc, sizeof(dst));
     hr = IVMRWindowlessControl9_GetVideoPosition(windowless_control, &src, &dst);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     SetRect(&expect, 4, 6, 16, 12);
     ok(EqualRect(&src, &expect), "Got source rect %s.\n", wine_dbgstr_rect(&src));
     SetRect(&expect, 0, 0, 0, 0);
@@ -4072,12 +4069,12 @@ static void test_windowless_size(void)
 
     SetRect(&dst, 40, 60, 120, 160);
     hr = IVMRWindowlessControl9_SetVideoPosition(windowless_control, NULL, &dst);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     memset(&src, 0xcc, sizeof(src));
     memset(&dst, 0xcc, sizeof(dst));
     hr = IVMRWindowlessControl9_GetVideoPosition(windowless_control, &src, &dst);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     SetRect(&expect, 4, 6, 16, 12);
     ok(EqualRect(&src, &expect), "Got source rect %s.\n", wine_dbgstr_rect(&src));
     SetRect(&expect, 40, 60, 120, 160);
@@ -4088,28 +4085,28 @@ static void test_windowless_size(void)
     ok(EqualRect(&src, &expect), "Got window rect %s.\n", wine_dbgstr_rect(&src));
 
     hr = IVMRAspectRatioControl9_SetAspectRatioMode(aspect_ratio_control, VMR9ARMode_LetterBox);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     aspect_mode = 0xdeadbeef;
     hr = IVMRWindowlessControl9_GetAspectRatioMode(windowless_control, &aspect_mode);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(aspect_mode == VMR9ARMode_LetterBox, "Got mode %lu.\n", aspect_mode);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(aspect_mode == VMR9ARMode_LetterBox, "Got mode %u.\n", aspect_mode);
 
     hr = IVMRWindowlessControl9_SetAspectRatioMode(windowless_control, VMR9ARMode_None);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     aspect_mode = 0xdeadbeef;
     hr = IVMRAspectRatioControl9_GetAspectRatioMode(aspect_ratio_control, &aspect_mode);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(aspect_mode == VMR9ARMode_None, "Got mode %lu.\n", aspect_mode);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(aspect_mode == VMR9ARMode_None, "Got mode %u.\n", aspect_mode);
 
     hr = IVMRWindowlessControl9_SetAspectRatioMode(windowless_control, VMR9ARMode_LetterBox);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     memset(&src, 0xcc, sizeof(src));
     memset(&dst, 0xcc, sizeof(dst));
     hr = IVMRWindowlessControl9_GetVideoPosition(windowless_control, &src, &dst);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     SetRect(&expect, 4, 6, 16, 12);
     ok(EqualRect(&src, &expect), "Got source rect %s.\n", wine_dbgstr_rect(&src));
     SetRect(&expect, 40, 60, 120, 160);
@@ -4118,12 +4115,12 @@ static void test_windowless_size(void)
     SetRect(&src, 0, 0, 32, 16);
     SetRect(&dst, 0, 0, 640, 480);
     hr = IVMRWindowlessControl9_SetVideoPosition(windowless_control, &src, &dst);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     memset(&src, 0xcc, sizeof(src));
     memset(&dst, 0xcc, sizeof(dst));
     hr = IVMRWindowlessControl9_GetVideoPosition(windowless_control, &src, &dst);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     SetRect(&expect, 0, 0, 32, 16);
     ok(EqualRect(&src, &expect), "Got source rect %s.\n", wine_dbgstr_rect(&src));
     SetRect(&expect, 0, 0, 640, 480);
@@ -4131,13 +4128,13 @@ static void test_windowless_size(void)
 
 out:
     ref = IFilterGraph2_Release(graph);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     IMemInputPin_Release(input);
     IPin_Release(pin);
     IVMRWindowlessControl9_Release(windowless_control);
     IVMRAspectRatioControl9_Release(aspect_ratio_control);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     DestroyWindow(window);
 }
 
@@ -4152,25 +4149,25 @@ static void test_mixing_prefs(void)
     set_mixing_mode(filter, 1);
 
     hr = IBaseFilter_QueryInterface(filter, &IID_IVMRMixerControl9, (void **)&mixer_control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVMRMixerControl9_GetMixingPrefs(mixer_control, &flags);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(flags == (MixerPref9_NoDecimation | MixerPref9_ARAdjustXorY | MixerPref9_BiLinearFiltering
-            | MixerPref9_RenderTargetRGB), "Got flags %#lx.\n", flags);
+            | MixerPref9_RenderTargetRGB), "Got flags %#x.\n", flags);
 
     hr = IVMRMixerControl9_SetMixingPrefs(mixer_control, MixerPref9_NoDecimation
             | MixerPref9_ARAdjustXorY | MixerPref9_PointFiltering | MixerPref9_RenderTargetRGB);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IVMRMixerControl9_GetMixingPrefs(mixer_control, &flags);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(flags == (MixerPref9_NoDecimation | MixerPref9_ARAdjustXorY | MixerPref9_PointFiltering
-            | MixerPref9_RenderTargetRGB), "Got flags %#lx.\n", flags);
+            | MixerPref9_RenderTargetRGB), "Got flags %#x.\n", flags);
 
     IVMRMixerControl9_Release(mixer_control);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 static void test_unconnected_eos(void)
@@ -4184,49 +4181,49 @@ static void test_unconnected_eos(void)
     ULONG ref;
 
     hr = IFilterGraph2_AddFilter(graph, filter, L"renderer");
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IFilterGraph2_QueryInterface(graph, &IID_IMediaControl, (void **)&control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IFilterGraph2_QueryInterface(graph, &IID_IMediaEvent, (void **)&eventsrc);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     ret = check_ec_complete(eventsrc, 0);
     ok(!ret, "Got %u EC_COMPLETE events.\n", ret);
 
     hr = IMediaControl_Pause(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     ret = check_ec_complete(eventsrc, 0);
     ok(!ret, "Got %u EC_COMPLETE events.\n", ret);
 
     hr = IMediaControl_Run(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     ret = check_ec_complete(eventsrc, 0);
     ok(ret == 1, "Got %u EC_COMPLETE events.\n", ret);
 
     hr = IMediaControl_Pause(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     ret = check_ec_complete(eventsrc, 0);
     ok(!ret, "Got %u EC_COMPLETE events.\n", ret);
 
     hr = IMediaControl_Run(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     ret = check_ec_complete(eventsrc, 0);
     ok(ret == 1, "Got %u EC_COMPLETE events.\n", ret);
 
     hr = IMediaControl_Stop(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     ret = check_ec_complete(eventsrc, 0);
     ok(!ret, "Got %u EC_COMPLETE events.\n", ret);
 
     hr = IMediaControl_Run(control);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     ret = check_ec_complete(eventsrc, 0);
     ok(ret == 1, "Got %u EC_COMPLETE events.\n", ret);
@@ -4234,9 +4231,9 @@ static void test_unconnected_eos(void)
     IMediaControl_Release(control);
     IMediaEvent_Release(eventsrc);
     ref = IFilterGraph2_Release(graph);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 START_TEST(vmr9)
@@ -4249,7 +4246,7 @@ START_TEST(vmr9)
     if (FAILED(hr = CoCreateInstance(&CLSID_VideoMixingRenderer9, NULL,
             CLSCTX_INPROC_SERVER, &IID_IBaseFilter, (void **)&filter)))
     {
-        skip("Failed to create VMR9, hr %#lx.\n", hr);
+        skip("Failed to create VMR9, hr %#x.\n", hr);
         return;
     }
     IBaseFilter_Release(filter);
diff --git a/dlls/quartz/tests/waveparser.c b/dlls/quartz/tests/waveparser.c
index 1c86a39c730..fee93b33f5f 100644
--- wine/dlls/quartz/tests/waveparser.c
+++ wine/dlls/quartz/tests/waveparser.c
@@ -30,7 +30,7 @@ static IBaseFilter *create_wave_parser(void)
     IBaseFilter *filter = NULL;
     HRESULT hr = CoCreateInstance(&CLSID_WAVEParser, NULL, CLSCTX_INPROC_SERVER,
             &IID_IBaseFilter, (void **)&filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     return filter;
 }
 
@@ -46,11 +46,11 @@ static WCHAR *load_resource(const WCHAR *name)
     wcscat(pathW, name);
 
     file = CreateFileW(pathW, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, 0);
-    ok(file != INVALID_HANDLE_VALUE, "Failed to create file %s, error %lu.\n",
+    ok(file != INVALID_HANDLE_VALUE, "Failed to create file %s, error %u.\n",
             wine_dbgstr_w(pathW), GetLastError());
 
     res = FindResourceW(NULL, name, (LPCWSTR)RT_RCDATA);
-    ok(!!res, "Failed to load resource, error %lu.\n", GetLastError());
+    ok(!!res, "Failed to load resource, error %u.\n", GetLastError());
     ptr = LockResource(LoadResource(GetModuleHandleA(NULL), res));
     WriteFile(file, ptr, SizeofResource( GetModuleHandleA(NULL), res), &written, NULL);
     ok(written == SizeofResource(GetModuleHandleA(NULL), res), "Failed to write resource.\n");
@@ -88,7 +88,7 @@ static IFilterGraph2 *connect_input(IBaseFilter *splitter, const WCHAR *filename
     IBaseFilter_FindPin(reader, L"Output", &source);
 
     hr = IFilterGraph2_ConnectDirect(graph, source, sink, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     IPin_Release(source);
     IPin_Release(sink);
@@ -107,7 +107,7 @@ static void check_interface_(unsigned int line, void *iface_ptr, REFIID iid, BOO
     expected_hr = supported ? S_OK : E_NOINTERFACE;
 
     hr = IUnknown_QueryInterface(iface, iid, (void **)&unk);
-    ok_(__FILE__, line)(hr == expected_hr, "Got hr %#lx, expected %#lx.\n", hr, expected_hr);
+    ok_(__FILE__, line)(hr == expected_hr, "Got hr %#x, expected %#x.\n", hr, expected_hr);
     if (SUCCEEDED(hr))
         IUnknown_Release(unk);
 }
@@ -212,53 +212,53 @@ static void test_aggregation(void)
     filter = (IBaseFilter *)0xdeadbeef;
     hr = CoCreateInstance(&CLSID_WAVEParser, &test_outer, CLSCTX_INPROC_SERVER,
             &IID_IBaseFilter, (void **)&filter);
-    ok(hr == E_NOINTERFACE, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOINTERFACE, "Got hr %#x.\n", hr);
     ok(!filter, "Got interface %p.\n", filter);
 
     hr = CoCreateInstance(&CLSID_WAVEParser, &test_outer, CLSCTX_INPROC_SERVER,
             &IID_IUnknown, (void **)&unk);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(outer_ref == 1, "Got unexpected refcount %ld.\n", outer_ref);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
     ok(unk != &test_outer, "Returned IUnknown should not be outer IUnknown.\n");
     ref = get_refcount(unk);
-    ok(ref == 1, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
 
     ref = IUnknown_AddRef(unk);
-    ok(ref == 2, "Got unexpected refcount %ld.\n", ref);
-    ok(outer_ref == 1, "Got unexpected refcount %ld.\n", outer_ref);
+    ok(ref == 2, "Got unexpected refcount %d.\n", ref);
+    ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
 
     ref = IUnknown_Release(unk);
-    ok(ref == 1, "Got unexpected refcount %ld.\n", ref);
-    ok(outer_ref == 1, "Got unexpected refcount %ld.\n", outer_ref);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
+    ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
 
     hr = IUnknown_QueryInterface(unk, &IID_IUnknown, (void **)&unk2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(unk2 == unk, "Got unexpected IUnknown %p.\n", unk2);
     IUnknown_Release(unk2);
 
     hr = IUnknown_QueryInterface(unk, &IID_IBaseFilter, (void **)&filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_QueryInterface(filter, &IID_IUnknown, (void **)&unk2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(unk2 == (IUnknown *)0xdeadbeef, "Got unexpected IUnknown %p.\n", unk2);
 
     hr = IBaseFilter_QueryInterface(filter, &IID_IBaseFilter, (void **)&filter2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(filter2 == (IBaseFilter *)0xdeadbeef, "Got unexpected IBaseFilter %p.\n", filter2);
 
     hr = IUnknown_QueryInterface(unk, &test_iid, (void **)&unk2);
-    ok(hr == E_NOINTERFACE, "Got hr %#lx.\n", hr);
+    ok(hr == E_NOINTERFACE, "Got hr %#x.\n", hr);
     ok(!unk2, "Got unexpected IUnknown %p.\n", unk2);
 
     hr = IBaseFilter_QueryInterface(filter, &test_iid, (void **)&unk2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(unk2 == (IUnknown *)0xdeadbeef, "Got unexpected IUnknown %p.\n", unk2);
 
     IBaseFilter_Release(filter);
     ref = IUnknown_Release(unk);
-    ok(!ref, "Got unexpected refcount %ld.\n", ref);
-    ok(outer_ref == 1, "Got unexpected refcount %ld.\n", outer_ref);
+    ok(!ref, "Got unexpected refcount %d.\n", ref);
+    ok(outer_ref == 1, "Got unexpected refcount %d.\n", outer_ref);
 }
 
 static void test_enum_pins(void)
@@ -273,79 +273,79 @@ static void test_enum_pins(void)
     BOOL ret;
 
     ref = get_refcount(filter);
-    ok(ref == 1, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
 
     hr = IBaseFilter_EnumPins(filter, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_EnumPins(filter, &enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ref = get_refcount(filter);
-    ok(ref == 2, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 2, "Got unexpected refcount %d.\n", ref);
     ref = get_refcount(enum1);
-    ok(ref == 1, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
 
     hr = IEnumPins_Next(enum1, 1, NULL, NULL);
-    ok(hr == E_POINTER, "Got hr %#lx.\n", hr);
+    ok(hr == E_POINTER, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum1, 1, pins, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ref = get_refcount(filter);
-    ok(ref == 3, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 3, "Got unexpected refcount %d.\n", ref);
     ref = get_refcount(pins[0]);
-    ok(ref == 3, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 3, "Got unexpected refcount %d.\n", ref);
     ref = get_refcount(enum1);
-    ok(ref == 1, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 1, "Got unexpected refcount %d.\n", ref);
     IPin_Release(pins[0]);
     ref = get_refcount(filter);
-    ok(ref == 2, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == 2, "Got unexpected refcount %d.\n", ref);
 
     hr = IEnumPins_Next(enum1, 1, pins, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum1, 1, pins, &count);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(count == 1, "Got count %lu.\n", count);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(count == 1, "Got count %u.\n", count);
     IPin_Release(pins[0]);
 
     hr = IEnumPins_Next(enum1, 1, pins, &count);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
-    ok(!count, "Got count %lu.\n", count);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    ok(!count, "Got count %u.\n", count);
 
     hr = IEnumPins_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum1, 2, pins, NULL);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum1, 2, pins, &count);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
-    ok(count == 1, "Got count %lu.\n", count);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    ok(count == 1, "Got count %u.\n", count);
     IPin_Release(pins[0]);
 
     hr = IEnumPins_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Clone(enum1, &enum2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Skip(enum1, 2);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Skip(enum1, 1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Skip(enum1, 1);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum1, 1, pins, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum2, 1, pins, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     IPin_Release(pins[0]);
 
     IEnumPins_Release(enum2);
@@ -353,46 +353,46 @@ static void test_enum_pins(void)
     graph = connect_input(filter, filename);
 
     hr = IEnumPins_Next(enum1, 1, pins, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum1, 1, pins, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     IPin_Release(pins[0]);
 
     hr = IEnumPins_Next(enum1, 1, pins, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     IPin_Release(pins[0]);
 
     hr = IEnumPins_Next(enum1, 1, pins, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum1, 2, pins, &count);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(count == 2, "Got count %lu.\n", count);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(count == 2, "Got count %u.\n", count);
     IPin_Release(pins[0]);
     IPin_Release(pins[1]);
 
     hr = IEnumPins_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum1, 3, pins, &count);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
-    ok(count == 2, "Got count %lu.\n", count);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    ok(count == 2, "Got count %u.\n", count);
     IPin_Release(pins[0]);
     IPin_Release(pins[1]);
 
     IEnumPins_Release(enum1);
     IFilterGraph2_Release(graph);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ret = DeleteFileW(filename);
-    ok(ret, "Failed to delete file, error %lu.\n", GetLastError());
+    ok(ret, "Failed to delete file, error %u.\n", GetLastError());
 }
 
 static void test_find_pin(void)
@@ -407,31 +407,31 @@ static void test_find_pin(void)
     BOOL ret;
 
     hr = IBaseFilter_FindPin(filter, L"input pin", &pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     IPin_Release(pin);
 
     hr = IBaseFilter_FindPin(filter, L"output", &pin);
-    ok(hr == VFW_E_NOT_FOUND, "Got hr %#lx.\n", hr);
+    ok(hr == VFW_E_NOT_FOUND, "Got hr %#x.\n", hr);
 
     graph = connect_input(filter, filename);
 
     hr = IBaseFilter_EnumPins(filter, &enum_pins);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumPins_Next(enum_pins, 1, &pin2, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_FindPin(filter, L"output", &pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(pin == pin2, "Expected pin %p, got %p.\n", pin2, pin);
     IPin_Release(pin);
     IPin_Release(pin2);
 
     hr = IEnumPins_Next(enum_pins, 1, &pin2, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_FindPin(filter, L"input pin", &pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(pin == pin2, "Expected pin %p, got %p.\n", pin2, pin);
     IPin_Release(pin);
     IPin_Release(pin2);
@@ -439,9 +439,9 @@ static void test_find_pin(void)
     IEnumPins_Release(enum_pins);
     IFilterGraph2_Release(graph);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ret = DeleteFileW(filename);
-    ok(ret, "Failed to delete file, error %lu.\n", GetLastError());
+    ok(ret, "Failed to delete file, error %u.\n", GetLastError());
 }
 
 static void test_pin_info(void)
@@ -460,52 +460,52 @@ static void test_pin_info(void)
     graph = connect_input(filter, filename);
 
     hr = IBaseFilter_FindPin(filter, L"input pin", &pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     expect_ref = get_refcount(filter);
     ref = get_refcount(pin);
-    ok(ref == expect_ref, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == expect_ref, "Got unexpected refcount %d.\n", ref);
 
     hr = IPin_QueryPinInfo(pin, &info);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(info.pFilter == filter, "Expected filter %p, got %p.\n", filter, info.pFilter);
     ok(info.dir == PINDIR_INPUT, "Got direction %d.\n", info.dir);
     ok(!wcscmp(info.achName, L"input pin"), "Got name %s.\n", wine_dbgstr_w(info.achName));
     ref = get_refcount(filter);
-    ok(ref == expect_ref + 1, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == expect_ref + 1, "Got unexpected refcount %d.\n", ref);
     ref = get_refcount(pin);
-    ok(ref == expect_ref + 1, "Got unexpected refcount %ld.\n", ref);
+    ok(ref == expect_ref + 1, "Got unexpected refcount %d.\n", ref);
     IBaseFilter_Release(info.pFilter);
 
     hr = IPin_QueryDirection(pin, &dir);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(dir == PINDIR_INPUT, "Got direction %d.\n", dir);
 
     hr = IPin_QueryId(pin, &id);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(!wcscmp(id, L"input pin"), "Got id %s.\n", wine_dbgstr_w(id));
     CoTaskMemFree(id);
 
     IPin_Release(pin);
 
     hr = IBaseFilter_FindPin(filter, L"output", &pin);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     check_interface(pin, &IID_IPin, TRUE);
     check_interface(pin, &IID_IMediaSeeking, TRUE);
 
     hr = IPin_QueryPinInfo(pin, &info);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(info.pFilter == filter, "Expected filter %p, got %p.\n", filter, info.pFilter);
     ok(info.dir == PINDIR_OUTPUT, "Got direction %d.\n", info.dir);
     ok(!wcscmp(info.achName, L"output"), "Got name %s.\n", wine_dbgstr_w(info.achName));
     IBaseFilter_Release(info.pFilter);
 
     hr = IPin_QueryDirection(pin, &dir);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(dir == PINDIR_OUTPUT, "Got direction %d.\n", dir);
 
     hr = IPin_QueryId(pin, &id);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(!wcscmp(id, L"output"), "Got id %s.\n", wine_dbgstr_w(id));
     CoTaskMemFree(id);
 
@@ -513,9 +513,9 @@ static void test_pin_info(void)
 
     IFilterGraph2_Release(graph);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ret = DeleteFileW(filename);
-    ok(ret, "Failed to delete file, error %lu.\n", GetLastError());
+    ok(ret, "Failed to delete file, error %u.\n", GetLastError());
 }
 
 static void test_media_types(void)
@@ -536,42 +536,42 @@ static void test_media_types(void)
     IBaseFilter_FindPin(filter, L"input pin", &pin);
 
     hr = IPin_EnumMediaTypes(pin, &enummt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enummt, 1, &pmt, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     IEnumMediaTypes_Release(enummt);
 
     mt.majortype = MEDIATYPE_Stream;
     mt.subtype = MEDIASUBTYPE_WAVE;
     hr = IPin_QueryAccept(pin, &mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     mt.bFixedSizeSamples = TRUE;
     mt.bTemporalCompression = TRUE;
     mt.lSampleSize = 123;
     mt.formattype = FORMAT_VideoInfo;
     hr = IPin_QueryAccept(pin, &mt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     mt.majortype = GUID_NULL;
     hr = IPin_QueryAccept(pin, &mt);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     mt.majortype = MEDIATYPE_Stream;
 
     mt.subtype = GUID_NULL;
     hr = IPin_QueryAccept(pin, &mt);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     mt.subtype = MEDIASUBTYPE_WAVE;
 
     graph = connect_input(filter, filename);
 
     hr = IPin_EnumMediaTypes(pin, &enummt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enummt, 1, &pmt, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     IEnumMediaTypes_Release(enummt);
     IPin_Release(pin);
@@ -579,48 +579,48 @@ static void test_media_types(void)
     IBaseFilter_FindPin(filter, L"output", &pin);
 
     hr = IPin_EnumMediaTypes(pin, &enummt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enummt, 1, &pmt, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(IsEqualGUID(&pmt->majortype, &MEDIATYPE_Audio), "Got major type %s.\n",
             wine_dbgstr_guid(&pmt->majortype));
     ok(IsEqualGUID(&pmt->subtype, &MEDIASUBTYPE_PCM), "Got subtype %s\n",
             wine_dbgstr_guid(&pmt->subtype));
     ok(pmt->bFixedSizeSamples == TRUE, "Got fixed size %d.\n", pmt->bFixedSizeSamples);
     ok(!pmt->bTemporalCompression, "Got temporal compression %d.\n", pmt->bTemporalCompression);
-    ok(pmt->lSampleSize == 1, "Got sample size %lu.\n", pmt->lSampleSize);
+    ok(pmt->lSampleSize == 1, "Got sample size %u.\n", pmt->lSampleSize);
     ok(IsEqualGUID(&pmt->formattype, &FORMAT_WaveFormatEx), "Got format type %s.\n",
             wine_dbgstr_guid(&pmt->formattype));
     ok(!pmt->pUnk, "Got pUnk %p.\n", pmt->pUnk);
-    ok(pmt->cbFormat == sizeof(WAVEFORMATEX), "Got format size %lu.\n", pmt->cbFormat);
+    ok(pmt->cbFormat == sizeof(WAVEFORMATEX), "Got format size %u.\n", pmt->cbFormat);
     ok(!memcmp(pmt->pbFormat, &expect_wfx, sizeof(WAVEFORMATEX)), "Format blocks didn't match.\n");
 
     hr = IPin_QueryAccept(pin, pmt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     pmt->bFixedSizeSamples = FALSE;
     pmt->bTemporalCompression = TRUE;
     pmt->lSampleSize = 123;
     hr = IPin_QueryAccept(pin, pmt);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     pmt->majortype = GUID_NULL;
     hr = IPin_QueryAccept(pin, pmt);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     pmt->majortype = MEDIATYPE_Audio;
 
     pmt->subtype = GUID_NULL;
     hr = IPin_QueryAccept(pin, pmt);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     pmt->subtype = MEDIASUBTYPE_WAVE;
 
     pmt->formattype = GUID_NULL;
     hr = IPin_QueryAccept(pin, pmt);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     pmt->formattype = FORMAT_None;
     hr = IPin_QueryAccept(pin, pmt);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     wfx = (WAVEFORMATEX *)pmt->pbFormat;
 
@@ -628,28 +628,28 @@ static void test_media_types(void)
     wfx->nAvgBytesPerSec = 44100 * 2;
     wfx->nBlockAlign = 2;
     hr = IPin_QueryAccept(pin, pmt);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     *wfx = expect_wfx;
 
     wfx->wFormatTag = WAVE_FORMAT_IMA_ADPCM;
     hr = IPin_QueryAccept(pin, pmt);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     *wfx = expect_wfx;
 
     CoTaskMemFree(pmt->pbFormat);
     CoTaskMemFree(pmt);
 
     hr = IEnumMediaTypes_Next(enummt, 1, &pmt, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     IEnumMediaTypes_Release(enummt);
     IPin_Release(pin);
 
     IFilterGraph2_Release(graph);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ret = DeleteFileW(filename);
-    ok(ret, "Failed to delete file, error %lu.\n", GetLastError());
+    ok(ret, "Failed to delete file, error %u.\n", GetLastError());
 }
 
 static void test_enum_media_types(void)
@@ -667,29 +667,29 @@ static void test_enum_media_types(void)
     IBaseFilter_FindPin(filter, L"input pin", &pin);
 
     hr = IPin_EnumMediaTypes(pin, &enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enum1, 1, mts, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enum1, 1, mts, &count);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
-    ok(!count, "Got count %lu.\n", count);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    ok(!count, "Got count %u.\n", count);
 
     hr = IEnumMediaTypes_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enum1, 1, mts, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Clone(enum1, &enum2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Skip(enum1, 1);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enum2, 1, mts, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     IEnumMediaTypes_Release(enum1);
     IEnumMediaTypes_Release(enum2);
@@ -698,64 +698,64 @@ static void test_enum_media_types(void)
     IBaseFilter_FindPin(filter, L"output", &pin);
 
     hr = IPin_EnumMediaTypes(pin, &enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enum1, 1, mts, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     CoTaskMemFree(mts[0]->pbFormat);
     CoTaskMemFree(mts[0]);
 
     hr = IEnumMediaTypes_Next(enum1, 1, mts, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enum1, 1, mts, &count);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(count == 1, "Got count %lu.\n", count);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(count == 1, "Got count %u.\n", count);
     CoTaskMemFree(mts[0]->pbFormat);
     CoTaskMemFree(mts[0]);
 
     hr = IEnumMediaTypes_Next(enum1, 1, mts, &count);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
-    ok(!count, "Got count %lu.\n", count);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    ok(!count, "Got count %u.\n", count);
 
     hr = IEnumMediaTypes_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enum1, 2, mts, &count);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
-    ok(count == 1, "Got count %lu.\n", count);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    ok(count == 1, "Got count %u.\n", count);
     CoTaskMemFree(mts[0]->pbFormat);
     CoTaskMemFree(mts[0]);
 
     hr = IEnumMediaTypes_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Clone(enum1, &enum2);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Skip(enum1, 2);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Skip(enum1, 1);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Reset(enum1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Skip(enum1, 1);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Skip(enum1, 1);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enum1, 1, mts, NULL);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IEnumMediaTypes_Next(enum2, 1, mts, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     CoTaskMemFree(mts[0]->pbFormat);
     CoTaskMemFree(mts[0]);
 
@@ -765,9 +765,9 @@ static void test_enum_media_types(void)
 
     IFilterGraph2_Release(graph);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ret = DeleteFileW(filename);
-    ok(ret, "Failed to delete file, error %lu.\n", GetLastError());
+    ok(ret, "Failed to delete file, error %u.\n", GetLastError());
 }
 
 static void test_unconnected_filter_state(void)
@@ -778,53 +778,53 @@ static void test_unconnected_filter_state(void)
     ULONG ref;
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(state == State_Stopped, "Got state %u.\n", state);
 
     hr = IBaseFilter_Pause(filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(state == State_Paused, "Got state %u.\n", state);
 
     hr = IBaseFilter_Run(filter, 0);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(state == State_Running, "Got state %u.\n", state);
 
     hr = IBaseFilter_Pause(filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(state == State_Paused, "Got state %u.\n", state);
 
     hr = IBaseFilter_Stop(filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(state == State_Stopped, "Got state %u.\n", state);
 
     hr = IBaseFilter_Run(filter, 0);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(state == State_Running, "Got state %u.\n", state);
 
     hr = IBaseFilter_Stop(filter);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IBaseFilter_GetState(filter, 0, &state);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(state == State_Stopped, "Got state %u.\n", state);
 
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
 }
 
 static void test_seeking(void)
@@ -864,137 +864,137 @@ static void test_seeking(void)
     IPin_QueryInterface(pin, &IID_IMediaSeeking, (void **)&seeking);
 
     hr = IMediaSeeking_GetCapabilities(seeking, &caps);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     todo_wine ok(caps == (AM_SEEKING_CanSeekAbsolute | AM_SEEKING_CanSeekForwards
             | AM_SEEKING_CanSeekBackwards | AM_SEEKING_CanGetStopPos
-            | AM_SEEKING_CanGetDuration | AM_SEEKING_CanDoSegments), "Got caps %#lx.\n", caps);
+            | AM_SEEKING_CanGetDuration | AM_SEEKING_CanDoSegments), "Got caps %#x.\n", caps);
 
     caps = AM_SEEKING_CanSeekAbsolute | AM_SEEKING_CanSeekForwards;
     hr = IMediaSeeking_CheckCapabilities(seeking, &caps);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
-    ok(caps == (AM_SEEKING_CanSeekAbsolute | AM_SEEKING_CanSeekForwards), "Got caps %#lx.\n", caps);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
+    ok(caps == (AM_SEEKING_CanSeekAbsolute | AM_SEEKING_CanSeekForwards), "Got caps %#x.\n", caps);
 
     caps = AM_SEEKING_CanSeekAbsolute | AM_SEEKING_CanGetCurrentPos;
     hr = IMediaSeeking_CheckCapabilities(seeking, &caps);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
-    ok(caps == AM_SEEKING_CanSeekAbsolute, "Got caps %#lx.\n", caps);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
+    ok(caps == AM_SEEKING_CanSeekAbsolute, "Got caps %#x.\n", caps);
 
     caps = AM_SEEKING_CanGetCurrentPos;
     hr = IMediaSeeking_CheckCapabilities(seeking, &caps);
-    ok(hr == E_FAIL, "Got hr %#lx.\n", hr);
-    ok(!caps, "Got caps %#lx.\n", caps);
+    ok(hr == E_FAIL, "Got hr %#x.\n", hr);
+    ok(!caps, "Got caps %#x.\n", caps);
 
     caps = 0;
     hr = IMediaSeeking_CheckCapabilities(seeking, &caps);
-    ok(hr == E_FAIL, "Got hr %#lx.\n", hr);
-    ok(!caps, "Got caps %#lx.\n", caps);
+    ok(hr == E_FAIL, "Got hr %#x.\n", hr);
+    ok(!caps, "Got caps %#x.\n", caps);
 
     for (i = 0; i < ARRAY_SIZE(format_tests); ++i)
     {
         hr = IMediaSeeking_IsFormatSupported(seeking, format_tests[i].guid);
-        todo_wine_if(i == 1) ok(hr == format_tests[i].hr, "Got hr %#lx for format %s.\n",
+        todo_wine_if(i == 1) ok(hr == format_tests[i].hr, "Got hr %#x for format %s.\n",
                 hr, wine_dbgstr_guid(format_tests[i].guid));
     }
 
     hr = IMediaSeeking_QueryPreferredFormat(seeking, &format);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(IsEqualGUID(&format, &TIME_FORMAT_MEDIA_TIME), "Got format %s.\n", wine_dbgstr_guid(&format));
 
     hr = IMediaSeeking_GetTimeFormat(seeking, &format);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(IsEqualGUID(&format, &TIME_FORMAT_MEDIA_TIME), "Got format %s.\n", wine_dbgstr_guid(&format));
 
     hr = IMediaSeeking_IsUsingTimeFormat(seeking, &TIME_FORMAT_MEDIA_TIME);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     hr = IMediaSeeking_IsUsingTimeFormat(seeking, &TIME_FORMAT_SAMPLE);
-    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    ok(hr == S_FALSE, "Got hr %#x.\n", hr);
 
     hr = IMediaSeeking_SetTimeFormat(seeking, &TIME_FORMAT_FRAME);
-    ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
     hr = IMediaSeeking_SetTimeFormat(seeking, &TIME_FORMAT_SAMPLE);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaSeeking_GetTimeFormat(seeking, &format);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     todo_wine ok(IsEqualGUID(&format, &TIME_FORMAT_SAMPLE), "Got format %s.\n", wine_dbgstr_guid(&format));
 
     hr = IMediaSeeking_IsUsingTimeFormat(seeking, &TIME_FORMAT_MEDIA_TIME);
-    todo_wine ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_FALSE, "Got hr %#x.\n", hr);
     hr = IMediaSeeking_IsUsingTimeFormat(seeking, &TIME_FORMAT_SAMPLE);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     hr = IMediaSeeking_SetTimeFormat(seeking, &TIME_FORMAT_MEDIA_TIME);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     duration = 0xdeadbeef;
     hr = IMediaSeeking_GetDuration(seeking, &duration);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(duration == 1000000, "Got duration %I64d.\n", duration);
 
     stop = current = 0xdeadbeef;
     hr = IMediaSeeking_GetStopPosition(seeking, &stop);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(stop == duration, "Expected time %s, got %s.\n",
             wine_dbgstr_longlong(duration), wine_dbgstr_longlong(stop));
     hr = IMediaSeeking_GetCurrentPosition(seeking, &current);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(!current, "Got time %s.\n", wine_dbgstr_longlong(current));
     stop = current = 0xdeadbeef;
     hr = IMediaSeeking_GetPositions(seeking, &current, &stop);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(!current, "Got time %s.\n", wine_dbgstr_longlong(current));
     ok(stop == duration, "Expected time %s, got %s.\n",
             wine_dbgstr_longlong(duration), wine_dbgstr_longlong(stop));
 
     time = 0xdeadbeef;
     hr = IMediaSeeking_ConvertTimeFormat(seeking, &time, &TIME_FORMAT_MEDIA_TIME, 0x123456789a, NULL);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(time == 0x123456789a, "Got time %s.\n", wine_dbgstr_longlong(time));
     time = 0xdeadbeef;
     hr = IMediaSeeking_ConvertTimeFormat(seeking, &time, NULL, 0x123456789a, &TIME_FORMAT_MEDIA_TIME);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(time == 0x123456789a, "Got time %s.\n", wine_dbgstr_longlong(time));
     time = 0xdeadbeef;
     hr = IMediaSeeking_ConvertTimeFormat(seeking, &time, NULL, 441, &TIME_FORMAT_SAMPLE);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
     todo_wine ok(time == 100000, "Got time %s.\n", wine_dbgstr_longlong(time));
 
     earliest = latest = 0xdeadbeef;
     hr = IMediaSeeking_GetAvailable(seeking, &earliest, &latest);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(!earliest, "Got time %s.\n", wine_dbgstr_longlong(earliest));
     ok(latest == duration, "Expected time %s, got %s.\n",
             wine_dbgstr_longlong(duration), wine_dbgstr_longlong(latest));
 
     rate = 0;
     hr = IMediaSeeking_GetRate(seeking, &rate);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(rate == 1.0, "Got rate %.16e.\n", rate);
 
     hr = IMediaSeeking_SetRate(seeking, 200.0);
-    todo_wine ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == S_OK, "Got hr %#x.\n", hr);
     rate = 0;
     hr = IMediaSeeking_GetRate(seeking, &rate);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     todo_wine ok(rate == 200.0, "Got rate %.16e.\n", rate);
 
     hr = IMediaSeeking_SetRate(seeking, -1.0);
-    todo_wine ok(hr == E_INVALIDARG, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == E_INVALIDARG, "Got hr %#x.\n", hr);
 
     hr = IMediaSeeking_GetPreroll(seeking, &time);
-    todo_wine ok(hr == E_NOTIMPL, "Got hr %#lx.\n", hr);
+    todo_wine ok(hr == E_NOTIMPL, "Got hr %#x.\n", hr);
 
     current = 200 * 10000;
     stop = 400 * 10000;
     hr = IMediaSeeking_SetPositions(seeking, &current, AM_SEEKING_AbsolutePositioning,
             &stop, AM_SEEKING_AbsolutePositioning);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(current == 200 * 10000, "Got time %s.\n", wine_dbgstr_longlong(current));
     ok(stop == 400 * 10000, "Got time %s.\n", wine_dbgstr_longlong(stop));
 
     stop = current = 0xdeadbeef;
     hr = IMediaSeeking_GetPositions(seeking, &current, &stop);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(current == 200 * 10000, "Got time %s.\n", wine_dbgstr_longlong(current));
     ok(stop == 400 * 10000, "Got time %s.\n", wine_dbgstr_longlong(stop));
 
@@ -1002,7 +1002,7 @@ static void test_seeking(void)
     stop = 400 * 10000;
     hr = IMediaSeeking_SetPositions(seeking, &current, AM_SEEKING_AbsolutePositioning | AM_SEEKING_ReturnTime,
             &stop, AM_SEEKING_AbsolutePositioning | AM_SEEKING_ReturnTime);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(current == 200 * 10000, "Got time %s.\n", wine_dbgstr_longlong(current));
     ok(stop == 400 * 10000, "Got time %s.\n", wine_dbgstr_longlong(stop));
 
@@ -1010,18 +1010,18 @@ static void test_seeking(void)
     stop = 200 * 10000;
     hr = IMediaSeeking_SetPositions(seeking, &current, AM_SEEKING_AbsolutePositioning | AM_SEEKING_ReturnTime,
             &stop, AM_SEEKING_AbsolutePositioning | AM_SEEKING_ReturnTime);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(current == 100 * 10000, "Got time %s.\n", wine_dbgstr_longlong(current));
     ok(stop == 200 * 10000, "Got time %s.\n", wine_dbgstr_longlong(stop));
 
     current = 50 * 10000;
     hr = IMediaSeeking_SetPositions(seeking, &current, AM_SEEKING_AbsolutePositioning,
             NULL, AM_SEEKING_NoPositioning);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
 
     stop = current = 0xdeadbeef;
     hr = IMediaSeeking_GetPositions(seeking, &current, &stop);
-    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(hr == S_OK, "Got hr %#x.\n", hr);
     ok(current == 50 * 10000, "Got time %s.\n", wine_dbgstr_longlong(current));
     ok(stop == 200 * 10000, "Got time %s.\n", wine_dbgstr_longlong(stop));
 
@@ -1029,9 +1029,9 @@ static void test_seeking(void)
     IPin_Release(pin);
     IFilterGraph2_Release(graph);
     ref = IBaseFilter_Release(filter);
-    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    ok(!ref, "Got outstanding refcount %d.\n", ref);
     ret = DeleteFileW(filename);
-    ok(ret, "Failed to delete file, error %lu.\n", GetLastError());
+    ok(ret, "Failed to delete file, error %u.\n", GetLastError());
 }
 
 START_TEST(waveparser)
diff --git a/dlls/quartz/videorenderer.c b/dlls/quartz/videorenderer.c
index f725a9998ce..1dbb8a02181 100644
--- wine/dlls/quartz/videorenderer.c
+++ wine/dlls/quartz/videorenderer.c
@@ -92,7 +92,7 @@ static HRESULT video_renderer_render(struct strmbase_renderer *iface, IMediaSamp
     hr = IMediaSample_GetPointer(pSample, &pbSrcStream);
     if (FAILED(hr))
     {
-        ERR("Failed to get buffer pointer, hr %#lx.\n", hr);
+        ERR("Cannot get pointer to sample data (%x)\n", hr);
         return hr;
     }
 
@@ -277,7 +277,7 @@ static HRESULT WINAPI VideoWindow_get_FullScreenMode(IVideoWindow *iface,
 {
     struct video_renderer *This = impl_from_IVideoWindow(iface);
 
-    TRACE("window %p, fullscreen %p.\n", This, FullScreenMode);
+    TRACE("(%p/%p)->(%p): %d\n", This, iface, FullScreenMode, This->FullScreenMode);
 
     if (!FullScreenMode)
         return E_POINTER;
@@ -292,7 +292,7 @@ static HRESULT WINAPI VideoWindow_put_FullScreenMode(IVideoWindow *iface, LONG f
     struct video_renderer *filter = impl_from_IVideoWindow(iface);
     HWND window = filter->window.hwnd;
 
-    FIXME("filter %p, fullscreen %ld.\n", filter, fullscreen);
+    FIXME("filter %p, fullscreen %d.\n", filter, fullscreen);
 
     if (fullscreen)
     {
@@ -399,7 +399,7 @@ static HRESULT WINAPI overlay_GetPalette(IOverlay *iface, DWORD *count, PALETTEE
 
 static HRESULT WINAPI overlay_SetPalette(IOverlay *iface, DWORD count, PALETTEENTRY *palette)
 {
-    FIXME("iface %p, count %lu, palette %p, stub!\n", iface, count, palette);
+    FIXME("iface %p, count %u, palette %p, stub!\n", iface, count, palette);
     return E_NOTIMPL;
 }
 
@@ -445,7 +445,7 @@ static HRESULT WINAPI overlay_GetVideoPosition(IOverlay *iface, RECT *source, RE
 
 static HRESULT WINAPI overlay_Advise(IOverlay *iface, IOverlayNotify *sink, DWORD flags)
 {
-    FIXME("iface %p, sink %p, flags %#lx, stub!\n", iface, sink, flags);
+    FIXME("iface %p, sink %p, flags %#x, stub!\n", iface, sink, flags);
     return E_NOTIMPL;
 }
 
@@ -481,8 +481,6 @@ HRESULT video_renderer_create(IUnknown *outer, IUnknown **out)
         return E_OUTOFMEMORY;
 
     strmbase_renderer_init(&object->renderer, outer, &CLSID_VideoRenderer, L"In", &renderer_ops);
-    wcscpy(object->renderer.sink.pin.name, L"Input");
-
     object->IOverlay_iface.lpVtbl = &overlay_vtbl;
 
     video_window_init(&object->window, &IVideoWindow_VTable,
diff --git a/dlls/quartz/vmr9.c b/dlls/quartz/vmr9.c
index 2330f8fc0c9..4bde811c6d7 100644
--- wine/dlls/quartz/vmr9.c
+++ wine/dlls/quartz/vmr9.c
@@ -33,7 +33,6 @@
 #include "ddraw.h"
 #include "dvdmedia.h"
 #include "d3d9.h"
-#include "videoacc.h"
 #include "vmr9.h"
 
 #include "wine/debug.h"
@@ -79,7 +78,6 @@ struct quartz_vmr
      * Native uses a separate reference count for IVMRSurfaceAllocatorNotify9. */
     LONG IVMRSurfaceAllocatorNotify9_refcount;
 
-    IAMVideoAccelerator IAMVideoAccelerator_iface;
     IOverlay IOverlay_iface;
 
     IVMRSurfaceAllocator9 *allocator;
@@ -246,7 +244,7 @@ static HRESULT vmr_render(struct strmbase_renderer *iface, IMediaSample *sample)
 
     if (FAILED(hr = IMediaSample_GetPointer(sample, &data)))
     {
-        ERR("Failed to get pointer to sample data, hr %#lx.\n", hr);
+        ERR("Failed to get pointer to sample data, hr %#x.\n", hr);
         return hr;
     }
     data_size = IMediaSample_GetActualDataLength(sample);
@@ -269,7 +267,7 @@ static HRESULT vmr_render(struct strmbase_renderer *iface, IMediaSample *sample)
 
     if (FAILED(hr = IDirect3DSurface9_LockRect(info.lpSurf, &locked_rect, NULL, D3DLOCK_DISCARD)))
     {
-        ERR("Failed to lock surface, hr %#lx.\n", hr);
+        ERR("Failed to lock surface, hr %#x.\n", hr);
         return hr;
     }
 
@@ -334,7 +332,7 @@ static HRESULT initialize_device(struct quartz_vmr *filter, VMR9AllocationInfo *
     if (FAILED(hr = IVMRSurfaceAllocator9_InitializeDevice(filter->allocator,
             filter->cookie, info, &count)))
     {
-        WARN("Failed to initialize device (flags %#lx), hr %#lx.\n", info->dwFlags, hr);
+        WARN("Failed to initialize device (flags %#x), hr %#x.\n", info->dwFlags, hr);
         return hr;
     }
 
@@ -343,7 +341,7 @@ static HRESULT initialize_device(struct quartz_vmr *filter, VMR9AllocationInfo *
         if (FAILED(hr = IVMRSurfaceAllocator9_GetSurface(filter->allocator,
                 filter->cookie, i, 0, &filter->surfaces[i])))
         {
-            ERR("Failed to get surface %lu, hr %#lx.\n", i, hr);
+            ERR("Failed to get surface %u, hr %#x.\n", i, hr);
             while (i--)
                 IDirect3DSurface9_Release(filter->surfaces[i]);
             IVMRSurfaceAllocator9_TerminateDevice(filter->allocator, filter->cookie);
@@ -427,7 +425,7 @@ static HRESULT allocate_surfaces(struct quartz_vmr *filter, const AM_MEDIA_TYPE
             break;
 
         default:
-            WARN("Unhandled video compression %#lx.\n", filter->bmiheader.biCompression);
+            WARN("Unhandled video compression %#x.\n", filter->bmiheader.biCompression);
             free(filter->surfaces);
             return VFW_E_TYPE_NOT_ACCEPTED;
         }
@@ -612,9 +610,7 @@ static HRESULT vmr_pin_query_interface(struct strmbase_renderer *iface, REFIID i
 {
     struct quartz_vmr *filter = impl_from_IBaseFilter(&iface->filter.IBaseFilter_iface);
 
-    if (IsEqualGUID(iid, &IID_IAMVideoAccelerator))
-        *out = &filter->IAMVideoAccelerator_iface;
-    else if (IsEqualGUID(iid, &IID_IOverlay))
+    if (IsEqualGUID(iid, &IID_IOverlay))
         *out = &filter->IOverlay_iface;
     else
         return E_NOINTERFACE;
@@ -886,12 +882,11 @@ static HRESULT WINAPI VMR7FilterConfig_SetImageCompositor(IVMRFilterConfig *ifac
     return E_NOTIMPL;
 }
 
-static HRESULT WINAPI VMR7FilterConfig_SetNumberOfStreams(IVMRFilterConfig *iface, DWORD count)
+static HRESULT WINAPI VMR7FilterConfig_SetNumberOfStreams(IVMRFilterConfig *iface, DWORD max)
 {
-    struct quartz_vmr *filter = impl_from_IVMRFilterConfig(iface);
-
-    FIXME("filter %p, count %lu, stub!\n", filter, count);
+    struct quartz_vmr *This = impl_from_IVMRFilterConfig(iface);
 
+    FIXME("(%p/%p)->(%u) stub\n", iface, This, max);
     return E_NOTIMPL;
 }
 
@@ -903,12 +898,11 @@ static HRESULT WINAPI VMR7FilterConfig_GetNumberOfStreams(IVMRFilterConfig *ifac
     return E_NOTIMPL;
 }
 
-static HRESULT WINAPI VMR7FilterConfig_SetRenderingPrefs(IVMRFilterConfig *iface, DWORD flags)
+static HRESULT WINAPI VMR7FilterConfig_SetRenderingPrefs(IVMRFilterConfig *iface, DWORD renderflags)
 {
-    struct quartz_vmr *filter = impl_from_IVMRFilterConfig(iface);
-
-    FIXME("filter %p, flags %#lx, stub!\n", filter, flags);
+    struct quartz_vmr *This = impl_from_IVMRFilterConfig(iface);
 
+    FIXME("(%p/%p)->(%u) stub\n", iface, This, renderflags);
     return E_NOTIMPL;
 }
 
@@ -924,7 +918,7 @@ static HRESULT WINAPI VMR7FilterConfig_SetRenderingMode(IVMRFilterConfig *iface,
 {
     struct quartz_vmr *filter = impl_from_IVMRFilterConfig(iface);
 
-    TRACE("iface %p, mode %#lx.\n", iface, mode);
+    TRACE("iface %p, mode %#x.\n", iface, mode);
 
     return IVMRFilterConfig9_SetRenderingMode(&filter->IVMRFilterConfig9_iface, mode);
 }
@@ -1110,7 +1104,7 @@ static HRESULT WINAPI VMR7MonitorConfig_GetAvailableMonitors(IVMRMonitorConfig *
     struct quartz_vmr *This = impl_from_IVMRMonitorConfig(iface);
     struct get_available_monitors_args args;
 
-    TRACE("filter %p, info %p, arraysize %lu, numdev %p.\n", This, info, arraysize, numdev);
+    FIXME("(%p/%p)->(%p, %u, %p) semi-stub\n", iface, This, info, arraysize, numdev);
 
     if (!numdev)
         return E_POINTER;
@@ -1210,7 +1204,7 @@ static HRESULT WINAPI VMR9MonitorConfig_GetAvailableMonitors(IVMRMonitorConfig9
     struct quartz_vmr *This = impl_from_IVMRMonitorConfig9(iface);
     struct get_available_monitors_args args;
 
-    TRACE("filter %p, info %p, arraysize %lu, numdev %p.\n", This, info, arraysize, numdev);
+    FIXME("(%p/%p)->(%p, %u, %p) semi-stub\n", iface, This, info, arraysize, numdev);
 
     if (!numdev)
         return E_POINTER;
@@ -1270,7 +1264,7 @@ static HRESULT WINAPI VMR9FilterConfig_SetNumberOfStreams(IVMRFilterConfig9 *ifa
 {
     struct quartz_vmr *filter = impl_from_IVMRFilterConfig9(iface);
 
-    FIXME("iface %p, count %lu, stub!\n", iface, count);
+    FIXME("iface %p, count %u, stub!\n", iface, count);
 
     if (!count)
     {
@@ -1313,12 +1307,11 @@ static HRESULT WINAPI VMR9FilterConfig_GetNumberOfStreams(IVMRFilterConfig9 *ifa
     return S_OK;
 }
 
-static HRESULT WINAPI VMR9FilterConfig_SetRenderingPrefs(IVMRFilterConfig9 *iface, DWORD flags)
+static HRESULT WINAPI VMR9FilterConfig_SetRenderingPrefs(IVMRFilterConfig9 *iface, DWORD renderflags)
 {
-    struct quartz_vmr *filter = impl_from_IVMRFilterConfig9(iface);
-
-    TRACE("filter %p, flags %#lx.\n", filter, flags);
+    struct quartz_vmr *This = impl_from_IVMRFilterConfig9(iface);
 
+    FIXME("(%p/%p)->(%u) stub\n", iface, This, renderflags);
     return E_NOTIMPL;
 }
 
@@ -1335,7 +1328,7 @@ static HRESULT WINAPI VMR9FilterConfig_SetRenderingMode(IVMRFilterConfig9 *iface
     HRESULT hr = S_OK;
     struct quartz_vmr *This = impl_from_IVMRFilterConfig9(iface);
 
-    TRACE("filter %p, mode %lu.\n", This, mode);
+    TRACE("(%p/%p)->(%u)\n", iface, This, mode);
 
     EnterCriticalSection(&This->renderer.filter.filter_cs);
     if (This->mode)
@@ -1360,14 +1353,14 @@ static HRESULT WINAPI VMR9FilterConfig_SetRenderingMode(IVMRFilterConfig9 *iface
 
         if (FAILED(hr = VMR9DefaultAllocatorPresenterImpl_create(This, (void **)&This->presenter)))
         {
-            ERR("Failed to create default presenter, hr %#lx.\n", hr);
+            ERR("Failed to create default presenter, hr %#x.\n", hr);
             break;
         }
 
         if (FAILED(hr = IVMRImagePresenter9_QueryInterface(This->presenter,
                     &IID_IVMRSurfaceAllocator9, (void **)&This->allocator)))
         {
-            ERR("Failed to query for IVMRSurfaceAllocator9, hr %#lx.\n", hr);
+            ERR("Failed to query for IVMRSurfaceAllocator9, hr %#x.\n", hr);
             IVMRImagePresenter9_Release(This->presenter);
             This->allocator = NULL;
             This->presenter = NULL;
@@ -1727,7 +1720,7 @@ static HRESULT WINAPI VMR9WindowlessControl_SetAspectRatioMode(IVMRWindowlessCon
 {
     struct quartz_vmr *filter = impl_from_IVMRWindowlessControl9(iface);
 
-    TRACE("filter %p, mode %lu.\n", filter, mode);
+    TRACE("filter %p, mode %u.\n", filter, mode);
 
     EnterCriticalSection(&filter->renderer.filter.filter_cs);
     filter->aspect_mode = mode;
@@ -1943,7 +1936,7 @@ static ULONG WINAPI VMR9SurfaceAllocatorNotify_AddRef(IVMRSurfaceAllocatorNotify
     struct quartz_vmr *filter = impl_from_IVMRSurfaceAllocatorNotify9(iface);
     ULONG refcount = InterlockedIncrement(&filter->IVMRSurfaceAllocatorNotify9_refcount);
 
-    TRACE("%p increasing refcount to %lu.\n", iface, refcount);
+    TRACE("%p increasing refcount to %u.\n", iface, refcount);
 
     return refcount;
 }
@@ -1953,7 +1946,7 @@ static ULONG WINAPI VMR9SurfaceAllocatorNotify_Release(IVMRSurfaceAllocatorNotif
     struct quartz_vmr *filter = impl_from_IVMRSurfaceAllocatorNotify9(iface);
     ULONG refcount = InterlockedDecrement(&filter->IVMRSurfaceAllocatorNotify9_refcount);
 
-    TRACE("%p decreasing refcount to %lu.\n", iface, refcount);
+    TRACE("%p decreasing refcount to %u.\n", iface, refcount);
 
     if (!refcount && !filter->renderer.filter.refcount)
         free(filter);
@@ -2038,7 +2031,7 @@ static HRESULT WINAPI VMR9SurfaceAllocatorNotify_AllocateSurfaceHelper(IVMRSurfa
     if (!allocinfo || !numbuffers || !surface)
         return E_POINTER;
 
-    TRACE("Flags %#lx, size %lux%lu, format %u (%#x), pool %u, minimum buffers %lu.\n",
+    TRACE("Flags %#x, size %ux%u, format %u (%#x), pool %u, minimum buffers %u.\n",
             allocinfo->dwFlags, allocinfo->dwWidth, allocinfo->dwHeight,
             allocinfo->Format, allocinfo->Format, allocinfo->Pool, allocinfo->MinBuffers);
 
@@ -2063,7 +2056,7 @@ static HRESULT WINAPI VMR9SurfaceAllocatorNotify_AllocateSurfaceHelper(IVMRSurfa
 
     if (!*numbuffers || *numbuffers < allocinfo->MinBuffers)
     {
-        WARN("%lu surfaces requested (minimum %lu); returning E_INVALIDARG.\n",
+        WARN("%u surfaces requested (minimum %u); returning E_INVALIDARG.\n",
                 *numbuffers, allocinfo->MinBuffers);
         return E_INVALIDARG;
     }
@@ -2110,12 +2103,12 @@ static HRESULT WINAPI VMR9SurfaceAllocatorNotify_AllocateSurfaceHelper(IVMRSurfa
     }
     else
     {
-        FIXME("Unhandled flags %#lx.\n", allocinfo->dwFlags);
+        FIXME("Unhandled flags %#x.\n", allocinfo->dwFlags);
         return E_NOTIMPL;
     }
 
     if (FAILED(hr))
-        WARN("%lu/%lu surfaces allocated, hr %#lx.\n", i, *numbuffers, hr);
+        WARN("%u/%u surfaces allocated, hr %#x.\n", i, *numbuffers, hr);
 
     if (i >= allocinfo->MinBuffers)
     {
@@ -2177,7 +2170,7 @@ static HRESULT WINAPI mixer_control9_SetAlpha(IVMRMixerControl9 *iface, DWORD st
 {
     struct quartz_vmr *filter = impl_from_IVMRMixerControl9(iface);
 
-    FIXME("filter %p, stream %lu, alpha %.8e, stub!\n", filter, stream, alpha);
+    FIXME("filter %p, stream %u, alpha %.8e, stub!\n", filter, stream, alpha);
 
     return E_NOTIMPL;
 }
@@ -2186,7 +2179,7 @@ static HRESULT WINAPI mixer_control9_GetAlpha(IVMRMixerControl9 *iface, DWORD st
 {
     struct quartz_vmr *filter = impl_from_IVMRMixerControl9(iface);
 
-    FIXME("filter %p, stream %lu, alpha %p, stub!\n", filter, stream, alpha);
+    FIXME("filter %p, stream %u, alpha %p, stub!\n", filter, stream, alpha);
 
     return E_NOTIMPL;
 }
@@ -2195,7 +2188,7 @@ static HRESULT WINAPI mixer_control9_SetZOrder(IVMRMixerControl9 *iface, DWORD s
 {
     struct quartz_vmr *filter = impl_from_IVMRMixerControl9(iface);
 
-    FIXME("filter %p, stream %lu, z %lu, stub!\n", filter, stream, z);
+    FIXME("filter %p, stream %u, z %u, stub!\n", filter, stream, z);
 
     return E_NOTIMPL;
 }
@@ -2204,7 +2197,7 @@ static HRESULT WINAPI mixer_control9_GetZOrder(IVMRMixerControl9 *iface, DWORD s
 {
     struct quartz_vmr *filter = impl_from_IVMRMixerControl9(iface);
 
-    FIXME("filter %p, stream %lu, z %p, stub!\n", filter, stream, z);
+    FIXME("filter %p, stream %u, z %p, stub!\n", filter, stream, z);
 
     return E_NOTIMPL;
 }
@@ -2214,7 +2207,7 @@ static HRESULT WINAPI mixer_control9_SetOutputRect(IVMRMixerControl9 *iface,
 {
     struct quartz_vmr *filter = impl_from_IVMRMixerControl9(iface);
 
-    FIXME("filter %p, stream %lu, rect %s, stub!\n", filter, stream, debugstr_normalized_rect(rect));
+    FIXME("filter %p, stream %u, rect %s, stub!\n", filter, stream, debugstr_normalized_rect(rect));
 
     return E_NOTIMPL;
 }
@@ -2224,7 +2217,7 @@ static HRESULT WINAPI mixer_control9_GetOutputRect(IVMRMixerControl9 *iface,
 {
     struct quartz_vmr *filter = impl_from_IVMRMixerControl9(iface);
 
-    FIXME("filter %p, stream %lu, rect %p, stub!\n", filter, stream, rect);
+    FIXME("filter %p, stream %u, rect %p, stub!\n", filter, stream, rect);
 
     return E_NOTIMPL;
 }
@@ -2233,7 +2226,7 @@ static HRESULT WINAPI mixer_control9_SetBackgroundClr(IVMRMixerControl9 *iface,
 {
     struct quartz_vmr *filter = impl_from_IVMRMixerControl9(iface);
 
-    FIXME("filter %p, color #%06lx, stub!\n", filter, color);
+    FIXME("filter %p, color #%06x, stub!\n", filter, color);
 
     return E_NOTIMPL;
 }
@@ -2251,7 +2244,7 @@ static HRESULT WINAPI mixer_control9_SetMixingPrefs(IVMRMixerControl9 *iface, DW
 {
     struct quartz_vmr *filter = impl_from_IVMRMixerControl9(iface);
 
-    FIXME("filter %p, flags %#lx, stub!\n", filter, flags);
+    FIXME("filter %p, flags %#x, stub!\n", filter, flags);
 
     EnterCriticalSection(&filter->renderer.filter.filter_cs);
     filter->mixing_prefs = flags;
@@ -2348,7 +2341,7 @@ static HRESULT WINAPI mixer_bitmap9_SetAlphaBitmap(IVMRMixerBitmap9 *iface,
         const VMR9AlphaBitmap *bitmap)
 {
     FIXME("iface %p, bitmap %p, stub!\n", iface, bitmap);
-    TRACE("dwFlags %#lx, hdc %p, pDDS %p, rSrc %s, rDest %s, fAlpha %.8e, clrSrcKey #%06lx, dwFilterMode %#lx.\n",
+    TRACE("dwFlags %#x, hdc %p, pDDS %p, rSrc %s, rDest %s, fAlpha %.8e, clrSrcKey #%06x, dwFilterMode %#x.\n",
             bitmap->dwFlags, bitmap->hdc, bitmap->pDDS, wine_dbgstr_rect(&bitmap->rSrc),
             debugstr_normalized_rect(&bitmap->rDest), bitmap->fAlpha, bitmap->clrSrcKey, bitmap->dwFilterMode);
     return E_NOTIMPL;
@@ -2417,7 +2410,7 @@ static HRESULT WINAPI aspect_ratio_control9_SetAspectRatioMode(IVMRAspectRatioCo
 {
     struct quartz_vmr *filter = impl_from_IVMRAspectRatioControl9(iface);
 
-    TRACE("filter %p, mode %lu.\n", filter, mode);
+    TRACE("filter %p, mode %u.\n", filter, mode);
 
     EnterCriticalSection(&filter->renderer.filter.filter_cs);
     filter->aspect_mode = mode;
@@ -2434,139 +2427,6 @@ static const IVMRAspectRatioControl9Vtbl aspect_ratio_control9_vtbl =
     aspect_ratio_control9_SetAspectRatioMode,
 };
 
-static struct quartz_vmr *impl_from_IAMVideoAccelerator(IAMVideoAccelerator *iface)
-{
-    return CONTAINING_RECORD(iface, struct quartz_vmr, IAMVideoAccelerator_iface);
-}
-
-static HRESULT WINAPI video_accelerator_QueryInterface(IAMVideoAccelerator *iface, REFIID iid, void **out)
-{
-    struct quartz_vmr *filter = impl_from_IAMVideoAccelerator(iface);
-    return IPin_QueryInterface(&filter->renderer.sink.pin.IPin_iface, iid, out);
-}
-
-static ULONG WINAPI video_accelerator_AddRef(IAMVideoAccelerator *iface)
-{
-    struct quartz_vmr *filter = impl_from_IAMVideoAccelerator(iface);
-    return IPin_AddRef(&filter->renderer.sink.pin.IPin_iface);
-}
-
-static ULONG WINAPI video_accelerator_Release(IAMVideoAccelerator *iface)
-{
-    struct quartz_vmr *filter = impl_from_IAMVideoAccelerator(iface);
-    return IPin_Release(&filter->renderer.sink.pin.IPin_iface);
-}
-
-static HRESULT WINAPI video_accelerator_GetVideoAcceleratorGUIDs(
-        IAMVideoAccelerator *iface, DWORD *count, GUID *accelerators)
-{
-    FIXME("iface %p, count %p, accelerators %p, stub!\n", iface, count, accelerators);
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI video_accelerator_GetUncompFormatsSupported(IAMVideoAccelerator *iface,
-        const GUID *accelerator, DWORD *count, DDPIXELFORMAT *formats)
-{
-    FIXME("iface %p, accelerator %s, count %p, formats %p, stub!\n",
-            iface, debugstr_guid(accelerator), count, formats);
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI video_accelerator_GetInternalMemInfo(IAMVideoAccelerator *iface,
-        const GUID *accelerator, const AMVAUncompDataInfo *format_info, AMVAInternalMemInfo *mem_info)
-{
-    FIXME("iface %p, accelerator %s, format_info %p, mem_info %p, stub!\n",
-            iface, debugstr_guid(accelerator), format_info, mem_info);
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI video_accelerator_GetCompBufferInfo(IAMVideoAccelerator *iface,
-        const GUID *accelerator, const AMVAUncompDataInfo *uncompressed_info,
-        DWORD *compressed_info_count, AMVACompBufferInfo *compressed_infos)
-{
-    FIXME("iface %p, accelerator %s, uncompressed_info %p, compressed_info_count %p, compressed_infos %p, stub!\n",
-            iface, debugstr_guid(accelerator), uncompressed_info, compressed_info_count, compressed_infos);
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI video_accelerator_GetInternalCompBufferInfo(
-        IAMVideoAccelerator *iface, DWORD *count, AMVACompBufferInfo *infos)
-{
-    FIXME("iface %p, count %p, infos %p, stub!\n", iface, count, infos);
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI video_accelerator_BeginFrame(IAMVideoAccelerator *iface, const AMVABeginFrameInfo *info)
-{
-    FIXME("iface %p, info %p, stub!\n", iface, info);
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI video_accelerator_EndFrame(IAMVideoAccelerator *iface, const AMVAEndFrameInfo *info)
-{
-    FIXME("iface %p, info %p, stub!\n", iface, info);
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI video_accelerator_GetBuffer(IAMVideoAccelerator *iface,
-        DWORD type_index, DWORD buffer_index, BOOL read_only, void **buffer, LONG *stride)
-{
-    FIXME("iface %p, type_index %lu, buffer_index %lu, read_only %d, buffer %p, stride %p, stub!\n",
-            iface, type_index, buffer_index, read_only, buffer, stride);
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI video_accelerator_ReleaseBuffer(
-        IAMVideoAccelerator *iface, DWORD type_index, DWORD buffer_index)
-{
-    FIXME("iface %p, type_index %lu, buffer_index %lu, stub!\n", iface, type_index, buffer_index);
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI video_accelerator_Execute(IAMVideoAccelerator *iface,
-        DWORD function, void *in_data, DWORD in_size, void *out_data,
-        DWORD out_size, DWORD buffer_count, const AMVABUFFERINFO *buffers)
-{
-    FIXME("iface %p, function %#lx, in_data %p, in_size %lu,"
-            " out_data %p, out_size %lu, buffer_count %lu, buffers %p, stub!\n",
-            iface, function, in_data, in_size, out_data, out_size, buffer_count, buffers);
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI video_accelerator_QueryRenderStatus(IAMVideoAccelerator *iface,
-        DWORD type_index, DWORD buffer_index, DWORD flags)
-{
-    FIXME("iface %p, type_index %lu, buffer_index %lu, flags %#lx, stub!\n",
-            iface, type_index, buffer_index, flags);
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI video_accelerator_DisplayFrame(
-        IAMVideoAccelerator *iface, DWORD index, IMediaSample *sample)
-{
-    FIXME("iface %p, index %lu, sample %p, stub!\n", iface, index, sample);
-    return E_NOTIMPL;
-}
-
-static const IAMVideoAcceleratorVtbl video_accelerator_vtbl =
-{
-    video_accelerator_QueryInterface,
-    video_accelerator_AddRef,
-    video_accelerator_Release,
-    video_accelerator_GetVideoAcceleratorGUIDs,
-    video_accelerator_GetUncompFormatsSupported,
-    video_accelerator_GetInternalMemInfo,
-    video_accelerator_GetCompBufferInfo,
-    video_accelerator_GetInternalCompBufferInfo,
-    video_accelerator_BeginFrame,
-    video_accelerator_EndFrame,
-    video_accelerator_GetBuffer,
-    video_accelerator_ReleaseBuffer,
-    video_accelerator_Execute,
-    video_accelerator_QueryRenderStatus,
-    video_accelerator_DisplayFrame,
-};
-
 static inline struct quartz_vmr *impl_from_IOverlay(IOverlay *iface)
 {
     return CONTAINING_RECORD(iface, struct quartz_vmr, IOverlay_iface);
@@ -2598,7 +2458,7 @@ static HRESULT WINAPI overlay_GetPalette(IOverlay *iface, DWORD *count, PALETTEE
 
 static HRESULT WINAPI overlay_SetPalette(IOverlay *iface, DWORD count, PALETTEENTRY *palette)
 {
-    FIXME("iface %p, count %lu, palette %p, stub!\n", iface, count, palette);
+    FIXME("iface %p, count %u, palette %p, stub!\n", iface, count, palette);
     return E_NOTIMPL;
 }
 
@@ -2647,7 +2507,7 @@ static HRESULT WINAPI overlay_GetVideoPosition(IOverlay *iface, RECT *source, RE
 
 static HRESULT WINAPI overlay_Advise(IOverlay *iface, IOverlayNotify *sink, DWORD flags)
 {
-    FIXME("iface %p, sink %p, flags %#lx, stub!\n", iface, sink, flags);
+    FIXME("iface %p, sink %p, flags %#x, stub!\n", iface, sink, flags);
     return E_NOTIMPL;
 }
 
@@ -2704,8 +2564,6 @@ static HRESULT vmr_create(IUnknown *outer, IUnknown **out, const CLSID *clsid)
     object->IVMRSurfaceAllocatorNotify9_iface.lpVtbl = &VMR9_SurfaceAllocatorNotify_Vtbl;
     object->IVMRWindowlessControl_iface.lpVtbl = &VMR7_WindowlessControl_Vtbl;
     object->IVMRWindowlessControl9_iface.lpVtbl = &VMR9_WindowlessControl_Vtbl;
-
-    object->IAMVideoAccelerator_iface.lpVtbl = &video_accelerator_vtbl;
     object->IOverlay_iface.lpVtbl = &overlay_vtbl;
 
     video_window_init(&object->window, &IVideoWindow_VTable,
@@ -2765,30 +2623,32 @@ static HRESULT WINAPI VMR9_ImagePresenter_QueryInterface(IVMRImagePresenter9 *if
 
 static ULONG WINAPI VMR9_ImagePresenter_AddRef(IVMRImagePresenter9 *iface)
 {
-    struct default_presenter *presenter = impl_from_IVMRImagePresenter9(iface);
-    ULONG refcount = InterlockedIncrement(&presenter->refCount);
+    struct default_presenter *This = impl_from_IVMRImagePresenter9(iface);
+    ULONG refCount = InterlockedIncrement(&This->refCount);
 
-    TRACE("%p increasing refcount to %lu.\n", presenter, refcount);
+    TRACE("(%p)->() AddRef from %d\n", iface, refCount - 1);
 
-    return refcount;
+    return refCount;
 }
 
 static ULONG WINAPI VMR9_ImagePresenter_Release(IVMRImagePresenter9 *iface)
 {
     struct default_presenter *This = impl_from_IVMRImagePresenter9(iface);
-    ULONG refcount = InterlockedDecrement(&This->refCount);
+    ULONG refCount = InterlockedDecrement(&This->refCount);
 
-    TRACE("%p decreasing refcount to %lu.\n", This, refcount);
+    TRACE("(%p)->() Release from %d\n", iface, refCount + 1);
 
-    if (!refcount)
+    if (!refCount)
     {
         DWORD i;
-
+        TRACE("Destroying\n");
         IDirect3D9_Release(This->d3d9_ptr);
 
+        TRACE("Number of surfaces: %u\n", This->num_surfaces);
         for (i = 0; i < This->num_surfaces; ++i)
         {
             IDirect3DSurface9 *surface = This->d3d9_surfaces[i];
+            TRACE("Releasing surface %p\n", surface);
             if (surface)
                 IDirect3DSurface9_Release(surface);
         }
@@ -2801,7 +2661,7 @@ static ULONG WINAPI VMR9_ImagePresenter_Release(IVMRImagePresenter9 *iface)
         free(This);
         return 0;
     }
-    return refcount;
+    return refCount;
 }
 
 static HRESULT WINAPI VMR9_ImagePresenter_StartPresenting(IVMRImagePresenter9 *iface, DWORD_PTR cookie)
@@ -2841,23 +2701,23 @@ static HRESULT WINAPI VMR9_ImagePresenter_PresentImage(IVMRImagePresenter9 *ifac
 
     if (FAILED(hr = IDirect3DDevice9_Clear(device, 0, NULL, D3DCLEAR_TARGET,
             D3DCOLOR_XRGB(0, 0, 0), 1.0f, 0)))
-        ERR("Failed to clear, hr %#lx.\n", hr);
+        ERR("Failed to clear, hr %#x.\n", hr);
 
     if (FAILED(hr = IDirect3DDevice9_BeginScene(device)))
-        ERR("Failed to begin scene, hr %#lx.\n", hr);
+        ERR("Failed to begin scene, hr %#x.\n", hr);
 
     if (FAILED(hr = IDirect3DDevice9_GetBackBuffer(device, 0, 0, D3DBACKBUFFER_TYPE_MONO, &backbuffer)))
     {
-        ERR("Failed to get backbuffer, hr %#lx.\n", hr);
+        ERR("Failed to get backbuffer, hr %#x.\n", hr);
         return hr;
     }
 
     if (FAILED(hr = IDirect3DDevice9_StretchRect(device, info->lpSurf, NULL, backbuffer, NULL, D3DTEXF_POINT)))
-        ERR("Failed to blit image, hr %#lx.\n", hr);
+        ERR("Failed to blit image, hr %#x.\n", hr);
     IDirect3DSurface9_Release(backbuffer);
 
     if (FAILED(hr = IDirect3DDevice9_EndScene(device)))
-        ERR("Failed to end scene, hr %#lx.\n", hr);
+        ERR("Failed to end scene, hr %#x.\n", hr);
 
     if (filter->aspect_mode == VMR9ARMode_LetterBox)
     {
@@ -2885,7 +2745,7 @@ static HRESULT WINAPI VMR9_ImagePresenter_PresentImage(IVMRImagePresenter9 *ifac
     }
 
     if (FAILED(hr = IDirect3DDevice9_Present(device, &src, &dst, NULL, NULL)))
-        ERR("Failed to present, hr %#lx.\n", hr);
+        ERR("Failed to present, hr %#x.\n", hr);
 
     return S_OK;
 }
@@ -2918,15 +2778,21 @@ static ULONG WINAPI VMR9_SurfaceAllocator_Release(IVMRSurfaceAllocator9 *iface)
     return IVMRImagePresenter9_Release(&presenter->IVMRImagePresenter9_iface);
 }
 
-static void adjust_surface_size(const D3DCAPS9 *caps, VMR9AllocationInfo *allocinfo)
+static HRESULT VMR9_SurfaceAllocator_SetAllocationSettings(struct default_presenter *This, VMR9AllocationInfo *allocinfo)
 {
+    D3DCAPS9 caps;
     UINT width, height;
+    HRESULT hr;
 
-    /* There are no restrictions on the size of offscreen surfaces. */
     if (!(allocinfo->dwFlags & VMR9AllocFlag_TextureSurface))
-        return;
+        /* Only needed for texture surfaces */
+        return S_OK;
 
-    if (!(caps->TextureCaps & D3DPTEXTURECAPS_POW2) || (caps->TextureCaps & D3DPTEXTURECAPS_SQUAREONLY))
+    hr = IDirect3DDevice9_GetDeviceCaps(This->d3d9_dev, &caps);
+    if (FAILED(hr))
+        return hr;
+
+    if (!(caps.TextureCaps & D3DPTEXTURECAPS_POW2) || (caps.TextureCaps & D3DPTEXTURECAPS_SQUAREONLY))
     {
         width = allocinfo->dwWidth;
         height = allocinfo->dwHeight;
@@ -2942,7 +2808,7 @@ static void adjust_surface_size(const D3DCAPS9 *caps, VMR9AllocationInfo *alloci
         FIXME("NPOW2 support missing, not using proper surfaces!\n");
     }
 
-    if (caps->TextureCaps & D3DPTEXTURECAPS_SQUAREONLY)
+    if (caps.TextureCaps & D3DPTEXTURECAPS_SQUAREONLY)
     {
         if (height > width)
             width = height;
@@ -2953,6 +2819,8 @@ static void adjust_surface_size(const D3DCAPS9 *caps, VMR9AllocationInfo *alloci
 
     allocinfo->dwHeight = height;
     allocinfo->dwWidth = width;
+
+    return hr;
 }
 
 static UINT d3d9_adapter_from_hwnd(IDirect3D9 *d3d9, HWND hwnd, HMONITOR *mon_out)
@@ -3013,7 +2881,7 @@ static HRESULT WINAPI VMR9_SurfaceAllocator_InitializeDevice(IVMRSurfaceAllocato
             NULL, D3DCREATE_MIXED_VERTEXPROCESSING, &d3dpp, &device);
     if (FAILED(hr))
     {
-        ERR("Failed to create device, hr %#lx.\n", hr);
+        ERR("Could not create device: %08x\n", hr);
         return hr;
     }
 
@@ -3031,13 +2899,19 @@ static HRESULT WINAPI VMR9_SurfaceAllocator_InitializeDevice(IVMRSurfaceAllocato
     if (!(This->d3d9_surfaces = calloc(*numbuffers, sizeof(IDirect3DSurface9 *))))
         return E_OUTOFMEMORY;
 
-    adjust_surface_size(&caps, info);
+    hr = VMR9_SurfaceAllocator_SetAllocationSettings(This, info);
+    if (FAILED(hr))
+        ERR("Setting allocation settings failed: %08x\n", hr);
+
+    if (SUCCEEDED(hr))
+    {
+        hr = IVMRSurfaceAllocatorNotify9_AllocateSurfaceHelper(This->SurfaceAllocatorNotify, info, numbuffers, This->d3d9_surfaces);
+        if (FAILED(hr))
+            ERR("Allocating surfaces failed: %08x\n", hr);
+    }
 
-    hr = IVMRSurfaceAllocatorNotify9_AllocateSurfaceHelper(This->SurfaceAllocatorNotify,
-            info, numbuffers, This->d3d9_surfaces);
     if (FAILED(hr))
     {
-        ERR("Failed to allocate surfaces, hr %#lx.\n", hr);
         IVMRSurfaceAllocator9_TerminateDevice(This->pVMR9->allocator, This->pVMR9->cookie);
         return hr;
     }
@@ -3049,7 +2923,7 @@ static HRESULT WINAPI VMR9_SurfaceAllocator_InitializeDevice(IVMRSurfaceAllocato
 
 static HRESULT WINAPI VMR9_SurfaceAllocator_TerminateDevice(IVMRSurfaceAllocator9 *iface, DWORD_PTR cookie)
 {
-    TRACE("iface %p, cookie %#Ix.\n", iface, cookie);
+    TRACE("iface %p, cookie %#lx.\n", iface, cookie);
 
     return S_OK;
 }
@@ -3113,6 +2987,8 @@ static IDirect3D9 *init_d3d9(HMODULE d3d9_handle)
 static HRESULT VMR9DefaultAllocatorPresenterImpl_create(struct quartz_vmr *parent, LPVOID * ppv)
 {
     struct default_presenter *object;
+    HRESULT hr = S_OK;
+    int i;
 
     if (!(object = calloc(1, sizeof(*object))))
         return E_OUTOFMEMORY;
@@ -3125,6 +3001,24 @@ static HRESULT VMR9DefaultAllocatorPresenterImpl_create(struct quartz_vmr *paren
         return VFW_E_DDRAW_CAPS_NOT_SUITABLE;
     }
 
+    i = 0;
+    do
+    {
+        D3DDISPLAYMODE mode;
+
+        hr = IDirect3D9_EnumAdapterModes(object->d3d9_ptr, i++, D3DFMT_X8R8G8B8, 0, &mode);
+	if (hr == D3DERR_INVALIDCALL) break; /* out of adapters */
+    } while (FAILED(hr));
+    if (FAILED(hr))
+        ERR("HR: %08x\n", hr);
+    if (hr == D3DERR_NOTAVAILABLE)
+    {
+        ERR("Format not supported\n");
+        IDirect3D9_Release(object->d3d9_ptr);
+        free(object);
+        return VFW_E_DDRAW_CAPS_NOT_SUITABLE;
+    }
+
     object->IVMRImagePresenter9_iface.lpVtbl = &VMR9_ImagePresenter;
     object->IVMRSurfaceAllocator9_iface.lpVtbl = &VMR9_SurfaceAllocator;
 
diff --git a/dlls/quartz/window.c b/dlls/quartz/window.c
index 3e19d9b582e..5b172d5f108 100644
--- wine/dlls/quartz/window.c
+++ wine/dlls/quartz/window.c
@@ -105,7 +105,7 @@ HRESULT video_window_create_window(struct video_window *window)
     winclass.lpszClassName = class_name;
     if (!RegisterClassW(&winclass) && GetLastError() != ERROR_CLASS_ALREADY_EXISTS)
     {
-        ERR("Failed to register class, error %lu.\n", GetLastError());
+        ERR("Unable to register window class: %u\n", GetLastError());
         return E_FAIL;
     }
 
@@ -151,7 +151,7 @@ HRESULT WINAPI BaseControlWindowImpl_GetTypeInfoCount(IVideoWindow *iface, UINT
 HRESULT WINAPI BaseControlWindowImpl_GetTypeInfo(IVideoWindow *iface, UINT index,
         LCID lcid, ITypeInfo **typeinfo)
 {
-    TRACE("iface %p, index %u, lcid %#lx, typeinfo %p.\n", iface, index, lcid, typeinfo);
+    TRACE("iface %p, index %u, lcid %#x, typeinfo %p.\n", iface, index, lcid, typeinfo);
     return strmbase_get_typeinfo(IVideoWindow_tid, typeinfo);
 }
 
@@ -161,7 +161,7 @@ HRESULT WINAPI BaseControlWindowImpl_GetIDsOfNames(IVideoWindow *iface, REFIID i
     ITypeInfo *typeinfo;
     HRESULT hr;
 
-    TRACE("iface %p, iid %s, names %p, count %u, lcid %#lx, ids %p.\n",
+    TRACE("iface %p, iid %s, names %p, count %u, lcid %#x, ids %p.\n",
             iface, debugstr_guid(iid), names, count, lcid, ids);
 
     if (SUCCEEDED(hr = strmbase_get_typeinfo(IVideoWindow_tid, &typeinfo)))
@@ -178,7 +178,7 @@ HRESULT WINAPI BaseControlWindowImpl_Invoke(IVideoWindow *iface, DISPID id, REFI
     ITypeInfo *typeinfo;
     HRESULT hr;
 
-    TRACE("iface %p, id %ld, iid %s, lcid %#lx, flags %#x, params %p, result %p, excepinfo %p, error_arg %p.\n",
+    TRACE("iface %p, id %d, iid %s, lcid %#x, flags %#x, params %p, result %p, excepinfo %p, error_arg %p.\n",
             iface, id, debugstr_guid(iid), lcid, flags, params, result, excepinfo, error_arg);
 
     if (SUCCEEDED(hr = strmbase_get_typeinfo(IVideoWindow_tid, &typeinfo)))
@@ -225,7 +225,7 @@ HRESULT WINAPI BaseControlWindowImpl_put_WindowStyle(IVideoWindow *iface, LONG s
 {
     struct video_window *window = impl_from_IVideoWindow(iface);
 
-    TRACE("window %p, style %#lx.\n", window, style);
+    TRACE("window %p, style %#x.\n", window, style);
 
     if (style & (WS_DISABLED|WS_HSCROLL|WS_MAXIMIZE|WS_MINIMIZE|WS_VSCROLL))
         return E_INVALIDARG;
@@ -250,7 +250,7 @@ HRESULT WINAPI BaseControlWindowImpl_put_WindowStyleEx(IVideoWindow *iface, LONG
 {
     struct video_window *window = impl_from_IVideoWindow(iface);
 
-    TRACE("window %p, style %#lx.\n", window, style);
+    TRACE("window %p, style %#x.\n", window, style);
 
     if (!SetWindowLongW(window->hwnd, GWL_EXSTYLE, style))
         return E_FAIL;
@@ -271,7 +271,7 @@ HRESULT WINAPI BaseControlWindowImpl_put_AutoShow(IVideoWindow *iface, LONG Auto
 {
     struct video_window *This = impl_from_IVideoWindow(iface);
 
-    TRACE("window %p, AutoShow %ld.\n", This, AutoShow);
+    TRACE("(%p/%p)->(%d)\n", This, iface, AutoShow);
 
     This->AutoShow = AutoShow;
 
@@ -293,7 +293,7 @@ HRESULT WINAPI BaseControlWindowImpl_put_WindowState(IVideoWindow *iface, LONG s
 {
     struct video_window *window = impl_from_IVideoWindow(iface);
 
-    TRACE("window %p, state %ld.\n", window, state);
+    TRACE("window %p, state %#x.\n", window, state);
 
     ShowWindow(window->hwnd, state);
     return S_OK;
@@ -323,7 +323,7 @@ HRESULT WINAPI BaseControlWindowImpl_put_BackgroundPalette(IVideoWindow *iface,
 {
     struct video_window *This = impl_from_IVideoWindow(iface);
 
-    FIXME("window %p, palette %ld, stub!\n", This, BackgroundPalette);
+    FIXME("(%p/%p)->(%d): stub !!!\n", This, iface, BackgroundPalette);
 
     return S_OK;
 }
@@ -341,7 +341,7 @@ HRESULT WINAPI BaseControlWindowImpl_put_Visible(IVideoWindow *iface, LONG visib
 {
     struct video_window *window = impl_from_IVideoWindow(iface);
 
-    TRACE("window %p, visible %ld.\n", window, visible);
+    TRACE("window %p, visible %d.\n", window, visible);
 
     ShowWindow(window->hwnd, visible ? SW_SHOW : SW_HIDE);
     return S_OK;
@@ -365,7 +365,7 @@ HRESULT WINAPI BaseControlWindowImpl_put_Left(IVideoWindow *iface, LONG left)
     struct video_window *window = impl_from_IVideoWindow(iface);
     RECT rect;
 
-    TRACE("window %p, left %ld.\n", window, left);
+    TRACE("window %p, left %d.\n", window, left);
 
     GetWindowRect(window->hwnd, &rect);
     if (!SetWindowPos(window->hwnd, NULL, left, rect.top, 0, 0,
@@ -392,7 +392,7 @@ HRESULT WINAPI BaseControlWindowImpl_put_Width(IVideoWindow *iface, LONG width)
     struct video_window *window = impl_from_IVideoWindow(iface);
     RECT rect;
 
-    TRACE("window %p, width %ld.\n", window, width);
+    TRACE("window %p, width %d.\n", window, width);
 
     GetWindowRect(window->hwnd, &rect);
     if (!SetWindowPos(window->hwnd, NULL, 0, 0, width, rect.bottom - rect.top,
@@ -419,7 +419,7 @@ HRESULT WINAPI BaseControlWindowImpl_put_Top(IVideoWindow *iface, LONG top)
     struct video_window *window = impl_from_IVideoWindow(iface);
     RECT rect;
 
-    TRACE("window %p, top %ld.\n", window, top);
+    TRACE("window %p, top %d.\n", window, top);
 
     GetWindowRect(window->hwnd, &rect);
     if (!SetWindowPos(window->hwnd, NULL, rect.left, top, 0, 0,
@@ -446,7 +446,7 @@ HRESULT WINAPI BaseControlWindowImpl_put_Height(IVideoWindow *iface, LONG height
     struct video_window *window = impl_from_IVideoWindow(iface);
     RECT rect;
 
-    TRACE("window %p, height %ld.\n", window, height);
+    TRACE("window %p, height %d.\n", window, height);
 
     GetWindowRect(window->hwnd, &rect);
     if (!SetWindowPos(window->hwnd, NULL, 0, 0, rect.right - rect.left,
@@ -473,7 +473,7 @@ HRESULT WINAPI BaseControlWindowImpl_put_Owner(IVideoWindow *iface, OAHWND owner
     struct video_window *window = impl_from_IVideoWindow(iface);
     HWND hwnd = window->hwnd;
 
-    TRACE("window %p, owner %#Ix.\n", window, owner);
+    TRACE("window %p, owner %#lx.\n", window, owner);
 
     /* Make sure we are marked as WS_CHILD before reparenting ourselves, so that
      * we do not steal focus. LEGO Island depends on this. */
@@ -503,7 +503,7 @@ HRESULT WINAPI BaseControlWindowImpl_put_MessageDrain(IVideoWindow *iface, OAHWN
 {
     struct video_window *This = impl_from_IVideoWindow(iface);
 
-    TRACE("window %p, drain %#Ix.\n", This, Drain);
+    TRACE("(%p/%p)->(%08x)\n", This, iface, (DWORD) Drain);
 
     This->hwndDrain = (HWND)Drain;
 
@@ -534,7 +534,7 @@ HRESULT WINAPI BaseControlWindowImpl_put_BorderColor(IVideoWindow *iface, LONG C
 {
     struct video_window *This = impl_from_IVideoWindow(iface);
 
-    TRACE("window %p, colour %#lx.\n", This, Color);
+    FIXME("(%p/%p)->(%d): stub !!!\n", This, iface, Color);
 
     return S_OK;
 }
@@ -546,12 +546,9 @@ HRESULT WINAPI BaseControlWindowImpl_get_FullScreenMode(IVideoWindow *iface, LON
     return E_NOTIMPL;
 }
 
-HRESULT WINAPI BaseControlWindowImpl_put_FullScreenMode(IVideoWindow *iface, LONG fullscreen)
+HRESULT WINAPI BaseControlWindowImpl_put_FullScreenMode(IVideoWindow *iface, LONG FullScreenMode)
 {
-    struct video_window *window = impl_from_IVideoWindow(iface);
-
-    TRACE("window %p, fullscreen %ld.\n", window, fullscreen);
-
+    TRACE("(%p)->(%d)\n", iface, FullScreenMode);
     return E_NOTIMPL;
 }
 
@@ -560,7 +557,7 @@ HRESULT WINAPI BaseControlWindowImpl_SetWindowForeground(IVideoWindow *iface, LO
     struct video_window *window = impl_from_IVideoWindow(iface);
     UINT flags = SWP_NOMOVE | SWP_NOSIZE;
 
-    TRACE("window %p, focus %ld.\n", window, focus);
+    TRACE("window %p, focus %d.\n", window, focus);
 
     if (focus != OAFALSE && focus != OATRUE)
         return E_INVALIDARG;
@@ -580,7 +577,7 @@ HRESULT WINAPI BaseControlWindowImpl_SetWindowPosition(IVideoWindow *iface,
 {
     struct video_window *window = impl_from_IVideoWindow(iface);
 
-    TRACE("window %p, left %ld, top %ld, width %ld, height %ld.\n", window, left, top, width, height);
+    TRACE("window %p, left %d, top %d, width %d, height %d.\n", window, left, top, width, height);
 
     if (!SetWindowPos(window->hwnd, NULL, left, top, width, height, SWP_NOACTIVATE | SWP_NOZORDER))
         return E_FAIL;
@@ -608,7 +605,7 @@ HRESULT WINAPI BaseControlWindowImpl_NotifyOwnerMessage(IVideoWindow *iface,
 {
     struct video_window *window = impl_from_IVideoWindow(iface);
 
-    TRACE("window %p, hwnd %#Ix, message %#lx, wparam %#Ix, lparam %#Ix.\n",
+    TRACE("window %p, hwnd %#lx, message %#x, wparam %#lx, lparam %#lx.\n",
             window, hwnd, message, wparam, lparam);
 
     /* That these messages are forwarded, and no others, is stated by the
@@ -664,11 +661,11 @@ HRESULT WINAPI BaseControlWindowImpl_GetRestorePosition(IVideoWindow *iface, LON
     return S_OK;
 }
 
-HRESULT WINAPI BaseControlWindowImpl_HideCursor(IVideoWindow *iface, LONG hide)
+HRESULT WINAPI BaseControlWindowImpl_HideCursor(IVideoWindow *iface, LONG HideCursor)
 {
-    struct video_window *window = impl_from_IVideoWindow(iface);
+    struct video_window *This = impl_from_IVideoWindow(iface);
 
-    FIXME("window %p, hide %ld, stub!\n", window, hide);
+    FIXME("(%p/%p)->(%d): stub !!!\n", This, iface, HideCursor);
 
     return S_OK;
 }
@@ -715,7 +712,7 @@ static HRESULT WINAPI basic_video_GetTypeInfoCount(IBasicVideo *iface, UINT *cou
 static HRESULT WINAPI basic_video_GetTypeInfo(IBasicVideo *iface, UINT index,
         LCID lcid, ITypeInfo **typeinfo)
 {
-    TRACE("iface %p, index %u, lcid %#lx, typeinfo %p.\n", iface, index, lcid, typeinfo);
+    TRACE("iface %p, index %u, lcid %#x, typeinfo %p.\n", iface, index, lcid, typeinfo);
     return strmbase_get_typeinfo(IBasicVideo_tid, typeinfo);
 }
 
@@ -725,7 +722,7 @@ static HRESULT WINAPI basic_video_GetIDsOfNames(IBasicVideo *iface, REFIID iid,
     ITypeInfo *typeinfo;
     HRESULT hr;
 
-    TRACE("iface %p, iid %s, names %p, count %u, lcid %#lx, ids %p.\n",
+    TRACE("iface %p, iid %s, names %p, count %u, lcid %#x, ids %p.\n",
             iface, debugstr_guid(iid), names, count, lcid, ids);
 
     if (SUCCEEDED(hr = strmbase_get_typeinfo(IBasicVideo_tid, &typeinfo)))
@@ -742,7 +739,7 @@ static HRESULT WINAPI basic_video_Invoke(IBasicVideo *iface, DISPID id, REFIID i
     ITypeInfo *typeinfo;
     HRESULT hr;
 
-    TRACE("iface %p, id %ld, iid %s, lcid %#lx, flags %#x, params %p, result %p, excepinfo %p, error_arg %p.\n",
+    TRACE("iface %p, id %d, iid %s, lcid %#x, flags %#x, params %p, result %p, excepinfo %p, error_arg %p.\n",
             iface, id, debugstr_guid(iid), lcid, flags, params, result, excepinfo, error_arg);
 
     if (SUCCEEDED(hr = strmbase_get_typeinfo(IBasicVideo_tid, &typeinfo)))
@@ -846,7 +843,7 @@ static HRESULT WINAPI basic_video_put_SourceLeft(IBasicVideo *iface, LONG left)
 {
     struct video_window *window = impl_from_IBasicVideo(iface);
 
-    TRACE("window %p, left %ld.\n", window, left);
+    TRACE("window %p, left %d.\n", window, left);
 
     if (left < 0 || window->src.right + left - window->src.left > get_bitmap_header(window)->biWidth)
         return E_INVALIDARG;
@@ -872,7 +869,7 @@ static HRESULT WINAPI basic_video_put_SourceWidth(IBasicVideo *iface, LONG width
 {
     struct video_window *window = impl_from_IBasicVideo(iface);
 
-    TRACE("window %p, width %ld.\n", window, width);
+    TRACE("window %p, width %d.\n", window, width);
 
     if (width <= 0 || window->src.left + width > get_bitmap_header(window)->biWidth)
         return E_INVALIDARG;
@@ -898,7 +895,7 @@ static HRESULT WINAPI basic_video_put_SourceTop(IBasicVideo *iface, LONG top)
 {
     struct video_window *window = impl_from_IBasicVideo(iface);
 
-    TRACE("window %p, top %ld.\n", window, top);
+    TRACE("window %p, top %d.\n", window, top);
 
     if (top < 0 || window->src.bottom + top - window->src.top > get_bitmap_header(window)->biHeight)
         return E_INVALIDARG;
@@ -924,7 +921,7 @@ static HRESULT WINAPI basic_video_put_SourceHeight(IBasicVideo *iface, LONG heig
 {
     struct video_window *window = impl_from_IBasicVideo(iface);
 
-    TRACE("window %p, height %ld.\n", window, height);
+    TRACE("window %p, height %d.\n", window, height);
 
     if (height <= 0 || window->src.top + height > get_bitmap_header(window)->biHeight)
         return E_INVALIDARG;
@@ -950,7 +947,7 @@ static HRESULT WINAPI basic_video_put_DestinationLeft(IBasicVideo *iface, LONG l
 {
     struct video_window *window = impl_from_IBasicVideo(iface);
 
-    TRACE("window %p, left %ld.\n", window, left);
+    TRACE("window %p, left %d.\n", window, left);
 
     window->default_dst = FALSE;
     OffsetRect(&window->dst, left - window->dst.left, 0);
@@ -974,7 +971,7 @@ static HRESULT WINAPI basic_video_put_DestinationWidth(IBasicVideo *iface, LONG
 {
     struct video_window *window = impl_from_IBasicVideo(iface);
 
-    TRACE("window %p, width %ld.\n", window, width);
+    TRACE("window %p, width %d.\n", window, width);
 
     if (width <= 0)
         return E_INVALIDARG;
@@ -1001,7 +998,7 @@ static HRESULT WINAPI basic_video_put_DestinationTop(IBasicVideo *iface, LONG to
 {
     struct video_window *window = impl_from_IBasicVideo(iface);
 
-    TRACE("window %p, top %ld.\n", window, top);
+    TRACE("window %p, top %d.\n", window, top);
 
     window->default_dst = FALSE;
     OffsetRect(&window->dst, 0, top - window->dst.top);
@@ -1025,7 +1022,7 @@ static HRESULT WINAPI basic_video_put_DestinationHeight(IBasicVideo *iface, LONG
 {
     struct video_window *window = impl_from_IBasicVideo(iface);
 
-    TRACE("window %p, height %ld.\n", window, height);
+    TRACE("window %p, height %d.\n", window, height);
 
     if (height <= 0)
         return E_INVALIDARG;
@@ -1054,7 +1051,7 @@ static HRESULT WINAPI basic_video_SetSourcePosition(IBasicVideo *iface,
     struct video_window *window = impl_from_IBasicVideo(iface);
     const BITMAPINFOHEADER *bitmap_header = get_bitmap_header(window);
 
-    TRACE("window %p, left %ld, top %ld, width %ld, height %ld.\n", window, left, top, width, height);
+    TRACE("window %p, left %d, top %d, width %d, height %d.\n", window, left, top, width, height);
 
     if (left < 0 || left + width > bitmap_header->biWidth || width <= 0)
         return E_INVALIDARG;
@@ -1098,7 +1095,7 @@ static HRESULT WINAPI basic_video_SetDestinationPosition(IBasicVideo *iface,
 {
     struct video_window *window = impl_from_IBasicVideo(iface);
 
-    TRACE("window %p, left %ld, top %ld, width %ld, height %ld.\n", window, left, top, width, height);
+    TRACE("window %p, left %d, top %d, width %d, height %d.\n", window, left, top, width, height);
 
     if (width <= 0 || height <= 0)
         return E_INVALIDARG;
@@ -1156,7 +1153,7 @@ static HRESULT WINAPI basic_video_GetVideoPaletteEntries(IBasicVideo *iface,
 {
     struct video_window *window = impl_from_IBasicVideo(iface);
 
-    FIXME("window %p, start %ld, count %ld, ret_count %p, palette %p, stub!\n",
+    FIXME("window %p, start %d, count %d, ret_count %p, palette %p, stub!\n",
             window, start, count, ret_count, palette);
 
     if (!ret_count || !palette)
@@ -1247,7 +1244,7 @@ static const IBasicVideoVtbl basic_video_vtbl =
 void video_window_unregister_class(void)
 {
     if (!UnregisterClassW(class_name, NULL) && GetLastError() != ERROR_CLASS_DOES_NOT_EXIST)
-        ERR("Failed to unregister class, error %lu.\n", GetLastError());
+        ERR("Failed to unregister class, error %u.\n", GetLastError());
 }
 
 void video_window_init(struct video_window *window, const IVideoWindowVtbl *vtbl,
diff --git a/dlls/wined3d/adapter_vk.c b/dlls/wined3d/adapter_vk.c
index f1ccb987750..423faa25648 100644
--- wine/dlls/wined3d/adapter_vk.c
+++ wine/dlls/wined3d/adapter_vk.c
@@ -2264,7 +2264,7 @@ static enum wined3d_feature_level feature_level_from_caps(const struct shader_ca
         return WINED3D_FEATURE_LEVEL_11_1;
 
     if (shader_model >= 4)
-        return WINED3D_FEATURE_LEVEL_10_1;
+        return WINED3D_FEATURE_LEVEL_11_1;
 
     return WINED3D_FEATURE_LEVEL_NONE;
 }
diff --git a/dlls/winegstreamer/Makefile.in b/dlls/winegstreamer/Makefile.in
index 3524cffb399..1b7caa769eb 100644
--- wine/dlls/winegstreamer/Makefile.in
+++ wine/dlls/winegstreamer/Makefile.in
@@ -1,19 +1,22 @@
+EXTRADEFS = -DWINE_NO_LONG_TYPES
 MODULE    = winegstreamer.dll
 UNIXLIB   = winegstreamer.so
 IMPORTLIB = winegstreamer
-IMPORTS   = strmbase ole32 msdmo
+IMPORTS   = strmbase ole32
 DELAYIMPORTS = mfplat
 EXTRAINCL = $(GSTREAMER_CFLAGS)
 EXTRALIBS = $(GSTREAMER_LIBS) $(PTHREAD_LIBS)
 
 C_SRCS = \
+	aac_decoder.c \
 	audioconvert.c \
+	colorconvert.c \
+	decode_transform.c \
 	h264_decoder.c \
 	main.c \
 	media_source.c \
 	mfplat.c \
 	quartz_parser.c \
-	wg_format.c \
 	wg_parser.c \
 	wg_transform.c \
 	wm_asyncreader.c \
diff --git a/dlls/winegstreamer/aac_decoder.c b/dlls/winegstreamer/aac_decoder.c
new file mode 100644
index 00000000000..97f2824039d
--- /dev/null
+++ wine/dlls/winegstreamer/aac_decoder.c
@@ -0,0 +1,620 @@
+/* AAC Decoder Transform
+ *
+ * Copyright 2022 Rémi Bernon for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "gst_private.h"
+
+#include "mfapi.h"
+#include "mferror.h"
+#include "mfobjects.h"
+#include "mftransform.h"
+#include "wmcodecdsp.h"
+
+#include "wine/debug.h"
+#include "wine/heap.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(mfplat);
+
+static const GUID *aac_decoder_input_types[] =
+{
+    &MFAudioFormat_AAC,
+};
+static const GUID *aac_decoder_output_types[] =
+{
+    &MFAudioFormat_PCM,
+    &MFAudioFormat_Float,
+};
+
+struct aac_decoder
+{
+    IMFTransform IMFTransform_iface;
+    LONG refcount;
+    IMFMediaType *input_type;
+    IMFMediaType *output_type;
+
+    IMFSample *input_sample;
+    struct wg_transform *wg_transform;
+};
+
+static struct aac_decoder *impl_from_IMFTransform(IMFTransform *iface)
+{
+    return CONTAINING_RECORD(iface, struct aac_decoder, IMFTransform_iface);
+}
+
+static void try_create_wg_transform(struct aac_decoder *decoder)
+{
+    struct wg_encoded_format input_format;
+    struct wg_format output_format;
+
+    if (!decoder->input_type || !decoder->output_type)
+        return;
+
+    if (decoder->wg_transform)
+        wg_transform_destroy(decoder->wg_transform);
+
+    mf_media_type_to_wg_encoded_format(decoder->input_type, &input_format);
+    if (input_format.encoded_type == WG_ENCODED_TYPE_UNKNOWN)
+        return;
+
+    mf_media_type_to_wg_format(decoder->output_type, &output_format);
+    if (output_format.major_type == WG_MAJOR_TYPE_UNKNOWN)
+        return;
+
+    decoder->wg_transform = wg_transform_create(&input_format, &output_format);
+    if (!decoder->wg_transform)
+        WARN("Failed to create wg_transform.\n");
+}
+
+static HRESULT WINAPI aac_decoder_QueryInterface(IMFTransform *iface, REFIID iid, void **out)
+{
+    struct aac_decoder *decoder = impl_from_IMFTransform(iface);
+
+    TRACE("iface %p, iid %s, out %p.\n", iface, debugstr_guid(iid), out);
+
+    if (IsEqualGUID(iid, &IID_IUnknown) || IsEqualGUID(iid, &IID_IMFTransform))
+        *out = &decoder->IMFTransform_iface;
+    else
+    {
+        *out = NULL;
+        WARN("%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid(iid));
+        return E_NOINTERFACE;
+    }
+
+    IUnknown_AddRef((IUnknown *)*out);
+    return S_OK;
+}
+
+static ULONG WINAPI aac_decoder_AddRef(IMFTransform *iface)
+{
+    struct aac_decoder *decoder = impl_from_IMFTransform(iface);
+    ULONG refcount = InterlockedIncrement(&decoder->refcount);
+
+    TRACE("iface %p increasing refcount to %u.\n", decoder, refcount);
+
+    return refcount;
+}
+
+static ULONG WINAPI aac_decoder_Release(IMFTransform *iface)
+{
+    struct aac_decoder *decoder = impl_from_IMFTransform(iface);
+    ULONG refcount = InterlockedDecrement(&decoder->refcount);
+
+    TRACE("iface %p decreasing refcount to %u.\n", decoder, refcount);
+
+    if (!refcount)
+    {
+        if (decoder->input_sample)
+            IMFSample_Release(decoder->input_sample);
+        if (decoder->wg_transform)
+            wg_transform_destroy(decoder->wg_transform);
+        if (decoder->input_type)
+            IMFMediaType_Release(decoder->input_type);
+        if (decoder->output_type)
+            IMFMediaType_Release(decoder->output_type);
+        free(decoder);
+    }
+
+    return refcount;
+}
+
+static HRESULT WINAPI aac_decoder_GetStreamLimits(IMFTransform *iface, DWORD *input_minimum, DWORD *input_maximum,
+        DWORD *output_minimum, DWORD *output_maximum)
+{
+    FIXME("iface %p, input_minimum %p, input_maximum %p, output_minimum %p, output_maximum %p stub!\n",
+            iface, input_minimum, input_maximum, output_minimum, output_maximum);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI aac_decoder_GetStreamCount(IMFTransform *iface, DWORD *inputs, DWORD *outputs)
+{
+    FIXME("iface %p, inputs %p, outputs %p stub!\n", iface, inputs, outputs);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI aac_decoder_GetStreamIDs(IMFTransform *iface, DWORD input_size, DWORD *inputs,
+        DWORD output_size, DWORD *outputs)
+{
+    FIXME("iface %p, input_size %u, inputs %p, output_size %u, outputs %p stub!\n",
+            iface, input_size, inputs, output_size, outputs);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI aac_decoder_GetInputStreamInfo(IMFTransform *iface, DWORD id, MFT_INPUT_STREAM_INFO *info)
+{
+    struct aac_decoder *decoder = impl_from_IMFTransform(iface);
+    UINT32 block_alignment;
+    HRESULT hr;
+
+    TRACE("iface %p, id %u, info %p.\n", iface, id, info);
+
+    if (!decoder->input_type || !decoder->output_type)
+        return MF_E_TRANSFORM_TYPE_NOT_SET;
+
+    if (FAILED(hr = IMFMediaType_GetUINT32(decoder->input_type, &MF_MT_AUDIO_BLOCK_ALIGNMENT, &block_alignment)))
+        return hr;
+
+    info->hnsMaxLatency = 0;
+    info->dwFlags = MFT_INPUT_STREAM_WHOLE_SAMPLES|MFT_INPUT_STREAM_SINGLE_SAMPLE_PER_BUFFER
+            |MFT_INPUT_STREAM_FIXED_SAMPLE_SIZE|MFT_INPUT_STREAM_HOLDS_BUFFERS;
+    info->cbSize = 0;
+    info->cbMaxLookahead = 0;
+    info->cbAlignment = 0;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI aac_decoder_GetOutputStreamInfo(IMFTransform *iface, DWORD id, MFT_OUTPUT_STREAM_INFO *info)
+{
+    struct aac_decoder *decoder = impl_from_IMFTransform(iface);
+    UINT32 channel_count, block_alignment;
+    HRESULT hr;
+
+    TRACE("iface %p, id %u, info %p.\n", iface, id, info);
+
+    if (!decoder->input_type || !decoder->output_type)
+        return MF_E_TRANSFORM_TYPE_NOT_SET;
+
+    if (FAILED(hr = IMFMediaType_GetUINT32(decoder->output_type, &MF_MT_AUDIO_NUM_CHANNELS, &channel_count)))
+        return hr;
+    if (FAILED(hr = IMFMediaType_GetUINT32(decoder->output_type, &MF_MT_AUDIO_BLOCK_ALIGNMENT, &block_alignment)))
+        return hr;
+
+    info->dwFlags = 0;
+    info->cbSize = 0x1800 * block_alignment * channel_count;
+    info->cbAlignment = 0;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI aac_decoder_GetAttributes(IMFTransform *iface, IMFAttributes **attributes)
+{
+    FIXME("iface %p, attributes %p stub!\n", iface, attributes);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI aac_decoder_GetInputStreamAttributes(IMFTransform *iface, DWORD id,
+        IMFAttributes **attributes)
+{
+    FIXME("iface %p, id %u, attributes %p stub!\n", iface, id, attributes);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI aac_decoder_GetOutputStreamAttributes(IMFTransform *iface, DWORD id,
+        IMFAttributes **attributes)
+{
+    FIXME("iface %p, id %u, attributes %p stub!\n", iface, id, attributes);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI aac_decoder_DeleteInputStream(IMFTransform *iface, DWORD id)
+{
+    FIXME("iface %p, id %u stub!\n", iface, id);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI aac_decoder_AddInputStreams(IMFTransform *iface, DWORD streams, DWORD *ids)
+{
+    FIXME("iface %p, streams %u, ids %p stub!\n", iface, streams, ids);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI aac_decoder_GetInputAvailableType(IMFTransform *iface, DWORD id, DWORD index,
+        IMFMediaType **type)
+{
+    FIXME("iface %p, id %u, index %u, type %p stub!\n", iface, id, index, type);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI aac_decoder_GetOutputAvailableType(IMFTransform *iface, DWORD id, DWORD index,
+        IMFMediaType **type)
+{
+    UINT32 channel_count, sample_size, sample_rate, block_alignment;
+    struct aac_decoder *decoder = impl_from_IMFTransform(iface);
+    IMFMediaType *media_type;
+    const GUID *output_type;
+    HRESULT hr;
+
+    TRACE("iface %p, id %u, index %u, type %p.\n", iface, id, index, type);
+
+    if (!decoder->input_type)
+        return MF_E_TRANSFORM_TYPE_NOT_SET;
+
+    *type = NULL;
+
+    if (index >= ARRAY_SIZE(aac_decoder_output_types))
+        return MF_E_NO_MORE_TYPES;
+    index = ARRAY_SIZE(aac_decoder_output_types) - index - 1;
+    output_type = aac_decoder_output_types[index];
+
+    if (FAILED(hr = MFCreateMediaType(&media_type)))
+        return hr;
+
+    if (FAILED(hr = IMFMediaType_SetGUID(media_type, &MF_MT_MAJOR_TYPE, &MFMediaType_Audio)))
+        goto done;
+    if (FAILED(hr = IMFMediaType_SetGUID(media_type, &MF_MT_SUBTYPE, output_type)))
+        goto done;
+
+    if (IsEqualGUID(output_type, &MFAudioFormat_Float))
+        sample_size = 32;
+    else if (IsEqualGUID(output_type, &MFAudioFormat_PCM))
+        sample_size = 16;
+    else
+    {
+        FIXME("Subtype %s not implemented!\n", debugstr_guid(output_type));
+        hr = E_NOTIMPL;
+        goto done;
+    }
+
+    if (FAILED(hr = IMFMediaType_SetUINT32(media_type, &MF_MT_AUDIO_BITS_PER_SAMPLE, sample_size)))
+        goto done;
+
+    if (FAILED(hr = IMFMediaType_GetUINT32(decoder->input_type, &MF_MT_AUDIO_NUM_CHANNELS, &channel_count)))
+        goto done;
+    if (FAILED(hr = IMFMediaType_SetUINT32(media_type, &MF_MT_AUDIO_NUM_CHANNELS, channel_count)))
+        goto done;
+
+    if (FAILED(hr = IMFMediaType_GetUINT32(decoder->input_type, &MF_MT_AUDIO_SAMPLES_PER_SECOND, &sample_rate)))
+        goto done;
+    if (FAILED(hr = IMFMediaType_SetUINT32(media_type, &MF_MT_AUDIO_SAMPLES_PER_SECOND, sample_rate)))
+        goto done;
+
+    block_alignment = sample_size * channel_count / 8;
+    if (FAILED(hr = IMFMediaType_SetUINT32(media_type, &MF_MT_AUDIO_BLOCK_ALIGNMENT, block_alignment)))
+        goto done;
+    if (FAILED(hr = IMFMediaType_SetUINT32(media_type, &MF_MT_AUDIO_AVG_BYTES_PER_SECOND, sample_rate * block_alignment)))
+        goto done;
+
+    if (FAILED(hr = IMFMediaType_SetUINT32(media_type, &MF_MT_ALL_SAMPLES_INDEPENDENT, 1)))
+        goto done;
+    if (FAILED(hr = IMFMediaType_SetUINT32(media_type, &MF_MT_FIXED_SIZE_SAMPLES, 1)))
+        goto done;
+    if (FAILED(hr = IMFMediaType_SetUINT32(media_type, &MF_MT_AUDIO_PREFER_WAVEFORMATEX, 1)))
+        goto done;
+
+done:
+    if (SUCCEEDED(hr))
+        IMFMediaType_AddRef((*type = media_type));
+
+    IMFMediaType_Release(media_type);
+    return hr;
+}
+
+static HRESULT WINAPI aac_decoder_SetInputType(IMFTransform *iface, DWORD id, IMFMediaType *type, DWORD flags)
+{
+    struct aac_decoder *decoder = impl_from_IMFTransform(iface);
+    MF_ATTRIBUTE_TYPE item_type;
+    GUID major, subtype;
+    HRESULT hr;
+    ULONG i;
+
+    TRACE("iface %p, id %u, type %p, flags %#x.\n", iface, id, type, flags);
+
+    if (FAILED(hr = IMFMediaType_GetGUID(type, &MF_MT_MAJOR_TYPE, &major)) ||
+        FAILED(hr = IMFMediaType_GetGUID(type, &MF_MT_SUBTYPE, &subtype)))
+        return hr;
+
+    if (!IsEqualGUID(&major, &MFMediaType_Audio))
+        return MF_E_INVALIDMEDIATYPE;
+
+    for (i = 0; i < ARRAY_SIZE(aac_decoder_input_types); ++i)
+        if (IsEqualGUID(&subtype, aac_decoder_input_types[i]))
+            break;
+    if (i == ARRAY_SIZE(aac_decoder_input_types))
+        return MF_E_INVALIDMEDIATYPE;
+
+    if (FAILED(IMFMediaType_GetItemType(type, &MF_MT_USER_DATA, &item_type)) ||
+        item_type != MF_ATTRIBUTE_BLOB)
+        return MF_E_INVALIDMEDIATYPE;
+    if (FAILED(IMFMediaType_GetItemType(type, &MF_MT_AUDIO_BLOCK_ALIGNMENT, &item_type)) ||
+        item_type != MF_ATTRIBUTE_UINT32)
+        return MF_E_INVALIDMEDIATYPE;
+    if (FAILED(IMFMediaType_GetItemType(type, &MF_MT_AUDIO_SAMPLES_PER_SECOND, &item_type)) ||
+        item_type != MF_ATTRIBUTE_UINT32)
+        return MF_E_INVALIDMEDIATYPE;
+    if (FAILED(IMFMediaType_GetItemType(type, &MF_MT_AUDIO_NUM_CHANNELS, &item_type)) ||
+        item_type != MF_ATTRIBUTE_UINT32)
+        return MF_E_INVALIDMEDIATYPE;
+    if (FAILED(IMFMediaType_GetItemType(type, &MF_MT_AUDIO_BITS_PER_SAMPLE, &item_type)) ||
+        item_type != MF_ATTRIBUTE_UINT32)
+        return MF_E_INVALIDMEDIATYPE;
+    if (FAILED(IMFMediaType_GetItemType(type, &MF_MT_AUDIO_AVG_BYTES_PER_SECOND, &item_type)) ||
+        item_type != MF_ATTRIBUTE_UINT32)
+        return MF_E_INVALIDMEDIATYPE;
+    if (FAILED(IMFMediaType_GetItemType(type, &MF_MT_AUDIO_PREFER_WAVEFORMATEX, &item_type)) ||
+        item_type != MF_ATTRIBUTE_UINT32)
+        return MF_E_INVALIDMEDIATYPE;
+
+    if (!decoder->input_type && FAILED(hr = MFCreateMediaType(&decoder->input_type)))
+        return hr;
+
+    if (decoder->output_type)
+    {
+        IMFMediaType_Release(decoder->output_type);
+        decoder->output_type = NULL;
+    }
+
+    return IMFMediaType_CopyAllItems(type, (IMFAttributes *)decoder->input_type);
+}
+
+static HRESULT WINAPI aac_decoder_SetOutputType(IMFTransform *iface, DWORD id, IMFMediaType *type, DWORD flags)
+{
+    struct aac_decoder *decoder = impl_from_IMFTransform(iface);
+    MF_ATTRIBUTE_TYPE item_type;
+    ULONG i, sample_size;
+    GUID major, subtype;
+    HRESULT hr;
+
+    TRACE("iface %p, id %u, type %p, flags %#x.\n", iface, id, type, flags);
+
+    if (FAILED(hr = IMFMediaType_GetGUID(type, &MF_MT_MAJOR_TYPE, &major)) ||
+        FAILED(hr = IMFMediaType_GetGUID(type, &MF_MT_SUBTYPE, &subtype)))
+        return hr;
+
+    if (!IsEqualGUID(&major, &MFMediaType_Audio))
+        return MF_E_INVALIDMEDIATYPE;
+
+    for (i = 0; i < ARRAY_SIZE(aac_decoder_output_types); ++i)
+        if (IsEqualGUID(&subtype, aac_decoder_output_types[i]))
+            break;
+    if (i == ARRAY_SIZE(aac_decoder_output_types))
+        return MF_E_INVALIDMEDIATYPE;
+
+    if (IsEqualGUID(&subtype, &MFAudioFormat_Float))
+        sample_size = 32;
+    else if (IsEqualGUID(&subtype, &MFAudioFormat_PCM))
+        sample_size = 16;
+    else
+    {
+        FIXME("Subtype %s not implemented!\n", debugstr_guid(&subtype));
+        hr = E_NOTIMPL;
+        return hr;
+    }
+
+    if (FAILED(IMFMediaType_SetUINT32(decoder->input_type, &MF_MT_AUDIO_BITS_PER_SAMPLE, sample_size)))
+        return MF_E_INVALIDMEDIATYPE;
+
+    if (FAILED(IMFMediaType_GetItemType(type, &MF_MT_AUDIO_AVG_BYTES_PER_SECOND, &item_type)) ||
+        item_type != MF_ATTRIBUTE_UINT32)
+        return MF_E_INVALIDMEDIATYPE;
+    if (FAILED(IMFMediaType_GetItemType(type, &MF_MT_AUDIO_BITS_PER_SAMPLE, &item_type)) ||
+        item_type != MF_ATTRIBUTE_UINT32)
+        return MF_E_INVALIDMEDIATYPE;
+    if (FAILED(IMFMediaType_GetItemType(type, &MF_MT_AUDIO_NUM_CHANNELS, &item_type)) ||
+        item_type != MF_ATTRIBUTE_UINT32)
+        return MF_E_INVALIDMEDIATYPE;
+    if (FAILED(IMFMediaType_GetItemType(type, &MF_MT_AUDIO_SAMPLES_PER_SECOND, &item_type)) ||
+        item_type != MF_ATTRIBUTE_UINT32)
+        return MF_E_INVALIDMEDIATYPE;
+    if (FAILED(IMFMediaType_GetItemType(type, &MF_MT_AUDIO_BLOCK_ALIGNMENT, &item_type)) ||
+        item_type != MF_ATTRIBUTE_UINT32)
+        return MF_E_INVALIDMEDIATYPE;
+
+    if (!decoder->output_type && FAILED(hr = MFCreateMediaType(&decoder->output_type)))
+        return hr;
+
+    if (FAILED(hr = IMFMediaType_CopyAllItems(type, (IMFAttributes *)decoder->output_type)))
+        return hr;
+
+    try_create_wg_transform(decoder);
+    return S_OK;
+}
+
+static HRESULT WINAPI aac_decoder_GetInputCurrentType(IMFTransform *iface, DWORD id, IMFMediaType **type)
+{
+    FIXME("iface %p, id %u, type %p stub!\n", iface, id, type);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI aac_decoder_GetOutputCurrentType(IMFTransform *iface, DWORD id, IMFMediaType **type)
+{
+    FIXME("iface %p, id %u, type %p stub!\n", iface, id, type);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI aac_decoder_GetInputStatus(IMFTransform *iface, DWORD id, DWORD *flags)
+{
+    FIXME("iface %p, id %u, flags %p stub!\n", iface, id, flags);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI aac_decoder_GetOutputStatus(IMFTransform *iface, DWORD *flags)
+{
+    FIXME("iface %p, flags %p stub!\n", iface, flags);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI aac_decoder_SetOutputBounds(IMFTransform *iface, LONGLONG lower, LONGLONG upper)
+{
+    FIXME("iface %p, lower %s, upper %s stub!\n", iface,
+            wine_dbgstr_longlong(lower), wine_dbgstr_longlong(upper));
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI aac_decoder_ProcessEvent(IMFTransform *iface, DWORD id, IMFMediaEvent *event)
+{
+    FIXME("iface %p, id %u, event %p stub!\n", iface, id, event);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI aac_decoder_ProcessMessage(IMFTransform *iface, MFT_MESSAGE_TYPE message, ULONG_PTR param)
+{
+    FIXME("iface %p, message %#x, param %p stub!\n", iface, message, (void *)param);
+    return S_OK;
+}
+
+static HRESULT WINAPI aac_decoder_ProcessInput(IMFTransform *iface, DWORD id, IMFSample *sample, DWORD flags)
+{
+    struct aac_decoder *decoder = impl_from_IMFTransform(iface);
+    IMFMediaBuffer *media_buffer;
+    MFT_INPUT_STREAM_INFO info;
+    UINT32 buffer_size;
+    BYTE *buffer;
+    HRESULT hr;
+
+    TRACE("iface %p, id %u, sample %p, flags %#x.\n", iface, id, sample, flags);
+
+    if (FAILED(hr = IMFTransform_GetInputStreamInfo(iface, 0, &info)))
+        return hr;
+
+    if (!decoder->wg_transform)
+        return MF_E_TRANSFORM_TYPE_NOT_SET;
+
+    if (decoder->input_sample)
+        return MF_E_NOTACCEPTING;
+
+    if (FAILED(hr = IMFSample_ConvertToContiguousBuffer(sample, &media_buffer)))
+        return hr;
+
+    if (FAILED(hr = IMFMediaBuffer_Lock(media_buffer, &buffer, NULL, &buffer_size)))
+        goto done;
+
+    if (SUCCEEDED(hr = wg_transform_push_data(decoder->wg_transform, buffer, buffer_size)))
+        IMFSample_AddRef((decoder->input_sample = sample));
+
+    IMFMediaBuffer_Unlock(media_buffer);
+
+done:
+    IMFMediaBuffer_Release(media_buffer);
+    return hr;
+}
+
+static HRESULT WINAPI aac_decoder_ProcessOutput(IMFTransform *iface, DWORD flags, DWORD count,
+        MFT_OUTPUT_DATA_BUFFER *samples, DWORD *status)
+{
+    struct aac_decoder *decoder = impl_from_IMFTransform(iface);
+    struct wg_sample wg_sample = {0};
+    IMFMediaBuffer *media_buffer;
+    MFT_OUTPUT_STREAM_INFO info;
+    HRESULT hr;
+
+    TRACE("iface %p, flags %#x, count %u, samples %p, status %p.\n", iface, flags, count, samples, status);
+
+    if (count > 1)
+    {
+        FIXME("Not implemented count %u\n", count);
+        return E_NOTIMPL;
+    }
+
+    if (FAILED(hr = IMFTransform_GetOutputStreamInfo(iface, 0, &info)))
+        return hr;
+
+    if (!decoder->wg_transform)
+        return MF_E_TRANSFORM_TYPE_NOT_SET;
+
+    *status = 0;
+    samples[0].dwStatus = 0;
+    if (!samples[0].pSample)
+    {
+        samples[0].dwStatus = MFT_OUTPUT_DATA_BUFFER_NO_SAMPLE;
+        return MF_E_TRANSFORM_NEED_MORE_INPUT;
+    }
+
+    if (FAILED(hr = IMFSample_ConvertToContiguousBuffer(samples[0].pSample, &media_buffer)))
+        return hr;
+
+    if (FAILED(hr = IMFMediaBuffer_Lock(media_buffer, &wg_sample.data, &wg_sample.size, NULL)))
+        goto done;
+
+    if (wg_sample.size < info.cbSize)
+        hr = MF_E_BUFFERTOOSMALL;
+    else if (SUCCEEDED(hr = wg_transform_read_data(decoder->wg_transform, &wg_sample)))
+    {
+        if (wg_sample.flags & WG_SAMPLE_FLAG_INCOMPLETE)
+            samples[0].dwStatus |= MFT_OUTPUT_DATA_BUFFER_INCOMPLETE;
+    }
+    else
+    {
+        if (decoder->input_sample)
+            IMFSample_Release(decoder->input_sample);
+        decoder->input_sample = NULL;
+    }
+
+    IMFMediaBuffer_Unlock(media_buffer);
+
+done:
+    IMFMediaBuffer_SetCurrentLength(media_buffer, wg_sample.size);
+    IMFMediaBuffer_Release(media_buffer);
+    return hr;
+}
+
+static const IMFTransformVtbl aac_decoder_vtbl =
+{
+    aac_decoder_QueryInterface,
+    aac_decoder_AddRef,
+    aac_decoder_Release,
+    aac_decoder_GetStreamLimits,
+    aac_decoder_GetStreamCount,
+    aac_decoder_GetStreamIDs,
+    aac_decoder_GetInputStreamInfo,
+    aac_decoder_GetOutputStreamInfo,
+    aac_decoder_GetAttributes,
+    aac_decoder_GetInputStreamAttributes,
+    aac_decoder_GetOutputStreamAttributes,
+    aac_decoder_DeleteInputStream,
+    aac_decoder_AddInputStreams,
+    aac_decoder_GetInputAvailableType,
+    aac_decoder_GetOutputAvailableType,
+    aac_decoder_SetInputType,
+    aac_decoder_SetOutputType,
+    aac_decoder_GetInputCurrentType,
+    aac_decoder_GetOutputCurrentType,
+    aac_decoder_GetInputStatus,
+    aac_decoder_GetOutputStatus,
+    aac_decoder_SetOutputBounds,
+    aac_decoder_ProcessEvent,
+    aac_decoder_ProcessMessage,
+    aac_decoder_ProcessInput,
+    aac_decoder_ProcessOutput,
+};
+
+HRESULT aac_decoder_create(REFIID riid, void **ret)
+{
+    struct aac_decoder *decoder;
+
+    TRACE("riid %s, ret %p.\n", debugstr_guid(riid), ret);
+
+    if (!(decoder = calloc(1, sizeof(*decoder))))
+        return E_OUTOFMEMORY;
+
+    decoder->IMFTransform_iface.lpVtbl = &aac_decoder_vtbl;
+    decoder->refcount = 1;
+
+    *ret = &decoder->IMFTransform_iface;
+    TRACE("Created decoder %p\n", *ret);
+    return S_OK;
+}
diff --git a/dlls/winegstreamer/audioconvert.c b/dlls/winegstreamer/audioconvert.c
index d5723cdf58f..2e16c9c78f5 100644
--- wine/dlls/winegstreamer/audioconvert.c
+++ wine/dlls/winegstreamer/audioconvert.c
@@ -35,6 +35,11 @@ struct audio_converter
     IMFMediaType *input_type;
     IMFMediaType *output_type;
     CRITICAL_SECTION cs;
+    BOOL buffer_inflight;
+    LONGLONG buffer_pts, buffer_dur;
+    struct wg_parser *parser;
+    struct wg_parser_stream *stream;
+    IMFAttributes *attributes, *output_attributes;
 };
 
 static struct audio_converter *impl_audio_converter_from_IMFTransform(IMFTransform *iface)
@@ -64,7 +69,7 @@ static ULONG WINAPI audio_converter_AddRef(IMFTransform *iface)
     struct audio_converter *transform = impl_audio_converter_from_IMFTransform(iface);
     ULONG refcount = InterlockedIncrement(&transform->refcount);
 
-    TRACE("%p, refcount %lu.\n", iface, refcount);
+    TRACE("%p, refcount %u.\n", iface, refcount);
 
     return refcount;
 }
@@ -74,12 +79,20 @@ static ULONG WINAPI audio_converter_Release(IMFTransform *iface)
     struct audio_converter *transform = impl_audio_converter_from_IMFTransform(iface);
     ULONG refcount = InterlockedDecrement(&transform->refcount);
 
-    TRACE("%p, refcount %lu.\n", iface, refcount);
+    TRACE("%p, refcount %u.\n", iface, refcount);
 
     if (!refcount)
     {
         transform->cs.DebugInfo->Spare[0] = 0;
         DeleteCriticalSection(&transform->cs);
+        if (transform->attributes)
+            IMFAttributes_Release(transform->attributes);
+        if (transform->output_attributes)
+            IMFAttributes_Release(transform->output_attributes);
+        if (transform->stream)
+            wg_parser_disconnect(transform->parser);
+        if (transform->parser)
+            wg_parser_destroy(transform->parser);
         free(transform);
     }
 
@@ -108,36 +121,75 @@ static HRESULT WINAPI audio_converter_GetStreamCount(IMFTransform *iface, DWORD
 static HRESULT WINAPI audio_converter_GetStreamIDs(IMFTransform *iface, DWORD input_size, DWORD *inputs,
         DWORD output_size, DWORD *outputs)
 {
-    TRACE("%p, %lu, %p, %lu, %p.\n", iface, input_size, inputs, output_size, outputs);
+    TRACE("%p %u %p %u %p.\n", iface, input_size, inputs, output_size, outputs);
 
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI audio_converter_GetInputStreamInfo(IMFTransform *iface, DWORD id, MFT_INPUT_STREAM_INFO *info)
 {
-    FIXME("%p, %lu, %p.\n", iface, id, info);
+    struct audio_converter *converter = impl_audio_converter_from_IMFTransform(iface);
 
-    return E_NOTIMPL;
+    TRACE("%p %u %p.\n", iface, id, info);
+
+    if (id != 0)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    info->dwFlags = MFT_INPUT_STREAM_WHOLE_SAMPLES | MFT_INPUT_STREAM_DOES_NOT_ADDREF;
+    info->cbMaxLookahead = 0;
+    info->cbAlignment = 0;
+    info->hnsMaxLatency = 0;
+    info->cbSize = 0;
+
+    EnterCriticalSection(&converter->cs);
+
+    if (converter->input_type)
+        IMFMediaType_GetUINT32(converter->input_type, &MF_MT_AUDIO_BLOCK_ALIGNMENT, &info->cbSize);
+
+    LeaveCriticalSection(&converter->cs);
+
+    return S_OK;
 }
 
 static HRESULT WINAPI audio_converter_GetOutputStreamInfo(IMFTransform *iface, DWORD id, MFT_OUTPUT_STREAM_INFO *info)
 {
-    FIXME("%p. %lu, %p.\n", iface, id, info);
+    struct audio_converter *converter = impl_audio_converter_from_IMFTransform(iface);
 
-    return E_NOTIMPL;
+    TRACE("%p %u %p.\n", iface, id, info);
+
+    if (id != 0)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    info->dwFlags = MFT_OUTPUT_STREAM_CAN_PROVIDE_SAMPLES | MFT_OUTPUT_STREAM_WHOLE_SAMPLES;
+    info->cbAlignment = 0;
+    info->cbSize = 0;
+
+    EnterCriticalSection(&converter->cs);
+
+    if (converter->output_type)
+        IMFMediaType_GetUINT32(converter->output_type, &MF_MT_AUDIO_BLOCK_ALIGNMENT, &info->cbSize);
+
+    LeaveCriticalSection(&converter->cs);
+
+    return S_OK;
 }
 
 static HRESULT WINAPI audio_converter_GetAttributes(IMFTransform *iface, IMFAttributes **attributes)
 {
-    FIXME("%p, %p.\n", iface, attributes);
+    struct audio_converter *converter = impl_audio_converter_from_IMFTransform(iface);
 
-    return E_NOTIMPL;
+    TRACE("%p, %p.\n", iface, attributes);
+
+    *attributes = converter->attributes;
+    IMFAttributes_AddRef(*attributes);
+
+    return S_OK;
 }
 
 static HRESULT WINAPI audio_converter_GetInputStreamAttributes(IMFTransform *iface, DWORD id,
         IMFAttributes **attributes)
 {
-    FIXME("%p, %lu, %p.\n", iface, id, attributes);
+    FIXME("%p, %u, %p.\n", iface, id, attributes);
 
     return E_NOTIMPL;
 }
@@ -145,21 +197,29 @@ static HRESULT WINAPI audio_converter_GetInputStreamAttributes(IMFTransform *ifa
 static HRESULT WINAPI audio_converter_GetOutputStreamAttributes(IMFTransform *iface, DWORD id,
         IMFAttributes **attributes)
 {
-    FIXME("%p, %lu, %p.\n", iface, id, attributes);
+    struct audio_converter *converter = impl_audio_converter_from_IMFTransform(iface);
 
-    return E_NOTIMPL;
+    TRACE("%p, %u, %p.\n", iface, id, attributes);
+
+    if (id != 0)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    *attributes = converter->output_attributes;
+    IMFAttributes_AddRef(*attributes);
+
+    return S_OK;
 }
 
 static HRESULT WINAPI audio_converter_DeleteInputStream(IMFTransform *iface, DWORD id)
 {
-    TRACE("%p, %lu.\n", iface, id);
+    TRACE("%p, %u.\n", iface, id);
 
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI audio_converter_AddInputStreams(IMFTransform *iface, DWORD streams, DWORD *ids)
 {
-    TRACE("%p, %lu, %p.\n", iface, streams, ids);
+    TRACE("%p, %u, %p.\n", iface, streams, ids);
 
     return E_NOTIMPL;
 }
@@ -170,7 +230,7 @@ static HRESULT WINAPI audio_converter_GetInputAvailableType(IMFTransform *iface,
     IMFMediaType *ret;
     HRESULT hr;
 
-    TRACE("%p, %lu, %lu, %p.\n", iface, id, index, type);
+    TRACE("%p, %u, %u, %p.\n", iface, id, index, type);
 
     if (id != 0)
         return MF_E_INVALIDSTREAMNUMBER;
@@ -222,7 +282,7 @@ static HRESULT WINAPI audio_converter_GetOutputAvailableType(IMFTransform *iface
     const GUID *subtype;
     DWORD rate, channels, bps;
 
-    TRACE("%p, %lu, %lu, %p.\n", iface, id, index, type);
+    TRACE("%p, %u, %u, %p.\n", iface, id, index, type);
 
     if (id != 0)
         return MF_E_INVALIDSTREAMNUMBER;
@@ -272,12 +332,13 @@ fail:
 static HRESULT WINAPI audio_converter_SetInputType(IMFTransform *iface, DWORD id, IMFMediaType *type, DWORD flags)
 {
     GUID major_type, subtype;
-    UINT32 unused;
+    struct wg_format format;
+    DWORD unused;
     HRESULT hr;
 
     struct audio_converter *converter = impl_audio_converter_from_IMFTransform(iface);
 
-    TRACE("%p, %lu, %p, %#lx.\n", iface, id, type, flags);
+    TRACE("%p, %u, %p, %#x.\n", iface, id, type, flags);
 
     if (id != 0)
         return MF_E_INVALIDSTREAMNUMBER;
@@ -291,6 +352,11 @@ static HRESULT WINAPI audio_converter_SetInputType(IMFTransform *iface, DWORD id
 
         if (converter->input_type)
         {
+            if (converter->stream)
+            {
+                wg_parser_disconnect(converter->parser);
+                converter->stream = NULL;
+            }
             IMFMediaType_Release(converter->input_type);
             converter->input_type = NULL;
         }
@@ -317,6 +383,10 @@ static HRESULT WINAPI audio_converter_SetInputType(IMFTransform *iface, DWORD id
     if (!IsEqualGUID(&subtype, &MFAudioFormat_PCM) && !IsEqualGUID(&subtype, &MFAudioFormat_Float))
         return MF_E_INVALIDTYPE;
 
+    mf_media_type_to_wg_format(type, &format);
+    if (!format.major_type)
+        return MF_E_INVALIDTYPE;
+
     if (flags & MFT_SET_TYPE_TEST_ONLY)
         return S_OK;
 
@@ -336,6 +406,21 @@ static HRESULT WINAPI audio_converter_SetInputType(IMFTransform *iface, DWORD id
         converter->input_type = NULL;
     }
 
+    if (converter->stream)
+    {
+        wg_parser_disconnect(converter->parser);
+        converter->stream = NULL;
+    }
+
+    if (converter->input_type && converter->output_type)
+    {
+        struct wg_format output_format;
+        mf_media_type_to_wg_format(converter->output_type, &output_format);
+
+        if (SUCCEEDED(hr = wg_parser_connect_unseekable(converter->parser, &format, 1, &output_format, NULL)))
+            converter->stream = wg_parser_get_stream(converter->parser, 0);
+    }
+
     LeaveCriticalSection(&converter->cs);
 
     return hr;
@@ -345,17 +430,15 @@ static HRESULT WINAPI audio_converter_SetOutputType(IMFTransform *iface, DWORD i
 {
     struct audio_converter *converter = impl_audio_converter_from_IMFTransform(iface);
     GUID major_type, subtype;
-    UINT32 unused;
+    struct wg_format format;
+    DWORD unused;
     HRESULT hr;
 
-    TRACE("%p, %lu, %p, %#lx.\n", iface, id, type, flags);
+    TRACE("%p, %u, %p, %#x.\n", iface, id, type, flags);
 
     if (id != 0)
         return MF_E_INVALIDSTREAMNUMBER;
 
-    if (!converter->input_type)
-        return MF_E_TRANSFORM_TYPE_NOT_SET;
-
     if (!type)
     {
         if (flags & MFT_SET_TYPE_TEST_ONLY)
@@ -365,6 +448,11 @@ static HRESULT WINAPI audio_converter_SetOutputType(IMFTransform *iface, DWORD i
 
         if (converter->output_type)
         {
+            if (converter->stream)
+            {
+                wg_parser_disconnect(converter->parser);
+                converter->stream = NULL;
+            }
             IMFMediaType_Release(converter->output_type);
             converter->output_type = NULL;
         }
@@ -391,6 +479,10 @@ static HRESULT WINAPI audio_converter_SetOutputType(IMFTransform *iface, DWORD i
     if (!IsEqualGUID(&subtype, &MFAudioFormat_PCM) && !IsEqualGUID(&subtype, &MFAudioFormat_Float))
         return MF_E_INVALIDTYPE;
 
+    mf_media_type_to_wg_format(type, &format);
+    if (!format.major_type)
+        return MF_E_INVALIDTYPE;
+
     if (flags & MFT_SET_TYPE_TEST_ONLY)
         return S_OK;
 
@@ -410,6 +502,21 @@ static HRESULT WINAPI audio_converter_SetOutputType(IMFTransform *iface, DWORD i
         converter->output_type = NULL;
     }
 
+    if (converter->stream)
+    {
+        wg_parser_disconnect(converter->parser);
+        converter->stream = NULL;
+    }
+
+    if (converter->input_type && converter->output_type)
+    {
+        struct wg_format input_format;
+        mf_media_type_to_wg_format(converter->input_type, &input_format);
+
+        if (SUCCEEDED(hr = wg_parser_connect_unseekable(converter->parser, &input_format, 1, &format, NULL)))
+            converter->stream = wg_parser_get_stream(converter->parser, 0);
+    }
+
     LeaveCriticalSection(&converter->cs);
 
     return hr;
@@ -421,7 +528,7 @@ static HRESULT WINAPI audio_converter_GetInputCurrentType(IMFTransform *iface, D
     IMFMediaType *ret;
     HRESULT hr;
 
-    TRACE("%p, %lu, %p.\n", converter, id, type);
+    TRACE("%p, %u, %p.\n", converter, id, type);
 
     if (id != 0)
         return MF_E_INVALIDSTREAMNUMBER;
@@ -452,7 +559,7 @@ static HRESULT WINAPI audio_converter_GetOutputCurrentType(IMFTransform *iface,
     IMFMediaType *ret;
     HRESULT hr;
 
-    TRACE("%p, %lu, %p.\n", converter, id, type);
+    TRACE("%p, %u, %p.\n", converter, id, type);
 
     if (id != 0)
         return MF_E_INVALIDSTREAMNUMBER;
@@ -479,7 +586,7 @@ static HRESULT WINAPI audio_converter_GetOutputCurrentType(IMFTransform *iface,
 
 static HRESULT WINAPI audio_converter_GetInputStatus(IMFTransform *iface, DWORD id, DWORD *flags)
 {
-    FIXME("%p, %lu, %p.\n", iface, id, flags);
+    FIXME("%p, %u, %p.\n", iface, id, flags);
 
     return E_NOTIMPL;
 }
@@ -500,17 +607,36 @@ static HRESULT WINAPI audio_converter_SetOutputBounds(IMFTransform *iface, LONGL
 
 static HRESULT WINAPI audio_converter_ProcessEvent(IMFTransform *iface, DWORD id, IMFMediaEvent *event)
 {
-    TRACE("%p, %lu, %p.\n", iface, id, event);
+    TRACE("%p, %u, %p.\n", iface, id, event);
 
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI audio_converter_ProcessMessage(IMFTransform *iface, MFT_MESSAGE_TYPE message, ULONG_PTR param)
 {
-    TRACE("%p, %u, %Iu.\n", iface, message, param);
+    struct audio_converter *converter = impl_audio_converter_from_IMFTransform(iface);
+    struct wg_parser_buffer wg_buffer;
+
+    TRACE("%p, %u %lu.\n", iface, message, param);
 
     switch(message)
     {
+        case MFT_MESSAGE_COMMAND_FLUSH:
+        {
+            EnterCriticalSection(&converter->cs);
+            if (!converter->buffer_inflight)
+            {
+                LeaveCriticalSection(&converter->cs);
+                return S_OK;
+            }
+
+            wg_parser_stream_get_buffer(converter->stream, &wg_buffer);
+            wg_parser_stream_release_buffer(converter->stream);
+            converter->buffer_inflight = FALSE;
+
+            LeaveCriticalSection(&converter->cs);
+            return S_OK;
+        }
         case MFT_MESSAGE_NOTIFY_BEGIN_STREAMING:
             return S_OK;
         default:
@@ -521,17 +647,197 @@ static HRESULT WINAPI audio_converter_ProcessMessage(IMFTransform *iface, MFT_ME
 
 static HRESULT WINAPI audio_converter_ProcessInput(IMFTransform *iface, DWORD id, IMFSample *sample, DWORD flags)
 {
-    FIXME("%p, %lu, %p, %#lx.\n", iface, id, sample, flags);
+    struct audio_converter *converter = impl_audio_converter_from_IMFTransform(iface);
+    IMFMediaBuffer *buffer = NULL;
+    unsigned char *buffer_data;
+    DWORD buffer_size;
+    uint64_t offset;
+    uint32_t size;
+    HRESULT hr;
 
-    return E_NOTIMPL;
+    TRACE("%p, %u, %p, %#x.\n", iface, id, sample, flags);
+
+    if (flags)
+        WARN("Unsupported flags %#x.\n", flags);
+
+    if (id != 0)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    EnterCriticalSection(&converter->cs);
+
+    if (!converter->stream)
+    {
+        hr = MF_E_TRANSFORM_TYPE_NOT_SET;
+        goto done;
+    }
+
+    if (converter->buffer_inflight)
+    {
+        hr = MF_E_NOTACCEPTING;
+        goto done;
+    }
+
+    if (FAILED(hr = IMFSample_ConvertToContiguousBuffer(sample, &buffer)))
+        goto done;
+
+    if (FAILED(hr = IMFMediaBuffer_Lock(buffer, &buffer_data, NULL, &buffer_size)))
+        goto done;
+
+    if (!wg_parser_get_next_read_offset(converter->parser, &offset, &size))
+    {
+        hr = MF_E_UNEXPECTED;
+        IMFMediaBuffer_Unlock(buffer);
+        goto done;
+    }
+
+    wg_parser_push_data(converter->parser, WG_READ_SUCCESS, buffer_data, buffer_size);
+
+    IMFMediaBuffer_Unlock(buffer);
+    converter->buffer_inflight = TRUE;
+    if (FAILED(IMFSample_GetSampleTime(sample, &converter->buffer_pts)))
+        converter->buffer_pts = -1;
+    if (FAILED(IMFSample_GetSampleDuration(sample, &converter->buffer_dur)))
+        converter->buffer_dur = -1;
+
+done:
+    if (buffer)
+        IMFMediaBuffer_Release(buffer);
+    LeaveCriticalSection(&converter->cs);
+    return hr;
 }
 
 static HRESULT WINAPI audio_converter_ProcessOutput(IMFTransform *iface, DWORD flags, DWORD count,
         MFT_OUTPUT_DATA_BUFFER *samples, DWORD *status)
 {
-    FIXME("%p, %#lx, %lu, %p, %p.\n", iface, flags, count, samples, status);
+    struct audio_converter *converter = impl_audio_converter_from_IMFTransform(iface);
+    IMFSample *allocated_sample = NULL;
+    struct wg_parser_buffer wg_buffer;
+    IMFMediaBuffer *buffer = NULL;
+    unsigned char *buffer_data;
+    DWORD buffer_len;
+    HRESULT hr = S_OK;
 
-    return E_NOTIMPL;
+    TRACE("%p, %#x, %u, %p, %p.\n", iface, flags, count, samples, status);
+
+    if (flags)
+        WARN("Unsupported flags %#x.\n", flags);
+
+    if (!count)
+        return S_OK;
+
+    if (count != 1)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    if (samples[0].dwStreamID != 0)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    EnterCriticalSection(&converter->cs);
+
+    if (!converter->stream)
+    {
+        hr = MF_E_TRANSFORM_TYPE_NOT_SET;
+        goto done;
+    }
+
+    if (!converter->buffer_inflight)
+    {
+        hr = MF_E_TRANSFORM_NEED_MORE_INPUT;
+        goto done;
+    }
+
+    if (!wg_parser_stream_get_buffer(converter->stream, &wg_buffer))
+        assert(0);
+
+    if (!samples[0].pSample)
+    {
+        if (FAILED(hr = MFCreateMemoryBuffer(wg_buffer.size, &buffer)))
+        {
+            ERR("Failed to create buffer, hr %#x.\n", hr);
+            goto done;
+        }
+
+        if (FAILED(hr = MFCreateSample(&allocated_sample)))
+        {
+            ERR("Failed to create sample, hr %#x.\n", hr);
+            goto done;
+        }
+
+        samples[0].pSample = allocated_sample;
+
+        if (FAILED(hr = IMFSample_AddBuffer(samples[0].pSample, buffer)))
+        {
+            ERR("Failed to add buffer, hr %#x.\n", hr);
+            goto done;
+        }
+
+        IMFMediaBuffer_Release(buffer);
+        buffer = NULL;
+    }
+
+    if (FAILED(hr = IMFSample_ConvertToContiguousBuffer(samples[0].pSample, &buffer)))
+    {
+        ERR("Failed to get buffer from sample, hr %#x.\n", hr);
+        goto done;
+    }
+
+    if (FAILED(hr = IMFMediaBuffer_GetMaxLength(buffer, &buffer_len)))
+    {
+        ERR("Failed to get buffer size, hr %#x.\n", hr);
+        goto done;
+    }
+
+    if (buffer_len < wg_buffer.size)
+    {
+        WARN("Client's buffer is smaller (%u bytes) than the output sample (%u bytes)\n",
+            buffer_len, wg_buffer.size);
+
+        hr = MF_E_BUFFERTOOSMALL;
+        goto done;
+    }
+
+    if (FAILED(hr = IMFMediaBuffer_SetCurrentLength(buffer, wg_buffer.size)))
+    {
+        ERR("Failed to set size, hr %#x.\n", hr);
+        goto done;
+    }
+
+    if (FAILED(hr = IMFMediaBuffer_Lock(buffer, &buffer_data, NULL, NULL)))
+    {
+        ERR("Failed to lock buffer hr %#x.\n", hr);
+        goto done;
+    }
+
+    if (!wg_parser_stream_copy_buffer(converter->stream, buffer_data, 0, wg_buffer.size))
+    {
+        ERR("Failed to copy buffer.\n");
+        IMFMediaBuffer_Unlock(buffer);
+        hr = E_FAIL;
+        goto done;
+    }
+
+    IMFMediaBuffer_Unlock(buffer);
+
+    wg_parser_stream_release_buffer(converter->stream);
+    converter->buffer_inflight = FALSE;
+
+    if (converter->buffer_pts != -1)
+        IMFSample_SetSampleTime(samples[0].pSample, converter->buffer_pts);
+    if (converter->buffer_dur != -1)
+        IMFSample_SetSampleDuration(samples[0].pSample, converter->buffer_dur);
+
+    samples[0].dwStatus = 0;
+    samples[0].pEvents = NULL;
+
+    done:
+    if (buffer)
+        IMFMediaBuffer_Release(buffer);
+    if (allocated_sample && FAILED(hr))
+    {
+        IMFSample_Release(allocated_sample);
+        samples[0].pSample = NULL;
+    }
+    LeaveCriticalSection(&converter->cs);
+    return hr;
 }
 
 static const IMFTransformVtbl audio_converter_vtbl =
@@ -567,6 +873,7 @@ static const IMFTransformVtbl audio_converter_vtbl =
 HRESULT audio_converter_create(REFIID riid, void **ret)
 {
     struct audio_converter *object;
+    HRESULT hr;
 
     TRACE("%s %p\n", debugstr_guid(riid), ret);
 
@@ -579,6 +886,25 @@ HRESULT audio_converter_create(REFIID riid, void **ret)
     InitializeCriticalSection(&object->cs);
     object->cs.DebugInfo->Spare[0] = (DWORD_PTR)(__FILE__ ": audio_converter_lock");
 
+    if (FAILED(hr = MFCreateAttributes(&object->attributes, 0)))
+    {
+        IMFTransform_Release(&object->IMFTransform_iface);
+        return hr;
+    }
+
+    if (FAILED(hr = MFCreateAttributes(&object->output_attributes, 0)))
+    {
+        IMFTransform_Release(&object->IMFTransform_iface);
+        return hr;
+    }
+
+    if (!(object->parser = wg_parser_create(WG_PARSER_AUDIOCONV, true)))
+    {
+        ERR("Failed to create audio converter due to GStreamer error.\n");
+        IMFTransform_Release(&object->IMFTransform_iface);
+        return E_OUTOFMEMORY;
+    }
+
     *ret = &object->IMFTransform_iface;
     return S_OK;
 }
diff --git a/dlls/winegstreamer/colorconvert.c b/dlls/winegstreamer/colorconvert.c
new file mode 100644
index 00000000000..92322e877ec
--- /dev/null
+++ wine/dlls/winegstreamer/colorconvert.c
@@ -0,0 +1,901 @@
+/* GStreamer Color Converter
+ *
+ * Copyright 2020 Derek Lesho
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "gst_private.h"
+
+#include "mfapi.h"
+#include "mferror.h"
+
+#include "wine/debug.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(mfplat);
+
+static const GUID *raw_types[] = {
+    &MFVideoFormat_RGB24,
+    &MFVideoFormat_RGB32,
+    &MFVideoFormat_RGB555,
+    &MFVideoFormat_RGB8,
+    &MFVideoFormat_AYUV,
+    &MFVideoFormat_I420,
+    &MFVideoFormat_IYUV,
+    &MFVideoFormat_NV11,
+    &MFVideoFormat_NV12,
+    &MFVideoFormat_UYVY,
+    &MFVideoFormat_v216,
+    &MFVideoFormat_v410,
+    &MFVideoFormat_YUY2,
+    &MFVideoFormat_YVYU,
+    &MFVideoFormat_YVYU,
+};
+
+struct color_converter
+{
+    IMFTransform IMFTransform_iface;
+    LONG refcount;
+    IMFMediaType *input_type;
+    IMFMediaType *output_type;
+    CRITICAL_SECTION cs;
+    BOOL buffer_inflight;
+    LONGLONG buffer_pts, buffer_dur;
+    struct wg_parser *parser;
+    struct wg_parser_stream *stream;
+};
+
+static struct color_converter *impl_color_converter_from_IMFTransform(IMFTransform *iface)
+{
+    return CONTAINING_RECORD(iface, struct color_converter, IMFTransform_iface);
+}
+
+static HRESULT WINAPI color_converter_QueryInterface(IMFTransform *iface, REFIID riid, void **obj)
+{
+    TRACE("%p, %s, %p.\n", iface, debugstr_guid(riid), obj);
+
+    if (IsEqualGUID(riid, &IID_IMFTransform) ||
+        IsEqualGUID(riid, &IID_IUnknown))
+    {
+        *obj = iface;
+        IMFTransform_AddRef(iface);
+        return S_OK;
+    }
+
+    WARN("Unsupported %s.\n", debugstr_guid(riid));
+    *obj = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI color_converter_AddRef(IMFTransform *iface)
+{
+    struct color_converter *transform = impl_color_converter_from_IMFTransform(iface);
+    ULONG refcount = InterlockedIncrement(&transform->refcount);
+
+    TRACE("%p, refcount %u.\n", iface, refcount);
+
+    return refcount;
+}
+
+static ULONG WINAPI color_converter_Release(IMFTransform *iface)
+{
+    struct color_converter *transform = impl_color_converter_from_IMFTransform(iface);
+    ULONG refcount = InterlockedDecrement(&transform->refcount);
+
+    TRACE("%p, refcount %u.\n", iface, refcount);
+
+    if (!refcount)
+    {
+        transform->cs.DebugInfo->Spare[0] = 0;
+        DeleteCriticalSection(&transform->cs);
+        if (transform->output_type)
+            IMFMediaType_Release(transform->output_type);
+        if (transform->stream)
+            wg_parser_disconnect(transform->parser);
+        if (transform->parser)
+            wg_parser_destroy(transform->parser);
+        free(transform);
+    }
+
+    return refcount;
+}
+
+static HRESULT WINAPI color_converter_GetStreamLimits(IMFTransform *iface, DWORD *input_minimum, DWORD *input_maximum,
+        DWORD *output_minimum, DWORD *output_maximum)
+{
+    TRACE("%p, %p, %p, %p, %p.\n", iface, input_minimum, input_maximum, output_minimum, output_maximum);
+
+    *input_minimum = *input_maximum = *output_minimum = *output_maximum = 1;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI color_converter_GetStreamCount(IMFTransform *iface, DWORD *inputs, DWORD *outputs)
+{
+    TRACE("%p, %p, %p.\n", iface, inputs, outputs);
+
+    *inputs = *outputs = 1;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI color_converter_GetStreamIDs(IMFTransform *iface, DWORD input_size, DWORD *inputs,
+        DWORD output_size, DWORD *outputs)
+{
+    TRACE("%p %u %p %u %p.\n", iface, input_size, inputs, output_size, outputs);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI color_converter_GetInputStreamInfo(IMFTransform *iface, DWORD id, MFT_INPUT_STREAM_INFO *info)
+{
+    struct color_converter *converter = impl_color_converter_from_IMFTransform(iface);
+    UINT64 framesize;
+    GUID subtype;
+
+    TRACE("%p %u %p.\n", iface, id, info);
+
+    if (id != 0)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    info->dwFlags = MFT_INPUT_STREAM_WHOLE_SAMPLES | MFT_INPUT_STREAM_DOES_NOT_ADDREF | MFT_INPUT_STREAM_FIXED_SAMPLE_SIZE;
+    info->cbMaxLookahead = 0;
+    info->cbAlignment = 0;
+    info->hnsMaxLatency = 0;
+    info->cbSize = 0;
+
+    EnterCriticalSection(&converter->cs);
+
+    if (converter->input_type)
+    {
+        if (SUCCEEDED(IMFMediaType_GetGUID(converter->input_type, &MF_MT_SUBTYPE, &subtype)) &&
+            SUCCEEDED(IMFMediaType_GetUINT64(converter->input_type, &MF_MT_FRAME_SIZE, &framesize)))
+        {
+            MFCalculateImageSize(&subtype, framesize >> 32, (UINT32) framesize, &info->cbSize);
+        }
+
+        if (!info->cbSize)
+            WARN("Failed to get desired input buffer size, the non-provided sample path will likely break\n");
+    }
+
+    LeaveCriticalSection(&converter->cs);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI color_converter_GetOutputStreamInfo(IMFTransform *iface, DWORD id, MFT_OUTPUT_STREAM_INFO *info)
+{
+    struct color_converter *converter = impl_color_converter_from_IMFTransform(iface);
+    UINT64 framesize;
+    GUID subtype;
+
+    TRACE("%p %u %p.\n", iface, id, info);
+
+    if (id != 0)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    info->dwFlags = MFT_OUTPUT_STREAM_FIXED_SAMPLE_SIZE | MFT_OUTPUT_STREAM_CAN_PROVIDE_SAMPLES | MFT_OUTPUT_STREAM_WHOLE_SAMPLES | MFT_OUTPUT_STREAM_SINGLE_SAMPLE_PER_BUFFER;
+    info->cbAlignment = 0;
+    info->cbSize = 0;
+
+    EnterCriticalSection(&converter->cs);
+
+    if (converter->output_type)
+    {
+        if (SUCCEEDED(IMFMediaType_GetGUID(converter->output_type, &MF_MT_SUBTYPE, &subtype)) &&
+            SUCCEEDED(IMFMediaType_GetUINT64(converter->output_type, &MF_MT_FRAME_SIZE, &framesize)))
+        {
+            MFCalculateImageSize(&subtype, framesize >> 32, (UINT32) framesize, &info->cbSize);
+        }
+
+        if (!info->cbSize)
+            WARN("Failed to get desired output buffer size, the non-provided sample path will likely break\n");
+    }
+
+    LeaveCriticalSection(&converter->cs);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI color_converter_GetAttributes(IMFTransform *iface, IMFAttributes **attributes)
+{
+    FIXME("%p, %p.\n", iface, attributes);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI color_converter_GetInputStreamAttributes(IMFTransform *iface, DWORD id,
+        IMFAttributes **attributes)
+{
+    FIXME("%p, %u, %p.\n", iface, id, attributes);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI color_converter_GetOutputStreamAttributes(IMFTransform *iface, DWORD id,
+        IMFAttributes **attributes)
+{
+    FIXME("%p, %u, %p.\n", iface, id, attributes);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI color_converter_DeleteInputStream(IMFTransform *iface, DWORD id)
+{
+    TRACE("%p, %u.\n", iface, id);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI color_converter_AddInputStreams(IMFTransform *iface, DWORD streams, DWORD *ids)
+{
+    TRACE("%p, %u, %p.\n", iface, streams, ids);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI color_converter_GetInputAvailableType(IMFTransform *iface, DWORD id, DWORD index,
+        IMFMediaType **type)
+{
+    IMFMediaType *ret;
+    HRESULT hr;
+
+    TRACE("%p, %u, %u, %p.\n", iface, id, index, type);
+
+    if (id != 0)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    if (index >= ARRAY_SIZE(raw_types))
+        return MF_E_NO_MORE_TYPES;
+
+    if (FAILED(hr = MFCreateMediaType(&ret)))
+        return hr;
+
+    if (FAILED(hr = IMFMediaType_SetGUID(ret, &MF_MT_MAJOR_TYPE, &MFMediaType_Video)))
+    {
+        IMFMediaType_Release(ret);
+        return hr;
+    }
+
+    if (FAILED(hr = IMFMediaType_SetGUID(ret, &MF_MT_SUBTYPE, raw_types[index])))
+    {
+        IMFMediaType_Release(ret);
+        return hr;
+    }
+
+    *type = ret;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI color_converter_GetOutputAvailableType(IMFTransform *iface, DWORD id, DWORD index,
+        IMFMediaType **type)
+{
+    struct color_converter *converter = impl_color_converter_from_IMFTransform(iface);
+    IMFMediaType *ret;
+    HRESULT hr;
+
+    TRACE("%p, %u, %u, %p.\n", iface, id, index, type);
+
+    if (id != 0)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    if (index >= ARRAY_SIZE(raw_types))
+        return MF_E_NO_MORE_TYPES;
+
+    if (FAILED(hr = MFCreateMediaType(&ret)))
+        return hr;
+
+    EnterCriticalSection(&converter->cs);
+
+    if (converter->input_type)
+        IMFMediaType_CopyAllItems(converter->input_type, (IMFAttributes *) ret);
+
+    LeaveCriticalSection(&converter->cs);
+
+    if (FAILED(hr = IMFMediaType_SetGUID(ret, &MF_MT_MAJOR_TYPE, &MFMediaType_Video)))
+    {
+        IMFMediaType_Release(ret);
+        return hr;
+    }
+
+    if (FAILED(hr = IMFMediaType_SetGUID(ret, &MF_MT_SUBTYPE, raw_types[index])))
+    {
+        IMFMediaType_Release(ret);
+        return hr;
+    }
+
+    *type = ret;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI color_converter_SetInputType(IMFTransform *iface, DWORD id, IMFMediaType *type, DWORD flags)
+{
+    struct color_converter *converter = impl_color_converter_from_IMFTransform(iface);
+    UINT64 input_framesize, output_framesize;
+    GUID major_type, subtype;
+    struct wg_format format;
+    unsigned int i;
+    HRESULT hr;
+
+    TRACE("%p, %u, %p, %#x.\n", iface, id, type, flags);
+
+    if (id != 0)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    if (!type)
+    {
+        if (flags & MFT_SET_TYPE_TEST_ONLY)
+            return S_OK;
+
+        EnterCriticalSection(&converter->cs);
+
+        if (converter->input_type)
+        {
+            if (converter->stream)
+            {
+                wg_parser_disconnect(converter->parser);
+                converter->stream = NULL;
+            }
+            IMFMediaType_Release(converter->input_type);
+            converter->input_type = NULL;
+        }
+
+        LeaveCriticalSection(&converter->cs);
+
+        return S_OK;
+    }
+
+    if (FAILED(IMFMediaType_GetGUID(type, &MF_MT_MAJOR_TYPE, &major_type)))
+        return MF_E_INVALIDTYPE;
+    if (FAILED(IMFMediaType_GetGUID(type, &MF_MT_SUBTYPE, &subtype)))
+        return MF_E_INVALIDTYPE;
+
+    if (!IsEqualGUID(&major_type, &MFMediaType_Video))
+        return MF_E_INVALIDTYPE;
+
+    for (i = 0; i < ARRAY_SIZE(raw_types); i++)
+    {
+        if (IsEqualGUID(&subtype, raw_types[i]))
+            break;
+    }
+
+    if (i == ARRAY_SIZE(raw_types))
+        return MF_E_INVALIDTYPE;
+
+    EnterCriticalSection(&converter->cs);
+
+    if(converter->output_type
+         && SUCCEEDED(IMFMediaType_GetUINT64(converter->output_type, &MF_MT_FRAME_SIZE, &output_framesize))
+         && SUCCEEDED(IMFMediaType_GetUINT64(type, &MF_MT_FRAME_SIZE, &input_framesize))
+         && input_framesize != output_framesize)
+    {
+        LeaveCriticalSection(&converter->cs);
+        return MF_E_INVALIDTYPE;
+    }
+
+    LeaveCriticalSection(&converter->cs);
+
+    mf_media_type_to_wg_format(type, &format);
+    if (!format.major_type)
+        return MF_E_INVALIDTYPE;
+
+    if (flags & MFT_SET_TYPE_TEST_ONLY)
+        return S_OK;
+
+    EnterCriticalSection(&converter->cs);
+
+    hr = S_OK;
+
+    if (!converter->input_type)
+        hr = MFCreateMediaType(&converter->input_type);
+
+    if (SUCCEEDED(hr))
+        hr = IMFMediaType_CopyAllItems(type, (IMFAttributes *) converter->input_type);
+
+    if (FAILED(hr))
+    {
+        IMFMediaType_Release(converter->input_type);
+        converter->input_type = NULL;
+    }
+
+    if (converter->stream)
+    {
+        wg_parser_disconnect(converter->parser);
+        converter->stream = NULL;
+    }
+
+    if (converter->input_type && converter->output_type)
+    {
+        struct wg_format output_format;
+        mf_media_type_to_wg_format(converter->output_type, &output_format);
+
+        if (SUCCEEDED(hr = wg_parser_connect_unseekable(converter->parser, &format, 1, &output_format, NULL)))
+            converter->stream = wg_parser_get_stream(converter->parser, 0);
+    }
+
+    LeaveCriticalSection(&converter->cs);
+
+    return hr;
+}
+
+static HRESULT WINAPI color_converter_SetOutputType(IMFTransform *iface, DWORD id, IMFMediaType *type, DWORD flags)
+{
+    struct color_converter *converter = impl_color_converter_from_IMFTransform(iface);
+    UINT64 input_framesize, output_framesize;
+    GUID major_type, subtype;
+    struct wg_format format;
+    unsigned int i;
+    HRESULT hr;
+
+    TRACE("%p, %u, %p, %#x.\n", iface, id, type, flags);
+
+    if (id != 0)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    if (!type)
+    {
+        if (flags & MFT_SET_TYPE_TEST_ONLY)
+            return S_OK;
+
+        EnterCriticalSection(&converter->cs);
+
+        if (converter->output_type)
+        {
+            if (converter->stream)
+            {
+                wg_parser_disconnect(converter->parser);
+                converter->stream = NULL;
+            }
+            IMFMediaType_Release(converter->output_type);
+            converter->output_type = NULL;
+        }
+
+        LeaveCriticalSection(&converter->cs);
+
+        return S_OK;
+    }
+
+    if (FAILED(IMFMediaType_GetGUID(type, &MF_MT_MAJOR_TYPE, &major_type)))
+        return MF_E_INVALIDTYPE;
+    if (FAILED(IMFMediaType_GetGUID(type, &MF_MT_SUBTYPE, &subtype)))
+        return MF_E_INVALIDTYPE;
+
+    if (!IsEqualGUID(&major_type, &MFMediaType_Video))
+        return MF_E_INVALIDTYPE;
+
+    for (i = 0; i < ARRAY_SIZE(raw_types); i++)
+    {
+        if (IsEqualGUID(&subtype, raw_types[i]))
+            break;
+    }
+
+    if (i == ARRAY_SIZE(raw_types))
+        return MF_E_INVALIDTYPE;
+
+    EnterCriticalSection(&converter->cs);
+
+    if(converter->input_type
+         && SUCCEEDED(IMFMediaType_GetUINT64(converter->input_type, &MF_MT_FRAME_SIZE, &input_framesize))
+         && SUCCEEDED(IMFMediaType_GetUINT64(type, &MF_MT_FRAME_SIZE, &output_framesize))
+         && input_framesize != output_framesize)
+    {
+        LeaveCriticalSection(&converter->cs);
+        return MF_E_INVALIDTYPE;
+    }
+
+    LeaveCriticalSection(&converter->cs);
+
+    mf_media_type_to_wg_format(type, &format);
+    if (!format.major_type)
+        return MF_E_INVALIDTYPE;
+
+    if (flags & MFT_SET_TYPE_TEST_ONLY)
+        return S_OK;
+
+    EnterCriticalSection(&converter->cs);
+
+    hr = S_OK;
+
+    if (!converter->output_type)
+        hr = MFCreateMediaType(&converter->output_type);
+
+    if (SUCCEEDED(hr))
+        hr = IMFMediaType_CopyAllItems(type, (IMFAttributes *) converter->output_type);
+
+    if (FAILED(hr))
+    {
+        IMFMediaType_Release(converter->output_type);
+        converter->output_type = NULL;
+    }
+
+    if (converter->stream)
+    {
+        wg_parser_disconnect(converter->parser);
+        converter->stream = NULL;
+    }
+
+    if (converter->input_type && converter->output_type)
+    {
+        struct wg_format input_format;
+        mf_media_type_to_wg_format(converter->input_type, &input_format);
+
+        if (SUCCEEDED(hr = wg_parser_connect_unseekable(converter->parser, &input_format, 1, &format, NULL)))
+            converter->stream = wg_parser_get_stream(converter->parser, 0);
+    }
+
+    LeaveCriticalSection(&converter->cs);
+
+    return hr;
+}
+
+static HRESULT WINAPI color_converter_GetInputCurrentType(IMFTransform *iface, DWORD id, IMFMediaType **type)
+{
+    FIXME("%p, %u, %p.\n", iface, id, type);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI color_converter_GetOutputCurrentType(IMFTransform *iface, DWORD id, IMFMediaType **type)
+{
+    struct color_converter *converter = impl_color_converter_from_IMFTransform(iface);
+    IMFMediaType *ret;
+    HRESULT hr;
+
+    TRACE("%p, %u, %p.\n", converter, id, type);
+
+    if (id != 0)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    if (FAILED(hr = MFCreateMediaType(&ret)))
+        return hr;
+
+    EnterCriticalSection(&converter->cs);
+
+    if (converter->output_type)
+        hr = IMFMediaType_CopyAllItems(converter->output_type, (IMFAttributes *)ret);
+    else
+        hr = MF_E_TRANSFORM_TYPE_NOT_SET;
+
+    LeaveCriticalSection(&converter->cs);
+
+    if (SUCCEEDED(hr))
+        *type = ret;
+    else
+        IMFMediaType_Release(ret);
+
+    return hr;
+}
+
+static HRESULT WINAPI color_converter_GetInputStatus(IMFTransform *iface, DWORD id, DWORD *flags)
+{
+    FIXME("%p, %u, %p.\n", iface, id, flags);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI color_converter_GetOutputStatus(IMFTransform *iface, DWORD *flags)
+{
+    FIXME("%p, %p.\n", iface, flags);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI color_converter_SetOutputBounds(IMFTransform *iface, LONGLONG lower, LONGLONG upper)
+{
+    FIXME("%p, %s, %s.\n", iface, wine_dbgstr_longlong(lower), wine_dbgstr_longlong(upper));
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI color_converter_ProcessEvent(IMFTransform *iface, DWORD id, IMFMediaEvent *event)
+{
+    TRACE("%p, %u, %p.\n", iface, id, event);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI color_converter_ProcessMessage(IMFTransform *iface, MFT_MESSAGE_TYPE message, ULONG_PTR param)
+{
+    struct color_converter *converter = impl_color_converter_from_IMFTransform(iface);
+    struct wg_parser_buffer wg_buffer;
+
+    TRACE("%p, %u %lu.\n", iface, message, param);
+
+    switch(message)
+    {
+        case MFT_MESSAGE_COMMAND_FLUSH:
+        {
+            EnterCriticalSection(&converter->cs);
+            if (!converter->buffer_inflight)
+            {
+                LeaveCriticalSection(&converter->cs);
+                return S_OK;
+            }
+
+            wg_parser_stream_get_buffer(converter->stream, &wg_buffer);
+            wg_parser_stream_release_buffer(converter->stream);
+            converter->buffer_inflight = FALSE;
+
+            LeaveCriticalSection(&converter->cs);
+            return S_OK;
+        }
+        case MFT_MESSAGE_NOTIFY_BEGIN_STREAMING:
+            return S_OK;
+        default:
+            FIXME("Unhandled message type %x.\n", message);
+            return E_NOTIMPL;
+    }
+}
+
+static HRESULT WINAPI color_converter_ProcessInput(IMFTransform *iface, DWORD id, IMFSample *sample, DWORD flags)
+{
+    struct color_converter *converter = impl_color_converter_from_IMFTransform(iface);
+    IMFMediaBuffer *buffer = NULL;
+    unsigned char *buffer_data;
+    DWORD buffer_size;
+    uint64_t offset;
+    uint32_t size;
+    HRESULT hr;
+
+    TRACE("%p, %u, %p, %#x.\n", iface, id, sample, flags);
+
+    if (flags)
+        WARN("Unsupported flags %#x.\n", flags);
+
+    if (id != 0)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    EnterCriticalSection(&converter->cs);
+
+    if (!converter->stream)
+    {
+        hr = MF_E_TRANSFORM_TYPE_NOT_SET;
+        goto done;
+    }
+
+    if (converter->buffer_inflight)
+    {
+        hr = MF_E_NOTACCEPTING;
+        goto done;
+    }
+
+    if (FAILED(hr = IMFSample_ConvertToContiguousBuffer(sample, &buffer)))
+        goto done;
+
+    if (FAILED(hr = IMFMediaBuffer_Lock(buffer, &buffer_data, NULL, &buffer_size)))
+        goto done;
+
+    for (;;)
+    {
+        if (!wg_parser_get_next_read_offset(converter->parser, &offset, &size))
+        {
+            TRACE("sink unconnected\n");
+            continue;
+        }
+
+        wg_parser_push_data(converter->parser, WG_READ_SUCCESS, buffer_data, min(buffer_size, size));
+
+        if (buffer_size <= size)
+            break;
+
+        buffer_data += size;
+        buffer_size -= size;
+    }
+
+    IMFMediaBuffer_Unlock(buffer);
+    converter->buffer_inflight = TRUE;
+    if (FAILED(IMFSample_GetSampleTime(sample, &converter->buffer_pts)))
+        converter->buffer_pts = -1;
+    if (FAILED(IMFSample_GetSampleDuration(sample, &converter->buffer_dur)))
+        converter->buffer_dur = -1;
+
+done:
+    if (buffer)
+        IMFMediaBuffer_Release(buffer);
+    LeaveCriticalSection(&converter->cs);
+    return hr;
+}
+
+static HRESULT WINAPI color_converter_ProcessOutput(IMFTransform *iface, DWORD flags, DWORD count,
+        MFT_OUTPUT_DATA_BUFFER *samples, DWORD *status)
+{
+    struct color_converter *converter = impl_color_converter_from_IMFTransform(iface);
+    IMFSample *allocated_sample = NULL;
+    struct wg_parser_buffer wg_buffer;
+    IMFMediaBuffer *buffer = NULL;
+    unsigned char *buffer_data;
+    DWORD buffer_len;
+    HRESULT hr = S_OK;
+
+    TRACE("%p, %#x, %u, %p, %p.\n", iface, flags, count, samples, status);
+
+    if (flags)
+        WARN("Unsupported flags %#x.\n", flags);
+
+    if (!count)
+        return S_OK;
+
+    if (count != 1)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    if (samples[0].dwStreamID != 0)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    EnterCriticalSection(&converter->cs);
+
+    if (!converter->stream)
+    {
+        hr = MF_E_TRANSFORM_TYPE_NOT_SET;
+        goto done;
+    }
+
+    if (!converter->buffer_inflight)
+    {
+        hr = MF_E_TRANSFORM_NEED_MORE_INPUT;
+        goto done;
+    }
+
+    if (!wg_parser_stream_get_buffer(converter->stream, &wg_buffer))
+        assert(0);
+
+    if (!samples[0].pSample)
+    {
+        if (FAILED(hr = MFCreateMemoryBuffer(wg_buffer.size, &buffer)))
+        {
+            ERR("Failed to create buffer, hr %#x.\n", hr);
+            goto done;
+        }
+
+        if (FAILED(hr = MFCreateSample(&allocated_sample)))
+        {
+            ERR("Failed to create sample, hr %#x.\n", hr);
+            goto done;
+        }
+
+        samples[0].pSample = allocated_sample;
+
+        if (FAILED(hr = IMFSample_AddBuffer(samples[0].pSample, buffer)))
+        {
+            ERR("Failed to add buffer, hr %#x.\n", hr);
+            goto done;
+        }
+
+        IMFMediaBuffer_Release(buffer);
+        buffer = NULL;
+    }
+
+    if (FAILED(hr = IMFSample_ConvertToContiguousBuffer(samples[0].pSample, &buffer)))
+    {
+        ERR("Failed to get buffer from sample, hr %#x.\n", hr);
+        goto done;
+    }
+
+    if (FAILED(hr = IMFMediaBuffer_GetMaxLength(buffer, &buffer_len)))
+    {
+        ERR("Failed to get buffer size, hr %#x.\n", hr);
+        goto done;
+    }
+
+    if (buffer_len < wg_buffer.size)
+    {
+        WARN("Client's buffer is smaller (%u bytes) than the output sample (%u bytes)\n",
+            buffer_len, wg_buffer.size);
+
+        hr = MF_E_BUFFERTOOSMALL;
+        goto done;
+    }
+
+    if (FAILED(hr = IMFMediaBuffer_SetCurrentLength(buffer, wg_buffer.size)))
+    {
+        ERR("Failed to set size, hr %#x.\n", hr);
+        goto done;
+    }
+
+    if (FAILED(hr = IMFMediaBuffer_Lock(buffer, &buffer_data, NULL, NULL)))
+    {
+        ERR("Failed to lock buffer hr %#x.\n", hr);
+        goto done;
+    }
+
+    if (!wg_parser_stream_copy_buffer(converter->stream, buffer_data, 0, wg_buffer.size))
+    {
+        ERR("Failed to copy buffer.\n");
+        IMFMediaBuffer_Unlock(buffer);
+        hr = E_FAIL;
+        goto done;
+    }
+
+    IMFMediaBuffer_Unlock(buffer);
+
+    wg_parser_stream_release_buffer(converter->stream);
+    converter->buffer_inflight = FALSE;
+
+    if (converter->buffer_pts != -1)
+        IMFSample_SetSampleTime(samples[0].pSample, converter->buffer_pts);
+    if (converter->buffer_dur != -1)
+        IMFSample_SetSampleDuration(samples[0].pSample, converter->buffer_dur);
+
+    samples[0].dwStatus = 0;
+    samples[0].pEvents = NULL;
+
+    done:
+    if (buffer)
+        IMFMediaBuffer_Release(buffer);
+    if (FAILED(hr) && allocated_sample)
+    {
+        IMFSample_Release(allocated_sample);
+        samples[0].pSample = NULL;
+    }
+    LeaveCriticalSection(&converter->cs);
+    return hr;
+}
+
+static const IMFTransformVtbl color_converter_vtbl =
+{
+    color_converter_QueryInterface,
+    color_converter_AddRef,
+    color_converter_Release,
+    color_converter_GetStreamLimits,
+    color_converter_GetStreamCount,
+    color_converter_GetStreamIDs,
+    color_converter_GetInputStreamInfo,
+    color_converter_GetOutputStreamInfo,
+    color_converter_GetAttributes,
+    color_converter_GetInputStreamAttributes,
+    color_converter_GetOutputStreamAttributes,
+    color_converter_DeleteInputStream,
+    color_converter_AddInputStreams,
+    color_converter_GetInputAvailableType,
+    color_converter_GetOutputAvailableType,
+    color_converter_SetInputType,
+    color_converter_SetOutputType,
+    color_converter_GetInputCurrentType,
+    color_converter_GetOutputCurrentType,
+    color_converter_GetInputStatus,
+    color_converter_GetOutputStatus,
+    color_converter_SetOutputBounds,
+    color_converter_ProcessEvent,
+    color_converter_ProcessMessage,
+    color_converter_ProcessInput,
+    color_converter_ProcessOutput,
+};
+
+HRESULT color_converter_create(REFIID riid, void **ret)
+{
+    struct color_converter *object;
+
+    TRACE("%s %p\n", debugstr_guid(riid), ret);
+
+    if (!(object = calloc(1, sizeof(*object))))
+        return E_OUTOFMEMORY;
+
+    object->IMFTransform_iface.lpVtbl = &color_converter_vtbl;
+    object->refcount = 1;
+
+    InitializeCriticalSection(&object->cs);
+    object->cs.DebugInfo->Spare[0] = (DWORD_PTR)(__FILE__ ": color_converter_lock");
+
+    if (!(object->parser = wg_parser_create(WG_PARSER_VIDEOCONV, true)))
+    {
+        ERR("Failed to create video converter due to GStreamer error.\n");
+        IMFTransform_Release(&object->IMFTransform_iface);
+        return E_OUTOFMEMORY;
+    }
+
+    *ret = &object->IMFTransform_iface;
+    return S_OK;
+}
diff --git a/dlls/winegstreamer/decode_transform.c b/dlls/winegstreamer/decode_transform.c
new file mode 100644
index 00000000000..fb7f432923f
--- /dev/null
+++ wine/dlls/winegstreamer/decode_transform.c
@@ -0,0 +1,1218 @@
+/* GStreamer Decoder Transform
+ *
+ * Copyright 2021 Derek Lesho
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "gst_private.h"
+
+#include "mfapi.h"
+#include "mferror.h"
+#include "mfobjects.h"
+#include "mftransform.h"
+
+#include "wine/debug.h"
+#include "wine/heap.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(mfplat);
+
+const GUID *h264_input_types[] = {&MFVideoFormat_H264};
+/* NV12 comes first https://docs.microsoft.com/en-us/windows/win32/medfound/mft-decoder-expose-output-types-in-native-order . thanks to @vitorhnn */
+const GUID *h264_output_types[] = {&MFVideoFormat_NV12, &MFVideoFormat_I420, &MFVideoFormat_IYUV, &MFVideoFormat_YUY2, &MFVideoFormat_YV12};
+
+const GUID *aac_input_types[] = {&MFAudioFormat_AAC};
+const GUID *aac_output_types[] = {&MFAudioFormat_Float};
+
+static struct decoder_desc
+{
+    const GUID *major_type;
+    const GUID **input_types;
+    unsigned int input_types_count;
+    const GUID **output_types;
+    unsigned int output_types_count;
+} decoder_descs[] =
+{
+    { /* DECODER_TYPE_H264 */
+        &MFMediaType_Video,
+        h264_input_types,
+        ARRAY_SIZE(h264_input_types),
+        h264_output_types,
+        ARRAY_SIZE(h264_output_types),
+    },
+    { /* DECODER_TYPE_AAC */
+        &MFMediaType_Audio,
+        aac_input_types,
+        ARRAY_SIZE(aac_input_types),
+        aac_output_types,
+        ARRAY_SIZE(aac_output_types),
+    }
+};
+
+struct pipeline_event
+{
+    enum
+    {
+        PIPELINE_EVENT_NONE,
+        PIPELINE_EVENT_PARSER_STARTED,
+        PIPELINE_EVENT_READ_REQUEST,
+    } type;
+    union
+    {
+        struct
+        {
+            struct wg_parser_stream *stream;
+        } parser_started;
+    } u;
+};
+
+struct mf_decoder
+{
+    IMFTransform IMFTransform_iface;
+    LONG refcount;
+    enum decoder_type type;
+    IMFMediaType *input_type, *output_type;
+    CRITICAL_SECTION cs, help_cs, event_cs;
+    CONDITION_VARIABLE help_cv, event_cv;
+    BOOL flushing, draining, eos, helper_thread_shutdown, video;
+    HANDLE helper_thread, read_thread;
+    uint64_t offset_tracker;
+    struct wg_parser *wg_parser;
+    struct wg_parser_stream *wg_stream;
+
+    struct
+    {
+        enum
+        {
+            HELP_REQ_NONE,
+            HELP_REQ_START_PARSER,
+        } type;
+    } help_request;
+
+    struct pipeline_event event;
+};
+
+static struct mf_decoder *impl_mf_decoder_from_IMFTransform(IMFTransform *iface)
+{
+    return CONTAINING_RECORD(iface, struct mf_decoder, IMFTransform_iface);
+}
+
+static HRESULT WINAPI mf_decoder_QueryInterface (IMFTransform *iface, REFIID riid, void **out)
+{
+    TRACE("%p, %s, %p.\n", iface, debugstr_guid(riid), out);
+
+    if (IsEqualIID(riid, &IID_IMFTransform) ||
+            IsEqualIID(riid, &IID_IUnknown))
+    {
+        *out = iface;
+        IMFTransform_AddRef(iface);
+        return S_OK;
+    }
+
+    WARN("Unsupported %s.\n", debugstr_guid(riid));
+    *out = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI mf_decoder_AddRef(IMFTransform *iface)
+{
+    struct mf_decoder *decoder = impl_mf_decoder_from_IMFTransform(iface);
+    ULONG refcount = InterlockedIncrement(&decoder->refcount);
+
+    TRACE("%p, refcount %u.\n", iface, refcount);
+
+    return refcount;
+}
+
+static ULONG WINAPI mf_decoder_Release(IMFTransform *iface)
+{
+    struct mf_decoder *decoder = impl_mf_decoder_from_IMFTransform(iface);
+    ULONG refcount = InterlockedDecrement(&decoder->refcount);
+
+    TRACE("%p, refcount %u.\n", iface, refcount);
+
+    if (!refcount)
+    {
+        if (decoder->input_type)
+        {
+            IMFMediaType_Release(decoder->input_type);
+            decoder->input_type = NULL;
+        }
+
+        if (decoder->output_type)
+        {
+            IMFMediaType_Release(decoder->output_type);
+            decoder->output_type = NULL;
+        }
+
+        if (decoder->wg_parser)
+        {
+            /* NULL wg_parser is possible if the wg_parser creation failed. */
+
+            if (decoder->wg_stream)
+                wg_parser_disconnect(decoder->wg_parser);
+
+            EnterCriticalSection(&decoder->event_cs);
+            decoder->helper_thread_shutdown = TRUE;
+            WakeAllConditionVariable(&decoder->event_cv);
+            LeaveCriticalSection(&decoder->event_cs);
+
+            EnterCriticalSection(&decoder->help_cs);
+            WakeAllConditionVariable(&decoder->help_cv);
+            LeaveCriticalSection(&decoder->help_cs);
+
+            if (WaitForSingleObject(decoder->helper_thread, 10000) != WAIT_OBJECT_0)
+                FIXME("Failed waiting for helper thread to terminate.\n");
+            CloseHandle(decoder->helper_thread);
+            if (WaitForSingleObject(decoder->read_thread, 10000) != WAIT_OBJECT_0)
+                FIXME("Failed waiting for read thread to terminate.\n");
+            CloseHandle(decoder->read_thread);
+
+            wg_parser_destroy(decoder->wg_parser);
+        }
+
+        DeleteCriticalSection(&decoder->cs);
+        DeleteCriticalSection(&decoder->help_cs);
+        DeleteCriticalSection(&decoder->event_cs);
+
+        heap_free(decoder);
+    }
+
+    return refcount;
+}
+
+static HRESULT WINAPI mf_decoder_GetStreamLimits(IMFTransform *iface, DWORD *input_minimum, DWORD *input_maximum,
+        DWORD *output_minimum, DWORD *output_maximum)
+{
+    TRACE("%p, %p, %p, %p, %p.\n", iface, input_minimum, input_maximum, output_minimum, output_maximum);
+
+    *input_minimum = *input_maximum = *output_minimum = *output_maximum = 1;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI mf_decoder_GetStreamCount(IMFTransform *iface, DWORD *inputs, DWORD *outputs)
+{
+    TRACE("%p %p %p.\n", iface, inputs, outputs);
+
+    *inputs = *outputs = 1;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI mf_decoder_GetStreamIDs(IMFTransform *iface, DWORD input_size, DWORD *inputs,
+        DWORD output_size, DWORD *outputs)
+{
+    TRACE("%p %u %p %u %p.\n", iface, input_size, inputs, output_size, outputs);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI mf_decoder_GetInputStreamInfo(IMFTransform *iface, DWORD id, MFT_INPUT_STREAM_INFO *info)
+{
+    struct mf_decoder *decoder = impl_mf_decoder_from_IMFTransform(iface);
+
+    TRACE("%p %u %p\n", decoder, id, info);
+
+    if (id != 0)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    info->dwFlags = MFT_INPUT_STREAM_WHOLE_SAMPLES | MFT_INPUT_STREAM_DOES_NOT_ADDREF;
+    info->cbAlignment = 0;
+    info->cbSize = 0;
+    /* TODO: retrieve following fields from gstreamer */
+    info->hnsMaxLatency = 0;
+    info->cbMaxLookahead = 0;
+    return S_OK;
+}
+
+static HRESULT WINAPI mf_decoder_GetOutputStreamInfo(IMFTransform *iface, DWORD id, MFT_OUTPUT_STREAM_INFO *info)
+{
+    struct mf_decoder *decoder = impl_mf_decoder_from_IMFTransform(iface);
+    MFT_OUTPUT_STREAM_INFO stream_info = {};
+    GUID output_subtype;
+    UINT64 framesize;
+
+    TRACE("%p %u %p\n", decoder, id, info);
+
+    if (id != 0)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    EnterCriticalSection(&decoder->cs);
+
+    if (!decoder->output_type)
+    {
+        LeaveCriticalSection(&decoder->cs);
+        return MF_E_TRANSFORM_TYPE_NOT_SET;
+    }
+
+    if (decoder->video)
+    {
+        stream_info.dwFlags = MFT_OUTPUT_STREAM_WHOLE_SAMPLES | MFT_OUTPUT_STREAM_SINGLE_SAMPLE_PER_BUFFER |
+                              MFT_OUTPUT_STREAM_FIXED_SAMPLE_SIZE | MFT_OUTPUT_STREAM_CAN_PROVIDE_SAMPLES;
+        stream_info.cbSize = 0;
+        if (SUCCEEDED(IMFMediaType_GetGUID(decoder->output_type, &MF_MT_SUBTYPE, &output_subtype)) &&
+            SUCCEEDED(IMFMediaType_GetUINT64(decoder->output_type, &MF_MT_FRAME_SIZE, &framesize)))
+        {
+            MFCalculateImageSize(&output_subtype, framesize >> 32, (UINT32) framesize, &stream_info.cbSize);
+        }
+        if (!stream_info.cbSize)
+            ERR("Failed to get desired output buffer size\n");
+    }
+    else
+    {
+        stream_info.dwFlags = MFT_OUTPUT_STREAM_FIXED_SAMPLE_SIZE | MFT_OUTPUT_STREAM_CAN_PROVIDE_SAMPLES;
+        stream_info.cbSize = 4;
+    }
+    stream_info.cbAlignment = 0;
+
+    LeaveCriticalSection(&decoder->cs);
+
+    *info = stream_info;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI mf_decoder_GetAttributes(IMFTransform *iface, IMFAttributes **attributes)
+{
+    FIXME("%p, %p. semi-stub!\n", iface, attributes);
+
+    return MFCreateAttributes(attributes, 0);
+}
+
+static HRESULT WINAPI mf_decoder_GetInputStreamAttributes(IMFTransform *iface, DWORD id,
+        IMFAttributes **attributes)
+{
+    FIXME("%p, %u, %p.\n", iface, id, attributes);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI mf_decoder_GetOutputStreamAttributes(IMFTransform *iface, DWORD id,
+        IMFAttributes **attributes)
+{
+    FIXME("%p, %u, %p.\n", iface, id, attributes);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI mf_decoder_DeleteInputStream(IMFTransform *iface, DWORD id)
+{
+    TRACE("%p, %u.\n", iface, id);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI mf_decoder_AddInputStreams(IMFTransform *iface, DWORD streams, DWORD *ids)
+{
+    TRACE("%p, %u, %p.\n", iface, streams, ids);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI mf_decoder_GetInputAvailableType(IMFTransform *iface, DWORD id, DWORD index,
+        IMFMediaType **type)
+{
+    struct mf_decoder *decoder = impl_mf_decoder_from_IMFTransform(iface);
+    IMFMediaType *input_type;
+    HRESULT hr;
+
+    TRACE("%p, %u, %u, %p\n", decoder, id, index, type);
+
+    if (id != 0)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    if (index >= decoder_descs[decoder->type].input_types_count)
+        return MF_E_NO_MORE_TYPES;
+
+    if (FAILED(hr = MFCreateMediaType(&input_type)))
+        return hr;
+
+    if (FAILED(hr = IMFMediaType_SetGUID(input_type, &MF_MT_MAJOR_TYPE, decoder_descs[decoder->type].major_type)))
+    {
+        IMFMediaType_Release(input_type);
+        return hr;
+    }
+
+    if (FAILED(hr = IMFMediaType_SetGUID(input_type, &MF_MT_SUBTYPE, decoder_descs[decoder->type].input_types[index])))
+    {
+        IMFMediaType_Release(input_type);
+        return hr;
+    }
+
+    *type = input_type;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI mf_decoder_GetOutputAvailableType(IMFTransform *iface, DWORD id, DWORD index,
+        IMFMediaType **type)
+{
+    struct mf_decoder *decoder = impl_mf_decoder_from_IMFTransform(iface);
+    IMFMediaType *output_type;
+    HRESULT hr;
+
+    TRACE("%p, %u, %u, %p\n", decoder, id, index, type);
+
+    if (id != 0)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    if (index >= decoder_descs[decoder->type].output_types_count)
+        return MF_E_NO_MORE_TYPES;
+
+    if (FAILED(hr = MFCreateMediaType(&output_type)))
+        return hr;
+
+    if (FAILED(hr = IMFMediaType_SetGUID(output_type, &MF_MT_MAJOR_TYPE, decoder_descs[decoder->type].major_type)))
+    {
+        IMFMediaType_Release(output_type);
+        return hr;
+    }
+
+    if (FAILED(hr = IMFMediaType_SetGUID(output_type, &MF_MT_SUBTYPE, decoder_descs[decoder->type].output_types[index])))
+    {
+        IMFMediaType_Release(output_type);
+        return hr;
+    }
+
+    *type = output_type;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI mf_decoder_SetInputType(IMFTransform *iface, DWORD id, IMFMediaType *type, DWORD flags)
+{
+    struct mf_decoder *decoder = impl_mf_decoder_from_IMFTransform(iface);
+    struct wg_format input_format;
+    GUID major_type, subtype;
+    unsigned int i;
+    HRESULT hr;
+
+    TRACE("%p, %u, %p, %#x.\n", decoder, id, type, flags);
+
+    if (id != 0)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    if (!type)
+    {
+        if (flags & MFT_SET_TYPE_TEST_ONLY)
+            return S_OK;
+
+        EnterCriticalSection(&decoder->cs);
+
+        if (decoder->wg_stream)
+        {
+            decoder->wg_stream = NULL;
+            wg_parser_disconnect(decoder->wg_parser);
+        }
+
+        if (decoder->input_type)
+        {
+            IMFMediaType_Release(decoder->input_type);
+            decoder->input_type = NULL;
+        }
+
+        LeaveCriticalSection(&decoder->cs);
+
+        return S_OK;
+    }
+
+    if (FAILED(IMFMediaType_GetGUID(type, &MF_MT_MAJOR_TYPE, &major_type)))
+        return MF_E_INVALIDTYPE;
+    if (FAILED(IMFMediaType_GetGUID(type, &MF_MT_SUBTYPE, &subtype)))
+        return MF_E_INVALIDTYPE;
+
+    if (!(IsEqualGUID(&major_type, decoder_descs[decoder->type].major_type)))
+        return MF_E_INVALIDTYPE;
+
+    for (i = 0; i < decoder_descs[decoder->type].input_types_count; i++)
+    {
+        if (IsEqualGUID(&subtype, decoder_descs[decoder->type].input_types[i]))
+            break;
+        if (i == decoder_descs[decoder->type].input_types_count)
+            return MF_E_INVALIDTYPE;
+    }
+
+    mf_media_type_to_wg_format(type, &input_format);
+    if (!input_format.major_type)
+        return MF_E_INVALIDTYPE;
+
+    if (flags & MFT_SET_TYPE_TEST_ONLY)
+        return S_OK;
+
+    EnterCriticalSection(&decoder->cs);
+
+    hr = S_OK;
+
+    if (decoder->wg_stream)
+    {
+        decoder->wg_stream = NULL;
+        wg_parser_disconnect(decoder->wg_parser);
+    }
+
+    if (!decoder->input_type)
+        hr = MFCreateMediaType(&decoder->input_type);
+
+    if (SUCCEEDED(hr) && FAILED(hr = IMFMediaType_CopyAllItems(type, (IMFAttributes*) decoder->input_type)))
+    {
+        IMFMediaType_Release(decoder->input_type);
+        decoder->input_type = NULL;
+    }
+
+    if (decoder->input_type && decoder->output_type)
+    {
+        EnterCriticalSection(&decoder->help_cs);
+        while(decoder->help_request.type != HELP_REQ_NONE)
+            SleepConditionVariableCS(&decoder->help_cv, &decoder->help_cs, INFINITE);
+        decoder->help_request.type = HELP_REQ_START_PARSER;
+        LeaveCriticalSection(&decoder->help_cs);
+        WakeAllConditionVariable(&decoder->help_cv);
+    }
+
+    LeaveCriticalSection(&decoder->cs);
+    return hr;
+}
+
+static HRESULT WINAPI mf_decoder_SetOutputType(IMFTransform *iface, DWORD id, IMFMediaType *type, DWORD flags)
+{
+    struct mf_decoder *decoder = impl_mf_decoder_from_IMFTransform(iface);
+    struct wg_format output_format;
+    GUID major_type, subtype;
+    HRESULT hr;
+    unsigned int i;
+
+    TRACE("%p, %u, %p, %#x.\n", decoder, id, type, flags);
+
+    if (id != 0)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    if (!type)
+    {
+        if (flags & MFT_SET_TYPE_TEST_ONLY)
+            return S_OK;
+
+        EnterCriticalSection(&decoder->cs);
+
+        if (decoder->wg_stream)
+        {
+            decoder->wg_stream = NULL;
+            wg_parser_disconnect(decoder->wg_parser);
+        }
+
+        if (decoder->output_type)
+        {
+            IMFMediaType_Release(decoder->output_type);
+            decoder->output_type = NULL;
+        }
+
+        LeaveCriticalSection(&decoder->cs);
+
+        return S_OK;
+    }
+
+    if (FAILED(IMFMediaType_GetGUID(type, &MF_MT_MAJOR_TYPE, &major_type)))
+        return MF_E_INVALIDTYPE;
+    if (FAILED(IMFMediaType_GetGUID(type, &MF_MT_SUBTYPE, &subtype)))
+        return MF_E_INVALIDTYPE;
+
+    if (!(IsEqualGUID(&major_type, decoder_descs[decoder->type].major_type)))
+        return MF_E_INVALIDTYPE;
+
+    for (i = 0; i < decoder_descs[decoder->type].output_types_count; i++)
+    {
+        if (IsEqualGUID(&subtype, decoder_descs[decoder->type].output_types[i]))
+            break;
+        if (i == decoder_descs[decoder->type].output_types_count)
+            return MF_E_INVALIDTYPE;
+    }
+
+    mf_media_type_to_wg_format(type, &output_format);
+    if (!output_format.major_type)
+        return MF_E_INVALIDTYPE;
+
+    if (flags & MFT_SET_TYPE_TEST_ONLY)
+        return S_OK;
+
+    EnterCriticalSection(&decoder->cs);
+
+    hr = S_OK;
+
+    if (decoder->wg_stream)
+    {
+        decoder->wg_stream = NULL;
+        wg_parser_disconnect(decoder->wg_parser);
+    }
+
+    if (!decoder->output_type)
+        hr = MFCreateMediaType(&decoder->output_type);
+
+    if (SUCCEEDED(hr) && FAILED(hr = IMFMediaType_CopyAllItems(type, (IMFAttributes*) decoder->output_type)))
+    {
+        IMFMediaType_Release(decoder->output_type);
+        decoder->output_type = NULL;
+    }
+
+    if (decoder->input_type && decoder->output_type)
+    {
+        EnterCriticalSection(&decoder->help_cs);
+        while(decoder->help_request.type != HELP_REQ_NONE)
+            SleepConditionVariableCS(&decoder->help_cv, &decoder->help_cs, INFINITE);
+        decoder->help_request.type = HELP_REQ_START_PARSER;
+        LeaveCriticalSection(&decoder->help_cs);
+        WakeAllConditionVariable(&decoder->help_cv);
+    }
+
+    LeaveCriticalSection(&decoder->cs);
+    return hr;
+}
+
+static HRESULT WINAPI mf_decoder_GetInputCurrentType(IMFTransform *iface, DWORD id, IMFMediaType **type)
+{
+    FIXME("%p, %u, %p.\n", iface, id, type);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI mf_decoder_GetOutputCurrentType(IMFTransform *iface, DWORD id, IMFMediaType **type)
+{
+    FIXME("%p, %u, %p.\n", iface, id, type);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI mf_decoder_GetInputStatus(IMFTransform *iface, DWORD id, DWORD *flags)
+{
+    FIXME("%p, %u, %p\n", iface, id, flags);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI mf_decoder_GetOutputStatus(IMFTransform *iface, DWORD *flags)
+{
+    FIXME("%p, %p.\n", iface, flags);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI mf_decoder_SetOutputBounds(IMFTransform *iface, LONGLONG lower, LONGLONG upper)
+{
+    FIXME("%p, %s, %s.\n", iface, wine_dbgstr_longlong(lower), wine_dbgstr_longlong(upper));
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI mf_decoder_ProcessEvent(IMFTransform *iface, DWORD id, IMFMediaEvent *event)
+{
+    FIXME("%p, %u, %p.\n", iface, id, event);
+
+    return E_NOTIMPL;
+}
+
+static DWORD CALLBACK helper_thread_func(PVOID ctx)
+{
+    struct mf_decoder *decoder = (struct mf_decoder *)ctx;
+
+    for(;;)
+    {
+        EnterCriticalSection(&decoder->help_cs);
+
+        while(!decoder->helper_thread_shutdown && decoder->help_request.type == HELP_REQ_NONE)
+            SleepConditionVariableCS(&decoder->help_cv, &decoder->help_cs, INFINITE);
+        if (decoder->helper_thread_shutdown)
+        {
+            LeaveCriticalSection(&decoder->help_cs);
+            return 0;
+        }
+
+        switch(decoder->help_request.type)
+        {
+            case HELP_REQ_START_PARSER:
+            {
+                struct wg_format input_format, output_format;
+                struct wg_rect wg_aperture = {0};
+                MFVideoArea *aperture = NULL;
+                UINT32 aperture_size;
+
+                decoder->help_request.type = HELP_REQ_NONE;
+                LeaveCriticalSection(&decoder->help_cs);
+
+                mf_media_type_to_wg_format(decoder->input_type, &input_format);
+                mf_media_type_to_wg_format(decoder->output_type, &output_format);
+
+                if (SUCCEEDED(IMFMediaType_GetAllocatedBlob(decoder->output_type,
+                    &MF_MT_MINIMUM_DISPLAY_APERTURE, (UINT8 **) &aperture, &aperture_size)))
+                {
+                    TRACE("Decoded media's aperture: x: %u %u/65536, y: %u %u/65536, area: %u x %u\n",
+                        aperture->OffsetX.value, aperture->OffsetX.fract,
+                        aperture->OffsetY.value, aperture->OffsetY.fract, aperture->Area.cx, aperture->Area.cy);
+
+                    /* TODO: verify aperture params? */
+
+                    wg_aperture.left = aperture->OffsetX.value;
+                    wg_aperture.top = aperture->OffsetY.value;
+                    wg_aperture.right = aperture->Area.cx;
+                    wg_aperture.bottom = aperture->Area.cy;
+
+                    CoTaskMemFree(aperture);
+                }
+
+                wg_parser_connect_unseekable(decoder->wg_parser,
+                    &input_format, 1, &output_format, aperture ? &wg_aperture : NULL);
+
+                EnterCriticalSection(&decoder->event_cs);
+                while (!decoder->helper_thread_shutdown && decoder->event.type != PIPELINE_EVENT_NONE)
+                    SleepConditionVariableCS(&decoder->event_cv, &decoder->event_cs, INFINITE);
+
+                if (decoder->helper_thread_shutdown)
+                {
+                    LeaveCriticalSection(&decoder->event_cs);
+                    return 0;
+                }
+
+                decoder->event.type = PIPELINE_EVENT_PARSER_STARTED;
+                decoder->event.u.parser_started.stream = wg_parser_get_stream(decoder->wg_parser, 0);
+
+                LeaveCriticalSection(&decoder->event_cs);
+                WakeAllConditionVariable(&decoder->event_cv);
+
+                break;
+            }
+            default:
+                assert(0);
+        }
+    }
+}
+
+/* We use a separate thread to wait for reads, as we may want to wait to WAIT_ANY
+   on a read and another event. */
+static DWORD CALLBACK read_thread_func(PVOID ctx)
+{
+    struct mf_decoder *decoder = (struct mf_decoder *)ctx;
+    uint64_t offset;
+    uint32_t size;
+
+    for (;;)
+    {
+        if (decoder->helper_thread_shutdown)
+            break;
+
+        if (!wg_parser_get_next_read_offset(decoder->wg_parser, &offset, &size))
+            continue;
+
+        EnterCriticalSection(&decoder->event_cs);
+        while (!decoder->helper_thread_shutdown && decoder->event.type != PIPELINE_EVENT_NONE)
+            SleepConditionVariableCS(&decoder->event_cv, &decoder->event_cs, INFINITE);
+
+        if (decoder->helper_thread_shutdown)
+        {
+            LeaveCriticalSection(&decoder->event_cs);
+            break;
+        }
+
+        decoder->event.type = PIPELINE_EVENT_READ_REQUEST;
+        WakeAllConditionVariable(&decoder->event_cv);
+        while (!decoder->helper_thread_shutdown && decoder->event.type == PIPELINE_EVENT_READ_REQUEST)
+            SleepConditionVariableCS(&decoder->event_cv, &decoder->event_cs, INFINITE);
+        LeaveCriticalSection(&decoder->event_cs);
+    }
+
+    return 0;
+}
+
+static struct pipeline_event get_pipeline_event(struct mf_decoder *decoder)
+{
+    struct pipeline_event ret;
+
+    EnterCriticalSection(&decoder->event_cs);
+    while(decoder->event.type == PIPELINE_EVENT_NONE)
+        SleepConditionVariableCS(&decoder->event_cv, &decoder->event_cs, INFINITE);
+
+    ret = decoder->event;
+
+    if (ret.type != PIPELINE_EVENT_READ_REQUEST)
+    {
+        decoder->event.type = PIPELINE_EVENT_NONE;
+        WakeAllConditionVariable(&decoder->event_cv);
+    }
+
+    LeaveCriticalSection(&decoder->event_cs);
+
+    return ret;
+}
+
+static HRESULT WINAPI mf_decoder_ProcessMessage(IMFTransform *iface, MFT_MESSAGE_TYPE message, ULONG_PTR param)
+{
+    struct mf_decoder *decoder = impl_mf_decoder_from_IMFTransform(iface);
+    HRESULT hr;
+
+    TRACE("%p, %x %lu.\n", decoder, message, param);
+
+    EnterCriticalSection(&decoder->cs);
+    if (!decoder->input_type || !decoder->output_type)
+    {
+        LeaveCriticalSection(&decoder->cs);
+        return MF_E_TRANSFORM_TYPE_NOT_SET;
+    }
+
+    hr = S_OK;
+
+    switch (message)
+    {
+        case MFT_MESSAGE_NOTIFY_BEGIN_STREAMING:
+        case MFT_MESSAGE_NOTIFY_START_OF_STREAM:
+            break;
+        case MFT_MESSAGE_NOTIFY_END_OF_STREAM:
+        {
+            if (param)
+            {
+                hr = MF_E_INVALIDSTREAMNUMBER;
+                break;
+            }
+            if (!decoder->wg_stream)
+            {
+                ERR("End-Of-Stream marked on a decoder MFT which hasn't finished initialization\n");
+                hr = E_FAIL;
+                break;
+            }
+
+            decoder->eos = TRUE;
+            break;
+        }
+        case MFT_MESSAGE_COMMAND_DRAIN:
+        {
+            struct pipeline_event pip_event;
+
+            if (!decoder->wg_stream)
+            {
+                ERR("Drain requested on a decoder MFT which hasn't finished initialization\n");
+                hr = E_FAIL;
+                break;
+            }
+
+            pip_event = get_pipeline_event(decoder);
+            assert(pip_event.type == PIPELINE_EVENT_READ_REQUEST);
+
+            wg_parser_push_data(decoder->wg_parser, WG_READ_EOS, NULL, 0);
+
+            EnterCriticalSection(&decoder->event_cs);
+            decoder->event.type = PIPELINE_EVENT_NONE;
+            LeaveCriticalSection(&decoder->event_cs);
+            WakeAllConditionVariable(&decoder->event_cv);
+
+            decoder->draining = TRUE;
+            decoder->offset_tracker = 0;
+            break;
+        }
+        case MFT_MESSAGE_COMMAND_FLUSH:
+        {
+            struct pipeline_event pip_event;
+
+            if (!decoder->wg_stream)
+            {
+                ERR("Flush requested on a decoder MFT which hasn't finished initialization\n");
+                hr = E_FAIL;
+                break;
+            }
+
+            pip_event = get_pipeline_event(decoder);
+            assert(pip_event.type == PIPELINE_EVENT_READ_REQUEST);
+
+            wg_parser_push_data(decoder->wg_parser, WG_READ_FLUSHING, NULL, 0);
+
+            EnterCriticalSection(&decoder->event_cs);
+            decoder->event.type = PIPELINE_EVENT_NONE;
+            LeaveCriticalSection(&decoder->event_cs);
+            WakeAllConditionVariable(&decoder->event_cv);
+
+            decoder->offset_tracker = 0;
+            break;
+        }
+        default:
+        {
+            ERR("Unhandled message type %x.\n", message);
+            hr = E_FAIL;
+            break;
+        }
+    }
+
+    LeaveCriticalSection(&decoder->cs);
+    return hr;
+}
+
+static HRESULT WINAPI mf_decoder_ProcessInput(IMFTransform *iface, DWORD id, IMFSample *sample, DWORD flags)
+{
+    struct mf_decoder *decoder = impl_mf_decoder_from_IMFTransform(iface);
+    struct pipeline_event pip_event;
+    IMFMediaBuffer *buffer = NULL;
+    HRESULT hr = S_OK;
+    BYTE *buffer_data;
+    DWORD buffer_size;
+    uint32_t size = 0;
+    uint64_t offset;
+
+    TRACE("%p, %u, %p, %#x.\n", decoder, id, sample, flags);
+
+    if (flags)
+        WARN("Unsupported flags %#x\n", flags);
+
+    if (id != 0)
+        return MF_E_INVALIDSTREAMNUMBER;
+
+    EnterCriticalSection(&decoder->cs);
+
+    if (!decoder->input_type || !decoder->output_type)
+    {
+        LeaveCriticalSection(&decoder->cs);
+        return MF_E_TRANSFORM_TYPE_NOT_SET;
+    }
+
+    if (decoder->draining)
+    {
+        LeaveCriticalSection(&decoder->cs);
+        return MF_E_NOTACCEPTING;
+    }
+
+    if (!decoder->wg_stream)
+    {
+        pip_event = get_pipeline_event(decoder);
+
+        switch (pip_event.type)
+        {
+            case PIPELINE_EVENT_PARSER_STARTED:
+                decoder->wg_stream = pip_event.u.parser_started.stream;
+                break;
+            case PIPELINE_EVENT_READ_REQUEST:
+                break;
+            default:
+                assert(0);
+        }
+    }
+
+    if (decoder->wg_stream && !wg_parser_stream_drain(decoder->wg_stream))
+    {
+        LeaveCriticalSection(&decoder->cs);
+        return MF_E_NOTACCEPTING;
+    }
+
+    /* At this point, we either have a pre-init read request, or drained pipeline */
+
+    if (FAILED(hr = IMFSample_ConvertToContiguousBuffer(sample, &buffer)))
+        goto done;
+
+    if (FAILED(hr = IMFMediaBuffer_Lock(buffer, &buffer_data, NULL, &buffer_size)))
+        goto done;
+
+    pip_event = get_pipeline_event(decoder);
+    assert(pip_event.type == PIPELINE_EVENT_READ_REQUEST);
+
+    for(;;)
+    {
+        uint32_t copy_size;
+
+        if (!wg_parser_get_next_read_offset(decoder->wg_parser, &offset, &size))
+            continue;
+
+        copy_size = min(size, buffer_size);
+
+        if (offset != decoder->offset_tracker)
+        {
+            ERR("A seek is needed, MFTs don't support this!\n");
+            wg_parser_push_data(decoder->wg_parser, WG_READ_FAILURE, NULL, 0);
+            IMFMediaBuffer_Unlock(buffer);
+            hr = E_FAIL;
+            goto done;
+        }
+
+        wg_parser_push_data(decoder->wg_parser, WG_READ_SUCCESS, buffer_data, buffer_size);
+
+        decoder->offset_tracker += copy_size;
+
+        if (buffer_size <= size)
+            break;
+
+        buffer_data += copy_size;
+        buffer_size -= copy_size;
+
+        WARN("Input sample split into multiple read requests\n");
+    }
+
+    EnterCriticalSection(&decoder->event_cs);
+    decoder->event.type = PIPELINE_EVENT_NONE;
+    LeaveCriticalSection(&decoder->event_cs);
+    WakeAllConditionVariable(&decoder->event_cv);
+
+    IMFMediaBuffer_Unlock(buffer);
+
+    done:
+    if (buffer)
+        IMFMediaBuffer_Release(buffer);
+    LeaveCriticalSection(&decoder->cs);
+    return hr;
+}
+
+static HRESULT WINAPI mf_decoder_ProcessOutput(IMFTransform *iface, DWORD flags, DWORD count,
+        MFT_OUTPUT_DATA_BUFFER *samples, DWORD *status)
+{
+    struct mf_decoder *decoder = impl_mf_decoder_from_IMFTransform(iface);
+    MFT_OUTPUT_DATA_BUFFER *relevant_buffer = NULL;
+    struct wg_parser_buffer wg_buffer;
+    struct pipeline_event pip_event;
+    IMFMediaBuffer *buffer;
+    DWORD buffer_len;
+    unsigned int i;
+    BYTE *data;
+    HRESULT hr;
+
+    TRACE("%p, %#x, %u, %p, %p.\n", iface, flags, count, samples, status);
+
+    if (flags)
+        WARN("Unsupported flags %#x\n", flags);
+
+    for (i = 0; i < count; i++)
+    {
+        MFT_OUTPUT_DATA_BUFFER *out_buffer = &samples[i];
+
+        if (out_buffer->dwStreamID != 0)
+            return MF_E_INVALIDSTREAMNUMBER;
+
+        if (relevant_buffer)
+            return MF_E_INVALIDSTREAMNUMBER;
+
+        relevant_buffer = out_buffer;
+    }
+
+    if (!relevant_buffer)
+        return S_OK;
+
+    EnterCriticalSection(&decoder->cs);
+
+    if (!decoder->input_type || !decoder->output_type)
+    {
+        LeaveCriticalSection(&decoder->cs);
+        return MF_E_TRANSFORM_TYPE_NOT_SET;
+    }
+
+    if (!decoder->wg_stream)
+    {
+        pip_event = get_pipeline_event(decoder);
+
+        switch (pip_event.type)
+        {
+            case PIPELINE_EVENT_PARSER_STARTED:
+                decoder->wg_stream = pip_event.u.parser_started.stream;
+                break;
+            case PIPELINE_EVENT_READ_REQUEST:
+                LeaveCriticalSection(&decoder->cs);
+                return MF_E_TRANSFORM_NEED_MORE_INPUT;
+            default:
+                assert(0);
+        }
+    }
+
+    if (wg_parser_stream_drain(decoder->wg_stream))
+    {
+        /* this would be unexpected, as we should get the EOS-event when a drain command completes. */
+        assert (!decoder->draining);
+
+        LeaveCriticalSection(&decoder->cs);
+        return MF_E_TRANSFORM_NEED_MORE_INPUT;
+    }
+
+    if (!wg_parser_stream_get_buffer(decoder->wg_stream, &wg_buffer))
+    {
+        if (!decoder->draining)
+        {
+            LeaveCriticalSection(&decoder->cs);
+            WARN("Received EOS event while not draining\n");
+            return E_FAIL;
+        }
+        decoder->draining = FALSE;
+        LeaveCriticalSection(&decoder->cs);
+        return MF_E_TRANSFORM_NEED_MORE_INPUT;
+    }
+
+    if (relevant_buffer->pSample)
+    {
+        if (FAILED(hr = IMFSample_ConvertToContiguousBuffer(relevant_buffer->pSample, &buffer)))
+        {
+            ERR("Failed to get buffer from sample, hr %#x.\n", hr);
+            LeaveCriticalSection(&decoder->cs);
+            return hr;
+        }
+    }
+    else
+    {
+        if (FAILED(hr = MFCreateMemoryBuffer(wg_buffer.size, &buffer)))
+        {
+            ERR("Failed to create buffer, hr %#x.\n", hr);
+            LeaveCriticalSection(&decoder->cs);
+            return hr;
+        }
+
+        if (FAILED(hr = MFCreateSample(&relevant_buffer->pSample)))
+        {
+            ERR("Failed to create sample, hr %#x.\n", hr);
+            LeaveCriticalSection(&decoder->cs);
+            IMFMediaBuffer_Release(buffer);
+            return hr;
+        }
+
+        if (FAILED(hr = IMFSample_AddBuffer(relevant_buffer->pSample, buffer)))
+        {
+            ERR("Failed to add buffer, hr %#x.\n", hr);
+            goto out;
+        }
+    }
+
+    if (FAILED(hr = IMFMediaBuffer_GetMaxLength(buffer, &buffer_len)))
+    {
+        ERR("Failed to get buffer size, hr %#x.\n", hr);
+        goto out;
+    }
+
+    if (buffer_len < wg_buffer.size)
+    {
+        WARN("Client's buffer is smaller (%u bytes) than the output sample (%u bytes)\n",
+            buffer_len, wg_buffer.size);
+
+        if (FAILED(hr = IMFMediaBuffer_SetCurrentLength(buffer, buffer_len)))
+        {
+            ERR("Failed to set size, hr %#x.\n", hr);
+            goto out;
+        }
+    }
+    else if (FAILED(hr = IMFMediaBuffer_SetCurrentLength(buffer, wg_buffer.size)))
+    {
+        ERR("Failed to set size, hr %#x.\n", hr);
+        goto out;
+    }
+
+
+    if (FAILED(hr = IMFMediaBuffer_Lock(buffer, &data, NULL, NULL)))
+    {
+        ERR("Failed to lock buffer, hr %#x.\n", hr);
+        goto out;
+    }
+
+    if (!wg_parser_stream_copy_buffer(decoder->wg_stream, data, 0, min(buffer_len, wg_buffer.size)))
+    {
+        hr = E_FAIL;
+        goto out;
+    }
+
+    if (FAILED(hr = IMFMediaBuffer_Unlock(buffer)))
+    {
+        ERR("Failed to unlock buffer, hr %#x.\n", hr);
+        goto out;
+    }
+
+    if (FAILED(hr = IMFSample_SetSampleTime(relevant_buffer->pSample, wg_buffer.pts)))
+    {
+        ERR("Failed to set sample time, hr %#x.\n", hr);
+        goto out;
+    }
+
+    if (FAILED(hr = IMFSample_SetSampleDuration(relevant_buffer->pSample, wg_buffer.duration)))
+    {
+        ERR("Failed to set sample duration, hr %#x.\n", hr);
+        goto out;
+    }
+
+    relevant_buffer->dwStatus = 0;
+    relevant_buffer->pEvents = NULL;
+    *status = 0;
+
+    out:
+    if (SUCCEEDED(hr))
+        wg_parser_stream_release_buffer(decoder->wg_stream);
+    LeaveCriticalSection(&decoder->cs);
+
+    if (FAILED(hr))
+    {
+        IMFSample_Release(relevant_buffer->pSample);
+        relevant_buffer->pSample = NULL;
+    }
+
+    IMFMediaBuffer_Release(buffer);
+
+    return hr;
+}
+
+static const IMFTransformVtbl mf_decoder_vtbl =
+{
+    mf_decoder_QueryInterface,
+    mf_decoder_AddRef,
+    mf_decoder_Release,
+    mf_decoder_GetStreamLimits,
+    mf_decoder_GetStreamCount,
+    mf_decoder_GetStreamIDs,
+    mf_decoder_GetInputStreamInfo,
+    mf_decoder_GetOutputStreamInfo,
+    mf_decoder_GetAttributes,
+    mf_decoder_GetInputStreamAttributes,
+    mf_decoder_GetOutputStreamAttributes,
+    mf_decoder_DeleteInputStream,
+    mf_decoder_AddInputStreams,
+    mf_decoder_GetInputAvailableType,
+    mf_decoder_GetOutputAvailableType,
+    mf_decoder_SetInputType,
+    mf_decoder_SetOutputType,
+    mf_decoder_GetInputCurrentType,
+    mf_decoder_GetOutputCurrentType,
+    mf_decoder_GetInputStatus,
+    mf_decoder_GetOutputStatus,
+    mf_decoder_SetOutputBounds,
+    mf_decoder_ProcessEvent,
+    mf_decoder_ProcessMessage,
+    mf_decoder_ProcessInput,
+    mf_decoder_ProcessOutput,
+};
+
+HRESULT decode_transform_create(REFIID riid, void **obj, enum decoder_type type)
+{
+    struct mf_decoder *object;
+    struct wg_parser *parser;
+
+    TRACE("%s, %p %u.\n", debugstr_guid(riid), obj, type);
+
+    if (!(object = heap_alloc_zero(sizeof(*object))))
+        return E_OUTOFMEMORY;
+
+    object->IMFTransform_iface.lpVtbl = &mf_decoder_vtbl;
+    object->refcount = 1;
+
+    object->type = type;
+    object->video = decoder_descs[type].major_type == &MFMediaType_Video;
+
+    InitializeCriticalSection(&object->cs);
+    InitializeCriticalSection(&object->help_cs);
+    InitializeCriticalSection(&object->event_cs);
+    InitializeConditionVariable(&object->help_cv);
+    InitializeConditionVariable(&object->event_cv);
+
+    if (!(parser = wg_parser_create(WG_PARSER_DECODEBIN, TRUE)))
+    {
+        ERR("Failed to create Decoder MFT type %u: Unspecified GStreamer error\n", type);
+        IMFTransform_Release(&object->IMFTransform_iface);
+        return E_OUTOFMEMORY;
+    }
+    object->wg_parser = parser;
+
+    object->helper_thread = CreateThread(NULL, 0, helper_thread_func, object, 0, NULL);
+    object->read_thread = CreateThread(NULL, 0, read_thread_func, object, 0, NULL);
+
+    *obj = &object->IMFTransform_iface;
+    return S_OK;
+}
diff --git a/dlls/winegstreamer/gst_private.h b/dlls/winegstreamer/gst_private.h
index f5da807a2ab..c6b256b4fdd 100644
--- wine/dlls/winegstreamer/gst_private.h
+++ wine/dlls/winegstreamer/gst_private.h
@@ -39,7 +39,7 @@
 
 #include "unixlib.h"
 
-bool array_reserve(void **elements, size_t *capacity, size_t count, size_t size);
+bool array_reserve(void **elements, size_t *capacity, size_t count, size_t size) DECLSPEC_HIDDEN;
 
 static inline const char *debugstr_time(REFERENCE_TIME time)
 {
@@ -64,67 +64,78 @@ static inline const char *debugstr_time(REFERENCE_TIME time)
 
 #define MEDIATIME_FROM_BYTES(x) ((LONGLONG)(x) * 10000000)
 
-struct wg_parser *wg_parser_create(enum wg_parser_type type, bool unlimited_buffering);
-void wg_parser_destroy(struct wg_parser *parser);
+struct wg_parser *wg_parser_create(enum wg_parser_type type, bool unlimited_buffering) DECLSPEC_HIDDEN;
+void wg_parser_destroy(struct wg_parser *parser) DECLSPEC_HIDDEN;
 
-HRESULT wg_parser_connect(struct wg_parser *parser, uint64_t file_size);
-void wg_parser_disconnect(struct wg_parser *parser);
+HRESULT wg_parser_connect(struct wg_parser *parser, uint64_t file_size) DECLSPEC_HIDDEN;
+HRESULT wg_parser_connect_unseekable(struct wg_parser *parser, const struct wg_format *in_format,
+            uint32_t stream_count, const struct wg_format *out_formats, const struct wg_rect *apertures) DECLSPEC_HIDDEN;
+void wg_parser_disconnect(struct wg_parser *parser) DECLSPEC_HIDDEN;
 
-bool wg_parser_get_next_read_offset(struct wg_parser *parser, uint64_t *offset, uint32_t *size);
-void wg_parser_push_data(struct wg_parser *parser, const void *data, uint32_t size);
+bool wg_parser_get_next_read_offset(struct wg_parser *parser, uint64_t *offset, uint32_t *size) DECLSPEC_HIDDEN;
+void wg_parser_push_data(struct wg_parser *parser, enum wg_read_result result, const void *data, uint32_t size) DECLSPEC_HIDDEN;
 
-uint32_t wg_parser_get_stream_count(struct wg_parser *parser);
-struct wg_parser_stream *wg_parser_get_stream(struct wg_parser *parser, uint32_t index);
+uint32_t wg_parser_get_stream_count(struct wg_parser *parser) DECLSPEC_HIDDEN;
+struct wg_parser_stream *wg_parser_get_stream(struct wg_parser *parser, uint32_t index) DECLSPEC_HIDDEN;
 
-void wg_parser_stream_get_preferred_format(struct wg_parser_stream *stream, struct wg_format *format);
-void wg_parser_stream_enable(struct wg_parser_stream *stream, const struct wg_format *format);
-void wg_parser_stream_disable(struct wg_parser_stream *stream);
+void wg_parser_stream_get_preferred_format(struct wg_parser_stream *stream, struct wg_format *format) DECLSPEC_HIDDEN;
+void wg_parser_stream_enable(struct wg_parser_stream *stream, const struct wg_format *format, const struct wg_rect *aperture, uint32_t flags) DECLSPEC_HIDDEN;
+void wg_parser_stream_disable(struct wg_parser_stream *stream) DECLSPEC_HIDDEN;
 
-bool wg_parser_stream_get_buffer(struct wg_parser_stream *stream, struct wg_parser_buffer *buffer);
+bool wg_parser_stream_get_buffer(struct wg_parser_stream *stream, struct wg_parser_buffer *buffer) DECLSPEC_HIDDEN;
 bool wg_parser_stream_copy_buffer(struct wg_parser_stream *stream,
-        void *data, uint32_t offset, uint32_t size);
-void wg_parser_stream_release_buffer(struct wg_parser_stream *stream);
+        void *data, uint32_t offset, uint32_t size) DECLSPEC_HIDDEN;
+void wg_parser_stream_release_buffer(struct wg_parser_stream *stream) DECLSPEC_HIDDEN;
 void wg_parser_stream_notify_qos(struct wg_parser_stream *stream,
-        bool underflow, double proportion, int64_t diff, uint64_t timestamp);
+        bool underflow, double proportion, int64_t diff, uint64_t timestamp) DECLSPEC_HIDDEN;
 
 /* Returns the duration in 100-nanosecond units. */
-uint64_t wg_parser_stream_get_duration(struct wg_parser_stream *stream);
+uint64_t wg_parser_stream_get_duration(struct wg_parser_stream *stream) DECLSPEC_HIDDEN;
+bool wg_parser_stream_get_language(struct wg_parser_stream *stream, char *buffer, uint32_t size) DECLSPEC_HIDDEN;
 /* start_pos and stop_pos are in 100-nanosecond units. */
 void wg_parser_stream_seek(struct wg_parser_stream *stream, double rate,
-        uint64_t start_pos, uint64_t stop_pos, DWORD start_flags, DWORD stop_flags);
+        uint64_t start_pos, uint64_t stop_pos, DWORD start_flags, DWORD stop_flags) DECLSPEC_HIDDEN;
+bool wg_parser_stream_drain(struct wg_parser_stream *stream) DECLSPEC_HIDDEN;
 
-struct wg_transform *wg_transform_create(const struct wg_format *input_format,
-        const struct wg_format *output_format);
-void wg_transform_destroy(struct wg_transform *transform);
-HRESULT wg_transform_push_data(struct wg_transform *transform, struct wg_sample *sample);
-HRESULT wg_transform_read_data(struct wg_transform *transform, struct wg_sample *sample);
+struct wg_transform *wg_transform_create(const struct wg_encoded_format *input_format,
+                const struct wg_format *output_format) DECLSPEC_HIDDEN;
+void wg_transform_destroy(struct wg_transform *transform) DECLSPEC_HIDDEN;
+HRESULT wg_transform_push_data(struct wg_transform *transform, const void *data, uint32_t size) DECLSPEC_HIDDEN;
+HRESULT wg_transform_read_data(struct wg_transform *transform, struct wg_sample *sample) DECLSPEC_HIDDEN;
 
 unsigned int wg_format_get_max_size(const struct wg_format *format);
 
-HRESULT avi_splitter_create(IUnknown *outer, IUnknown **out);
-HRESULT decodebin_parser_create(IUnknown *outer, IUnknown **out);
-HRESULT mpeg_splitter_create(IUnknown *outer, IUnknown **out);
-HRESULT wave_parser_create(IUnknown *outer, IUnknown **out);
-HRESULT wma_decoder_create(IUnknown *outer, IUnknown **out);
+HRESULT avi_splitter_create(IUnknown *outer, IUnknown **out) DECLSPEC_HIDDEN;
+HRESULT decodebin_parser_create(IUnknown *outer, IUnknown **out) DECLSPEC_HIDDEN;
+HRESULT mpeg_splitter_create(IUnknown *outer, IUnknown **out) DECLSPEC_HIDDEN;
+HRESULT wave_parser_create(IUnknown *outer, IUnknown **out) DECLSPEC_HIDDEN;
+HRESULT wma_decoder_create(IUnknown *outer, IUnknown **out) DECLSPEC_HIDDEN;
 
 bool amt_from_wg_format(AM_MEDIA_TYPE *mt, const struct wg_format *format, bool wm);
 bool amt_to_wg_format(const AM_MEDIA_TYPE *mt, struct wg_format *format);
 
-BOOL init_gstreamer(void);
+BOOL init_gstreamer(void) DECLSPEC_HIDDEN;
 
-extern HRESULT mfplat_get_class_object(REFCLSID rclsid, REFIID riid, void **obj);
-extern HRESULT mfplat_DllRegisterServer(void);
+extern HRESULT mfplat_get_class_object(REFCLSID rclsid, REFIID riid, void **obj) DECLSPEC_HIDDEN;
+extern HRESULT mfplat_DllRegisterServer(void) DECLSPEC_HIDDEN;
 
-IMFMediaType *mf_media_type_from_wg_format(const struct wg_format *format);
-void mf_media_type_to_wg_format(IMFMediaType *type, struct wg_format *format);
+IMFMediaType *mf_media_type_from_wg_format(const struct wg_format *format) DECLSPEC_HIDDEN;
+void mf_media_type_to_wg_format(IMFMediaType *type, struct wg_format *format) DECLSPEC_HIDDEN;
+void mf_media_type_to_wg_encoded_format(IMFMediaType *type, struct wg_encoded_format *format) DECLSPEC_HIDDEN;
 
-HRESULT mf_create_wg_sample(IMFSample *sample, struct wg_sample **out);
-void mf_destroy_wg_sample(struct wg_sample *wg_sample);
+HRESULT winegstreamer_stream_handler_create(REFIID riid, void **obj) DECLSPEC_HIDDEN;
 
-HRESULT winegstreamer_stream_handler_create(REFIID riid, void **obj);
+HRESULT aac_decoder_create(REFIID riid, void **ret) DECLSPEC_HIDDEN;
+HRESULT h264_decoder_create(REFIID riid, void **ret) DECLSPEC_HIDDEN;
+HRESULT audio_converter_create(REFIID riid, void **ret) DECLSPEC_HIDDEN;
+HRESULT color_converter_create(REFIID riid, void **ret) DECLSPEC_HIDDEN;
 
-HRESULT h264_decoder_create(REFIID riid, void **ret);
-HRESULT audio_converter_create(REFIID riid, void **ret);
+enum decoder_type
+{
+    DECODER_TYPE_H264,
+    DECODER_TYPE_AAC,
+};
+HRESULT decode_transform_create(REFIID riid, void **obj, enum decoder_type) DECLSPEC_HIDDEN;
 
 struct wm_stream
 {
diff --git a/dlls/winegstreamer/h264_decoder.c b/dlls/winegstreamer/h264_decoder.c
index 8bfa15529db..f6a4d47188f 100644
--- wine/dlls/winegstreamer/h264_decoder.c
+++ wine/dlls/winegstreamer/h264_decoder.c
@@ -23,17 +23,18 @@
 #include "mferror.h"
 #include "mfobjects.h"
 #include "mftransform.h"
+#include "wmcodecdsp.h"
 
 #include "wine/debug.h"
+#include "wine/heap.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(mfplat);
 
-static const GUID *const h264_decoder_input_types[] =
+static const GUID *h264_decoder_input_types[] =
 {
     &MFVideoFormat_H264,
-    &MFVideoFormat_H264_ES,
 };
-static const GUID *const h264_decoder_output_types[] =
+static const GUID *h264_decoder_output_types[] =
 {
     &MFVideoFormat_NV12,
     &MFVideoFormat_YV12,
@@ -50,6 +51,8 @@ struct h264_decoder
     IMFMediaType *output_type;
 
     struct wg_transform *wg_transform;
+    struct wg_format wg_format;
+    ULONGLONG last_pts;
 };
 
 static struct h264_decoder *impl_from_IMFTransform(IMFTransform *iface)
@@ -59,77 +62,88 @@ static struct h264_decoder *impl_from_IMFTransform(IMFTransform *iface)
 
 static HRESULT try_create_wg_transform(struct h264_decoder *decoder)
 {
-    struct wg_format input_format;
+    struct wg_encoded_format input_format;
     struct wg_format output_format;
 
     if (decoder->wg_transform)
         wg_transform_destroy(decoder->wg_transform);
-    decoder->wg_transform = NULL;
 
-    mf_media_type_to_wg_format(decoder->input_type, &input_format);
-    if (input_format.major_type == WG_MAJOR_TYPE_UNKNOWN)
+    mf_media_type_to_wg_encoded_format(decoder->input_type, &input_format);
+    if (input_format.encoded_type == WG_ENCODED_TYPE_UNKNOWN)
         return MF_E_INVALIDMEDIATYPE;
 
     mf_media_type_to_wg_format(decoder->output_type, &output_format);
     if (output_format.major_type == WG_MAJOR_TYPE_UNKNOWN)
         return MF_E_INVALIDMEDIATYPE;
 
-    if (!(decoder->wg_transform = wg_transform_create(&input_format, &output_format)))
-        return E_FAIL;
+    decoder->last_pts = 0;
+    decoder->wg_transform = wg_transform_create(&input_format, &output_format);
+    if (decoder->wg_transform)
+        return S_OK;
 
-    return S_OK;
+    WARN("Failed to create H264 wg_transform.\n");
+    return E_FAIL;
 }
 
 static HRESULT fill_output_media_type(IMFMediaType *media_type, IMFMediaType *default_type)
 {
     UINT32 value, width, height;
-    UINT64 ratio;
+    MFVideoArea aperture = {0};
+    UINT64 value64;
     GUID subtype;
     HRESULT hr;
 
     if (FAILED(hr = IMFMediaType_GetGUID(media_type, &MF_MT_SUBTYPE, &subtype)))
         return hr;
 
-    if (FAILED(hr = IMFMediaType_GetUINT64(media_type, &MF_MT_FRAME_SIZE, &ratio)))
+    if (FAILED(hr = IMFMediaType_GetUINT64(media_type, &MF_MT_FRAME_SIZE, &value64)))
     {
-        if (!default_type || FAILED(hr = IMFMediaType_GetUINT64(default_type, &MF_MT_FRAME_SIZE, &ratio)))
-            ratio = (UINT64)1920 << 32 | 1080;
-        if (FAILED(hr = IMFMediaType_SetUINT64(media_type, &MF_MT_FRAME_SIZE, ratio)))
+        if (!default_type || FAILED(hr = IMFMediaType_GetUINT64(default_type, &MF_MT_FRAME_SIZE, &value64)))
+            value64 = (UINT64)1920 << 32 | 1080;
+        if (FAILED(hr = IMFMediaType_SetUINT64(media_type, &MF_MT_FRAME_SIZE, value64)))
             return hr;
     }
-    width = ratio >> 32;
-    height = ratio;
+    width = value64 >> 32;
+    height = value64;
 
     if (FAILED(hr = IMFMediaType_GetItem(media_type, &MF_MT_FRAME_RATE, NULL)))
     {
-        if (!default_type || FAILED(hr = IMFMediaType_GetUINT64(default_type, &MF_MT_FRAME_RATE, &ratio)))
-            ratio = (UINT64)30000 << 32 | 1001;
-        if (FAILED(hr = IMFMediaType_SetUINT64(media_type, &MF_MT_FRAME_RATE, ratio)))
+        if (!default_type || FAILED(hr = IMFMediaType_GetUINT64(default_type, &MF_MT_FRAME_RATE, &value64)))
+            value64 = (UINT64)30000 << 32 | 1001;
+        if (FAILED(hr = IMFMediaType_SetUINT64(media_type, &MF_MT_FRAME_RATE, value64)))
             return hr;
     }
 
     if (FAILED(hr = IMFMediaType_GetItem(media_type, &MF_MT_PIXEL_ASPECT_RATIO, NULL)))
     {
-        if (!default_type || FAILED(hr = IMFMediaType_GetUINT64(default_type, &MF_MT_PIXEL_ASPECT_RATIO, &ratio)))
-            ratio = (UINT64)1 << 32 | 1;
-        if (FAILED(hr = IMFMediaType_SetUINT64(media_type, &MF_MT_PIXEL_ASPECT_RATIO, ratio)))
+        if (!default_type || FAILED(hr = IMFMediaType_GetUINT64(default_type, &MF_MT_PIXEL_ASPECT_RATIO, &value64)))
+            value64 = (UINT64)1 << 32 | 1;
+        if (FAILED(hr = IMFMediaType_SetUINT64(media_type, &MF_MT_PIXEL_ASPECT_RATIO, value64)))
             return hr;
     }
 
     if (FAILED(hr = IMFMediaType_GetItem(media_type, &MF_MT_SAMPLE_SIZE, NULL)))
     {
-        if ((!default_type || FAILED(hr = IMFMediaType_GetUINT32(default_type, &MF_MT_SAMPLE_SIZE, &value))) &&
-                FAILED(hr = MFCalculateImageSize(&subtype, width, height, &value)))
-            return hr;
+        if (!default_type || FAILED(hr = IMFMediaType_GetUINT32(default_type, &MF_MT_SAMPLE_SIZE, &value)))
+        {
+            if (IsEqualGUID(&subtype, &MFVideoFormat_YUY2))
+                value = width * height * 2;
+            else
+                value = width * height * 3 / 2;
+        }
         if (FAILED(hr = IMFMediaType_SetUINT32(media_type, &MF_MT_SAMPLE_SIZE, value)))
             return hr;
     }
 
     if (FAILED(hr = IMFMediaType_GetItem(media_type, &MF_MT_DEFAULT_STRIDE, NULL)))
     {
-        if ((!default_type || FAILED(hr = IMFMediaType_GetUINT32(default_type, &MF_MT_DEFAULT_STRIDE, &value))) &&
-                FAILED(hr = MFGetStrideForBitmapInfoHeader(subtype.Data1, width, (LONG *)&value)))
-            return hr;
+        if (!default_type || FAILED(hr = IMFMediaType_GetUINT32(default_type, &MF_MT_DEFAULT_STRIDE, &value)))
+        {
+            if (IsEqualGUID(&subtype, &MFVideoFormat_YUY2))
+                value = width * 2;
+            else
+                value = width;
+        }
         if (FAILED(hr = IMFMediaType_SetUINT32(media_type, &MF_MT_DEFAULT_STRIDE, value)))
             return hr;
     }
@@ -166,17 +180,27 @@ static HRESULT fill_output_media_type(IMFMediaType *media_type, IMFMediaType *de
             return hr;
     }
 
+    if (FAILED(hr = IMFMediaType_GetItem(media_type, &MF_MT_MINIMUM_DISPLAY_APERTURE, NULL)))
+    {
+        if (default_type && SUCCEEDED(hr = IMFMediaType_GetBlob(default_type, &MF_MT_MINIMUM_DISPLAY_APERTURE,
+                (BYTE *)&aperture, sizeof(aperture), NULL)))
+        {
+            if (FAILED(hr = IMFMediaType_SetBlob(media_type, &MF_MT_MINIMUM_DISPLAY_APERTURE,
+                    (BYTE *)&aperture, sizeof(aperture))))
+                return hr;
+        }
+    }
+
     return S_OK;
 }
 
-static HRESULT WINAPI transform_QueryInterface(IMFTransform *iface, REFIID iid, void **out)
+static HRESULT WINAPI h264_decoder_QueryInterface(IMFTransform *iface, REFIID iid, void **out)
 {
     struct h264_decoder *decoder = impl_from_IMFTransform(iface);
 
     TRACE("iface %p, iid %s, out %p.\n", iface, debugstr_guid(iid), out);
 
-    if (IsEqualGUID(iid, &IID_IUnknown) ||
-            IsEqualGUID(iid, &IID_IMFTransform))
+    if (IsEqualGUID(iid, &IID_IUnknown) || IsEqualGUID(iid, &IID_IMFTransform))
         *out = &decoder->IMFTransform_iface;
     else
     {
@@ -189,22 +213,22 @@ static HRESULT WINAPI transform_QueryInterface(IMFTransform *iface, REFIID iid,
     return S_OK;
 }
 
-static ULONG WINAPI transform_AddRef(IMFTransform *iface)
+static ULONG WINAPI h264_decoder_AddRef(IMFTransform *iface)
 {
     struct h264_decoder *decoder = impl_from_IMFTransform(iface);
     ULONG refcount = InterlockedIncrement(&decoder->refcount);
 
-    TRACE("iface %p increasing refcount to %lu.\n", decoder, refcount);
+    TRACE("iface %p increasing refcount to %u.\n", decoder, refcount);
 
     return refcount;
 }
 
-static ULONG WINAPI transform_Release(IMFTransform *iface)
+static ULONG WINAPI h264_decoder_Release(IMFTransform *iface)
 {
     struct h264_decoder *decoder = impl_from_IMFTransform(iface);
     ULONG refcount = InterlockedDecrement(&decoder->refcount);
 
-    TRACE("iface %p decreasing refcount to %lu.\n", decoder, refcount);
+    TRACE("iface %p decreasing refcount to %u.\n", decoder, refcount);
 
     if (!refcount)
     {
@@ -220,33 +244,33 @@ static ULONG WINAPI transform_Release(IMFTransform *iface)
     return refcount;
 }
 
-static HRESULT WINAPI transform_GetStreamLimits(IMFTransform *iface, DWORD *input_minimum,
-        DWORD *input_maximum, DWORD *output_minimum, DWORD *output_maximum)
+static HRESULT WINAPI h264_decoder_GetStreamLimits(IMFTransform *iface, DWORD *input_minimum, DWORD *input_maximum,
+        DWORD *output_minimum, DWORD *output_maximum)
 {
     FIXME("iface %p, input_minimum %p, input_maximum %p, output_minimum %p, output_maximum %p stub!\n",
             iface, input_minimum, input_maximum, output_minimum, output_maximum);
     return E_NOTIMPL;
 }
 
-static HRESULT WINAPI transform_GetStreamCount(IMFTransform *iface, DWORD *inputs, DWORD *outputs)
+static HRESULT WINAPI h264_decoder_GetStreamCount(IMFTransform *iface, DWORD *inputs, DWORD *outputs)
 {
     FIXME("iface %p, inputs %p, outputs %p stub!\n", iface, inputs, outputs);
     return E_NOTIMPL;
 }
 
-static HRESULT WINAPI transform_GetStreamIDs(IMFTransform *iface, DWORD input_size,
-        DWORD *inputs, DWORD output_size, DWORD *outputs)
+static HRESULT WINAPI h264_decoder_GetStreamIDs(IMFTransform *iface, DWORD input_size, DWORD *inputs,
+        DWORD output_size, DWORD *outputs)
 {
-    FIXME("iface %p, input_size %lu, inputs %p, output_size %lu, outputs %p stub!\n", iface,
-            input_size, inputs, output_size, outputs);
+    FIXME("iface %p, input_size %u, inputs %p, output_size %u, outputs %p stub!\n",
+            iface, input_size, inputs, output_size, outputs);
     return E_NOTIMPL;
 }
 
-static HRESULT WINAPI transform_GetInputStreamInfo(IMFTransform *iface, DWORD id, MFT_INPUT_STREAM_INFO *info)
+static HRESULT WINAPI h264_decoder_GetInputStreamInfo(IMFTransform *iface, DWORD id, MFT_INPUT_STREAM_INFO *info)
 {
     struct h264_decoder *decoder = impl_from_IMFTransform(iface);
 
-    TRACE("iface %p, id %#lx, info %p.\n", iface, id, info);
+    TRACE("iface %p, id %u, info %p.\n", iface, id, info);
 
     if (!decoder->input_type)
         return MF_E_TRANSFORM_TYPE_NOT_SET;
@@ -260,70 +284,68 @@ static HRESULT WINAPI transform_GetInputStreamInfo(IMFTransform *iface, DWORD id
     return S_OK;
 }
 
-static HRESULT WINAPI transform_GetOutputStreamInfo(IMFTransform *iface, DWORD id, MFT_OUTPUT_STREAM_INFO *info)
+static HRESULT WINAPI h264_decoder_GetOutputStreamInfo(IMFTransform *iface, DWORD id, MFT_OUTPUT_STREAM_INFO *info)
 {
     struct h264_decoder *decoder = impl_from_IMFTransform(iface);
-    UINT32 sample_size;
-    UINT64 frame_size;
+    IMFMediaType *media_type;
+    HRESULT hr;
 
-    TRACE("iface %p, id %#lx, info %p.\n", iface, id, info);
+    TRACE("iface %p, id %u, info %p.\n", iface, id, info);
 
-    if (!decoder->output_type)
-        sample_size = 1920 * 1088 * 2;
-    else if (FAILED(IMFMediaType_GetUINT32(decoder->output_type, &MF_MT_SAMPLE_SIZE, &sample_size)))
-    {
-        if (FAILED(IMFMediaType_GetUINT64(decoder->output_type, &MF_MT_FRAME_SIZE, &frame_size)))
-            sample_size = 1920 * 1088 * 2;
-        else
-            sample_size = (frame_size >> 32) * (UINT32)frame_size * 2;
-    }
+    if (!decoder->input_type || !decoder->output_type)
+        return MF_E_TRANSFORM_TYPE_NOT_SET;
+
+    media_type = decoder->output_type;
 
     info->dwFlags = MFT_OUTPUT_STREAM_WHOLE_SAMPLES | MFT_OUTPUT_STREAM_SINGLE_SAMPLE_PER_BUFFER | MFT_OUTPUT_STREAM_FIXED_SAMPLE_SIZE;
-    info->cbSize = sample_size;
+    if (FAILED(hr = IMFMediaType_GetUINT32(media_type, &MF_MT_SAMPLE_SIZE, &info->cbSize)))
+        info->cbSize = 1920 * 1080 * 2;
     info->cbAlignment = 0;
 
     return S_OK;
 }
 
-static HRESULT WINAPI transform_GetAttributes(IMFTransform *iface, IMFAttributes **attributes)
+static HRESULT WINAPI h264_decoder_GetAttributes(IMFTransform *iface, IMFAttributes **attributes)
 {
     FIXME("iface %p, attributes %p stub!\n", iface, attributes);
+
     return MFCreateAttributes(attributes, 0);
 }
 
-static HRESULT WINAPI transform_GetInputStreamAttributes(IMFTransform *iface, DWORD id, IMFAttributes **attributes)
+static HRESULT WINAPI h264_decoder_GetInputStreamAttributes(IMFTransform *iface, DWORD id,
+        IMFAttributes **attributes)
 {
-    FIXME("iface %p, id %#lx, attributes %p stub!\n", iface, id, attributes);
+    FIXME("iface %p, id %u, attributes %p stub!\n", iface, id, attributes);
     return E_NOTIMPL;
 }
 
-static HRESULT WINAPI transform_GetOutputStreamAttributes(IMFTransform *iface, DWORD id,
+static HRESULT WINAPI h264_decoder_GetOutputStreamAttributes(IMFTransform *iface, DWORD id,
         IMFAttributes **attributes)
 {
-    FIXME("iface %p, id %#lx, attributes %p stub!\n", iface, id, attributes);
+    FIXME("iface %p, id %u, attributes %p stub!\n", iface, id, attributes);
     return E_NOTIMPL;
 }
 
-static HRESULT WINAPI transform_DeleteInputStream(IMFTransform *iface, DWORD id)
+static HRESULT WINAPI h264_decoder_DeleteInputStream(IMFTransform *iface, DWORD id)
 {
-    FIXME("iface %p, id %#lx stub!\n", iface, id);
+    FIXME("iface %p, id %u stub!\n", iface, id);
     return E_NOTIMPL;
 }
 
-static HRESULT WINAPI transform_AddInputStreams(IMFTransform *iface, DWORD streams, DWORD *ids)
+static HRESULT WINAPI h264_decoder_AddInputStreams(IMFTransform *iface, DWORD streams, DWORD *ids)
 {
-    FIXME("iface %p, streams %lu, ids %p stub!\n", iface, streams, ids);
+    FIXME("iface %p, streams %u, ids %p stub!\n", iface, streams, ids);
     return E_NOTIMPL;
 }
 
-static HRESULT WINAPI transform_GetInputAvailableType(IMFTransform *iface, DWORD id, DWORD index,
+static HRESULT WINAPI h264_decoder_GetInputAvailableType(IMFTransform *iface, DWORD id, DWORD index,
         IMFMediaType **type)
 {
     IMFMediaType *media_type;
     const GUID *subtype;
     HRESULT hr;
 
-    TRACE("iface %p, id %#lx, index %#lx, type %p.\n", iface, id, index, type);
+    TRACE("iface %p, id %u, index %u, type %p.\n", iface, id, index, type);
 
     *type = NULL;
 
@@ -342,15 +364,15 @@ static HRESULT WINAPI transform_GetInputAvailableType(IMFTransform *iface, DWORD
     return hr;
 }
 
-static HRESULT WINAPI transform_GetOutputAvailableType(IMFTransform *iface, DWORD id,
-        DWORD index, IMFMediaType **type)
+static HRESULT WINAPI h264_decoder_GetOutputAvailableType(IMFTransform *iface, DWORD id, DWORD index,
+        IMFMediaType **type)
 {
     struct h264_decoder *decoder = impl_from_IMFTransform(iface);
     IMFMediaType *media_type;
     const GUID *output_type;
     HRESULT hr;
 
-    TRACE("iface %p, id %#lx, index %#lx, type %p.\n", iface, id, index, type);
+    TRACE("iface %p, id %u, index %u, type %p.\n", iface, id, index, type);
 
     if (!decoder->input_type)
         return MF_E_TRANSFORM_TYPE_NOT_SET;
@@ -369,7 +391,7 @@ static HRESULT WINAPI transform_GetOutputAvailableType(IMFTransform *iface, DWOR
     if (FAILED(hr = IMFMediaType_SetGUID(media_type, &MF_MT_SUBTYPE, output_type)))
         goto done;
 
-    hr = fill_output_media_type(media_type, NULL);
+    hr = fill_output_media_type(media_type, decoder->output_type);
 
 done:
     if (SUCCEEDED(hr))
@@ -379,14 +401,14 @@ done:
     return hr;
 }
 
-static HRESULT WINAPI transform_SetInputType(IMFTransform *iface, DWORD id, IMFMediaType *type, DWORD flags)
+static HRESULT WINAPI h264_decoder_SetInputType(IMFTransform *iface, DWORD id, IMFMediaType *type, DWORD flags)
 {
     struct h264_decoder *decoder = impl_from_IMFTransform(iface);
     GUID major, subtype;
     HRESULT hr;
     ULONG i;
 
-    TRACE("iface %p, id %#lx, type %p, flags %#lx.\n", iface, id, type, flags);
+    TRACE("iface %p, id %u, type %p, flags %#x.\n", iface, id, type, flags);
 
     if (FAILED(hr = IMFMediaType_GetGUID(type, &MF_MT_MAJOR_TYPE, &major)) ||
             FAILED(hr = IMFMediaType_GetGUID(type, &MF_MT_SUBTYPE, &subtype)))
@@ -414,14 +436,15 @@ static HRESULT WINAPI transform_SetInputType(IMFTransform *iface, DWORD id, IMFM
     return S_OK;
 }
 
-static HRESULT WINAPI transform_SetOutputType(IMFTransform *iface, DWORD id, IMFMediaType *type, DWORD flags)
+static HRESULT WINAPI h264_decoder_SetOutputType(IMFTransform *iface, DWORD id, IMFMediaType *type, DWORD flags)
 {
     struct h264_decoder *decoder = impl_from_IMFTransform(iface);
     GUID major, subtype;
+    BOOL identical;
     HRESULT hr;
     ULONG i;
 
-    TRACE("iface %p, id %#lx, type %p, flags %#lx.\n", iface, id, type, flags);
+    TRACE("iface %p, id %u, type %p, flags %#x.\n", iface, id, type, flags);
 
     if (!decoder->input_type)
         return MF_E_TRANSFORM_TYPE_NOT_SET;
@@ -440,7 +463,13 @@ static HRESULT WINAPI transform_SetOutputType(IMFTransform *iface, DWORD id, IMF
         return MF_E_INVALIDMEDIATYPE;
 
     if (decoder->output_type)
+    {
+        if (SUCCEEDED(hr = IMFMediaType_Compare(decoder->output_type, (IMFAttributes *)type,
+                MF_ATTRIBUTES_MATCH_THEIR_ITEMS, &identical)) && identical)
+            return S_OK;
         IMFMediaType_Release(decoder->output_type);
+    }
+
     IMFMediaType_AddRef((decoder->output_type = type));
 
     if (FAILED(hr = try_create_wg_transform(decoder)))
@@ -452,56 +481,71 @@ static HRESULT WINAPI transform_SetOutputType(IMFTransform *iface, DWORD id, IMF
     return hr;
 }
 
-static HRESULT WINAPI transform_GetInputCurrentType(IMFTransform *iface, DWORD id, IMFMediaType **type)
+static HRESULT WINAPI h264_decoder_GetInputCurrentType(IMFTransform *iface, DWORD id, IMFMediaType **type)
 {
-    FIXME("iface %p, id %#lx, type %p stub!\n", iface, id, type);
+    FIXME("iface %p, id %u, type %p stub!\n", iface, id, type);
     return E_NOTIMPL;
 }
 
-static HRESULT WINAPI transform_GetOutputCurrentType(IMFTransform *iface, DWORD id, IMFMediaType **type)
+static HRESULT WINAPI h264_decoder_GetOutputCurrentType(IMFTransform *iface, DWORD id, IMFMediaType **type)
 {
-    FIXME("iface %p, id %#lx, type %p stub!\n", iface, id, type);
+    FIXME("iface %p, id %u, type %p stub!\n", iface, id, type);
     return E_NOTIMPL;
 }
 
-static HRESULT WINAPI transform_GetInputStatus(IMFTransform *iface, DWORD id, DWORD *flags)
+static HRESULT WINAPI h264_decoder_GetInputStatus(IMFTransform *iface, DWORD id, DWORD *flags)
 {
-    FIXME("iface %p, id %#lx, flags %p stub!\n", iface, id, flags);
+    FIXME("iface %p, id %u, flags %p stub!\n", iface, id, flags);
     return E_NOTIMPL;
 }
 
-static HRESULT WINAPI transform_GetOutputStatus(IMFTransform *iface, DWORD *flags)
+static HRESULT WINAPI h264_decoder_GetOutputStatus(IMFTransform *iface, DWORD *flags)
 {
     FIXME("iface %p, flags %p stub!\n", iface, flags);
     return E_NOTIMPL;
 }
 
-static HRESULT WINAPI transform_SetOutputBounds(IMFTransform *iface, LONGLONG lower, LONGLONG upper)
+static HRESULT WINAPI h264_decoder_SetOutputBounds(IMFTransform *iface, LONGLONG lower, LONGLONG upper)
 {
-    FIXME("iface %p, lower %I64d, upper %I64d stub!\n", iface, lower, upper);
+    FIXME("iface %p, lower %s, upper %s stub!\n", iface,
+            wine_dbgstr_longlong(lower), wine_dbgstr_longlong(upper));
     return E_NOTIMPL;
 }
 
-static HRESULT WINAPI transform_ProcessEvent(IMFTransform *iface, DWORD id, IMFMediaEvent *event)
+static HRESULT WINAPI h264_decoder_ProcessEvent(IMFTransform *iface, DWORD id, IMFMediaEvent *event)
 {
-    FIXME("iface %p, id %#lx, event %p stub!\n", iface, id, event);
+    FIXME("iface %p, id %u, event %p stub!\n", iface, id, event);
     return E_NOTIMPL;
 }
 
-static HRESULT WINAPI transform_ProcessMessage(IMFTransform *iface, MFT_MESSAGE_TYPE message, ULONG_PTR param)
+static HRESULT WINAPI h264_decoder_ProcessMessage(IMFTransform *iface, MFT_MESSAGE_TYPE message, ULONG_PTR param)
 {
-    FIXME("iface %p, message %#x, param %Ix stub!\n", iface, message, param);
+    struct h264_decoder *decoder = impl_from_IMFTransform(iface);
+
+    FIXME("iface %p, message %#x, param %p stub!\n", iface, message, (void *)param);
+
+    switch (message)
+    {
+    case MFT_MESSAGE_NOTIFY_BEGIN_STREAMING:
+        memset(&decoder->wg_format, 0, sizeof(decoder->wg_format));
+        break;
+    default:
+        break;
+    }
+
     return S_OK;
 }
 
-static HRESULT WINAPI transform_ProcessInput(IMFTransform *iface, DWORD id, IMFSample *sample, DWORD flags)
+static HRESULT WINAPI h264_decoder_ProcessInput(IMFTransform *iface, DWORD id, IMFSample *sample, DWORD flags)
 {
     struct h264_decoder *decoder = impl_from_IMFTransform(iface);
-    struct wg_sample *wg_sample;
+    IMFMediaBuffer *media_buffer;
     MFT_INPUT_STREAM_INFO info;
+    UINT32 buffer_size;
+    BYTE *buffer;
     HRESULT hr;
 
-    TRACE("iface %p, id %#lx, sample %p, flags %#lx.\n", iface, id, sample, flags);
+    TRACE("iface %p, id %u, sample %p, flags %#x.\n", iface, id, sample, flags);
 
     if (FAILED(hr = IMFTransform_GetInputStreamInfo(iface, 0, &info)))
         return hr;
@@ -509,27 +553,41 @@ static HRESULT WINAPI transform_ProcessInput(IMFTransform *iface, DWORD id, IMFS
     if (!decoder->wg_transform)
         return MF_E_TRANSFORM_TYPE_NOT_SET;
 
-    if (FAILED(hr = mf_create_wg_sample(sample, &wg_sample)))
+    if (FAILED(hr = IMFSample_ConvertToContiguousBuffer(sample, &media_buffer)))
         return hr;
 
-    hr = wg_transform_push_data(decoder->wg_transform, wg_sample);
+    if (FAILED(hr = IMFMediaBuffer_Lock(media_buffer, &buffer, NULL, &buffer_size)))
+        goto done;
+
+    hr = wg_transform_push_data(decoder->wg_transform, buffer, buffer_size);
 
-    mf_destroy_wg_sample(wg_sample);
+    IMFMediaBuffer_Unlock(media_buffer);
+
+done:
+    IMFMediaBuffer_Release(media_buffer);
     return hr;
 }
 
-static HRESULT WINAPI transform_ProcessOutput(IMFTransform *iface, DWORD flags, DWORD count,
+static HRESULT WINAPI h264_decoder_ProcessOutput(IMFTransform *iface, DWORD flags, DWORD count,
         MFT_OUTPUT_DATA_BUFFER *samples, DWORD *status)
 {
     struct h264_decoder *decoder = impl_from_IMFTransform(iface);
+    struct wg_sample wg_sample = {0};
+    IMFMediaBuffer *media_buffer;
     MFT_OUTPUT_STREAM_INFO info;
-    struct wg_sample *wg_sample;
+    MFVideoArea aperture = {0};
+    IMFMediaType *media_type;
+    UINT32 align, offset;
+    UINT64 framerate;
     HRESULT hr;
 
-    TRACE("iface %p, flags %#lx, count %lu, samples %p, status %p.\n", iface, flags, count, samples, status);
+    TRACE("iface %p, flags %#x, count %u, samples %p, status %p.\n", iface, flags, count, samples, status);
 
-    if (count != 1)
-        return E_INVALIDARG;
+    if (count > 1)
+    {
+        FIXME("Not implemented count %u\n", count);
+        return E_NOTIMPL;
+    }
 
     if (FAILED(hr = IMFTransform_GetOutputStreamInfo(iface, 0, &info)))
         return hr;
@@ -539,48 +597,116 @@ static HRESULT WINAPI transform_ProcessOutput(IMFTransform *iface, DWORD flags,
 
     *status = 0;
     samples[0].dwStatus = 0;
-    if (!samples[0].pSample) return E_INVALIDARG;
+    if (!samples[0].pSample)
+    {
+        samples[0].dwStatus = MFT_OUTPUT_DATA_BUFFER_NO_SAMPLE;
+        return MF_E_TRANSFORM_NEED_MORE_INPUT;
+    }
 
-    if (FAILED(hr = mf_create_wg_sample(samples[0].pSample, &wg_sample)))
+    if (FAILED(hr = IMFSample_ConvertToContiguousBuffer(samples[0].pSample, &media_buffer)))
         return hr;
 
-    if (wg_sample->max_size < info.cbSize)
+    if (FAILED(hr = IMFMediaBuffer_Lock(media_buffer, &wg_sample.data, &wg_sample.size, NULL)))
+        goto done;
+
+    wg_sample.format = &decoder->wg_format;
+    if (wg_sample.size < info.cbSize)
         hr = MF_E_BUFFERTOOSMALL;
-    else
-        hr = wg_transform_read_data(decoder->wg_transform, wg_sample);
+    else if (SUCCEEDED(hr = wg_transform_read_data(decoder->wg_transform, &wg_sample)))
+    {
+        if (!(wg_sample.flags & (WG_SAMPLE_FLAG_HAS_PTS|WG_SAMPLE_FLAG_HAS_DURATION)))
+        {
+            IMFMediaType_GetUINT64(decoder->output_type, &MF_MT_FRAME_RATE, &framerate);
+            wg_sample.pts = decoder->last_pts;
+            wg_sample.duration = (UINT64)10000000 * (UINT32)framerate / (framerate >> 32);
+            wg_sample.flags |= (WG_SAMPLE_FLAG_HAS_PTS|WG_SAMPLE_FLAG_HAS_DURATION);
+            decoder->last_pts += wg_sample.duration;
+        }
+
+        if (wg_sample.flags & WG_SAMPLE_FLAG_HAS_PTS)
+            IMFSample_SetSampleTime(samples[0].pSample, wg_sample.pts);
+        if (wg_sample.flags & WG_SAMPLE_FLAG_HAS_DURATION)
+            IMFSample_SetSampleDuration(samples[0].pSample, wg_sample.duration);
+
+        if (decoder->wg_format.u.video.format == WG_VIDEO_FORMAT_NV12 &&
+                (align = decoder->wg_format.u.video.height & 15))
+        {
+            offset = decoder->wg_format.u.video.width * decoder->wg_format.u.video.height;
+            align = (16 - align) * decoder->wg_format.u.video.width;
+            memmove(wg_sample.data + offset + align, wg_sample.data + offset,
+                    wg_sample.size - offset);
+            wg_sample.size += align;
+        }
+
+        hr = IMFMediaBuffer_SetCurrentLength(media_buffer, wg_sample.size);
+    }
+    else if (hr == MF_E_TRANSFORM_STREAM_CHANGE)
+    {
+        media_type = mf_media_type_from_wg_format(&decoder->wg_format);
+        IMFMediaType_SetUINT32(media_type, &MF_MT_SAMPLE_SIZE, wg_sample.size);
+        IMFMediaType_DeleteItem(media_type, &MF_MT_FRAME_RATE);
+        IMFMediaType_DeleteItem(decoder->output_type, &MF_MT_DEFAULT_STRIDE);
+        fill_output_media_type(media_type, decoder->output_type);
+
+        if (decoder->wg_format.u.video.format == WG_VIDEO_FORMAT_NV12 &&
+                (align = decoder->wg_format.u.video.height & 15))
+        {
+            aperture.Area.cx = decoder->wg_format.u.video.width;
+            aperture.Area.cy = decoder->wg_format.u.video.height;
+            IMFMediaType_SetBlob(media_type, &MF_MT_MINIMUM_DISPLAY_APERTURE,
+                    (BYTE *)&aperture, sizeof(aperture));
+
+            aperture.Area.cy += 16 - align;
+            IMFMediaType_SetUINT64(media_type, &MF_MT_FRAME_SIZE,
+                    (UINT64)aperture.Area.cx << 32 | aperture.Area.cy);
+            IMFMediaType_SetUINT32(media_type, &MF_MT_SAMPLE_SIZE,
+                    aperture.Area.cx * aperture.Area.cy * 3 / 2);
+        }
 
-    mf_destroy_wg_sample(wg_sample);
+        IMFMediaType_Release(decoder->output_type);
+        decoder->output_type = media_type;
+
+        samples[0].dwStatus |= MFT_OUTPUT_DATA_BUFFER_FORMAT_CHANGE;
+        *status |= MFT_OUTPUT_DATA_BUFFER_FORMAT_CHANGE;
+    }
+
+    IMFMediaBuffer_Unlock(media_buffer);
+
+done:
+    if (FAILED(hr))
+        IMFMediaBuffer_SetCurrentLength(media_buffer, 0);
+    IMFMediaBuffer_Release(media_buffer);
     return hr;
 }
 
-static const IMFTransformVtbl transform_vtbl =
-{
-    transform_QueryInterface,
-    transform_AddRef,
-    transform_Release,
-    transform_GetStreamLimits,
-    transform_GetStreamCount,
-    transform_GetStreamIDs,
-    transform_GetInputStreamInfo,
-    transform_GetOutputStreamInfo,
-    transform_GetAttributes,
-    transform_GetInputStreamAttributes,
-    transform_GetOutputStreamAttributes,
-    transform_DeleteInputStream,
-    transform_AddInputStreams,
-    transform_GetInputAvailableType,
-    transform_GetOutputAvailableType,
-    transform_SetInputType,
-    transform_SetOutputType,
-    transform_GetInputCurrentType,
-    transform_GetOutputCurrentType,
-    transform_GetInputStatus,
-    transform_GetOutputStatus,
-    transform_SetOutputBounds,
-    transform_ProcessEvent,
-    transform_ProcessMessage,
-    transform_ProcessInput,
-    transform_ProcessOutput,
+static const IMFTransformVtbl h264_decoder_vtbl =
+{
+    h264_decoder_QueryInterface,
+    h264_decoder_AddRef,
+    h264_decoder_Release,
+    h264_decoder_GetStreamLimits,
+    h264_decoder_GetStreamCount,
+    h264_decoder_GetStreamIDs,
+    h264_decoder_GetInputStreamInfo,
+    h264_decoder_GetOutputStreamInfo,
+    h264_decoder_GetAttributes,
+    h264_decoder_GetInputStreamAttributes,
+    h264_decoder_GetOutputStreamAttributes,
+    h264_decoder_DeleteInputStream,
+    h264_decoder_AddInputStreams,
+    h264_decoder_GetInputAvailableType,
+    h264_decoder_GetOutputAvailableType,
+    h264_decoder_SetInputType,
+    h264_decoder_SetOutputType,
+    h264_decoder_GetInputCurrentType,
+    h264_decoder_GetOutputCurrentType,
+    h264_decoder_GetInputStatus,
+    h264_decoder_GetOutputStatus,
+    h264_decoder_SetOutputBounds,
+    h264_decoder_ProcessEvent,
+    h264_decoder_ProcessMessage,
+    h264_decoder_ProcessInput,
+    h264_decoder_ProcessOutput,
 };
 
 HRESULT h264_decoder_create(REFIID riid, void **ret)
@@ -592,7 +718,7 @@ HRESULT h264_decoder_create(REFIID riid, void **ret)
     if (!(decoder = calloc(1, sizeof(*decoder))))
         return E_OUTOFMEMORY;
 
-    decoder->IMFTransform_iface.lpVtbl = &transform_vtbl;
+    decoder->IMFTransform_iface.lpVtbl = &h264_decoder_vtbl;
     decoder->refcount = 1;
 
     *ret = &decoder->IMFTransform_iface;
diff --git a/dlls/winegstreamer/main.c b/dlls/winegstreamer/main.c
index d88a462d81e..219fde82dc6 100644
--- wine/dlls/winegstreamer/main.c
+++ wine/dlls/winegstreamer/main.c
@@ -25,9 +25,7 @@
 #include "gst_private.h"
 #include "winternl.h"
 #include "rpcproxy.h"
-#include "dmoreg.h"
 #include "gst_guids.h"
-#include "wmcodecdsp.h"
 
 static unixlib_handle_t unix_handle;
 
@@ -70,20 +68,13 @@ struct wg_parser *wg_parser_create(enum wg_parser_type type, bool unlimited_buff
         .unlimited_buffering = unlimited_buffering,
     };
 
-    TRACE("type %#x, unlimited_buffering %d.\n", type, unlimited_buffering);
-
     if (__wine_unix_call(unix_handle, unix_wg_parser_create, &params))
         return NULL;
-
-    TRACE("Returning parser %p.\n", params.parser);
-
     return params.parser;
 }
 
 void wg_parser_destroy(struct wg_parser *parser)
 {
-    TRACE("parser %p.\n", parser);
-
     __wine_unix_call(unix_handle, unix_wg_parser_destroy, parser);
 }
 
@@ -95,15 +86,26 @@ HRESULT wg_parser_connect(struct wg_parser *parser, uint64_t file_size)
         .file_size = file_size,
     };
 
-    TRACE("parser %p, file_size %I64u.\n", parser, file_size);
-
     return __wine_unix_call(unix_handle, unix_wg_parser_connect, &params);
 }
 
-void wg_parser_disconnect(struct wg_parser *parser)
+HRESULT wg_parser_connect_unseekable(struct wg_parser *parser, const struct wg_format *in_format,
+        uint32_t stream_count, const struct wg_format *out_formats, const struct wg_rect *apertures)
 {
-    TRACE("parser %p.\n", parser);
+    struct wg_parser_connect_unseekable_params params =
+    {
+        .parser = parser,
+        .in_format = in_format,
+        .stream_count = stream_count,
+        .out_formats = out_formats,
+        .apertures = apertures,
+    };
+
+    return __wine_unix_call(unix_handle, unix_wg_parser_connect_unseekable, &params);
+}
 
+void wg_parser_disconnect(struct wg_parser *parser)
+{
     __wine_unix_call(unix_handle, unix_wg_parser_disconnect, parser);
 }
 
@@ -114,8 +116,6 @@ bool wg_parser_get_next_read_offset(struct wg_parser *parser, uint64_t *offset,
         .parser = parser,
     };
 
-    TRACE("parser %p, offset %p, size %p.\n", parser, offset, size);
-
     if (__wine_unix_call(unix_handle, unix_wg_parser_get_next_read_offset, &params))
         return false;
     *offset = params.offset;
@@ -123,17 +123,16 @@ bool wg_parser_get_next_read_offset(struct wg_parser *parser, uint64_t *offset,
     return true;
 }
 
-void wg_parser_push_data(struct wg_parser *parser, const void *data, uint32_t size)
+void wg_parser_push_data(struct wg_parser *parser, enum wg_read_result result, const void *data, uint32_t size)
 {
     struct wg_parser_push_data_params params =
     {
         .parser = parser,
+        .result = result,
         .data = data,
         .size = size,
     };
 
-    TRACE("parser %p, data %p, size %u.\n", parser, data, size);
-
     __wine_unix_call(unix_handle, unix_wg_parser_push_data, &params);
 }
 
@@ -144,8 +143,6 @@ uint32_t wg_parser_get_stream_count(struct wg_parser *parser)
         .parser = parser,
     };
 
-    TRACE("parser %p.\n", parser);
-
     __wine_unix_call(unix_handle, unix_wg_parser_get_stream_count, &params);
     return params.count;
 }
@@ -158,11 +155,7 @@ struct wg_parser_stream *wg_parser_get_stream(struct wg_parser *parser, uint32_t
         .index = index,
     };
 
-    TRACE("parser %p, index %u.\n", parser, index);
-
     __wine_unix_call(unix_handle, unix_wg_parser_get_stream, &params);
-
-    TRACE("Returning stream %p.\n", params.stream);
     return params.stream;
 }
 
@@ -174,28 +167,24 @@ void wg_parser_stream_get_preferred_format(struct wg_parser_stream *stream, stru
         .format = format,
     };
 
-    TRACE("stream %p, format %p.\n", stream, format);
-
     __wine_unix_call(unix_handle, unix_wg_parser_stream_get_preferred_format, &params);
 }
 
-void wg_parser_stream_enable(struct wg_parser_stream *stream, const struct wg_format *format)
+void wg_parser_stream_enable(struct wg_parser_stream *stream, const struct wg_format *format, const struct wg_rect *aperture, uint32_t flags)
 {
     struct wg_parser_stream_enable_params params =
     {
         .stream = stream,
         .format = format,
+        .aperture = aperture,
+        .flags = flags,
     };
 
-    TRACE("stream %p, format %p.\n", stream, format);
-
     __wine_unix_call(unix_handle, unix_wg_parser_stream_enable, &params);
 }
 
 void wg_parser_stream_disable(struct wg_parser_stream *stream)
 {
-    TRACE("stream %p.\n", stream);
-
     __wine_unix_call(unix_handle, unix_wg_parser_stream_disable, stream);
 }
 
@@ -207,8 +196,6 @@ bool wg_parser_stream_get_buffer(struct wg_parser_stream *stream, struct wg_pars
         .buffer = buffer,
     };
 
-    TRACE("stream %p, buffer %p.\n", stream, buffer);
-
     return !__wine_unix_call(unix_handle, unix_wg_parser_stream_get_buffer, &params);
 }
 
@@ -223,15 +210,11 @@ bool wg_parser_stream_copy_buffer(struct wg_parser_stream *stream,
         .size = size,
     };
 
-    TRACE("stream %p, data %p, offset %u, size %u.\n", stream, data, offset, size);
-
     return !__wine_unix_call(unix_handle, unix_wg_parser_stream_copy_buffer, &params);
 }
 
 void wg_parser_stream_release_buffer(struct wg_parser_stream *stream)
 {
-    TRACE("stream %p.\n", stream);
-
     __wine_unix_call(unix_handle, unix_wg_parser_stream_release_buffer, stream);
 }
 
@@ -247,9 +230,6 @@ void wg_parser_stream_notify_qos(struct wg_parser_stream *stream,
         .timestamp = timestamp,
     };
 
-    TRACE("stream %p, underflow %d, proportion %.16e, diff %I64d, timestamp %I64u.\n",
-            stream, underflow, proportion, diff, timestamp);
-
     __wine_unix_call(unix_handle, unix_wg_parser_stream_notify_qos, &params);
 }
 
@@ -260,14 +240,22 @@ uint64_t wg_parser_stream_get_duration(struct wg_parser_stream *stream)
         .stream = stream,
     };
 
-    TRACE("stream %p.\n", stream);
-
     __wine_unix_call(unix_handle, unix_wg_parser_stream_get_duration, &params);
-
-    TRACE("Returning duration %I64u.\n", params.duration);
     return params.duration;
 }
 
+bool wg_parser_stream_get_language(struct wg_parser_stream *stream, char *buffer, uint32_t size)
+{
+    struct wg_parser_stream_get_language_params params =
+    {
+        .stream = stream,
+        .buffer = buffer,
+        .size = size,
+    };
+
+    return !__wine_unix_call(unix_handle, unix_wg_parser_stream_get_language, &params);
+}
+
 void wg_parser_stream_seek(struct wg_parser_stream *stream, double rate,
         uint64_t start_pos, uint64_t stop_pos, DWORD start_flags, DWORD stop_flags)
 {
@@ -281,13 +269,15 @@ void wg_parser_stream_seek(struct wg_parser_stream *stream, double rate,
         .stop_flags = stop_flags,
     };
 
-    TRACE("stream %p, rate %.16e, start_pos %I64u, stop_pos %I64u, start_flags %#lx, stop_flags %#lx.\n",
-            stream, rate, start_pos, stop_pos, start_flags, stop_flags);
-
     __wine_unix_call(unix_handle, unix_wg_parser_stream_seek, &params);
 }
 
-struct wg_transform *wg_transform_create(const struct wg_format *input_format,
+bool wg_parser_stream_drain(struct wg_parser_stream *stream)
+{
+    return !__wine_unix_call(unix_handle, unix_wg_parser_stream_drain, stream);
+}
+
+struct wg_transform *wg_transform_create(const struct wg_encoded_format *input_format,
         const struct wg_format *output_format)
 {
     struct wg_transform_create_params params =
@@ -296,37 +286,26 @@ struct wg_transform *wg_transform_create(const struct wg_format *input_format,
         .output_format = output_format,
     };
 
-    TRACE("input_format %p, output_format %p.\n", input_format, output_format);
-
     if (__wine_unix_call(unix_handle, unix_wg_transform_create, &params))
         return NULL;
-
-    TRACE("Returning transform %p.\n", params.transform);
     return params.transform;
 }
 
 void wg_transform_destroy(struct wg_transform *transform)
 {
-    TRACE("transform %p.\n", transform);
-
     __wine_unix_call(unix_handle, unix_wg_transform_destroy, transform);
 }
 
-HRESULT wg_transform_push_data(struct wg_transform *transform, struct wg_sample *sample)
+HRESULT wg_transform_push_data(struct wg_transform *transform, const void *data, uint32_t size)
 {
     struct wg_transform_push_data_params params =
     {
         .transform = transform,
-        .sample = sample,
+        .data = data,
+        .size = size,
     };
-    NTSTATUS status;
-
-    TRACE("transform %p, sample %p.\n", transform, sample);
-
-    if ((status = __wine_unix_call(unix_handle, unix_wg_transform_push_data, &params)))
-        return HRESULT_FROM_NT(status);
 
-    return params.result;
+    return __wine_unix_call(unix_handle, unix_wg_transform_push_data, &params);
 }
 
 HRESULT wg_transform_read_data(struct wg_transform *transform, struct wg_sample *sample)
@@ -336,14 +315,8 @@ HRESULT wg_transform_read_data(struct wg_transform *transform, struct wg_sample
         .transform = transform,
         .sample = sample,
     };
-    NTSTATUS status;
 
-    TRACE("transform %p, sample %p.\n", transform, sample);
-
-    if ((status = __wine_unix_call(unix_handle, unix_wg_transform_read_data, &params)))
-        return HRESULT_FROM_NT(status);
-
-    return params.result;
+    return __wine_unix_call(unix_handle, unix_wg_transform_read_data, &params);
 }
 
 BOOL WINAPI DllMain(HINSTANCE instance, DWORD reason, void *reserved)
@@ -619,24 +592,16 @@ static const REGFILTER2 reg_decodebin_parser =
 
 HRESULT WINAPI DllRegisterServer(void)
 {
-    DMO_PARTIAL_MEDIATYPE wma_decoder_output[2] =
-    {
-        {.type = MEDIATYPE_Audio, .subtype = MEDIASUBTYPE_PCM},
-        {.type = MEDIATYPE_Audio, .subtype = MEDIASUBTYPE_IEEE_FLOAT},
-    };
-    DMO_PARTIAL_MEDIATYPE wma_decoder_input[4] =
-    {
-        {.type = MEDIATYPE_Audio, .subtype = MEDIASUBTYPE_MSAUDIO1},
-        {.type = MEDIATYPE_Audio, .subtype = MEDIASUBTYPE_WMAUDIO2},
-        {.type = MEDIATYPE_Audio, .subtype = MEDIASUBTYPE_WMAUDIO3},
-        {.type = MEDIATYPE_Audio, .subtype = MEDIASUBTYPE_WMAUDIO_LOSSLESS},
-    };
-
     IFilterMapper2 *mapper;
     HRESULT hr;
 
     TRACE(".\n");
 
+    init_gstreamer();
+
+    if (FAILED(hr = mfplat_DllRegisterServer()))
+        return hr;
+
     if (FAILED(hr = __wine_register_resources()))
         return hr;
 
@@ -653,10 +618,6 @@ HRESULT WINAPI DllRegisterServer(void)
 
     IFilterMapper2_Release(mapper);
 
-    if (FAILED(hr = DMORegister(L"WMA Decoder DMO", &CLSID_WMADecMediaObject, &DMOCATEGORY_AUDIO_DECODER,
-            0, ARRAY_SIZE(wma_decoder_input), wma_decoder_input, ARRAY_SIZE(wma_decoder_output), wma_decoder_output)))
-        return hr;
-
     return mfplat_DllRegisterServer();
 }
 
@@ -680,9 +641,5 @@ HRESULT WINAPI DllUnregisterServer(void)
     IFilterMapper2_UnregisterFilter(mapper, NULL, NULL, &CLSID_WAVEParser);
 
     IFilterMapper2_Release(mapper);
-
-    if (FAILED(hr = DMOUnregister(&CLSID_WMADecMediaObject, &DMOCATEGORY_AUDIO_DECODER)))
-        return hr;
-
     return S_OK;
 }
diff --git a/dlls/winegstreamer/media_source.c b/dlls/winegstreamer/media_source.c
index f07b83f413e..82a6da1bcbf 100644
--- wine/dlls/winegstreamer/media_source.c
+++ wine/dlls/winegstreamer/media_source.c
@@ -105,7 +105,6 @@ struct media_source
         SOURCE_RUNNING,
         SOURCE_SHUTDOWN,
     } state;
-    float rate;
 
     HANDLE read_thread;
     bool read_thread_shutdown;
@@ -305,7 +304,7 @@ static void flush_token_queue(struct media_stream *stream, BOOL send)
                         &stream->parent_source->async_commands_callback, &command->IUnknown_iface);
             }
             if (FAILED(hr))
-                WARN("Could not enqueue sample request, hr %#lx\n", hr);
+                WARN("Could not enqueue sample request, hr %#x\n", hr);
         }
         else if (stream->token_queue[i])
             IUnknown_Release(stream->token_queue[i]);
@@ -358,15 +357,11 @@ static void start_pipeline(struct media_source *source, struct source_async_comm
             IMFMediaTypeHandler_GetCurrentMediaType(mth, &current_mt);
 
             mf_media_type_to_wg_format(current_mt, &format);
-            wg_parser_stream_enable(stream->wg_stream, &format);
+            wg_parser_stream_enable(stream->wg_stream, &format, NULL, 0);
 
             IMFMediaType_Release(current_mt);
             IMFMediaTypeHandler_Release(mth);
         }
-        else
-        {
-            wg_parser_stream_disable(stream->wg_stream);
-        }
 
         if (position->vt != VT_EMPTY)
             stream->eos = FALSE;
@@ -423,7 +418,10 @@ static void stop_pipeline(struct media_source *source)
     {
         struct media_stream *stream = source->streams[i];
         if (stream->state != STREAM_INACTIVE)
+        {
             IMFMediaEventQueue_QueueEventParamVar(stream->event_queue, MEStreamStopped, &GUID_NULL, S_OK, NULL);
+            wg_parser_stream_disable(stream->wg_stream);
+        }
     }
 
     IMFMediaEventQueue_QueueEventParamVar(source->event_queue, MESourceStopped, &GUID_NULL, S_OK, NULL);
@@ -460,32 +458,32 @@ static void send_buffer(struct media_stream *stream, const struct wg_parser_buff
 
     if (FAILED(hr = MFCreateSample(&sample)))
     {
-        ERR("Failed to create sample, hr %#lx.\n", hr);
+        ERR("Failed to create sample, hr %#x.\n", hr);
         return;
     }
 
     if (FAILED(hr = MFCreateMemoryBuffer(wg_buffer->size, &buffer)))
     {
-        ERR("Failed to create buffer, hr %#lx.\n", hr);
+        ERR("Failed to create buffer, hr %#x.\n", hr);
         IMFSample_Release(sample);
         return;
     }
 
     if (FAILED(hr = IMFSample_AddBuffer(sample, buffer)))
     {
-        ERR("Failed to add buffer, hr %#lx.\n", hr);
+        ERR("Failed to add buffer, hr %#x.\n", hr);
         goto out;
     }
 
     if (FAILED(hr = IMFMediaBuffer_SetCurrentLength(buffer, wg_buffer->size)))
     {
-        ERR("Failed to set size, hr %#lx.\n", hr);
+        ERR("Failed to set size, hr %#x.\n", hr);
         goto out;
     }
 
     if (FAILED(hr = IMFMediaBuffer_Lock(buffer, &data, NULL, NULL)))
     {
-        ERR("Failed to lock buffer, hr %#lx.\n", hr);
+        ERR("Failed to lock buffer, hr %#x.\n", hr);
         goto out;
     }
 
@@ -499,19 +497,19 @@ static void send_buffer(struct media_stream *stream, const struct wg_parser_buff
 
     if (FAILED(hr = IMFMediaBuffer_Unlock(buffer)))
     {
-        ERR("Failed to unlock buffer, hr %#lx.\n", hr);
+        ERR("Failed to unlock buffer, hr %#x.\n", hr);
         goto out;
     }
 
     if (FAILED(hr = IMFSample_SetSampleTime(sample, wg_buffer->pts)))
     {
-        ERR("Failed to set sample time, hr %#lx.\n", hr);
+        ERR("Failed to set sample time, hr %#x.\n", hr);
         goto out;
     }
 
     if (FAILED(hr = IMFSample_SetSampleDuration(sample, wg_buffer->duration)))
     {
-        ERR("Failed to set sample duration, hr %#lx.\n", hr);
+        ERR("Failed to set sample duration, hr %#x.\n", hr);
         goto out;
     }
 
@@ -626,7 +624,7 @@ static DWORD CALLBACK read_thread(void *arg)
          * an error when reading past the file size. */
         if (!size)
         {
-            wg_parser_push_data(source->wg_parser, data, 0);
+            wg_parser_push_data(source->wg_parser, WG_READ_SUCCESS, data, 0);
             continue;
         }
 
@@ -641,10 +639,10 @@ static DWORD CALLBACK read_thread(void *arg)
         if (SUCCEEDED(hr = IMFByteStream_SetCurrentPosition(byte_stream, offset)))
             hr = IMFByteStream_Read(byte_stream, data, size, &ret_size);
         if (FAILED(hr))
-            ERR("Failed to read %u bytes at offset %I64u, hr %#lx.\n", size, offset, hr);
+            ERR("Failed to read %u bytes at offset %I64u, hr %#x.\n", size, offset, hr);
         else if (ret_size != size)
-            ERR("Unexpected short read: requested %u bytes, got %lu.\n", size, ret_size);
-        wg_parser_push_data(source->wg_parser, SUCCEEDED(hr) ? data : NULL, ret_size);
+            ERR("Unexpected short read: requested %u bytes, got %u.\n", size, ret_size);
+        wg_parser_push_data(source->wg_parser, SUCCEEDED(hr) ? WG_READ_SUCCESS : WG_READ_FAILURE, data, ret_size);
     }
 
     free(data);
@@ -680,7 +678,7 @@ static ULONG WINAPI media_stream_AddRef(IMFMediaStream *iface)
     struct media_stream *stream = impl_from_IMFMediaStream(iface);
     ULONG ref = InterlockedIncrement(&stream->ref);
 
-    TRACE("%p, refcount %lu.\n", iface, ref);
+    TRACE("%p, refcount %u.\n", iface, ref);
 
     return ref;
 }
@@ -690,7 +688,7 @@ static ULONG WINAPI media_stream_Release(IMFMediaStream *iface)
     struct media_stream *stream = impl_from_IMFMediaStream(iface);
     ULONG ref = InterlockedDecrement(&stream->ref);
 
-    TRACE("%p, refcount %lu.\n", iface, ref);
+    TRACE("%p, refcount %u.\n", iface, ref);
 
     if (!ref)
     {
@@ -707,7 +705,7 @@ static HRESULT WINAPI media_stream_GetEvent(IMFMediaStream *iface, DWORD flags,
 {
     struct media_stream *stream = impl_from_IMFMediaStream(iface);
 
-    TRACE("%p, %#lx, %p.\n", iface, flags, event);
+    TRACE("%p, %#x, %p.\n", iface, flags, event);
 
     return IMFMediaEventQueue_GetEvent(stream->event_queue, flags, event);
 }
@@ -735,7 +733,7 @@ static HRESULT WINAPI media_stream_QueueEvent(IMFMediaStream *iface, MediaEventT
 {
     struct media_stream *stream = impl_from_IMFMediaStream(iface);
 
-    TRACE("%p, %lu, %s, %#lx, %p.\n", iface, event_type, debugstr_guid(ext_type), hr, value);
+    TRACE("%p, %d, %s, %#x, %p.\n", iface, event_type, debugstr_guid(ext_type), hr, value);
 
     return IMFMediaEventQueue_QueueEventParamVar(stream->event_queue, event_type, ext_type, hr, value);
 }
@@ -826,7 +824,7 @@ static HRESULT new_media_stream(struct media_source *source,
     struct media_stream *object = calloc(1, sizeof(*object));
     HRESULT hr;
 
-    TRACE("source %p, wg_stream %p, stream_id %lu.\n", source, wg_stream, stream_id);
+    TRACE("source %p, wg_stream %p, stream_id %u.\n", source, wg_stream, stream_id);
 
     object->IMFMediaStream_iface.lpVtbl = &media_stream_vtbl;
     object->ref = 1;
@@ -855,7 +853,7 @@ static HRESULT new_media_stream(struct media_source *source,
 static HRESULT media_stream_init_desc(struct media_stream *stream)
 {
     IMFMediaTypeHandler *type_handler = NULL;
-    IMFMediaType *stream_types[6];
+    IMFMediaType *stream_types[8];
     struct wg_format format;
     DWORD type_count = 0;
     unsigned int i;
@@ -874,6 +872,8 @@ static HRESULT media_stream_init_desc(struct media_stream *stream)
             &MFVideoFormat_YUY2,
             &MFVideoFormat_IYUV,
             &MFVideoFormat_I420,
+            &MFVideoFormat_ARGB32,
+            &MFVideoFormat_RGB32,
         };
 
         IMFMediaType *base_type = mf_media_type_from_wg_format(&format);
@@ -1092,9 +1092,6 @@ static ULONG WINAPI media_source_rate_control_Release(IMFRateControl *iface)
 
 static HRESULT WINAPI media_source_rate_control_SetRate(IMFRateControl *iface, BOOL thin, float rate)
 {
-    struct media_source *source = impl_from_IMFRateControl(iface);
-    HRESULT hr;
-
     FIXME("%p, %d, %f.\n", iface, thin, rate);
 
     if (rate < 0.0f)
@@ -1103,24 +1100,20 @@ static HRESULT WINAPI media_source_rate_control_SetRate(IMFRateControl *iface, B
     if (thin)
         return MF_E_THINNING_UNSUPPORTED;
 
-    if (FAILED(hr = IMFRateSupport_IsRateSupported(&source->IMFRateSupport_iface, thin, rate, NULL)))
-        return hr;
-
-    source->rate = rate;
+    if (rate != 1.0f)
+        return MF_E_UNSUPPORTED_RATE;
 
-    return IMFMediaEventQueue_QueueEventParamVar(source->event_queue, MESourceRateChanged, &GUID_NULL, S_OK, NULL);
+    return S_OK;
 }
 
 static HRESULT WINAPI media_source_rate_control_GetRate(IMFRateControl *iface, BOOL *thin, float *rate)
 {
-    struct media_source *source = impl_from_IMFRateControl(iface);
-
     TRACE("%p, %p, %p.\n", iface, thin, rate);
 
     if (thin)
         *thin = FALSE;
 
-    *rate = source->rate;
+    *rate = 1.0f;
 
     return S_OK;
 }
@@ -1166,7 +1159,7 @@ static ULONG WINAPI media_source_AddRef(IMFMediaSource *iface)
     struct media_source *source = impl_from_IMFMediaSource(iface);
     ULONG ref = InterlockedIncrement(&source->ref);
 
-    TRACE("%p, refcount %lu.\n", iface, ref);
+    TRACE("%p, refcount %u.\n", iface, ref);
 
     return ref;
 }
@@ -1176,7 +1169,7 @@ static ULONG WINAPI media_source_Release(IMFMediaSource *iface)
     struct media_source *source = impl_from_IMFMediaSource(iface);
     ULONG ref = InterlockedDecrement(&source->ref);
 
-    TRACE("%p, refcount %lu.\n", iface, ref);
+    TRACE("%p, refcount %u.\n", iface, ref);
 
     if (!ref)
     {
@@ -1192,7 +1185,7 @@ static HRESULT WINAPI media_source_GetEvent(IMFMediaSource *iface, DWORD flags,
 {
     struct media_source *source = impl_from_IMFMediaSource(iface);
 
-    TRACE("%p, %#lx, %p.\n", iface, flags, event);
+    TRACE("%p, %#x, %p.\n", iface, flags, event);
 
     return IMFMediaEventQueue_GetEvent(source->event_queue, flags, event);
 }
@@ -1220,7 +1213,7 @@ static HRESULT WINAPI media_source_QueueEvent(IMFMediaSource *iface, MediaEventT
 {
     struct media_source *source = impl_from_IMFMediaSource(iface);
 
-    TRACE("%p, %lu, %s, %#lx, %p.\n", iface, event_type, debugstr_guid(ext_type), hr, value);
+    TRACE("%p, %d, %s, %#x, %p.\n", iface, event_type, debugstr_guid(ext_type), hr, value);
 
     return IMFMediaEventQueue_QueueEventParamVar(source->event_queue, event_type, ext_type, hr, value);
 }
@@ -1379,6 +1372,7 @@ static const IMFMediaSourceVtbl IMFMediaSource_vtbl =
 
 static HRESULT media_source_constructor(IMFByteStream *bytestream, struct media_source **out_media_source)
 {
+    BOOL video_selected = FALSE, audio_selected = FALSE;
     IMFStreamDescriptor **descriptors = NULL;
     unsigned int stream_count = UINT_MAX;
     struct media_source *object;
@@ -1400,7 +1394,7 @@ static HRESULT media_source_constructor(IMFByteStream *bytestream, struct media_
 
     if (FAILED(hr = IMFByteStream_GetLength(bytestream, &file_size)))
     {
-        FIXME("Failed to get byte stream length, hr %#lx.\n", hr);
+        FIXME("Failed to get byte stream length, hr %#x.\n", hr);
         return hr;
     }
 
@@ -1415,7 +1409,6 @@ static HRESULT media_source_constructor(IMFByteStream *bytestream, struct media_
     object->ref = 1;
     object->byte_stream = bytestream;
     IMFByteStream_AddRef(bytestream);
-    object->rate = 1.0f;
 
     if (FAILED(hr = MFCreateEventQueue(&object->event_queue)))
         goto fail;
@@ -1458,7 +1451,7 @@ static HRESULT media_source_constructor(IMFByteStream *bytestream, struct media_
 
         if (FAILED(hr = media_stream_init_desc(object->streams[i])))
         {
-            ERR("Failed to finish initialization of media stream %p, hr %#lx.\n", object->streams[i], hr);
+            ERR("Failed to finish initialization of media stream %p, hr %x.\n", object->streams[i], hr);
             IMFMediaSource_Release(&object->streams[i]->parent_source->IMFMediaSource_iface);
             IMFMediaEventQueue_Release(object->streams[i]->event_queue);
             free(object->streams[i]);
@@ -1473,15 +1466,52 @@ static HRESULT media_source_constructor(IMFByteStream *bytestream, struct media_
     descriptors = malloc(object->stream_count * sizeof(IMFStreamDescriptor *));
     for (i = 0; i < object->stream_count; i++)
     {
-        IMFMediaStream_GetStreamDescriptor(&object->streams[i]->IMFMediaStream_iface, &descriptors[i]);
+        IMFStreamDescriptor **descriptor = &descriptors[object->stream_count - 1 - i];
+        char language[128];
+        DWORD language_len;
+        WCHAR *languageW;
+
+        IMFMediaStream_GetStreamDescriptor(&object->streams[i]->IMFMediaStream_iface, descriptor);
+
+        if (wg_parser_stream_get_language(object->streams[i]->wg_stream, language, sizeof(language)))
+        {
+            if ((language_len = MultiByteToWideChar(CP_UTF8, 0, language, -1, NULL, 0)))
+            {
+                languageW = malloc(language_len * sizeof(WCHAR));
+                if (MultiByteToWideChar(CP_UTF8, 0, language, -1, languageW, language_len))
+                {
+                    IMFStreamDescriptor_SetString(*descriptor, &MF_SD_LANGUAGE, languageW);
+                }
+                free(languageW);
+            }
+        }
     }
 
     if (FAILED(hr = MFCreatePresentationDescriptor(object->stream_count, descriptors, &object->pres_desc)))
         goto fail;
 
+    /* Select one of each major type. */
     for (i = 0; i < object->stream_count; i++)
     {
-        IMFPresentationDescriptor_SelectStream(object->pres_desc, i);
+        IMFMediaTypeHandler *handler;
+        GUID major_type;
+        BOOL select_stream = FALSE;
+
+        IMFStreamDescriptor_GetMediaTypeHandler(descriptors[i], &handler);
+        IMFMediaTypeHandler_GetMajorType(handler, &major_type);
+        if (IsEqualGUID(&major_type, &MFMediaType_Video) && !video_selected)
+        {
+            select_stream = TRUE;
+            video_selected = TRUE;
+        }
+        if (IsEqualGUID(&major_type, &MFMediaType_Audio) && !audio_selected)
+        {
+            select_stream = TRUE;
+            audio_selected = TRUE;
+        }
+        if (select_stream)
+            IMFPresentationDescriptor_SelectStream(object->pres_desc, i);
+        IMFMediaTypeHandler_Release(handler);
         IMFStreamDescriptor_Release(descriptors[i]);
     }
     free(descriptors);
@@ -1500,7 +1530,7 @@ static HRESULT media_source_constructor(IMFByteStream *bytestream, struct media_
     return S_OK;
 
     fail:
-    WARN("Failed to construct MFMediaSource, hr %#lx.\n", hr);
+    WARN("Failed to construct MFMediaSource, hr %#x.\n", hr);
 
     if (descriptors)
     {
@@ -1587,7 +1617,7 @@ static ULONG WINAPI winegstreamer_stream_handler_AddRef(IMFByteStreamHandler *if
     struct winegstreamer_stream_handler *handler = impl_from_IMFByteStreamHandler(iface);
     ULONG refcount = InterlockedIncrement(&handler->refcount);
 
-    TRACE("%p, refcount %lu.\n", handler, refcount);
+    TRACE("%p, refcount %u.\n", handler, refcount);
 
     return refcount;
 }
@@ -1598,7 +1628,7 @@ static ULONG WINAPI winegstreamer_stream_handler_Release(IMFByteStreamHandler *i
     ULONG refcount = InterlockedDecrement(&handler->refcount);
     struct winegstreamer_stream_handler_result *result, *next;
 
-    TRACE("%p, refcount %lu.\n", iface, refcount);
+    TRACE("%p, refcount %u.\n", iface, refcount);
 
     if (!refcount)
     {
@@ -1654,7 +1684,7 @@ static ULONG WINAPI create_object_context_AddRef(IUnknown *iface)
     struct create_object_context *context = impl_from_IUnknown(iface);
     ULONG refcount = InterlockedIncrement(&context->refcount);
 
-    TRACE("%p, refcount %lu.\n", iface, refcount);
+    TRACE("%p, refcount %u.\n", iface, refcount);
 
     return refcount;
 }
@@ -1664,7 +1694,7 @@ static ULONG WINAPI create_object_context_Release(IUnknown *iface)
     struct create_object_context *context = impl_from_IUnknown(iface);
     ULONG refcount = InterlockedDecrement(&context->refcount);
 
-    TRACE("%p, refcount %lu.\n", iface, refcount);
+    TRACE("%p, refcount %u.\n", iface, refcount);
 
     if (!refcount)
     {
@@ -1694,7 +1724,7 @@ static HRESULT WINAPI winegstreamer_stream_handler_BeginCreateObject(IMFByteStre
     IMFAsyncResult *caller, *item;
     HRESULT hr;
 
-    TRACE("%p, %s, %#lx, %p, %p, %p, %p.\n", iface, debugstr_w(url), flags, props, cancel_cookie, callback, state);
+    TRACE("%p, %s, %#x, %p, %p, %p, %p.\n", iface, debugstr_w(url), flags, props, cancel_cookie, callback, state);
 
     if (cancel_cookie)
         *cancel_cookie = NULL;
@@ -1871,7 +1901,7 @@ static HRESULT WINAPI winegstreamer_stream_handler_callback_GetParameters(IMFAsy
 static HRESULT winegstreamer_stream_handler_create_object(struct winegstreamer_stream_handler *This, WCHAR *url, IMFByteStream *stream, DWORD flags,
                                             IPropertyStore *props, IUnknown **out_object, MF_OBJECT_TYPE *out_obj_type)
 {
-    TRACE("%p, %s, %p, %#lx, %p, %p, %p.\n", This, debugstr_w(url), stream, flags, props, out_object, out_obj_type);
+    TRACE("%p, %s, %p, %u, %p, %p, %p.\n", This, debugstr_w(url), stream, flags, props, out_object, out_obj_type);
 
     if (flags & MF_RESOLUTION_MEDIASOURCE)
     {
@@ -1890,7 +1920,7 @@ static HRESULT winegstreamer_stream_handler_create_object(struct winegstreamer_s
     }
     else
     {
-        FIXME("Unhandled flags %#lx.\n", flags);
+        FIXME("flags = %08x\n", flags);
         return E_NOTIMPL;
     }
 }
diff --git a/dlls/winegstreamer/mfplat.c b/dlls/winegstreamer/mfplat.c
index 97e27bb7301..3ec45d7de4e 100644
--- wine/dlls/winegstreamer/mfplat.c
+++ wine/dlls/winegstreamer/mfplat.c
@@ -29,6 +29,8 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(mfplat);
 
+DEFINE_MEDIATYPE_GUID(MFAudioFormat_XMAudio2, 0x0166);
+
 struct video_processor
 {
     IMFTransform IMFTransform_iface;
@@ -64,7 +66,7 @@ static ULONG WINAPI video_processor_AddRef(IMFTransform *iface)
     struct video_processor *transform = impl_video_processor_from_IMFTransform(iface);
     ULONG refcount = InterlockedIncrement(&transform->refcount);
 
-    TRACE("%p, refcount %lu.\n", iface, refcount);
+    TRACE("%p, refcount %u.\n", iface, refcount);
 
     return refcount;
 }
@@ -74,7 +76,7 @@ static ULONG WINAPI video_processor_Release(IMFTransform *iface)
     struct video_processor *transform = impl_video_processor_from_IMFTransform(iface);
     ULONG refcount = InterlockedDecrement(&transform->refcount);
 
-    TRACE("%p, refcount %lu.\n", iface, refcount);
+    TRACE("%p, refcount %u.\n", iface, refcount);
 
     if (!refcount)
     {
@@ -146,7 +148,7 @@ static HRESULT WINAPI video_processor_GetOutputStreamAttributes(IMFTransform *if
 {
     struct video_processor *transform = impl_video_processor_from_IMFTransform(iface);
 
-    TRACE("%p, %lu, %p.\n", iface, id, attributes);
+    TRACE("%p, %u, %p.\n", iface, id, attributes);
 
     *attributes = transform->output_attributes;
     IMFAttributes_AddRef(*attributes);
@@ -156,14 +158,14 @@ static HRESULT WINAPI video_processor_GetOutputStreamAttributes(IMFTransform *if
 
 static HRESULT WINAPI video_processor_DeleteInputStream(IMFTransform *iface, DWORD id)
 {
-    TRACE("%p, %lu.\n", iface, id);
+    TRACE("%p, %u.\n", iface, id);
 
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI video_processor_AddInputStreams(IMFTransform *iface, DWORD streams, DWORD *ids)
 {
-    TRACE("%p, %lu, %p.\n", iface, streams, ids);
+    TRACE("%p, %u, %p.\n", iface, streams, ids);
 
     return E_NOTIMPL;
 }
@@ -171,7 +173,7 @@ static HRESULT WINAPI video_processor_AddInputStreams(IMFTransform *iface, DWORD
 static HRESULT WINAPI video_processor_GetInputAvailableType(IMFTransform *iface, DWORD id, DWORD index,
         IMFMediaType **type)
 {
-    FIXME("%p, %lu, %lu, %p.\n", iface, id, index, type);
+    FIXME("%p, %u, %u, %p.\n", iface, id, index, type);
 
     return E_NOTIMPL;
 }
@@ -179,42 +181,42 @@ static HRESULT WINAPI video_processor_GetInputAvailableType(IMFTransform *iface,
 static HRESULT WINAPI video_processor_GetOutputAvailableType(IMFTransform *iface, DWORD id, DWORD index,
         IMFMediaType **type)
 {
-    FIXME("%p, %lu, %lu, %p.\n", iface, id, index, type);
+    FIXME("%p, %u, %u, %p.\n", iface, id, index, type);
 
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI video_processor_SetInputType(IMFTransform *iface, DWORD id, IMFMediaType *type, DWORD flags)
 {
-    FIXME("%p, %lu, %p, %#lx.\n", iface, id, type, flags);
+    FIXME("%p, %u, %p, %#x.\n", iface, id, type, flags);
 
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI video_processor_SetOutputType(IMFTransform *iface, DWORD id, IMFMediaType *type, DWORD flags)
 {
-    FIXME("%p, %lu, %p, %#lx.\n", iface, id, type, flags);
+    FIXME("%p, %u, %p, %#x.\n", iface, id, type, flags);
 
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI video_processor_GetInputCurrentType(IMFTransform *iface, DWORD id, IMFMediaType **type)
 {
-    FIXME("%p, %lu, %p.\n", iface, id, type);
+    FIXME("%p, %u, %p.\n", iface, id, type);
 
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI video_processor_GetOutputCurrentType(IMFTransform *iface, DWORD id, IMFMediaType **type)
 {
-    FIXME("%p, %lu, %p.\n", iface, id, type);
+    FIXME("%p, %u, %p.\n", iface, id, type);
 
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI video_processor_GetInputStatus(IMFTransform *iface, DWORD id, DWORD *flags)
 {
-    FIXME("%p, %lu, %p.\n", iface, id, flags);
+    FIXME("%p, %u, %p.\n", iface, id, flags);
 
     return E_NOTIMPL;
 }
@@ -235,21 +237,21 @@ static HRESULT WINAPI video_processor_SetOutputBounds(IMFTransform *iface, LONGL
 
 static HRESULT WINAPI video_processor_ProcessEvent(IMFTransform *iface, DWORD id, IMFMediaEvent *event)
 {
-    TRACE("%p, %lu, %p.\n", iface, id, event);
+    TRACE("%p, %u, %p.\n", iface, id, event);
 
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI video_processor_ProcessMessage(IMFTransform *iface, MFT_MESSAGE_TYPE message, ULONG_PTR param)
 {
-    FIXME("%p, %u, %#Ix.\n", iface, message, param);
+    FIXME("%p, %u.\n", iface, message);
 
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI video_processor_ProcessInput(IMFTransform *iface, DWORD id, IMFSample *sample, DWORD flags)
 {
-    FIXME("%p, %lu, %p, %#lx.\n", iface, id, sample, flags);
+    FIXME("%p, %u, %p, %#x.\n", iface, id, sample, flags);
 
     return E_NOTIMPL;
 }
@@ -257,7 +259,7 @@ static HRESULT WINAPI video_processor_ProcessInput(IMFTransform *iface, DWORD id
 static HRESULT WINAPI video_processor_ProcessOutput(IMFTransform *iface, DWORD flags, DWORD count,
         MFT_OUTPUT_DATA_BUFFER *samples, DWORD *status)
 {
-    FIXME("%p, %#lx, %lu, %p, %p.\n", iface, flags, count, samples, status);
+    FIXME("%p, %#x, %u, %p, %p.\n", iface, flags, count, samples, status);
 
     return E_NOTIMPL;
 }
@@ -408,7 +410,9 @@ class_objects[] =
     { &CLSID_VideoProcessorMFT, &video_processor_create },
     { &CLSID_GStreamerByteStreamHandler, &winegstreamer_stream_handler_create },
     { &CLSID_WINEAudioConverter, &audio_converter_create },
+    { &CLSID_CColorConvertDMO, &color_converter_create },
     { &CLSID_MSH264DecoderMFT, &h264_decoder_create },
+    { &CLSID_MSAACDecMFT, &aac_decoder_create },
 };
 
 HRESULT mfplat_get_class_object(REFCLSID rclsid, REFIID riid, void **obj)
@@ -438,39 +442,75 @@ HRESULT mfplat_get_class_object(REFCLSID rclsid, REFIID riid, void **obj)
 }
 
 static WCHAR audio_converterW[] = L"Audio Converter";
-static const GUID *const audio_converter_supported_types[] =
+static const GUID *audio_converter_supported_types[] =
 {
     &MFAudioFormat_PCM,
     &MFAudioFormat_Float,
 };
 
 static WCHAR wma_decoderW[] = L"WMAudio Decoder MFT";
-static const GUID *const wma_decoder_input_types[] =
+static const GUID *wma_decoder_input_types[] =
 {
     &MEDIASUBTYPE_MSAUDIO1,
     &MFAudioFormat_WMAudioV8,
     &MFAudioFormat_WMAudioV9,
     &MFAudioFormat_WMAudio_Lossless,
 };
-static const GUID *const wma_decoder_output_types[] =
+static const GUID *wma_decoder_output_types[] =
 {
     &MFAudioFormat_PCM,
     &MFAudioFormat_Float,
 };
 
-static WCHAR h264_decoderW[] = L"Microsoft H264 Video Decoder MFT";
-static const GUID *const h264_decoder_input_types[] =
+static WCHAR video_processorW[] = L"Video Processor MFT";
+static const GUID *video_processor_supported_types[] =
+{
+    &MFVideoFormat_IYUV,
+};
+
+static WCHAR color_converterW[] = L"Color Converter";
+static const GUID *color_converter_supported_types[] =
+{
+    &MFVideoFormat_RGB24,
+    &MFVideoFormat_RGB32,
+    &MFVideoFormat_RGB555,
+    &MFVideoFormat_RGB8,
+    &MFVideoFormat_AYUV,
+    &MFVideoFormat_I420,
+    &MFVideoFormat_IYUV,
+    &MFVideoFormat_NV11,
+    &MFVideoFormat_NV12,
+    &MFVideoFormat_UYVY,
+    &MFVideoFormat_v216,
+    &MFVideoFormat_v410,
+    &MFVideoFormat_YUY2,
+    &MFVideoFormat_YVYU,
+    &MFVideoFormat_YVYU,
+};
+
+static WCHAR h264_decoderW[] = L"H.264 Decoder";
+static const GUID *h264_decoder_input_types[] =
 {
     &MFVideoFormat_H264,
-    &MFVideoFormat_H264_ES,
 };
-static const GUID *const h264_decoder_output_types[] =
+static const GUID *h264_decoder_output_types[] =
 {
     &MFVideoFormat_NV12,
-    &MFVideoFormat_YV12,
-    &MFVideoFormat_IYUV,
     &MFVideoFormat_I420,
+    &MFVideoFormat_IYUV,
     &MFVideoFormat_YUY2,
+    &MFVideoFormat_YV12,
+};
+
+static WCHAR aac_decoderW[] = L"AAC Decoder";
+static const GUID *aac_decoder_input_types[] =
+{
+    &MFAudioFormat_AAC,
+};
+static const GUID *aac_decoder_output_types[] =
+{
+    &MFAudioFormat_Float,
+    &MFAudioFormat_PCM,
 };
 
 static const struct mft
@@ -481,9 +521,9 @@ static const struct mft
     const UINT32 flags;
     const GUID *major_type;
     const UINT32 input_types_count;
-    const GUID *const *input_types;
+    const GUID **input_types;
     const UINT32 output_types_count;
-    const GUID *const *output_types;
+    const GUID **output_types;
 }
 mfts[] =
 {
@@ -509,6 +549,28 @@ mfts[] =
         ARRAY_SIZE(wma_decoder_output_types),
         wma_decoder_output_types,
     },
+    {
+        &CLSID_VideoProcessorMFT,
+        &MFT_CATEGORY_VIDEO_PROCESSOR,
+        video_processorW,
+        0,
+        &MFMediaType_Video,
+        ARRAY_SIZE(video_processor_supported_types),
+        video_processor_supported_types,
+        ARRAY_SIZE(video_processor_supported_types),
+        video_processor_supported_types,
+    },
+    {
+        &CLSID_CColorConvertDMO,
+        &MFT_CATEGORY_VIDEO_EFFECT,
+        color_converterW,
+        MFT_ENUM_FLAG_SYNCMFT,
+        &MFMediaType_Video,
+        ARRAY_SIZE(color_converter_supported_types),
+        color_converter_supported_types,
+        ARRAY_SIZE(color_converter_supported_types),
+        color_converter_supported_types,
+    },
     {
         &CLSID_MSH264DecoderMFT,
         &MFT_CATEGORY_VIDEO_DECODER,
@@ -520,13 +582,24 @@ mfts[] =
         ARRAY_SIZE(h264_decoder_output_types),
         h264_decoder_output_types,
     },
+    {
+        &CLSID_MSAACDecMFT,
+        &MFT_CATEGORY_AUDIO_DECODER,
+        aac_decoderW,
+        MFT_ENUM_FLAG_SYNCMFT,
+        &MFMediaType_Audio,
+        ARRAY_SIZE(aac_decoder_input_types),
+        aac_decoder_input_types,
+        ARRAY_SIZE(aac_decoder_output_types),
+        aac_decoder_output_types,
+    },
 };
 
 HRESULT mfplat_DllRegisterServer(void)
 {
     unsigned int i, j;
     HRESULT hr;
-    MFT_REGISTER_TYPE_INFO input_types[4], output_types[5];
+    MFT_REGISTER_TYPE_INFO input_types[15], output_types[15];
 
     for (i = 0; i < ARRAY_SIZE(mfts); i++)
     {
@@ -548,7 +621,7 @@ HRESULT mfplat_DllRegisterServer(void)
 
         if (FAILED(hr))
         {
-            FIXME("Failed to register MFT, hr %#lx.\n", hr);
+            FIXME("Failed to register MFT, hr %#x\n", hr);
             return hr;
         }
     }
@@ -615,7 +688,8 @@ static IMFMediaType *mf_media_type_from_wg_format_audio(const struct wg_format *
             IMFMediaType_SetUINT32(type, &MF_MT_AUDIO_BITS_PER_SAMPLE, audio_formats[i].depth);
             IMFMediaType_SetUINT32(type, &MF_MT_AUDIO_SAMPLES_PER_SECOND, format->u.audio.rate);
             IMFMediaType_SetUINT32(type, &MF_MT_AUDIO_NUM_CHANNELS, format->u.audio.channels);
-            IMFMediaType_SetUINT32(type, &MF_MT_AUDIO_CHANNEL_MASK, format->u.audio.channel_mask);
+            if (format->u.audio.channel_mask)
+                IMFMediaType_SetUINT32(type, &MF_MT_AUDIO_CHANNEL_MASK, format->u.audio.channel_mask);
             IMFMediaType_SetUINT32(type, &MF_MT_ALL_SAMPLES_INDEPENDENT, TRUE);
             IMFMediaType_SetUINT32(type, &MF_MT_AUDIO_BLOCK_ALIGNMENT, format->u.audio.channels * audio_formats[i].depth / 8);
 
@@ -659,10 +733,6 @@ IMFMediaType *mf_media_type_from_wg_format(const struct wg_format *format)
 {
     switch (format->major_type)
     {
-        case WG_MAJOR_TYPE_H264:
-        case WG_MAJOR_TYPE_WMA:
-            FIXME("Format %u not implemented!\n", format->major_type);
-            /* fallthrough */
         case WG_MAJOR_TYPE_UNKNOWN:
             return NULL;
 
@@ -677,11 +747,17 @@ IMFMediaType *mf_media_type_from_wg_format(const struct wg_format *format)
     return NULL;
 }
 
-static void mf_media_type_to_wg_format_audio(IMFMediaType *type, const GUID *subtype, struct wg_format *format)
+static void mf_media_type_to_wg_format_audio(IMFMediaType *type, struct wg_format *format)
 {
     UINT32 rate, channels, channel_mask, depth;
     unsigned int i;
+    GUID subtype;
 
+    if (FAILED(IMFMediaType_GetGUID(type, &MF_MT_SUBTYPE, &subtype)))
+    {
+        FIXME("Subtype is not set.\n");
+        return;
+    }
     if (FAILED(IMFMediaType_GetUINT32(type, &MF_MT_AUDIO_SAMPLES_PER_SECOND, &rate)))
     {
         FIXME("Sample rate is not set.\n");
@@ -703,6 +779,8 @@ static void mf_media_type_to_wg_format_audio(IMFMediaType *type, const GUID *sub
             channel_mask = KSAUDIO_SPEAKER_MONO;
         else if (channels == 2)
             channel_mask = KSAUDIO_SPEAKER_STEREO;
+        else if IsEqualGUID(&subtype, &MFAudioFormat_AAC)
+            channel_mask = 0;
         else
         {
             FIXME("Channel mask is not set.\n");
@@ -717,20 +795,26 @@ static void mf_media_type_to_wg_format_audio(IMFMediaType *type, const GUID *sub
 
     for (i = 0; i < ARRAY_SIZE(audio_formats); ++i)
     {
-        if (IsEqualGUID(subtype, audio_formats[i].subtype) && depth == audio_formats[i].depth)
+        if (IsEqualGUID(&subtype, audio_formats[i].subtype) && depth == audio_formats[i].depth)
         {
             format->u.audio.format = audio_formats[i].format;
             return;
         }
     }
-    FIXME("Unrecognized audio subtype %s, depth %u.\n", debugstr_guid(subtype), depth);
+    FIXME("Unrecognized audio subtype %s, depth %u.\n", debugstr_guid(&subtype), depth);
 }
 
-static void mf_media_type_to_wg_format_video(IMFMediaType *type, const GUID *subtype, struct wg_format *format)
+static void mf_media_type_to_wg_format_video(IMFMediaType *type, struct wg_format *format)
 {
     UINT64 frame_rate, frame_size;
     unsigned int i;
+    GUID subtype;
 
+    if (FAILED(IMFMediaType_GetGUID(type, &MF_MT_SUBTYPE, &subtype)))
+    {
+        FIXME("Subtype is not set.\n");
+        return;
+    }
     if (FAILED(IMFMediaType_GetUINT64(type, &MF_MT_FRAME_SIZE, &frame_size)))
     {
         FIXME("Frame size is not set.\n");
@@ -751,20 +835,41 @@ static void mf_media_type_to_wg_format_video(IMFMediaType *type, const GUID *sub
 
     for (i = 0; i < ARRAY_SIZE(video_formats); ++i)
     {
-        if (IsEqualGUID(subtype, video_formats[i].subtype))
+        if (IsEqualGUID(&subtype, video_formats[i].subtype))
         {
             format->u.video.format = video_formats[i].format;
-            return;
+            break;
         }
     }
-    FIXME("Unrecognized video subtype %s.\n", debugstr_guid(subtype));
+    if (i == ARRAY_SIZE(video_formats))
+        FIXME("Unrecognized video subtype %s.\n", debugstr_guid(&subtype));
+}
+
+void mf_media_type_to_wg_format(IMFMediaType *type, struct wg_format *format)
+{
+    GUID major_type;
+
+    memset(format, 0, sizeof(*format));
+
+    if (FAILED(IMFMediaType_GetMajorType(type, &major_type)))
+    {
+        FIXME("Major type is not set.\n");
+        return;
+    }
+
+    if (IsEqualGUID(&major_type, &MFMediaType_Audio))
+        mf_media_type_to_wg_format_audio(type, format);
+    else if (IsEqualGUID(&major_type, &MFMediaType_Video))
+        mf_media_type_to_wg_format_video(type, format);
+    else
+        FIXME("Unrecognized major type %s.\n", debugstr_guid(&major_type));
 }
 
-static void mf_media_type_to_wg_format_wma(IMFMediaType *type, const GUID *subtype, struct wg_format *format)
+static void mf_media_type_to_wg_encoded_format_xwma(IMFMediaType *type, struct wg_encoded_format *format,
+        enum wg_encoded_type encoded_type, UINT32 version)
 {
     UINT32 rate, depth, channels, block_align, bytes_per_second, codec_data_len;
     BYTE codec_data[64];
-    UINT32 version;
 
     if (FAILED(IMFMediaType_GetUINT32(type, &MF_MT_AUDIO_SAMPLES_PER_SECOND, &rate)))
     {
@@ -776,6 +881,11 @@ static void mf_media_type_to_wg_format_wma(IMFMediaType *type, const GUID *subty
         FIXME("Channel count is not set.\n");
         return;
     }
+    if (FAILED(IMFMediaType_GetUINT32(type, &MF_MT_AUDIO_AVG_BYTES_PER_SECOND, &bytes_per_second)))
+    {
+        FIXME("Bitrate is not set.\n");
+        return;
+    }
     if (FAILED(IMFMediaType_GetUINT32(type, &MF_MT_AUDIO_BLOCK_ALIGNMENT, &block_align)))
     {
         FIXME("Block alignment is not set.\n");
@@ -791,61 +901,85 @@ static void mf_media_type_to_wg_format_wma(IMFMediaType *type, const GUID *subty
         FIXME("Codec data is not set.\n");
         return;
     }
-    if (FAILED(IMFMediaType_GetUINT32(type, &MF_MT_AUDIO_AVG_BYTES_PER_SECOND, &bytes_per_second)))
+
+    format->encoded_type = encoded_type;
+    format->u.xwma.version = version;
+    format->u.xwma.bitrate = bytes_per_second * 8;
+    format->u.xwma.rate = rate;
+    format->u.xwma.depth = depth;
+    format->u.xwma.channels = channels;
+    format->u.xwma.block_align = block_align;
+    format->u.xwma.codec_data_len = codec_data_len;
+    memcpy(format->u.xwma.codec_data, codec_data, codec_data_len);
+}
+
+static void mf_media_type_to_wg_encoded_format_aac(IMFMediaType *type, struct wg_encoded_format *format)
+{
+    UINT32 codec_data_len, payload_type, profile_level_indication;
+    BYTE codec_data[64];
+
+    /* Audio specific config is stored at after HEAACWAVEINFO in MF_MT_USER_DATA
+     * https://docs.microsoft.com/en-us/windows/win32/api/mmreg/ns-mmreg-heaacwaveformat
+     */
+    struct
     {
-        FIXME("Bitrate is not set.\n");
-        bytes_per_second = 0;
-    }
+        WORD payload_type;
+        WORD profile_level_indication;
+        WORD type;
+        WORD reserved1;
+        DWORD reserved2;
+    } *aac_info = (void *)codec_data;
 
-    if (IsEqualGUID(subtype, &MEDIASUBTYPE_MSAUDIO1))
-        version = 1;
-    else if (IsEqualGUID(subtype, &MFAudioFormat_WMAudioV8))
-        version = 2;
-    else if (IsEqualGUID(subtype, &MFAudioFormat_WMAudioV9))
-        version = 3;
-    else if (IsEqualGUID(subtype, &MFAudioFormat_WMAudio_Lossless))
-        version = 4;
-    else
+    if (FAILED(IMFMediaType_GetBlob(type, &MF_MT_USER_DATA, codec_data, sizeof(codec_data), &codec_data_len)))
     {
-        assert(0);
+        FIXME("Codec data is not set.\n");
         return;
     }
+    if (FAILED(IMFMediaType_GetUINT32(type, &MF_MT_AAC_PAYLOAD_TYPE, &payload_type)))
+    {
+        FIXME("AAC payload type is not set.\n");
+        payload_type = aac_info->payload_type;
+    }
+    if (FAILED(IMFMediaType_GetUINT32(type, &MF_MT_AAC_AUDIO_PROFILE_LEVEL_INDICATION, &profile_level_indication)))
+    {
+        FIXME("AAC provile level indication is not set.\n");
+        profile_level_indication = aac_info->profile_level_indication;
+    }
 
-    format->major_type = WG_MAJOR_TYPE_WMA;
-    format->u.wma.version = version;
-    format->u.wma.bitrate = bytes_per_second * 8;
-    format->u.wma.rate = rate;
-    format->u.wma.depth = depth;
-    format->u.wma.channels = channels;
-    format->u.wma.block_align = block_align;
-    format->u.wma.codec_data_len = codec_data_len;
-    memcpy(format->u.wma.codec_data, codec_data, codec_data_len);
+    format->encoded_type = WG_ENCODED_TYPE_AAC;
+    format->u.aac.payload_type = payload_type;
+    format->u.aac.profile_level_indication = profile_level_indication;
+    format->u.aac.codec_data_len = 0;
+
+    if (codec_data_len > sizeof(*aac_info))
+    {
+        format->u.aac.codec_data_len = codec_data_len - sizeof(*aac_info);
+        memcpy(format->u.aac.codec_data, codec_data + sizeof(*aac_info), codec_data_len - sizeof(*aac_info));
+    }
 }
 
-static void mf_media_type_to_wg_format_h264(IMFMediaType *type, struct wg_format *format)
+static void mf_media_type_to_wg_encoded_format_h264(IMFMediaType *type, struct wg_encoded_format *format)
 {
     UINT64 frame_rate, frame_size;
     UINT32 profile, level;
 
-    memset(format, 0, sizeof(*format));
-    format->major_type = WG_MAJOR_TYPE_H264;
+    format->encoded_type = WG_ENCODED_TYPE_H264;
+    format->u.h264.width = 0;
+    format->u.h264.height = 0;
+    format->u.h264.fps_n = 1;
+    format->u.h264.fps_d = 1;
 
     if (SUCCEEDED(IMFMediaType_GetUINT64(type, &MF_MT_FRAME_SIZE, &frame_size)))
     {
-        format->u.h264.width = frame_size >> 32;
+        format->u.h264.width = (UINT32)(frame_size >> 32);
         format->u.h264.height = (UINT32)frame_size;
     }
 
     if (SUCCEEDED(IMFMediaType_GetUINT64(type, &MF_MT_FRAME_RATE, &frame_rate)) && (UINT32)frame_rate)
     {
-        format->u.h264.fps_n = frame_rate >> 32;
+        format->u.h264.fps_n = (UINT32)(frame_rate >> 32);
         format->u.h264.fps_d = (UINT32)frame_rate;
     }
-    else
-    {
-        format->u.h264.fps_n = 1;
-        format->u.h264.fps_d = 1;
-    }
 
     if (SUCCEEDED(IMFMediaType_GetUINT32(type, &MF_MT_MPEG2_PROFILE, &profile)))
         format->u.h264.profile = profile;
@@ -854,7 +988,7 @@ static void mf_media_type_to_wg_format_h264(IMFMediaType *type, struct wg_format
         format->u.h264.level = level;
 }
 
-void mf_media_type_to_wg_format(IMFMediaType *type, struct wg_format *format)
+void mf_media_type_to_wg_encoded_format(IMFMediaType *type, struct wg_encoded_format *format)
 {
     GUID major_type, subtype;
 
@@ -873,70 +1007,30 @@ void mf_media_type_to_wg_format(IMFMediaType *type, struct wg_format *format)
 
     if (IsEqualGUID(&major_type, &MFMediaType_Audio))
     {
-        if (IsEqualGUID(&subtype, &MEDIASUBTYPE_MSAUDIO1) ||
-                IsEqualGUID(&subtype, &MFAudioFormat_WMAudioV8) ||
-                IsEqualGUID(&subtype, &MFAudioFormat_WMAudioV9) ||
-                IsEqualGUID(&subtype, &MFAudioFormat_WMAudio_Lossless))
-            mf_media_type_to_wg_format_wma(type, &subtype, format);
+        if (IsEqualGUID(&subtype, &MEDIASUBTYPE_MSAUDIO1))
+            mf_media_type_to_wg_encoded_format_xwma(type, format, WG_ENCODED_TYPE_WMA, 1);
+        else if (IsEqualGUID(&subtype, &MFAudioFormat_WMAudioV8))
+            mf_media_type_to_wg_encoded_format_xwma(type, format, WG_ENCODED_TYPE_WMA, 2);
+        else if (IsEqualGUID(&subtype, &MFAudioFormat_WMAudioV9))
+            mf_media_type_to_wg_encoded_format_xwma(type, format, WG_ENCODED_TYPE_WMA, 3);
+        else if (IsEqualGUID(&subtype, &MFAudioFormat_WMAudio_Lossless))
+            mf_media_type_to_wg_encoded_format_xwma(type, format, WG_ENCODED_TYPE_WMA, 4);
+        else if (IsEqualGUID(&subtype, &MFAudioFormat_XMAudio2))
+            mf_media_type_to_wg_encoded_format_xwma(type, format, WG_ENCODED_TYPE_XMA, 2);
+        else if (IsEqualGUID(&subtype, &MFAudioFormat_AAC))
+            mf_media_type_to_wg_encoded_format_aac(type, format);
         else
-            mf_media_type_to_wg_format_audio(type, &subtype, format);
+            FIXME("Unimplemented audio subtype %s.\n", debugstr_guid(&subtype));
     }
     else if (IsEqualGUID(&major_type, &MFMediaType_Video))
     {
         if (IsEqualGUID(&subtype, &MFVideoFormat_H264))
-            mf_media_type_to_wg_format_h264(type, format);
+            mf_media_type_to_wg_encoded_format_h264(type, format);
         else
-            mf_media_type_to_wg_format_video(type, &subtype, format);
+            FIXME("Unimplemented audio subtype %s.\n", debugstr_guid(&subtype));
     }
     else
-        FIXME("Unrecognized major type %s.\n", debugstr_guid(&major_type));
-}
-
-struct mf_sample
-{
-    IMFSample *sample;
-    IMFMediaBuffer *media_buffer;
-    struct wg_sample wg_sample;
-};
-
-HRESULT mf_create_wg_sample(IMFSample *sample, struct wg_sample **out)
-{
-    DWORD current_length, max_length;
-    struct mf_sample *mf_sample;
-    BYTE *buffer;
-    HRESULT hr;
-
-    if (!(mf_sample = calloc(1, sizeof(*mf_sample))))
-        return E_OUTOFMEMORY;
-    if (FAILED(hr = IMFSample_ConvertToContiguousBuffer(sample, &mf_sample->media_buffer)))
-        goto out;
-    if (FAILED(hr = IMFMediaBuffer_Lock(mf_sample->media_buffer, &buffer, &max_length, &current_length)))
-        goto out;
-
-    IMFSample_AddRef((mf_sample->sample = sample));
-    mf_sample->wg_sample.data = buffer;
-    mf_sample->wg_sample.size = current_length;
-    mf_sample->wg_sample.max_size = max_length;
-
-    TRACE("Created mf_sample %p for sample %p.\n", mf_sample, sample);
-    *out = &mf_sample->wg_sample;
-    return S_OK;
-
-out:
-    if (mf_sample->media_buffer)
-        IMFMediaBuffer_Release(mf_sample->media_buffer);
-    free(mf_sample);
-    return hr;
-}
-
-void mf_destroy_wg_sample(struct wg_sample *wg_sample)
-{
-    struct mf_sample *mf_sample = CONTAINING_RECORD(wg_sample, struct mf_sample, wg_sample);
-
-    IMFMediaBuffer_Unlock(mf_sample->media_buffer);
-    IMFMediaBuffer_SetCurrentLength(mf_sample->media_buffer, wg_sample->size);
-    IMFMediaBuffer_Release(mf_sample->media_buffer);
-
-    IMFSample_Release(mf_sample->sample);
-    free(mf_sample);
+    {
+        FIXME("Unimplemented major type %s.\n", debugstr_guid(&major_type));
+    }
 }
diff --git a/dlls/winegstreamer/quartz_parser.c b/dlls/winegstreamer/quartz_parser.c
index 7b82f3efbc9..e9a3b00016d 100644
--- wine/dlls/winegstreamer/quartz_parser.c
+++ wine/dlls/winegstreamer/quartz_parser.c
@@ -29,8 +29,8 @@
 #include "dvdmedia.h"
 #include "mmreg.h"
 #include "ks.h"
-#include "wmcodecdsp.h"
 #include "initguid.h"
+#include "wmcodecdsp.h"
 #include "ksmedia.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(quartz);
@@ -328,11 +328,6 @@ unsigned int wg_format_get_max_size(const struct wg_format *format)
             break;
         }
 
-        case WG_MAJOR_TYPE_H264:
-        case WG_MAJOR_TYPE_WMA:
-            FIXME("Format %u not implemented!\n", format->major_type);
-            return 0;
-
         case WG_MAJOR_TYPE_UNKNOWN:
             FIXME("Cannot guess maximum sample size for unknown format.\n");
             return 0;
@@ -424,10 +419,6 @@ bool amt_from_wg_format(AM_MEDIA_TYPE *mt, const struct wg_format *format, bool
 
     switch (format->major_type)
     {
-    case WG_MAJOR_TYPE_H264:
-    case WG_MAJOR_TYPE_WMA:
-        FIXME("Format %u not implemented!\n", format->major_type);
-        /* fallthrough */
     case WG_MAJOR_TYPE_UNKNOWN:
         return false;
 
@@ -470,7 +461,7 @@ static bool amt_to_wg_format_audio(const AM_MEDIA_TYPE *mt, struct wg_format *fo
     }
     if (mt->cbFormat < sizeof(WAVEFORMATEX) || !mt->pbFormat)
     {
-        ERR("Unexpected format size %lu.\n", mt->cbFormat);
+        ERR("Unexpected format size %u.\n", mt->cbFormat);
         return false;
     }
 
@@ -522,7 +513,7 @@ static bool amt_to_wg_format_audio_mpeg1(const AM_MEDIA_TYPE *mt, struct wg_form
     }
     if (mt->cbFormat < sizeof(*audio_format) || !mt->pbFormat)
     {
-        ERR("Unexpected format size %lu.\n", mt->cbFormat);
+        ERR("Unexpected format size %u.\n", mt->cbFormat);
         return false;
     }
 
@@ -551,7 +542,7 @@ static bool amt_to_wg_format_audio_mpeg1_layer3(const AM_MEDIA_TYPE *mt, struct
     }
     if (mt->cbFormat < sizeof(*audio_format) || !mt->pbFormat)
     {
-        ERR("Unexpected format size %lu.\n", mt->cbFormat);
+        ERR("Unexpected format size %u.\n", mt->cbFormat);
         return false;
     }
 
@@ -596,7 +587,7 @@ static bool amt_to_wg_format_video(const AM_MEDIA_TYPE *mt, struct wg_format *fo
     }
     if (mt->cbFormat < sizeof(VIDEOINFOHEADER) || !mt->pbFormat)
     {
-        ERR("Unexpected format size %lu.\n", mt->cbFormat);
+        ERR("Unexpected format size %u.\n", mt->cbFormat);
         return false;
     }
 
@@ -692,11 +683,11 @@ static HRESULT send_sample(struct parser_source *pin, IMediaSample *sample,
     HRESULT hr;
     BYTE *ptr = NULL;
 
-    TRACE("offset %u, size %u, sample size %lu.\n", offset, size, IMediaSample_GetSize(sample));
+    TRACE("offset %u, size %u, sample size %u\n", offset, size, IMediaSample_GetSize(sample));
 
     hr = IMediaSample_SetActualDataLength(sample, size);
     if(FAILED(hr)){
-        ERR("Failed to set sample size, hr %#lx.\n", hr);
+        WARN("SetActualDataLength failed: %08x\n", hr);
         return hr;
     }
 
@@ -746,10 +737,12 @@ static HRESULT send_sample(struct parser_source *pin, IMediaSample *sample,
     IMediaSample_SetSyncPoint(sample, !buffer->delta);
 
     if (!pin->pin.pin.peer)
-        return VFW_E_NOT_CONNECTED;
+        hr = VFW_E_NOT_CONNECTED;
+    else
+        hr = IMemInputPin_Receive(pin->pin.pMemInputPin, sample);
+
+    TRACE("sending sample returned: %08x\n", hr);
 
-    hr = IMemInputPin_Receive(pin->pin.pMemInputPin, sample);
-    TRACE("Receive() returned hr %#lx.\n", hr);
     return hr;
 }
 
@@ -764,7 +757,7 @@ static void send_buffer(struct parser_source *pin, const struct wg_parser_buffer
     {
         if (FAILED(hr = IPin_NewSegment(pin->pin.pin.peer,
                 pin->seek.llCurrent, pin->seek.llStop, pin->seek.dRate)))
-            WARN("Failed to deliver new segment, hr %#lx.\n", hr);
+            WARN("Failed to deliver new segment, hr %#x.\n", hr);
         pin->need_segment = false;
     }
 
@@ -779,9 +772,12 @@ static void send_buffer(struct parser_source *pin, const struct wg_parser_buffer
         {
             uint32_t advance;
 
-            if (FAILED(hr = IMemAllocator_GetBuffer(pin->pin.pAllocator, &sample, NULL, NULL, 0)))
+            hr = BaseOutputPinImpl_GetDeliveryBuffer(&pin->pin, &sample, NULL, NULL, 0);
+
+            if (FAILED(hr))
             {
-                ERR("Failed to get a sample, hr %#lx.\n", hr);
+                if (hr != VFW_E_NOT_CONNECTED)
+                    ERR("Could not get a delivery buffer (%x), returning GST_FLOW_FLUSHING\n", hr);
                 break;
             }
 
@@ -799,9 +795,12 @@ static void send_buffer(struct parser_source *pin, const struct wg_parser_buffer
     }
     else
     {
-        if (FAILED(hr = IMemAllocator_GetBuffer(pin->pin.pAllocator, &sample, NULL, NULL, 0)))
+        hr = BaseOutputPinImpl_GetDeliveryBuffer(&pin->pin, &sample, NULL, NULL, 0);
+
+        if (FAILED(hr))
         {
-            ERR("Failed to get a sample, hr %#lx.\n", hr);
+            if (hr != VFW_E_NOT_CONNECTED)
+                ERR("Could not get a delivery buffer (%x), returning GST_FLOW_FLUSHING\n", hr);
         }
         else
         {
@@ -888,9 +887,9 @@ static DWORD CALLBACK read_thread(void *arg)
 
         hr = IAsyncReader_SyncRead(filter->reader, offset, size, data);
         if (FAILED(hr))
-            ERR("Failed to read %u bytes at offset %I64u, hr %#lx.\n", size, offset, hr);
+            ERR("Failed to read %u bytes at offset %I64u, hr %#x.\n", size, offset, hr);
 
-        wg_parser_push_data(filter->wg_parser, SUCCEEDED(hr) ? data : NULL, size);
+        wg_parser_push_data(filter->wg_parser, SUCCEEDED(hr) ? WG_READ_SUCCESS : WG_READ_FAILURE, data, size);
     }
 
     free(data);
@@ -961,24 +960,6 @@ static HRESULT parser_init_stream(struct strmbase_filter *iface)
 
     filter->streaming = true;
 
-    for (i = 0; i < filter->source_count; ++i)
-    {
-        struct parser_source *source = filter->sources[i];
-        struct wg_format format;
-        bool ret;
-
-        if (source->pin.pin.peer)
-        {
-            ret = amt_to_wg_format(&source->pin.pin.mt, &format);
-            assert(ret);
-            wg_parser_stream_enable(source->wg_stream, &format);
-        }
-        else
-        {
-            wg_parser_stream_disable(source->wg_stream);
-        }
-    }
-
     /* DirectShow retains the old seek positions, but resets to them every time
      * it transitions from stopped -> paused. */
 
@@ -997,7 +978,7 @@ static HRESULT parser_init_stream(struct strmbase_filter *iface)
             continue;
 
         if (FAILED(hr = IMemAllocator_Commit(pin->pin.pAllocator)))
-            ERR("Failed to commit allocator, hr %#lx.\n", hr);
+            ERR("Failed to commit allocator, hr %#x.\n", hr);
 
         pin->need_segment = true;
         pin->eos = false;
@@ -1117,13 +1098,20 @@ static const struct strmbase_sink_ops sink_ops =
 static BOOL decodebin_parser_filter_init_gst(struct parser *filter)
 {
     struct wg_parser *parser = filter->wg_parser;
+    const char *sgi = getenv("SteamGameId");
+    const WCHAR *format;
     unsigned int i, stream_count;
     WCHAR source_name[20];
 
+    /* King of Fighters XIII requests the WMV decoder filter pins by name
+     * to connect them to a Sample Grabber filter.
+     */
+    format = (sgi && !strcmp(sgi, "222940")) ? L"out%u" : L"Stream %02u";
+
     stream_count = wg_parser_get_stream_count(parser);
     for (i = 0; i < stream_count; ++i)
     {
-        swprintf(source_name, ARRAY_SIZE(source_name), L"Stream %02u", i);
+        swprintf(source_name, ARRAY_SIZE(source_name), format, i);
         if (!create_pin(filter, wg_parser_get_stream(parser, i), source_name))
             return FALSE;
     }
@@ -1209,7 +1197,7 @@ HRESULT decodebin_parser_create(IUnknown *outer, IUnknown **out)
     if (!(object = calloc(1, sizeof(*object))))
         return E_OUTOFMEMORY;
 
-    if (!(object->wg_parser = wg_parser_create(WG_PARSER_DECODEBIN, false)))
+    if (!(object->wg_parser = wg_parser_create(WG_PARSER_DECODEBIN, true)))
     {
         free(object);
         return E_OUTOFMEMORY;
@@ -1260,14 +1248,14 @@ static HRESULT WINAPI stream_select_Info(IAMStreamSelect *iface, LONG index,
         AM_MEDIA_TYPE **mt, DWORD *flags, LCID *lcid, DWORD *group, WCHAR **name,
         IUnknown **object, IUnknown **unknown)
 {
-    FIXME("iface %p, index %ld, mt %p, flags %p, lcid %p, group %p, name %p, object %p, unknown %p, stub!\n",
+    FIXME("iface %p, index %d, mt %p, flags %p, lcid %p, group %p, name %p, object %p, unknown %p, stub!\n",
             iface, index, mt, flags, lcid, group, name, object, unknown);
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI stream_select_Enable(IAMStreamSelect *iface, LONG index, DWORD flags)
 {
-    FIXME("iface %p, index %ld, flags %#lx, stub!\n", iface, index, flags);
+    FIXME("iface %p, index %d, flags %#x, stub!\n", iface, index, flags);
     return E_NOTIMPL;
 }
 
@@ -1329,7 +1317,7 @@ static HRESULT WINAPI GST_Seeking_SetPositions(IMediaSeeking *iface,
     struct parser *filter = impl_from_strmbase_filter(pin->pin.pin.filter);
     int i;
 
-    TRACE("pin %p, current %s, current_flags %#lx, stop %s, stop_flags %#lx.\n",
+    TRACE("pin %p, current %s, current_flags %#x, stop %s, stop_flags %#x.\n",
             pin, current ? debugstr_time(*current) : "<null>", current_flags,
             stop ? debugstr_time(*stop) : "<null>", stop_flags);
 
@@ -1451,7 +1439,7 @@ static HRESULT WINAPI GST_QualityControl_Notify(IQualityControl *iface, IBaseFil
     uint64_t timestamp;
     int64_t diff;
 
-    TRACE("pin %p, sender %p, type %s, proportion %ld, late %s, timestamp %s.\n",
+    TRACE("pin %p, sender %p, type %s, proportion %u, late %s, timestamp %s.\n",
             pin, sender, q.Type == Famine ? "Famine" : "Flood", q.Proportion,
             debugstr_time(q.Late), debugstr_time(q.TimeStamp));
 
@@ -1547,6 +1535,8 @@ static HRESULT WINAPI GSTOutPin_DecideBufferSize(struct strmbase_source *iface,
     struct parser_source *pin = impl_source_from_IPin(&iface->pin.IPin_iface);
     unsigned int buffer_size = 16384;
     ALLOCATOR_PROPERTIES ret_props;
+    struct wg_format format;
+    bool ret;
 
     if (IsEqualGUID(&pin->pin.pin.mt.formattype, &FORMAT_VideoInfo))
     {
@@ -1561,6 +1551,10 @@ static HRESULT WINAPI GSTOutPin_DecideBufferSize(struct strmbase_source *iface,
         buffer_size = format->nAvgBytesPerSec;
     }
 
+    ret = amt_to_wg_format(&pin->pin.pin.mt, &format);
+    assert(ret);
+    wg_parser_stream_enable(pin->wg_stream, &format, NULL, STREAM_ENABLE_FLAG_FLIP_RGB);
+
     /* We do need to drop any buffers that might have been sent with the old
      * caps, but this will be handled in parser_init_stream(). */
 
@@ -1570,6 +1564,13 @@ static HRESULT WINAPI GSTOutPin_DecideBufferSize(struct strmbase_source *iface,
     return IMemAllocator_SetProperties(allocator, props, &ret_props);
 }
 
+static void source_disconnect(struct strmbase_source *iface)
+{
+    struct parser_source *pin = impl_source_from_IPin(&iface->pin.IPin_iface);
+
+    wg_parser_stream_disable(pin->wg_stream);
+}
+
 static void free_source_pin(struct parser_source *pin)
 {
     if (pin->pin.pin.peer)
@@ -1595,6 +1596,7 @@ static const struct strmbase_source_ops source_ops =
     .pfnAttemptConnection = BaseOutputPinImpl_AttemptConnection,
     .pfnDecideAllocator = BaseOutputPinImpl_DecideAllocator,
     .pfnDecideBufferSize = GSTOutPin_DecideBufferSize,
+    .source_disconnect = source_disconnect,
 };
 
 static struct parser_source *create_pin(struct parser *filter,
@@ -1633,12 +1635,6 @@ static HRESULT GST_RemoveOutputPins(struct parser *This)
     if (!This->sink_connected)
         return S_OK;
 
-    for (i = 0; i < This->source_count; ++i)
-    {
-        if (This->sources[i])
-            free_source_pin(This->sources[i]);
-    }
-
     wg_parser_disconnect(This->wg_parser);
 
     /* read_thread() needs to stay alive to service any read requests GStreamer
@@ -1647,6 +1643,12 @@ static HRESULT GST_RemoveOutputPins(struct parser *This)
     WaitForSingleObject(This->read_thread, INFINITE);
     CloseHandle(This->read_thread);
 
+    for (i = 0; i < This->source_count; ++i)
+    {
+        if (This->sources[i])
+            free_source_pin(This->sources[i]);
+    }
+
     This->source_count = 0;
     free(This->sources);
     This->sources = NULL;
diff --git a/dlls/winegstreamer/unix_private.h b/dlls/winegstreamer/unix_private.h
index 7bce8263aaf..88566ab1db5 100644
--- wine/dlls/winegstreamer/unix_private.h
+++ wine/dlls/winegstreamer/unix_private.h
@@ -23,14 +23,11 @@
 
 #include "unixlib.h"
 
-#include <gst/gst.h>
-
 extern bool init_gstreamer(void) DECLSPEC_HIDDEN;
 extern GstElement *create_element(const char *name, const char *plugin_set) DECLSPEC_HIDDEN;
-
+extern GstCaps *wg_format_to_caps(const struct wg_format *format) DECLSPEC_HIDDEN;
 extern void wg_format_from_caps(struct wg_format *format, const GstCaps *caps) DECLSPEC_HIDDEN;
 extern bool wg_format_compare(const struct wg_format *a, const struct wg_format *b) DECLSPEC_HIDDEN;
-extern GstCaps *wg_format_to_caps(const struct wg_format *format) DECLSPEC_HIDDEN;
 
 extern NTSTATUS wg_transform_create(void *args) DECLSPEC_HIDDEN;
 extern NTSTATUS wg_transform_destroy(void *args) DECLSPEC_HIDDEN;
diff --git a/dlls/winegstreamer/unixlib.h b/dlls/winegstreamer/unixlib.h
index f4e2ea4966b..e39cf54fd08 100644
--- wine/dlls/winegstreamer/unixlib.h
+++ wine/dlls/winegstreamer/unixlib.h
@@ -37,8 +37,6 @@ struct wg_format
         WG_MAJOR_TYPE_UNKNOWN,
         WG_MAJOR_TYPE_VIDEO,
         WG_MAJOR_TYPE_AUDIO,
-        WG_MAJOR_TYPE_WMA,
-        WG_MAJOR_TYPE_H264,
     } major_type;
 
     union
@@ -90,6 +88,22 @@ struct wg_format
             uint32_t channel_mask; /* In WinMM format. */
             uint32_t rate;
         } audio;
+    } u;
+};
+
+struct wg_encoded_format
+{
+    enum wg_encoded_type
+    {
+        WG_ENCODED_TYPE_UNKNOWN,
+        WG_ENCODED_TYPE_WMA,
+        WG_ENCODED_TYPE_XMA,
+        WG_ENCODED_TYPE_AAC,
+        WG_ENCODED_TYPE_H264,
+    } encoded_type;
+
+    union
+    {
         struct
         {
             uint32_t version;
@@ -100,7 +114,14 @@ struct wg_format
             uint32_t block_align;
             uint32_t codec_data_len;
             unsigned char codec_data[64];
-        } wma;
+        } xwma;
+        struct
+        {
+            uint32_t payload_type;
+            uint32_t profile_level_indication;
+            uint32_t codec_data_len;
+            unsigned char codec_data[64];
+        } aac;
         struct
         {
             int32_t width, height;
@@ -111,17 +132,12 @@ struct wg_format
     } u;
 };
 
-enum wg_sample_flag
+struct wg_rect
 {
-    WG_SAMPLE_FLAG_INCOMPLETE = 1,
-};
-
-struct wg_sample
-{
-    UINT32 flags;
-    UINT32 max_size;
-    UINT32 size;
-    BYTE *data;
+    uint32_t left;
+    uint32_t right;
+    uint32_t top;
+    uint32_t bottom;
 };
 
 struct wg_parser_buffer
@@ -133,12 +149,22 @@ struct wg_parser_buffer
 };
 C_ASSERT(sizeof(struct wg_parser_buffer) == 32);
 
+enum wg_read_result
+{
+    WG_READ_SUCCESS,
+    WG_READ_FAILURE,
+    WG_READ_FLUSHING,
+    WG_READ_EOS,
+};
+
 enum wg_parser_type
 {
     WG_PARSER_DECODEBIN,
     WG_PARSER_AVIDEMUX,
     WG_PARSER_MPEGAUDIOPARSE,
     WG_PARSER_WAVPARSE,
+    WG_PARSER_AUDIOCONV,
+    WG_PARSER_VIDEOCONV,
 };
 
 struct wg_parser_create_params
@@ -154,6 +180,15 @@ struct wg_parser_connect_params
     UINT64 file_size;
 };
 
+struct wg_parser_connect_unseekable_params
+{
+    struct wg_parser *parser;
+    const struct wg_format *in_format;
+    UINT32 stream_count;
+    const struct wg_format *out_formats;
+    const struct wg_rect *apertures;
+};
+
 struct wg_parser_get_next_read_offset_params
 {
     struct wg_parser *parser;
@@ -164,6 +199,7 @@ struct wg_parser_get_next_read_offset_params
 struct wg_parser_push_data_params
 {
     struct wg_parser *parser;
+    enum wg_read_result result;
     const void *data;
     UINT32 size;
 };
@@ -187,10 +223,14 @@ struct wg_parser_stream_get_preferred_format_params
     struct wg_format *format;
 };
 
+#define STREAM_ENABLE_FLAG_FLIP_RGB 0x1
+
 struct wg_parser_stream_enable_params
 {
     struct wg_parser_stream *stream;
     const struct wg_format *format;
+    const struct wg_rect *aperture;
+    uint32_t flags;
 };
 
 struct wg_parser_stream_get_buffer_params
@@ -222,6 +262,13 @@ struct wg_parser_stream_get_duration_params
     UINT64 duration;
 };
 
+struct wg_parser_stream_get_language_params
+{
+    struct wg_parser_stream *stream;
+    char *buffer;
+    UINT32 size;
+};
+
 struct wg_parser_stream_seek_params
 {
     struct wg_parser_stream *stream;
@@ -233,22 +280,38 @@ struct wg_parser_stream_seek_params
 struct wg_transform_create_params
 {
     struct wg_transform *transform;
-    const struct wg_format *input_format;
+    const struct wg_encoded_format *input_format;
     const struct wg_format *output_format;
 };
 
 struct wg_transform_push_data_params
 {
     struct wg_transform *transform;
-    struct wg_sample *sample;
-    HRESULT result;
+    const void *data;
+    UINT32 size;
+};
+
+enum wg_sample_flags
+{
+    WG_SAMPLE_FLAG_INCOMPLETE = 1,
+    WG_SAMPLE_FLAG_HAS_PTS = 2,
+    WG_SAMPLE_FLAG_HAS_DURATION = 4,
+};
+
+struct wg_sample
+{
+    UINT32 flags;
+    BYTE *data;
+    UINT32 size;
+    /* pts and duration are in 100-nanosecond units. */
+    ULONGLONG pts, duration;
+    struct wg_format *format;
 };
 
 struct wg_transform_read_data_params
 {
     struct wg_transform *transform;
     struct wg_sample *sample;
-    HRESULT result;
 };
 
 enum unix_funcs
@@ -257,6 +320,7 @@ enum unix_funcs
     unix_wg_parser_destroy,
 
     unix_wg_parser_connect,
+    unix_wg_parser_connect_unseekable,
     unix_wg_parser_disconnect,
 
     unix_wg_parser_get_next_read_offset,
@@ -275,8 +339,11 @@ enum unix_funcs
     unix_wg_parser_stream_notify_qos,
 
     unix_wg_parser_stream_get_duration,
+    unix_wg_parser_stream_get_language,
     unix_wg_parser_stream_seek,
 
+    unix_wg_parser_stream_drain,
+
     unix_wg_transform_create,
     unix_wg_transform_destroy,
 
diff --git a/dlls/winegstreamer/wg_parser.c b/dlls/winegstreamer/wg_parser.c
index 48b88a4b11c..cbd037e42c8 100644
--- wine/dlls/winegstreamer/wg_parser.c
+++ wine/dlls/winegstreamer/wg_parser.c
@@ -30,6 +30,7 @@
 #include <stdarg.h>
 #include <stdio.h>
 
+#define GLIB_VERSION_MIN_REQUIRED GLIB_VERSION_2_30
 #include <gst/gst.h>
 #include <gst/video/video.h>
 #include <gst/audio/audio.h>
@@ -61,7 +62,7 @@ struct wg_parser
     init_gst_cb init_gst;
 
     struct wg_parser_stream **streams;
-    unsigned int stream_count;
+    unsigned int stream_count, expected_stream_count;
 
     GstElement *container, *decodebin;
     GstBus *bus;
@@ -75,7 +76,7 @@ struct wg_parser
     pthread_mutex_t mutex;
 
     pthread_cond_t init_cond;
-    bool no_more_pads, has_duration, error;
+    bool no_more_pads, has_duration, error, pull_mode, seekable;
 
     pthread_cond_t read_cond, read_done_cond;
     struct
@@ -87,9 +88,12 @@ struct wg_parser
         GstFlowReturn ret;
     } read_request;
 
-    bool sink_connected;
+    bool sink_connected, draining;
 
     bool unlimited_buffering;
+    struct wg_format input_format;
+
+    bool use_mediaconv;
 };
 
 struct wg_parser_stream
@@ -97,9 +101,10 @@ struct wg_parser_stream
     struct wg_parser *parser;
 
     GstPad *their_src, *post_sink, *post_src, *my_sink;
-    GstElement *flip;
+    GstElement *flip, *box;
     GstSegment segment;
     struct wg_format preferred_format, current_format;
+    struct wg_rect aperture;
 
     pthread_cond_t event_cond, event_empty_cond;
     GstBuffer *buffer;
@@ -108,8 +113,402 @@ struct wg_parser_stream
     bool flushing, eos, enabled, has_caps;
 
     uint64_t duration;
+    gchar *language_code;
 };
 
+static enum wg_audio_format wg_audio_format_from_gst(GstAudioFormat format)
+{
+    switch (format)
+    {
+        case GST_AUDIO_FORMAT_U8:
+            return WG_AUDIO_FORMAT_U8;
+        case GST_AUDIO_FORMAT_S16LE:
+            return WG_AUDIO_FORMAT_S16LE;
+        case GST_AUDIO_FORMAT_S24LE:
+            return WG_AUDIO_FORMAT_S24LE;
+        case GST_AUDIO_FORMAT_S32LE:
+            return WG_AUDIO_FORMAT_S32LE;
+        case GST_AUDIO_FORMAT_F32LE:
+            return WG_AUDIO_FORMAT_F32LE;
+        case GST_AUDIO_FORMAT_F64LE:
+            return WG_AUDIO_FORMAT_F64LE;
+        default:
+            return WG_AUDIO_FORMAT_UNKNOWN;
+    }
+}
+
+static uint32_t wg_channel_position_from_gst(GstAudioChannelPosition position)
+{
+    static const uint32_t position_map[] =
+    {
+        SPEAKER_FRONT_LEFT,
+        SPEAKER_FRONT_RIGHT,
+        SPEAKER_FRONT_CENTER,
+        SPEAKER_LOW_FREQUENCY,
+        SPEAKER_BACK_LEFT,
+        SPEAKER_BACK_RIGHT,
+        SPEAKER_FRONT_LEFT_OF_CENTER,
+        SPEAKER_FRONT_RIGHT_OF_CENTER,
+        SPEAKER_BACK_CENTER,
+        0,
+        SPEAKER_SIDE_LEFT,
+        SPEAKER_SIDE_RIGHT,
+        SPEAKER_TOP_FRONT_LEFT,
+        SPEAKER_TOP_FRONT_RIGHT,
+        SPEAKER_TOP_FRONT_CENTER,
+        SPEAKER_TOP_CENTER,
+        SPEAKER_TOP_BACK_LEFT,
+        SPEAKER_TOP_BACK_RIGHT,
+        0,
+        0,
+        SPEAKER_TOP_BACK_CENTER,
+    };
+
+    if (position == GST_AUDIO_CHANNEL_POSITION_MONO)
+        return SPEAKER_FRONT_CENTER;
+
+    if (position >= 0 && position < ARRAY_SIZE(position_map))
+        return position_map[position];
+    return 0;
+}
+
+static uint32_t wg_channel_mask_from_gst(const GstAudioInfo *info)
+{
+    uint32_t mask = 0, position;
+    unsigned int i;
+
+    for (i = 0; i < GST_AUDIO_INFO_CHANNELS(info); ++i)
+    {
+        if (!(position = wg_channel_position_from_gst(GST_AUDIO_INFO_POSITION(info, i))))
+        {
+            GST_WARNING("Unsupported channel %#x.", GST_AUDIO_INFO_POSITION(info, i));
+            return 0;
+        }
+        /* Make sure it's also in WinMM order. WinMM mandates that channels be
+         * ordered, as it were, from least to most significant SPEAKER_* bit.
+         * Hence we fail if the current channel was already specified, or if any
+         * higher bit was already specified. */
+        if (mask & ~(position - 1))
+        {
+            GST_WARNING("Unsupported channel order.");
+            return 0;
+        }
+        mask |= position;
+    }
+    return mask;
+}
+
+static void wg_format_from_audio_info(struct wg_format *format, const GstAudioInfo *info)
+{
+    format->major_type = WG_MAJOR_TYPE_AUDIO;
+    format->u.audio.format = wg_audio_format_from_gst(GST_AUDIO_INFO_FORMAT(info));
+    format->u.audio.channels = GST_AUDIO_INFO_CHANNELS(info);
+    format->u.audio.channel_mask = wg_channel_mask_from_gst(info);
+    format->u.audio.rate = GST_AUDIO_INFO_RATE(info);
+}
+
+static enum wg_video_format wg_video_format_from_gst(GstVideoFormat format)
+{
+    switch (format)
+    {
+        case GST_VIDEO_FORMAT_BGRA:
+            return WG_VIDEO_FORMAT_BGRA;
+        case GST_VIDEO_FORMAT_BGRx:
+            return WG_VIDEO_FORMAT_BGRx;
+        case GST_VIDEO_FORMAT_BGR:
+            return WG_VIDEO_FORMAT_BGR;
+        case GST_VIDEO_FORMAT_RGB15:
+            return WG_VIDEO_FORMAT_RGB15;
+        case GST_VIDEO_FORMAT_RGB16:
+            return WG_VIDEO_FORMAT_RGB16;
+        case GST_VIDEO_FORMAT_AYUV:
+            return WG_VIDEO_FORMAT_AYUV;
+        case GST_VIDEO_FORMAT_I420:
+            return WG_VIDEO_FORMAT_I420;
+        case GST_VIDEO_FORMAT_NV12:
+            return WG_VIDEO_FORMAT_NV12;
+        case GST_VIDEO_FORMAT_UYVY:
+            return WG_VIDEO_FORMAT_UYVY;
+        case GST_VIDEO_FORMAT_YUY2:
+            return WG_VIDEO_FORMAT_YUY2;
+        case GST_VIDEO_FORMAT_YV12:
+            return WG_VIDEO_FORMAT_YV12;
+        case GST_VIDEO_FORMAT_YVYU:
+            return WG_VIDEO_FORMAT_YVYU;
+        default:
+            return WG_VIDEO_FORMAT_UNKNOWN;
+    }
+}
+
+static void wg_format_from_video_info(struct wg_format *format, const GstVideoInfo *info)
+{
+    format->major_type = WG_MAJOR_TYPE_VIDEO;
+    format->u.video.format = wg_video_format_from_gst(GST_VIDEO_INFO_FORMAT(info));
+    format->u.video.width = GST_VIDEO_INFO_WIDTH(info);
+    format->u.video.height = GST_VIDEO_INFO_HEIGHT(info);
+    format->u.video.fps_n = GST_VIDEO_INFO_FPS_N(info);
+    format->u.video.fps_d = GST_VIDEO_INFO_FPS_D(info);
+}
+
+static void wg_format_from_caps_audio_mpeg(struct wg_format *format, const GstCaps *caps)
+{
+    const GstStructure *structure = gst_caps_get_structure(caps, 0);
+    gint layer, channels, rate;
+
+    if (!gst_structure_get_int(structure, "layer", &layer))
+    {
+        GST_WARNING("Missing \"layer\" value.");
+        return;
+    }
+    if (!gst_structure_get_int(structure, "channels", &channels))
+    {
+        GST_WARNING("Missing \"channels\" value.");
+        return;
+    }
+    if (!gst_structure_get_int(structure, "rate", &rate))
+    {
+        GST_WARNING("Missing \"rate\" value.");
+        return;
+    }
+
+    format->major_type = WG_MAJOR_TYPE_AUDIO;
+
+    if (layer == 1)
+        format->u.audio.format = WG_AUDIO_FORMAT_MPEG1_LAYER1;
+    else if (layer == 2)
+        format->u.audio.format = WG_AUDIO_FORMAT_MPEG1_LAYER2;
+    else if (layer == 3)
+        format->u.audio.format = WG_AUDIO_FORMAT_MPEG1_LAYER3;
+
+    format->u.audio.channels = channels;
+    format->u.audio.rate = rate;
+}
+
+static void wg_format_from_caps_video_cinepak(struct wg_format *format, const GstCaps *caps)
+{
+    const GstStructure *structure = gst_caps_get_structure(caps, 0);
+    gint width, height, fps_n, fps_d;
+
+    if (!gst_structure_get_int(structure, "width", &width))
+    {
+        GST_WARNING("Missing \"width\" value.");
+        return;
+    }
+    if (!gst_structure_get_int(structure, "height", &height))
+    {
+        GST_WARNING("Missing \"height\" value.");
+        return;
+    }
+    if (!gst_structure_get_fraction(structure, "framerate", &fps_n, &fps_d))
+    {
+        fps_n = 0;
+        fps_d = 1;
+    }
+
+    format->major_type = WG_MAJOR_TYPE_VIDEO;
+    format->u.video.format = WG_VIDEO_FORMAT_CINEPAK;
+    format->u.video.width = width;
+    format->u.video.height = height;
+    format->u.video.fps_n = fps_n;
+    format->u.video.fps_d = fps_d;
+}
+
+void wg_format_from_caps(struct wg_format *format, const GstCaps *caps)
+{
+    const GstStructure *structure = gst_caps_get_structure(caps, 0);
+    const char *name = gst_structure_get_name(structure);
+
+    memset(format, 0, sizeof(*format));
+
+    if (!strcmp(name, "audio/x-raw"))
+    {
+        GstAudioInfo info;
+
+        if (gst_audio_info_from_caps(&info, caps))
+            wg_format_from_audio_info(format, &info);
+    }
+    else if (!strcmp(name, "video/x-raw"))
+    {
+        GstVideoInfo info;
+
+        if (gst_video_info_from_caps(&info, caps))
+            wg_format_from_video_info(format, &info);
+    }
+    else if (!strcmp(name, "audio/mpeg"))
+    {
+        wg_format_from_caps_audio_mpeg(format, caps);
+    }
+    else if (!strcmp(name, "video/x-cinepak"))
+    {
+        wg_format_from_caps_video_cinepak(format, caps);
+    }
+    else
+    {
+        gchar *str = gst_caps_to_string(caps);
+
+        GST_FIXME("Unhandled caps %s.", str);
+        g_free(str);
+    }
+}
+
+static GstAudioFormat wg_audio_format_to_gst(enum wg_audio_format format)
+{
+    switch (format)
+    {
+        case WG_AUDIO_FORMAT_U8:    return GST_AUDIO_FORMAT_U8;
+        case WG_AUDIO_FORMAT_S16LE: return GST_AUDIO_FORMAT_S16LE;
+        case WG_AUDIO_FORMAT_S24LE: return GST_AUDIO_FORMAT_S24LE;
+        case WG_AUDIO_FORMAT_S32LE: return GST_AUDIO_FORMAT_S32LE;
+        case WG_AUDIO_FORMAT_F32LE: return GST_AUDIO_FORMAT_F32LE;
+        case WG_AUDIO_FORMAT_F64LE: return GST_AUDIO_FORMAT_F64LE;
+        default: return GST_AUDIO_FORMAT_UNKNOWN;
+    }
+}
+
+static void wg_channel_mask_to_gst(GstAudioChannelPosition *positions, uint32_t mask, uint32_t channel_count)
+{
+    const uint32_t orig_mask = mask;
+    unsigned int i;
+    DWORD bit;
+
+    static const GstAudioChannelPosition position_map[] =
+    {
+        GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,
+        GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,
+        GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER,
+        GST_AUDIO_CHANNEL_POSITION_LFE1,
+        GST_AUDIO_CHANNEL_POSITION_REAR_LEFT,
+        GST_AUDIO_CHANNEL_POSITION_REAR_RIGHT,
+        GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT_OF_CENTER,
+        GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT_OF_CENTER,
+        GST_AUDIO_CHANNEL_POSITION_REAR_CENTER,
+        GST_AUDIO_CHANNEL_POSITION_SIDE_LEFT,
+        GST_AUDIO_CHANNEL_POSITION_SIDE_RIGHT,
+        GST_AUDIO_CHANNEL_POSITION_TOP_CENTER,
+        GST_AUDIO_CHANNEL_POSITION_TOP_FRONT_LEFT,
+        GST_AUDIO_CHANNEL_POSITION_TOP_FRONT_CENTER,
+        GST_AUDIO_CHANNEL_POSITION_TOP_FRONT_RIGHT,
+        GST_AUDIO_CHANNEL_POSITION_TOP_REAR_LEFT,
+        GST_AUDIO_CHANNEL_POSITION_TOP_REAR_CENTER,
+        GST_AUDIO_CHANNEL_POSITION_TOP_REAR_RIGHT,
+    };
+
+    for (i = 0; i < channel_count; ++i)
+    {
+        positions[i] = GST_AUDIO_CHANNEL_POSITION_NONE;
+        if (BitScanForward(&bit, mask))
+        {
+            if (bit < ARRAY_SIZE(position_map))
+                positions[i] = position_map[bit];
+            else
+                GST_WARNING("Invalid channel mask %#x.\n", orig_mask);
+            mask &= ~(1 << bit);
+        }
+        else
+        {
+            GST_WARNING("Incomplete channel mask %#x.\n", orig_mask);
+        }
+    }
+}
+
+static GstCaps *wg_format_to_caps_audio(const struct wg_format *format)
+{
+    GstAudioChannelPosition positions[32];
+    GstAudioFormat audio_format;
+    GstAudioInfo info;
+
+    if ((audio_format = wg_audio_format_to_gst(format->u.audio.format)) == GST_AUDIO_FORMAT_UNKNOWN)
+        return NULL;
+
+    wg_channel_mask_to_gst(positions, format->u.audio.channel_mask, format->u.audio.channels);
+    gst_audio_info_set_format(&info, audio_format, format->u.audio.rate, format->u.audio.channels, positions);
+    return gst_audio_info_to_caps(&info);
+}
+
+static GstVideoFormat wg_video_format_to_gst(enum wg_video_format format)
+{
+    switch (format)
+    {
+        case WG_VIDEO_FORMAT_BGRA:  return GST_VIDEO_FORMAT_BGRA;
+        case WG_VIDEO_FORMAT_BGRx:  return GST_VIDEO_FORMAT_BGRx;
+        case WG_VIDEO_FORMAT_BGR:   return GST_VIDEO_FORMAT_BGR;
+        case WG_VIDEO_FORMAT_RGB15: return GST_VIDEO_FORMAT_RGB15;
+        case WG_VIDEO_FORMAT_RGB16: return GST_VIDEO_FORMAT_RGB16;
+        case WG_VIDEO_FORMAT_AYUV:  return GST_VIDEO_FORMAT_AYUV;
+        case WG_VIDEO_FORMAT_I420:  return GST_VIDEO_FORMAT_I420;
+        case WG_VIDEO_FORMAT_NV12:  return GST_VIDEO_FORMAT_NV12;
+        case WG_VIDEO_FORMAT_UYVY:  return GST_VIDEO_FORMAT_UYVY;
+        case WG_VIDEO_FORMAT_YUY2:  return GST_VIDEO_FORMAT_YUY2;
+        case WG_VIDEO_FORMAT_YV12:  return GST_VIDEO_FORMAT_YV12;
+        case WG_VIDEO_FORMAT_YVYU:  return GST_VIDEO_FORMAT_YVYU;
+        default: return GST_VIDEO_FORMAT_UNKNOWN;
+    }
+}
+
+static GstCaps *wg_format_to_caps_video(const struct wg_format *format)
+{
+    GstVideoFormat video_format;
+    GstVideoInfo info;
+    unsigned int i;
+    GstCaps *caps;
+
+    if ((video_format = wg_video_format_to_gst(format->u.video.format)) == GST_VIDEO_FORMAT_UNKNOWN)
+        return NULL;
+
+    gst_video_info_set_format(&info, video_format, format->u.video.width, abs(format->u.video.height));
+    if ((caps = gst_video_info_to_caps(&info)))
+    {
+        /* Clear some fields that shouldn't prevent us from connecting. */
+        for (i = 0; i < gst_caps_get_size(caps); ++i)
+        {
+            gst_structure_remove_fields(gst_caps_get_structure(caps, i),
+                    "framerate", "pixel-aspect-ratio", "colorimetry", "chroma-site", NULL);
+        }
+    }
+    return caps;
+}
+
+GstCaps *wg_format_to_caps(const struct wg_format *format)
+{
+    switch (format->major_type)
+    {
+        case WG_MAJOR_TYPE_UNKNOWN:
+            return NULL;
+        case WG_MAJOR_TYPE_AUDIO:
+            return wg_format_to_caps_audio(format);
+        case WG_MAJOR_TYPE_VIDEO:
+            return wg_format_to_caps_video(format);
+    }
+    assert(0);
+    return NULL;
+}
+
+bool wg_format_compare(const struct wg_format *a, const struct wg_format *b)
+{
+    if (a->major_type != b->major_type)
+        return false;
+
+    switch (a->major_type)
+    {
+        case WG_MAJOR_TYPE_UNKNOWN:
+            return false;
+
+        case WG_MAJOR_TYPE_AUDIO:
+            return a->u.audio.format == b->u.audio.format
+                    && a->u.audio.channels == b->u.audio.channels
+                    && a->u.audio.rate == b->u.audio.rate;
+
+        case WG_MAJOR_TYPE_VIDEO:
+            /* Do not compare FPS. */
+            return a->u.video.format == b->u.video.format
+                    && a->u.video.width == b->u.video.width
+                    && abs(a->u.video.height) == abs(b->u.video.height);
+    }
+
+    assert(0);
+    return false;
+}
+
 static NTSTATUS wg_parser_get_stream_count(void *args)
 {
     struct wg_parser_get_stream_count_params *params = args;
@@ -133,7 +532,7 @@ static NTSTATUS wg_parser_get_next_read_offset(void *args)
 
     pthread_mutex_lock(&parser->mutex);
 
-    while (parser->sink_connected && !parser->read_request.size)
+    while (parser->sink_connected && (!parser->read_request.size || parser->read_request.done))
         pthread_cond_wait(&parser->read_cond, &parser->mutex);
 
     if (!parser->sink_connected)
@@ -149,16 +548,33 @@ static NTSTATUS wg_parser_get_next_read_offset(void *args)
     return S_OK;
 }
 
+static GstFlowReturn wg_read_result_to_gst(enum wg_read_result result)
+{
+    switch (result)
+    {
+    case WG_READ_SUCCESS: return GST_FLOW_OK;
+    case WG_READ_FAILURE: return GST_FLOW_ERROR;
+    case WG_READ_FLUSHING: return GST_FLOW_FLUSHING;
+    case WG_READ_EOS: return GST_FLOW_EOS;
+    }
+    return GST_FLOW_ERROR;
+}
+
 static NTSTATUS wg_parser_push_data(void *args)
 {
     const struct wg_parser_push_data_params *params = args;
     struct wg_parser *parser = params->parser;
+    enum wg_read_result result = params->result;
     const void *data = params->data;
     uint32_t size = params->size;
 
     pthread_mutex_lock(&parser->mutex);
 
-    if (data)
+    if (result != WG_READ_SUCCESS)
+    {
+            parser->read_request.ret = wg_read_result_to_gst(result);
+    }
+    else if (data)
     {
         if (size)
         {
@@ -196,7 +612,9 @@ static NTSTATUS wg_parser_stream_get_preferred_format(void *args)
 {
     const struct wg_parser_stream_get_preferred_format_params *params = args;
 
-    *params->format = params->stream->preferred_format;
+    if (params->stream->has_caps)
+        *params->format = params->stream->preferred_format;
+
     return S_OK;
 }
 
@@ -205,42 +623,65 @@ static NTSTATUS wg_parser_stream_enable(void *args)
     const struct wg_parser_stream_enable_params *params = args;
     struct wg_parser_stream *stream = params->stream;
     const struct wg_format *format = params->format;
-    struct wg_parser *parser = stream->parser;
+    const struct wg_rect *aperture = params->aperture;
 
-    pthread_mutex_lock(&parser->mutex);
+    if (!stream->parser->seekable)
+        return S_OK;
 
     stream->current_format = *format;
     stream->enabled = true;
 
-    pthread_mutex_unlock(&parser->mutex);
-
     if (format->major_type == WG_MAJOR_TYPE_VIDEO)
     {
-        bool flip = (format->u.video.height < 0);
-
-        switch (format->u.video.format)
+        if (params->flags & STREAM_ENABLE_FLAG_FLIP_RGB)
         {
-            case WG_VIDEO_FORMAT_BGRA:
-            case WG_VIDEO_FORMAT_BGRx:
-            case WG_VIDEO_FORMAT_BGR:
-            case WG_VIDEO_FORMAT_RGB15:
-            case WG_VIDEO_FORMAT_RGB16:
-                flip = !flip;
-                break;
+            bool flip = (format->u.video.height < 0);
 
-            case WG_VIDEO_FORMAT_AYUV:
-            case WG_VIDEO_FORMAT_I420:
-            case WG_VIDEO_FORMAT_NV12:
-            case WG_VIDEO_FORMAT_UYVY:
-            case WG_VIDEO_FORMAT_YUY2:
-            case WG_VIDEO_FORMAT_YV12:
-            case WG_VIDEO_FORMAT_YVYU:
-            case WG_VIDEO_FORMAT_UNKNOWN:
-            case WG_VIDEO_FORMAT_CINEPAK:
-                break;
+            switch (format->u.video.format)
+            {
+                case WG_VIDEO_FORMAT_BGRA:
+                case WG_VIDEO_FORMAT_BGRx:
+                case WG_VIDEO_FORMAT_BGR:
+                case WG_VIDEO_FORMAT_RGB15:
+                case WG_VIDEO_FORMAT_RGB16:
+                    flip = !flip;
+                    break;
+
+                case WG_VIDEO_FORMAT_AYUV:
+                case WG_VIDEO_FORMAT_I420:
+                case WG_VIDEO_FORMAT_NV12:
+                case WG_VIDEO_FORMAT_UYVY:
+                case WG_VIDEO_FORMAT_YUY2:
+                case WG_VIDEO_FORMAT_YV12:
+                case WG_VIDEO_FORMAT_YVYU:
+                case WG_VIDEO_FORMAT_UNKNOWN:
+                case WG_VIDEO_FORMAT_CINEPAK:
+                    break;
+            }
+
+            gst_util_set_object_arg(G_OBJECT(stream->flip), "method", flip ? "vertical-flip" : "none");
         }
 
-        gst_util_set_object_arg(G_OBJECT(stream->flip), "method", flip ? "vertical-flip" : "none");
+        if (aperture)
+        {
+            if (!stream->box && (stream->aperture.left || stream->aperture.top ||
+                (stream->aperture.right && stream->aperture.right != stream->current_format.u.video.width) ||
+                (stream->aperture.bottom && stream->aperture.bottom != stream->current_format.u.video.height)))
+            {
+                fprintf(stderr, "winegstreamer: failed to create videobox, are %u-bit GStreamer \"good\" plugins installed?\n",
+                    8 * (int)sizeof(void *));
+                return E_FAIL;
+            }
+
+            if (aperture->left)
+                g_object_set(G_OBJECT(stream->box), "left", -aperture->left, NULL);
+            if (aperture->top)
+                g_object_set(G_OBJECT(stream->box), "top", -aperture->top, NULL);
+            if (aperture->right)
+                g_object_set(G_OBJECT(stream->box), "right", aperture->right - format->u.video.width, NULL);
+            if (aperture->bottom)
+                g_object_set(G_OBJECT(stream->box), "bottom", aperture->bottom - format->u.video.height, NULL);
+        }
     }
 
     gst_pad_push_event(stream->my_sink, gst_event_new_reconfigure());
@@ -250,13 +691,8 @@ static NTSTATUS wg_parser_stream_enable(void *args)
 static NTSTATUS wg_parser_stream_disable(void *args)
 {
     struct wg_parser_stream *stream = args;
-    struct wg_parser *parser = stream->parser;
 
-    pthread_mutex_lock(&parser->mutex);
     stream->enabled = false;
-    stream->current_format.major_type = WG_MAJOR_TYPE_UNKNOWN;
-    pthread_mutex_unlock(&parser->mutex);
-    pthread_cond_signal(&stream->event_empty_cond);
     return S_OK;
 }
 
@@ -350,6 +786,14 @@ static NTSTATUS wg_parser_stream_get_duration(void *args)
     return S_OK;
 }
 
+static NTSTATUS wg_parser_stream_get_language(void *args)
+{
+    struct wg_parser_stream_get_language_params *params = args;
+    if (params->stream->language_code)
+        lstrcpynA(params->buffer, params->stream->language_code, params->size);
+    return params->stream->language_code ? S_OK : E_FAIL;
+}
+
 static NTSTATUS wg_parser_stream_seek(void *args)
 {
     GstSeekType start_type = GST_SEEK_TYPE_SET, stop_type = GST_SEEK_TYPE_SET;
@@ -358,6 +802,9 @@ static NTSTATUS wg_parser_stream_seek(void *args)
     DWORD stop_flags = params->stop_flags;
     GstSeekFlags flags = 0;
 
+    if (!params->stream->parser->seekable)
+        return E_FAIL;
+
     if (start_flags & AM_SEEKING_SeekToKeyFrame)
         flags |= GST_SEEK_FLAG_KEY_UNIT;
     if (start_flags & AM_SEEKING_Segment)
@@ -377,6 +824,44 @@ static NTSTATUS wg_parser_stream_seek(void *args)
     return S_OK;
 }
 
+static NTSTATUS wg_parser_stream_drain(void *args)
+{
+    struct wg_parser_stream *stream = args;
+    struct wg_parser *parser = stream->parser;
+    bool ret;
+
+    pthread_mutex_lock(&parser->mutex);
+
+    /* Sanity check making sure caller didn't try to drain an already-EOS or unselected stream.
+       There's no reason for a caller to do this, but it could be an accident in which case we
+       should indicate that the stream is drained instead of locking-up. */
+    if (!stream->enabled || stream->eos)
+    {
+        pthread_mutex_unlock(&parser->mutex);
+        return true;
+    }
+
+    parser->draining = true;
+    pthread_cond_signal(&parser->read_done_cond);
+
+    /* We must wait for either an event to occur or the drain to complete.
+       Since drains are blocking, we assign this responsibility to the thread
+       pulling data, as the pipeline will not need to pull more data until
+       the drain completes.  If one input buffer yields more than one output
+       buffer, the chain callback blocks on the wg_parser_stream_buffer_release
+       for the first buffer, which would never be called if the drain function
+       hadn't completed. */
+    while (parser->draining && !stream->buffer)
+        pthread_cond_wait(&stream->event_cond, &parser->mutex);
+
+    ret = !stream->buffer;
+    parser->draining = false;
+
+    pthread_mutex_unlock(&stream->parser->mutex);
+
+    return ret;
+}
+
 static NTSTATUS wg_parser_stream_notify_qos(void *args)
 {
     const struct wg_parser_stream_notify_qos_params *params = args;
@@ -425,6 +910,34 @@ static GstAutoplugSelectResult autoplug_select_cb(GstElement *bin, GstPad *pad,
     return GST_AUTOPLUG_SELECT_TRY;
 }
 
+static gint find_videoconv_cb(gconstpointer a, gconstpointer b)
+{
+    const GValue *val_a = a, *val_b = b;
+    GstElementFactory *factory_a = g_value_get_object(val_a), *factory_b = g_value_get_object(val_b);
+    const char *name_a = gst_element_factory_get_longname(factory_a), *name_b = gst_element_factory_get_longname(factory_b);
+
+    if (!strcmp(name_a, "Proton video converter"))
+        return -1;
+    if (!strcmp(name_b, "Proton video converter"))
+        return 1;
+    return 0;
+}
+
+static GValueArray *autoplug_sort_cb(GstElement *bin, GstPad *pad,
+        GstCaps *caps, GValueArray *factories, gpointer user)
+{
+    struct wg_parser *parser = user;
+    GValueArray *ret = g_value_array_copy(factories);
+
+    if (!parser->use_mediaconv)
+        return NULL;
+
+    GST_DEBUG("parser %p.", parser);
+
+    g_value_array_sort(ret, find_videoconv_cb);
+    return ret;
+}
+
 static void no_more_pads_cb(GstElement *element, gpointer user)
 {
     struct wg_parser *parser = user;
@@ -447,7 +960,6 @@ static gboolean sink_event_cb(GstPad *pad, GstObject *parent, GstEvent *event)
     switch (event->type)
     {
         case GST_EVENT_SEGMENT:
-            pthread_mutex_lock(&parser->mutex);
             if (stream->enabled)
             {
                 const GstSegment *segment;
@@ -456,31 +968,29 @@ static gboolean sink_event_cb(GstPad *pad, GstObject *parent, GstEvent *event)
 
                 if (segment->format != GST_FORMAT_TIME)
                 {
-                    pthread_mutex_unlock(&parser->mutex);
                     GST_FIXME("Unhandled format \"%s\".", gst_format_get_name(segment->format));
                     break;
                 }
 
                 gst_segment_copy_into(segment, &stream->segment);
             }
-            pthread_mutex_unlock(&parser->mutex);
             break;
 
         case GST_EVENT_EOS:
             pthread_mutex_lock(&parser->mutex);
             stream->eos = true;
+            pthread_mutex_unlock(&parser->mutex);
             if (stream->enabled)
                 pthread_cond_signal(&stream->event_cond);
             else
                 pthread_cond_signal(&parser->init_cond);
-            pthread_mutex_unlock(&parser->mutex);
             break;
 
         case GST_EVENT_FLUSH_START:
-            pthread_mutex_lock(&parser->mutex);
-
             if (stream->enabled)
             {
+                pthread_mutex_lock(&parser->mutex);
+
                 stream->flushing = true;
                 pthread_cond_signal(&stream->event_empty_cond);
 
@@ -490,9 +1000,9 @@ static gboolean sink_event_cb(GstPad *pad, GstObject *parent, GstEvent *event)
                     gst_buffer_unref(stream->buffer);
                     stream->buffer = NULL;
                 }
-            }
 
-            pthread_mutex_unlock(&parser->mutex);
+                pthread_mutex_unlock(&parser->mutex);
+            }
             break;
 
         case GST_EVENT_FLUSH_STOP:
@@ -541,21 +1051,19 @@ static GstFlowReturn sink_chain_cb(GstPad *pad, GstObject *parent, GstBuffer *bu
 
     GST_LOG("stream %p, buffer %p.", stream, buffer);
 
-    pthread_mutex_lock(&parser->mutex);
-
-    /* Allow this buffer to be flushed by GStreamer. We are effectively
-     * implementing a queue object here. */
-
-    while (stream->enabled && !stream->flushing && stream->buffer)
-        pthread_cond_wait(&stream->event_empty_cond, &parser->mutex);
-
     if (!stream->enabled)
     {
-        pthread_mutex_unlock(&parser->mutex);
         gst_buffer_unref(buffer);
         return GST_FLOW_OK;
     }
 
+    /* Allow this buffer to be flushed by GStreamer. We are effectively
+     * implementing a queue object here. */
+
+    pthread_mutex_lock(&parser->mutex);
+
+    while (!stream->flushing && stream->buffer)
+        pthread_cond_wait(&stream->event_empty_cond, &parser->mutex);
     if (stream->flushing)
     {
         pthread_mutex_unlock(&parser->mutex);
@@ -588,7 +1096,6 @@ static GstFlowReturn sink_chain_cb(GstPad *pad, GstObject *parent, GstBuffer *bu
 static gboolean sink_query_cb(GstPad *pad, GstObject *parent, GstQuery *query)
 {
     struct wg_parser_stream *stream = gst_pad_get_element_private(pad);
-    struct wg_parser *parser = stream->parser;
 
     GST_LOG("stream %p, type \"%s\".", stream, gst_query_type_get_name(query->type));
 
@@ -601,10 +1108,10 @@ static gboolean sink_query_cb(GstPad *pad, GstObject *parent, GstQuery *query)
 
             gst_query_parse_caps(query, &filter);
 
-            pthread_mutex_lock(&parser->mutex);
-            caps = wg_format_to_caps(&stream->current_format);
-            pthread_mutex_unlock(&parser->mutex);
-
+            if (stream->enabled)
+                caps = wg_format_to_caps(&stream->current_format);
+            else
+                caps = gst_caps_new_any();
             if (!caps)
                 return FALSE;
 
@@ -630,11 +1137,8 @@ static gboolean sink_query_cb(GstPad *pad, GstObject *parent, GstQuery *query)
             gboolean ret = TRUE;
             GstCaps *caps;
 
-            pthread_mutex_lock(&parser->mutex);
-
-            if (stream->current_format.major_type == WG_MAJOR_TYPE_UNKNOWN)
+            if (!stream->enabled)
             {
-                pthread_mutex_unlock(&parser->mutex);
                 gst_query_set_accept_caps_result(query, TRUE);
                 return TRUE;
             }
@@ -642,9 +1146,6 @@ static gboolean sink_query_cb(GstPad *pad, GstObject *parent, GstQuery *query)
             gst_query_parse_accept_caps(query, &caps);
             wg_format_from_caps(&format, caps);
             ret = wg_format_compare(&format, &stream->current_format);
-
-            pthread_mutex_unlock(&parser->mutex);
-
             if (!ret && gst_debug_category_get_threshold(GST_CAT_DEFAULT) >= GST_LEVEL_WARNING)
             {
                 gchar *str = gst_caps_to_string(caps);
@@ -673,23 +1174,35 @@ GstElement *create_element(const char *name, const char *plugin_set)
 static struct wg_parser_stream *create_stream(struct wg_parser *parser)
 {
     struct wg_parser_stream *stream, **new_array;
+    unsigned int i;
     char pad_name[19];
 
-    if (!(new_array = realloc(parser->streams, (parser->stream_count + 1) * sizeof(*parser->streams))))
-        return NULL;
-    parser->streams = new_array;
+    for (i = 0; i < parser->expected_stream_count; i++)
+    {
+        if (!parser->streams[i]->parser)
+        {
+            stream = parser->streams[i];
+            break;
+        }
+    }
 
-    if (!(stream = calloc(1, sizeof(*stream))))
-        return NULL;
+    if (i == parser->expected_stream_count)
+    {
+        if (!(new_array = realloc(parser->streams, (parser->stream_count + 1) * sizeof(*parser->streams))))
+            return NULL;
+        parser->streams = new_array;
+
+        if (!(stream = calloc(1, sizeof(*stream))))
+            return NULL;
+    }
 
     gst_segment_init(&stream->segment, GST_FORMAT_UNDEFINED);
 
     stream->parser = parser;
-    stream->current_format.major_type = WG_MAJOR_TYPE_UNKNOWN;
     pthread_cond_init(&stream->event_cond, NULL);
     pthread_cond_init(&stream->event_empty_cond, NULL);
 
-    sprintf(pad_name, "qz_sink_%u", parser->stream_count);
+    sprintf(pad_name, "wine_sink_%u", parser->stream_count);
     stream->my_sink = gst_pad_new(pad_name, GST_PAD_SINK);
     gst_pad_set_element_private(stream->my_sink, stream);
     gst_pad_set_chain_function(stream->my_sink, sink_chain_cb);
@@ -706,10 +1219,14 @@ static void free_stream(struct wg_parser_stream *stream)
     {
         if (stream->post_sink)
         {
+            gst_pad_unlink(stream->their_src, stream->post_sink);
+            gst_pad_unlink(stream->post_src, stream->my_sink);
             gst_object_unref(stream->post_src);
             gst_object_unref(stream->post_sink);
             stream->post_src = stream->post_sink = NULL;
         }
+        else
+            gst_pad_unlink(stream->their_src, stream->my_sink);
         gst_object_unref(stream->their_src);
     }
     gst_object_unref(stream->my_sink);
@@ -717,6 +1234,9 @@ static void free_stream(struct wg_parser_stream *stream)
     pthread_cond_destroy(&stream->event_cond);
     pthread_cond_destroy(&stream->event_empty_cond);
 
+    if (stream->language_code)
+        g_free(stream->language_code);
+
     free(stream);
 }
 
@@ -741,7 +1261,53 @@ static void pad_added_cb(GstElement *element, GstPad *pad, gpointer user)
 
     if (!strcmp(name, "video/x-raw"))
     {
-        GstElement *deinterlace, *vconv, *flip, *vconv2;
+        GstElement *capssetter, *deinterlace, *vconv, *flip, *box, *vconv2;
+
+        /* Hack?: Flatten down the colorimetry to default values, without
+         * actually modifying the video at all.
+         *
+         * We want to do color matrix conversions when converting from YUV to
+         * RGB or vice versa. We do *not* want to do color matrix conversions
+         * when converting YUV <-> YUV or RGB <-> RGB, because these are slow
+         * (it essentially means always using the slow path, never going through
+         * liborc). However, we have two videoconvert elements, and it's
+         * basically impossible to know what conversions each is going to do
+         * until caps are negotiated (without depending on some implementation
+         * details, and even then it'snot exactly trivial). And setting
+         * matrix-mode after caps are negotiated has no effect.
+         *
+         * Nor can we just retain colorimetry information the way we retain
+         * other caps values, because videoconvert automatically clears it if
+         * not doing passthrough. I think that this would only happen if we have
+         * to do a double conversion, but that is possible. Not likely, but I
+         * don't want to have to be the one to find out that there's still a
+         * game broken.
+         *
+         * [Note that we'd actually kind of like to retain colorimetry
+         * information, just in case it does ever become relevant to pass that
+         * on to the next DirectShow filter. Hence I think the correct solution
+         * for upstream is to get videoconvert to Not Do That.]
+         *
+         * So as a fallback solution, we force an identity transformation of
+         * the caps to those with a "default" color matrix—i.e. transform the
+         * caps, but not the data. We do this by *pre*pending a capssetter to
+         * the front of the chain, and we remove the matrix-mode setting for the
+         * videoconvert elements.
+         */
+        if (!(capssetter = gst_element_factory_make("capssetter", NULL)))
+        {
+            GST_ERROR("Failed to create capssetter, are %u-bit GStreamer \"good\" plugins installed?\n",
+                    8 * (int)sizeof(void *));
+            goto out;
+        }
+        gst_util_set_object_arg(G_OBJECT(capssetter), "join", "true");
+        /* Actually, this is invalid, but it causes videoconvert to use default
+         * colorimetry as a result. Yes, this is depending on undocumented
+         * implementation details. It's a hack.
+         *
+         * Sadly there doesn't seem to be a way to get capssetter to clear
+         * certain fields while leaving others untouched. */
+        gst_util_set_object_arg(G_OBJECT(capssetter), "caps", "video/x-raw,colorimetry=0:0:0:0");
 
         /* DirectShow can express interlaced video, but downstream filters can't
          * necessarily consume it. In particular, the video renderer can't. */
@@ -754,32 +1320,77 @@ static void pad_added_cb(GstElement *element, GstPad *pad, gpointer user)
         if (!(vconv = create_element("videoconvert", "base")))
             goto out;
 
+        /* Let GStreamer choose a default number of threads. */
+        gst_util_set_object_arg(G_OBJECT(vconv), "n-threads", "0");
+
         /* GStreamer outputs RGB video top-down, but DirectShow expects bottom-up. */
         if (!(flip = create_element("videoflip", "good")))
             goto out;
 
+        box = gst_element_factory_make("videobox", NULL);
+
         /* videoflip does not support 15 and 16-bit RGB so add a second videoconvert
          * to do the final conversion. */
         if (!(vconv2 = create_element("videoconvert", "base")))
             goto out;
 
+        /* Let GStreamer choose a default number of threads. */
+        gst_util_set_object_arg(G_OBJECT(vconv2), "n-threads", "0");
+
+        if (!parser->seekable)
+        {
+            if (!box && (stream->aperture.left || stream->aperture.top ||
+                (stream->aperture.right && stream->aperture.right != stream->current_format.u.video.width) ||
+                (stream->aperture.bottom && stream->aperture.bottom != stream->current_format.u.video.height)))
+            {
+                fprintf(stderr, "winegstreamer: failed to create videobox, are %u-bit GStreamer \"good\" plugins installed?\n",
+                    8 * (int)sizeof(void *));
+                goto out;
+            }
+            if (stream->aperture.left)
+                g_object_set(G_OBJECT(box), "left", -stream->aperture.left, NULL);
+            if (stream->aperture.bottom)
+                g_object_set(G_OBJECT(box), "top", -stream->aperture.top, NULL);
+            if (stream->aperture.right)
+                g_object_set(G_OBJECT(box), "right", stream->aperture.right - stream->current_format.u.video.width, NULL);
+            if (stream->aperture.bottom)
+                g_object_set(G_OBJECT(box), "bottom", stream->aperture.bottom - stream->current_format.u.video.height, NULL);
+        }
+
         /* The bin takes ownership of these elements. */
+        gst_bin_add(GST_BIN(parser->container), capssetter);
+        gst_element_sync_state_with_parent(capssetter);
         gst_bin_add(GST_BIN(parser->container), deinterlace);
         gst_element_sync_state_with_parent(deinterlace);
         gst_bin_add(GST_BIN(parser->container), vconv);
         gst_element_sync_state_with_parent(vconv);
         gst_bin_add(GST_BIN(parser->container), flip);
         gst_element_sync_state_with_parent(flip);
+        if (box)
+        {
+            gst_bin_add(GST_BIN(parser->container), box);
+            gst_element_sync_state_with_parent(box);
+        }
         gst_bin_add(GST_BIN(parser->container), vconv2);
         gst_element_sync_state_with_parent(vconv2);
 
+        gst_element_link(capssetter, deinterlace);
         gst_element_link(deinterlace, vconv);
         gst_element_link(vconv, flip);
-        gst_element_link(flip, vconv2);
+        if (box)
+        {
+            gst_element_link(flip, box);
+            gst_element_link(box, vconv2);
+        }
+        else
+        {
+            gst_element_link(flip, vconv2);
+        }
 
-        stream->post_sink = gst_element_get_static_pad(deinterlace, "sink");
+        stream->post_sink = gst_element_get_static_pad(capssetter, "sink");
         stream->post_src = gst_element_get_static_pad(vconv2, "src");
         stream->flip = flip;
+        stream->box = box;
     }
     else if (!strcmp(name, "audio/x-raw"))
     {
@@ -868,6 +1479,7 @@ static GstFlowReturn src_getrange_cb(GstPad *pad, GstObject *parent,
 {
     struct wg_parser *parser = gst_pad_get_element_private(pad);
     GstFlowReturn ret;
+    unsigned int i;
 
     GST_LOG("pad %p, offset %" G_GINT64_MODIFIER "u, size %u, buffer %p.", pad, offset, size, *buffer);
 
@@ -889,6 +1501,14 @@ static GstFlowReturn src_getrange_cb(GstPad *pad, GstObject *parent,
 
     pthread_mutex_lock(&parser->mutex);
 
+    if (parser->draining)
+    {
+        gst_pad_peer_query(parser->my_src, gst_query_new_drain());
+        parser->draining = false;
+        for (i = 0; i < parser->stream_count; i++)
+            pthread_cond_signal(&parser->streams[i]->event_cond);
+    }
+
     assert(!parser->read_request.size);
     parser->read_request.buffer = *buffer;
     parser->read_request.offset = offset;
@@ -901,7 +1521,16 @@ static GstFlowReturn src_getrange_cb(GstPad *pad, GstObject *parent,
      * read_thread() not running. */
 
     while (!parser->read_request.done)
+    {
         pthread_cond_wait(&parser->read_done_cond, &parser->mutex);
+        if (parser->draining)
+        {
+            gst_pad_peer_query(parser->my_src, gst_query_new_drain());
+            parser->draining = false;
+            for (i = 0; i < parser->stream_count; i++)
+                pthread_cond_signal(&parser->streams[i]->event_cond);
+        }
+    }
 
     *buffer = parser->read_request.buffer;
     ret = parser->read_request.ret;
@@ -929,7 +1558,7 @@ static gboolean src_query_cb(GstPad *pad, GstObject *parent, GstQuery *query)
                 gst_query_set_duration(query, GST_FORMAT_PERCENT, GST_FORMAT_PERCENT_MAX);
                 return TRUE;
             }
-            else if (format == GST_FORMAT_BYTES)
+            else if (format == GST_FORMAT_BYTES && parser->seekable)
             {
                 gst_query_set_duration(query, GST_FORMAT_BYTES, parser->file_size);
                 return TRUE;
@@ -943,15 +1572,42 @@ static gboolean src_query_cb(GstPad *pad, GstObject *parent, GstQuery *query)
                 GST_WARNING("Cannot seek using format \"%s\".", gst_format_get_name(format));
                 return FALSE;
             }
+            if (!parser->seekable)
+                return FALSE;
             gst_query_set_seeking(query, GST_FORMAT_BYTES, 1, 0, parser->file_size);
             return TRUE;
 
         case GST_QUERY_SCHEDULING:
-            gst_query_set_scheduling(query, GST_SCHEDULING_FLAG_SEEKABLE, 1, -1, 0);
+            gst_query_set_scheduling(query, parser->seekable ? GST_SCHEDULING_FLAG_SEEKABLE : GST_SCHEDULING_FLAG_SEQUENTIAL, 1, -1, 0);
             gst_query_add_scheduling_mode(query, GST_PAD_MODE_PUSH);
             gst_query_add_scheduling_mode(query, GST_PAD_MODE_PULL);
             return TRUE;
 
+        case GST_QUERY_CAPS:
+        {
+            GstCaps *caps, *filter, *temp;
+
+            gst_query_parse_caps(query, &filter);
+
+            if (parser->input_format.major_type)
+                caps = wg_format_to_caps(&parser->input_format);
+            else
+                caps = gst_caps_new_any();
+            if (!caps)
+                return FALSE;
+
+            if (filter)
+            {
+                temp = gst_caps_intersect(caps, filter);
+                gst_caps_unref(caps);
+                caps = temp;
+            }
+
+            gst_query_set_caps_result(query, caps);
+            gst_caps_unref(caps);
+            return TRUE;
+        }
+
         default:
             GST_WARNING("Unhandled query type %s.", GST_QUERY_TYPE_NAME(query));
             return FALSE;
@@ -961,35 +1617,81 @@ static gboolean src_query_cb(GstPad *pad, GstObject *parent, GstQuery *query)
 static void *push_data(void *arg)
 {
     struct wg_parser *parser = arg;
+    ULONG alloc_size = 16384;
+    GstCaps *caps = NULL;
+    GstSegment *segment;
     GstBuffer *buffer;
+    unsigned int i;
     guint max_size;
 
     GST_DEBUG("Starting push thread.");
 
-    if (!(buffer = gst_buffer_new_allocate(NULL, 16384, NULL)))
+    if (parser->input_format.major_type)
+        caps = wg_format_to_caps(&parser->input_format);
+
+    if (parser->input_format.major_type == WG_MAJOR_TYPE_VIDEO)
     {
-        GST_ERROR("Failed to allocate memory.");
-        return NULL;
+        GstVideoInfo info;
+        gst_video_info_from_caps(&info, caps);
+        alloc_size = info.size;
     }
 
     max_size = parser->stop_offset ? parser->stop_offset : parser->file_size;
 
+    gst_pad_push_event(parser->my_src, gst_event_new_stream_start("wg_stream"));
+
+    if (caps) gst_pad_push_event(parser->my_src, gst_event_new_caps(caps));
+
+    segment = gst_segment_new();
+    gst_segment_init(segment, GST_FORMAT_BYTES);
+    gst_pad_push_event(parser->my_src, gst_event_new_segment(segment));
+
     for (;;)
     {
         ULONG size;
         int ret;
 
-        if (parser->next_offset >= max_size)
+        if (parser->seekable && parser->next_offset >= max_size)
             break;
-        size = min(16384, max_size - parser->next_offset);
+        size = parser->seekable ? min(alloc_size, max_size - parser->next_offset) : alloc_size;
 
-        if ((ret = src_getrange_cb(parser->my_src, NULL, parser->next_offset, size, &buffer)) < 0)
+        buffer = NULL;
+        if ((ret = src_getrange_cb(parser->my_src, NULL, parser->next_offset, size, &buffer) < 0))
         {
+            /* When we are in unseekable push mode, the pushing pad is responsible for handling flushing.  */
+            if (!parser->seekable && ret == GST_FLOW_FLUSHING)
+            {
+                gst_pad_push_event(parser->my_src, gst_event_new_seek(1.0f,
+                    GST_FORMAT_BYTES, GST_SEEK_FLAG_FLUSH, GST_SEEK_TYPE_NONE, 0, GST_SEEK_TYPE_NONE, 0));
+                continue;
+            }
+
+            if (!parser->seekable && ret == GST_FLOW_EOS)
+            {
+                gst_pad_push_event(parser->my_src, gst_event_new_eos());
+                pthread_mutex_lock(&parser->mutex);
+                for (i = 0; i < parser->stream_count; i++)
+                {
+                    if (!parser->streams[i]->enabled)
+                        continue;
+                    while (!parser->streams[i]->flushing && !parser->streams[i]->eos)
+                        pthread_cond_wait(&parser->streams[i]->event_empty_cond, &parser->mutex);
+                    parser->streams[i]->eos = false;
+                }
+
+                pthread_mutex_unlock(&parser->mutex);
+
+                segment = gst_segment_new();
+                gst_segment_init(segment, GST_FORMAT_BYTES);
+                gst_pad_push_event(parser->my_src, gst_event_new_segment(segment));
+                continue;
+            }
+
             GST_ERROR("Failed to read data, ret %s.", gst_flow_get_name(ret));
             break;
         }
 
-        parser->next_offset += size;
+        parser->next_offset += gst_buffer_get_size(buffer);
 
         buffer->duration = buffer->pts = -1;
         if ((ret = gst_pad_push(parser->my_src, buffer)) < 0)
@@ -999,8 +1701,6 @@ static void *push_data(void *arg)
         }
     }
 
-    gst_buffer_unref(buffer);
-
     gst_pad_push_event(parser->my_src, gst_event_new_eos());
 
     GST_DEBUG("Stopping push thread.");
@@ -1041,9 +1741,12 @@ static gboolean src_activate_mode_cb(GstPad *pad, GstObject *parent, GstPadMode
     GST_DEBUG("%s source pad for parser %p in %s mode.",
             activate ? "Activating" : "Deactivating", parser, gst_pad_mode_get_name(mode));
 
+    parser->pull_mode = false;
+
     switch (mode)
     {
         case GST_PAD_MODE_PULL:
+            parser->pull_mode = activate;
             return TRUE;
         case GST_PAD_MODE_PUSH:
             return activate_push(pad, activate);
@@ -1053,9 +1756,12 @@ static gboolean src_activate_mode_cb(GstPad *pad, GstObject *parent, GstPadMode
     return FALSE;
 }
 
+static BOOL decodebin_parser_init_gst(struct wg_parser *parser);
+
 static GstBusSyncReply bus_handler_cb(GstBus *bus, GstMessage *msg, gpointer user)
 {
     struct wg_parser *parser = user;
+    const GstStructure *structure;
     gchar *dbg_info = NULL;
     GError *err = NULL;
 
@@ -1090,6 +1796,21 @@ static GstBusSyncReply bus_handler_cb(GstBus *bus, GstMessage *msg, gpointer use
         pthread_cond_signal(&parser->init_cond);
         break;
 
+    case GST_MESSAGE_ELEMENT:
+        structure = gst_message_get_structure(msg);
+        if (gst_structure_has_name(structure, "missing-plugin"))
+        {
+            pthread_mutex_lock(&parser->mutex);
+            if (!parser->use_mediaconv && parser->init_gst == decodebin_parser_init_gst)
+            {
+                GST_WARNING("Autoplugged element failed to initialise, trying again with protonvideoconvert.");
+                parser->error = true;
+                pthread_cond_signal(&parser->init_cond);
+            }
+            pthread_mutex_unlock(&parser->mutex);
+        }
+        break;
+
     default:
         break;
     }
@@ -1105,6 +1826,7 @@ static gboolean src_perform_seek(struct wg_parser *parser, GstEvent *event)
     GstEvent *flush_event;
     GstSeekFlags flags;
     gint64 cur, stop;
+    GstSegment *seg;
     guint32 seqnum;
     gdouble rate;
 
@@ -1138,7 +1860,12 @@ static gboolean src_perform_seek(struct wg_parser *parser, GstEvent *event)
         gst_event_set_seqnum(flush_event, seqnum);
         gst_pad_push_event(parser->my_src, flush_event);
         if (thread)
+        {
             gst_pad_set_active(parser->my_src, 1);
+            seg = gst_segment_new();
+            gst_segment_init(seg, GST_FORMAT_BYTES);
+            gst_pad_push_event(parser->my_src, gst_event_new_segment(seg));
+        }
     }
 
     return TRUE;
@@ -1172,16 +1899,27 @@ static gboolean src_event_cb(GstPad *pad, GstObject *parent, GstEvent *event)
     return ret;
 }
 
-static NTSTATUS wg_parser_connect(void *args)
+static gchar *query_language(GstPad *pad)
+{
+    GstTagList *tag_list;
+    GstEvent *tag_event;
+    gchar *ret = NULL;
+
+    if ((tag_event = gst_pad_get_sticky_event(pad, GST_EVENT_TAG, 0)))
+    {
+        gst_event_parse_tag(tag_event, &tag_list);
+        gst_tag_list_get_string(tag_list, "language-code", &ret);
+        gst_event_unref(tag_event);
+    }
+
+    return ret;
+}
+
+static HRESULT wg_parser_connect_inner(struct wg_parser *parser)
 {
-    GstStaticPadTemplate src_template = GST_STATIC_PAD_TEMPLATE("quartz_src",
+    GstStaticPadTemplate src_template = GST_STATIC_PAD_TEMPLATE("wine_src",
             GST_PAD_SRC, GST_PAD_ALWAYS, GST_STATIC_CAPS_ANY);
-    const struct wg_parser_connect_params *params = args;
-    struct wg_parser *parser = params->parser;
-    unsigned int i;
-    int ret;
 
-    parser->file_size = params->file_size;
     parser->sink_connected = true;
 
     if (!parser->bus)
@@ -1193,7 +1931,7 @@ static NTSTATUS wg_parser_connect(void *args)
     parser->container = gst_bin_new(NULL);
     gst_element_set_bus(parser->container, parser->bus);
 
-    parser->my_src = gst_pad_new_from_static_template(&src_template, "quartz-src");
+    parser->my_src = gst_pad_new_from_static_template(&src_template, "wine-src");
     gst_pad_set_getrange_function(parser->my_src, src_getrange_cb);
     gst_pad_set_query_function(parser->my_src, src_query_cb);
     gst_pad_set_activatemode_function(parser->my_src, src_activate_mode_cb);
@@ -1204,14 +1942,41 @@ static NTSTATUS wg_parser_connect(void *args)
     parser->next_pull_offset = 0;
     parser->error = false;
 
+    return S_OK;
+}
+
+static NTSTATUS wg_parser_connect(void *args)
+{
+    const struct wg_parser_connect_params *params = args;
+    struct wg_parser *parser = params->parser;
+    bool use_mediaconv = false;
+    unsigned int i;
+    HRESULT hr;
+    int ret;
+
+    parser->seekable = true;
+    parser->file_size = params->file_size;
+
+    if ((hr = wg_parser_connect_inner(parser)))
+        return hr;
+
     if (!parser->init_gst(parser))
         goto out;
 
     gst_element_set_state(parser->container, GST_STATE_PAUSED);
+    if (!parser->pull_mode)
+        gst_pad_set_active(parser->my_src, 1);
     ret = gst_element_get_state(parser->container, NULL, NULL, -1);
+
     if (ret == GST_STATE_CHANGE_FAILURE)
     {
-        GST_ERROR("Failed to play stream.\n");
+        if (!parser->use_mediaconv && parser->init_gst == decodebin_parser_init_gst && parser->pull_mode)
+        {
+            GST_WARNING("Failed to play media, trying again with protonvideoconvert.");
+            use_mediaconv = true;
+        }
+        else
+            GST_ERROR("Failed to play stream.\n");
         goto out;
     }
 
@@ -1221,6 +1986,8 @@ static NTSTATUS wg_parser_connect(void *args)
         pthread_cond_wait(&parser->init_cond, &parser->mutex);
     if (parser->error)
     {
+        if (!parser->use_mediaconv && parser->init_gst == decodebin_parser_init_gst)
+            use_mediaconv = true;
         pthread_mutex_unlock(&parser->mutex);
         goto out;
     }
@@ -1293,13 +2060,7 @@ static NTSTATUS wg_parser_connect(void *args)
                 pthread_cond_wait(&parser->init_cond, &parser->mutex);
             }
         }
-
-        /* Now that we're fully initialized, enable the stream so that further
-         * samples get queued instead of being discarded. We don't actually need
-         * the samples (in particular, the frontend should seek before
-         * attempting to read anything), but we don't want to waste CPU time
-         * trying to decode them. */
-        stream->enabled = true;
+        stream->language_code = query_language(stream->their_src);
     }
 
     pthread_mutex_unlock(&parser->mutex);
@@ -1312,6 +2073,7 @@ out:
         gst_element_set_state(parser->container, GST_STATE_NULL);
     if (parser->their_sink)
     {
+        gst_pad_unlink(parser->my_src, parser->their_sink);
         gst_object_unref(parser->their_sink);
         parser->my_src = parser->their_sink = NULL;
     }
@@ -1334,9 +2096,58 @@ out:
     pthread_mutex_unlock(&parser->mutex);
     pthread_cond_signal(&parser->read_cond);
 
+    if (use_mediaconv)
+    {
+        parser->use_mediaconv = true;
+        hr = wg_parser_connect(args);
+        parser->use_mediaconv = false;
+        return hr;
+    }
+
     return E_FAIL;
 }
 
+static NTSTATUS wg_parser_connect_unseekable(void *args)
+{
+    const struct wg_parser_connect_unseekable_params *params = args;
+    const struct wg_format *out_formats = params->out_formats;
+    const struct wg_format *in_format = params->in_format;
+    const struct wg_rect *apertures = params->apertures;
+    uint32_t stream_count = params->stream_count;
+    struct wg_parser *parser = params->parser;
+    unsigned int i;
+    HRESULT hr;
+
+    parser->seekable = false;
+    /* since typefind is not available here, we must have an input_format */
+    parser->input_format = *in_format;
+
+    if ((hr = wg_parser_connect_inner(parser)))
+        return hr;
+
+    parser->stop_offset = -1;
+
+    parser->expected_stream_count = stream_count;
+    parser->streams = calloc(stream_count, sizeof(*parser->streams));
+
+    for (i = 0; i < stream_count; i++)
+    {
+        parser->streams[i] = calloc(1, sizeof(*parser->streams[i]));
+        parser->streams[i]->current_format = out_formats[i];
+        if (apertures)
+            parser->streams[i]->aperture = apertures[i];
+        parser->streams[i]->enabled = true;
+    }
+
+    if (!parser->init_gst(parser))
+        return E_FAIL;
+
+    if (parser->stream_count < parser->expected_stream_count)
+        return E_FAIL;
+
+    return S_OK;
+}
+
 static NTSTATUS wg_parser_disconnect(void *args)
 {
     struct wg_parser *parser = args;
@@ -1344,14 +2155,20 @@ static NTSTATUS wg_parser_disconnect(void *args)
 
     /* Unblock all of our streams. */
     pthread_mutex_lock(&parser->mutex);
+    parser->no_more_pads = true;
+    pthread_cond_signal(&parser->init_cond);
     for (i = 0; i < parser->stream_count; ++i)
     {
         parser->streams[i]->flushing = true;
+        pthread_cond_signal(&parser->streams[i]->event_cond);
         pthread_cond_signal(&parser->streams[i]->event_empty_cond);
     }
     pthread_mutex_unlock(&parser->mutex);
 
     gst_element_set_state(parser->container, GST_STATE_NULL);
+    if (!parser->pull_mode)
+        gst_pad_set_active(parser->my_src, 0);
+    gst_pad_unlink(parser->my_src, parser->their_sink);
     gst_object_unref(parser->my_src);
     gst_object_unref(parser->their_sink);
     parser->my_src = parser->their_sink = NULL;
@@ -1383,6 +2200,9 @@ static BOOL decodebin_parser_init_gst(struct wg_parser *parser)
     if (!(element = create_element("decodebin", "base")))
         return FALSE;
 
+    if (parser->input_format.major_type)
+        g_object_set(G_OBJECT(element), "sink-caps", wg_format_to_caps(&parser->input_format), NULL);
+
     gst_bin_add(GST_BIN(parser->container), element);
     parser->decodebin = element;
 
@@ -1396,6 +2216,7 @@ static BOOL decodebin_parser_init_gst(struct wg_parser *parser)
     g_signal_connect(element, "pad-added", G_CALLBACK(pad_added_cb), parser);
     g_signal_connect(element, "pad-removed", G_CALLBACK(pad_removed_cb), parser);
     g_signal_connect(element, "autoplug-select", G_CALLBACK(autoplug_select_cb), parser);
+    g_signal_connect(element, "autoplug-sort", G_CALLBACK(autoplug_sort_cb), parser);
     g_signal_connect(element, "no-more-pads", G_CALLBACK(no_more_pads_cb), parser);
 
     parser->their_sink = gst_element_get_static_pad(element, "sink");
@@ -1406,7 +2227,7 @@ static BOOL decodebin_parser_init_gst(struct wg_parser *parser)
 
     if ((ret = gst_pad_link(parser->my_src, parser->their_sink)) < 0)
     {
-        GST_ERROR("Failed to link pads, error %d.", ret);
+        GST_ERROR("Failed to link pads, error %d.\n", ret);
         return FALSE;
     }
 
@@ -1435,7 +2256,7 @@ static BOOL avi_parser_init_gst(struct wg_parser *parser)
 
     if ((ret = gst_pad_link(parser->my_src, parser->their_sink)) < 0)
     {
-        GST_ERROR("Failed to link pads, error %d.", ret);
+        GST_ERROR("Failed to link pads, error %d.\n", ret);
         return FALSE;
     }
 
@@ -1456,7 +2277,7 @@ static BOOL mpeg_audio_parser_init_gst(struct wg_parser *parser)
     parser->their_sink = gst_element_get_static_pad(element, "sink");
     if ((ret = gst_pad_link(parser->my_src, parser->their_sink)) < 0)
     {
-        GST_ERROR("Failed to link sink pads, error %d.", ret);
+        GST_ERROR("Failed to link sink pads, error %d.\n", ret);
         return FALSE;
     }
 
@@ -1466,7 +2287,7 @@ static BOOL mpeg_audio_parser_init_gst(struct wg_parser *parser)
     gst_object_ref(stream->their_src = gst_element_get_static_pad(element, "src"));
     if ((ret = gst_pad_link(stream->their_src, stream->my_sink)) < 0)
     {
-        GST_ERROR("Failed to link source pads, error %d.", ret);
+        GST_ERROR("Failed to link source pads, error %d.\n", ret);
         return FALSE;
     }
     gst_pad_set_active(stream->my_sink, 1);
@@ -1490,7 +2311,7 @@ static BOOL wave_parser_init_gst(struct wg_parser *parser)
     parser->their_sink = gst_element_get_static_pad(element, "sink");
     if ((ret = gst_pad_link(parser->my_src, parser->their_sink)) < 0)
     {
-        GST_ERROR("Failed to link sink pads, error %d.", ret);
+        GST_ERROR("Failed to link sink pads, error %d.\n", ret);
         return FALSE;
     }
 
@@ -1501,7 +2322,7 @@ static BOOL wave_parser_init_gst(struct wg_parser *parser)
     gst_object_ref(stream->their_src);
     if ((ret = gst_pad_link(stream->their_src, stream->my_sink)) < 0)
     {
-        GST_ERROR("Failed to link source pads, error %d.", ret);
+        GST_ERROR("Failed to link source pads, error %d.\n", ret);
         return FALSE;
     }
     gst_pad_set_active(stream->my_sink, 1);
@@ -1511,6 +2332,119 @@ static BOOL wave_parser_init_gst(struct wg_parser *parser)
     return TRUE;
 }
 
+static BOOL audio_convert_init_gst(struct wg_parser *parser)
+{
+    struct wg_parser_stream *stream;
+    GstElement *convert, *resampler;
+    int ret;
+
+    if (parser->seekable)
+        return FALSE;
+
+    if (parser->expected_stream_count != 1)
+        return FALSE;
+
+    if (parser->input_format.major_type != WG_MAJOR_TYPE_AUDIO)
+        return FALSE;
+
+    if (!(convert = create_element("audioconvert", "base")))
+        return FALSE;
+
+    gst_bin_add(GST_BIN(parser->container), convert);
+
+    if (!(resampler = create_element("audioresample", "base")))
+        return FALSE;
+
+    gst_bin_add(GST_BIN(parser->container), resampler);
+
+    gst_element_link(convert, resampler);
+
+    parser->their_sink = gst_element_get_static_pad(convert, "sink");
+    if ((ret = gst_pad_link(parser->my_src, parser->their_sink)) < 0)
+    {
+        GST_ERROR("Failed to link sink pads, error %d.\n", ret);
+        return FALSE;
+    }
+
+    if (!(stream = create_stream(parser)))
+        return FALSE;
+
+    stream->their_src = gst_element_get_static_pad(resampler, "src");
+    gst_object_ref(stream->their_src);
+    if ((ret = gst_pad_link(stream->their_src, stream->my_sink)) < 0)
+    {
+        GST_ERROR("Failed to link source pads, error %d.\n", ret);
+        return FALSE;
+    }
+    gst_pad_set_active(stream->my_sink, 1);
+
+    parser->no_more_pads = true;
+
+    gst_element_set_state(parser->container, GST_STATE_PAUSED);
+    gst_pad_set_active(parser->my_src, 1);
+    ret = gst_element_get_state(parser->container, NULL, NULL, -1);
+    if (ret == GST_STATE_CHANGE_FAILURE)
+    {
+        GST_ERROR("Failed to play stream.\n");
+        return FALSE;
+    }
+
+    return TRUE;
+}
+
+static BOOL video_convert_init_gst(struct wg_parser *parser)
+{
+    struct wg_parser_stream *stream;
+    GstElement *convert;
+    int ret;
+
+    if (parser->seekable)
+        return FALSE;
+
+    if (parser->expected_stream_count != 1)
+        return FALSE;
+
+    if (parser->input_format.major_type != WG_MAJOR_TYPE_VIDEO)
+        return FALSE;
+
+    if (!(convert = create_element("videoconvert", "base")))
+        return FALSE;
+
+    gst_bin_add(GST_BIN(parser->container), convert);
+
+    parser->their_sink = gst_element_get_static_pad(convert, "sink");
+    if ((ret = gst_pad_link(parser->my_src, parser->their_sink)) < 0)
+    {
+        GST_ERROR("Failed to link sink pads, error %d.\n", ret);
+        return FALSE;
+    }
+
+    if (!(stream = create_stream(parser)))
+        return FALSE;
+
+    stream->their_src = gst_element_get_static_pad(convert, "src");
+    gst_object_ref(stream->their_src);
+    if ((ret = gst_pad_link(stream->their_src, stream->my_sink)) < 0)
+    {
+        GST_ERROR("Failed to link source pads, error %d.\n", ret);
+        return FALSE;
+    }
+    gst_pad_set_active(stream->my_sink, 1);
+
+    parser->no_more_pads = true;
+
+    gst_element_set_state(parser->container, GST_STATE_PAUSED);
+    gst_pad_set_active(parser->my_src, 1);
+    ret = gst_element_get_state(parser->container, NULL, NULL, -1);
+    if (ret == GST_STATE_CHANGE_FAILURE)
+    {
+        GST_ERROR("Failed to play stream.\n");
+        return FALSE;
+    }
+
+    return TRUE;
+}
+
 static void init_gstreamer_once(void)
 {
     char arg0[] = "wine";
@@ -1519,6 +2453,22 @@ static void init_gstreamer_once(void)
     int argc = ARRAY_SIZE(args) - 1;
     char **argv = args;
     GError *err;
+    const char *e;
+
+    if ((e = getenv("WINE_GST_REGISTRY_DIR")))
+    {
+        char gst_reg[PATH_MAX];
+#if defined(__x86_64__)
+        const char *arch = "/registry.x86_64.bin";
+#elif defined(__i386__)
+        const char *arch = "/registry.i386.bin";
+#else
+#error Bad arch
+#endif
+        strcpy(gst_reg, e);
+        strcat(gst_reg, arch);
+        setenv("GST_REGISTRY_1_0", gst_reg, 1);
+    }
 
     if (!gst_init_check(&argc, &argv, &err))
     {
@@ -1529,7 +2479,7 @@ static void init_gstreamer_once(void)
 
     GST_DEBUG_CATEGORY_INIT(wine, "WINE", GST_DEBUG_FG_RED, "Wine GStreamer support");
 
-    GST_INFO("GStreamer library version %s; wine built with %d.%d.%d.",
+    GST_INFO("GStreamer library version %s; wine built with %d.%d.%d.\n",
             gst_version_string(), GST_VERSION_MAJOR, GST_VERSION_MINOR, GST_VERSION_MICRO);
 }
 
@@ -1537,7 +2487,10 @@ bool init_gstreamer(void)
 {
     static pthread_once_t init_once = PTHREAD_ONCE_INIT;
 
-    return !pthread_once(&init_once, init_gstreamer_once);
+    if (pthread_once(&init_once, init_gstreamer_once))
+        return false;
+
+    return true;
 }
 
 static NTSTATUS wg_parser_create(void *args)
@@ -1548,6 +2501,8 @@ static NTSTATUS wg_parser_create(void *args)
         [WG_PARSER_AVIDEMUX] = avi_parser_init_gst,
         [WG_PARSER_MPEGAUDIOPARSE] = mpeg_audio_parser_init_gst,
         [WG_PARSER_WAVPARSE] = wave_parser_init_gst,
+        [WG_PARSER_AUDIOCONV] = audio_convert_init_gst,
+        [WG_PARSER_VIDEOCONV] = video_convert_init_gst,
     };
 
     struct wg_parser_create_params *params = args;
@@ -1566,7 +2521,7 @@ static NTSTATUS wg_parser_create(void *args)
     parser->init_gst = init_funcs[params->type];
     parser->unlimited_buffering = params->unlimited_buffering;
 
-    GST_DEBUG("Created winegstreamer parser %p.", parser);
+    GST_DEBUG("Created winegstreamer parser %p.\n", parser);
     params->parser = parser;
     return S_OK;
 }
@@ -1597,6 +2552,7 @@ const unixlib_entry_t __wine_unix_call_funcs[] =
     X(wg_parser_destroy),
 
     X(wg_parser_connect),
+    X(wg_parser_connect_unseekable),
     X(wg_parser_disconnect),
 
     X(wg_parser_get_next_read_offset),
@@ -1615,8 +2571,11 @@ const unixlib_entry_t __wine_unix_call_funcs[] =
     X(wg_parser_stream_notify_qos),
 
     X(wg_parser_stream_get_duration),
+    X(wg_parser_stream_get_language),
     X(wg_parser_stream_seek),
 
+    X(wg_parser_stream_drain),
+
     X(wg_transform_create),
     X(wg_transform_destroy),
 
diff --git a/dlls/winegstreamer/wg_transform.c b/dlls/winegstreamer/wg_transform.c
index 49c7bfaa927..b080894dbe4 100644
--- wine/dlls/winegstreamer/wg_transform.c
+++ wine/dlls/winegstreamer/wg_transform.c
@@ -32,98 +32,315 @@
 #include <gst/video/video.h>
 #include <gst/audio/audio.h>
 
-#include "ntstatus.h"
-#define WIN32_NO_STATUS
 #include "winternl.h"
+#include "dshow.h"
 #include "mferror.h"
 
 #include "unix_private.h"
 
+#include "wine/list.h"
+
 GST_DEBUG_CATEGORY_EXTERN(wine);
 #define GST_CAT_DEFAULT wine
 
+struct wg_transform_sample
+{
+    struct list entry;
+    GstSample *sample;
+};
+
 struct wg_transform
 {
     GstElement *container;
     GstPad *my_src, *my_sink;
     GstPad *their_sink, *their_src;
-    GstSegment segment;
-    GstBufferList *input;
-    guint input_max_length;
-    GstAtomicQueue *output_queue;
-    GstBuffer *output_buffer;
+    pthread_mutex_t mutex;
+    struct list samples;
+    GstCaps *sink_caps;
 };
 
+static GstCaps *wg_format_to_caps_xwma(const struct wg_encoded_format *format)
+{
+    GstBuffer *buffer;
+    GstCaps *caps;
+
+    if (format->encoded_type == WG_ENCODED_TYPE_WMA)
+    {
+        caps = gst_caps_new_empty_simple("audio/x-wma");
+        if (format->u.xwma.version)
+            gst_caps_set_simple(caps, "wmaversion", G_TYPE_INT, format->u.xwma.version, NULL);
+    }
+    else
+    {
+        caps = gst_caps_new_empty_simple("audio/x-xma");
+        if (format->u.xwma.version)
+            gst_caps_set_simple(caps, "xmaversion", G_TYPE_INT, format->u.xwma.version, NULL);
+    }
+
+    if (format->u.xwma.bitrate)
+        gst_caps_set_simple(caps, "bitrate", G_TYPE_INT, format->u.xwma.bitrate, NULL);
+    if (format->u.xwma.rate)
+        gst_caps_set_simple(caps, "rate", G_TYPE_INT, format->u.xwma.rate, NULL);
+    if (format->u.xwma.depth)
+        gst_caps_set_simple(caps, "depth", G_TYPE_INT, format->u.xwma.depth, NULL);
+    if (format->u.xwma.channels)
+        gst_caps_set_simple(caps, "channels", G_TYPE_INT, format->u.xwma.channels, NULL);
+    if (format->u.xwma.block_align)
+        gst_caps_set_simple(caps, "block_align", G_TYPE_INT, format->u.xwma.block_align, NULL);
+
+    if (format->u.xwma.codec_data_len)
+    {
+        buffer = gst_buffer_new_and_alloc(format->u.xwma.codec_data_len);
+        gst_buffer_fill(buffer, 0, format->u.xwma.codec_data, format->u.xwma.codec_data_len);
+        gst_caps_set_simple(caps, "codec_data", GST_TYPE_BUFFER, buffer, NULL);
+        gst_buffer_unref(buffer);
+    }
+
+    return caps;
+}
+
+static GstCaps *wg_format_to_caps_aac(const struct wg_encoded_format *format)
+{
+    const char *profile, *level, *stream_format;
+    GstBuffer *buffer;
+    GstCaps *caps;
+
+    caps = gst_caps_new_empty_simple("audio/mpeg");
+    gst_caps_set_simple(caps, "mpegversion", G_TYPE_INT, 4, NULL);
+
+    switch (format->u.aac.payload_type)
+    {
+        case 0: stream_format = "raw"; break;
+        case 1: stream_format = "adts"; break;
+        case 2: stream_format = "adif"; break;
+        case 3: stream_format = "loas"; break;
+        default: stream_format = "raw"; break;
+    }
+    if (stream_format)
+        gst_caps_set_simple(caps, "stream-format", G_TYPE_STRING, stream_format, NULL);
+
+    switch (format->u.aac.profile_level_indication)
+    {
+        case 0x29: profile = "lc"; level = "2";  break;
+        case 0x2A: profile = "lc"; level = "4"; break;
+        case 0x2B: profile = "lc"; level = "5"; break;
+        default:
+            GST_FIXME("Unrecognized profile-level-indication %u\n", format->u.aac.profile_level_indication);
+            /* fallthrough */
+        case 0x00: case 0xFE: profile = level = NULL; break; /* unspecified */
+    }
+    if (profile)
+        gst_caps_set_simple(caps, "profile", G_TYPE_STRING, profile, NULL);
+    if (level)
+        gst_caps_set_simple(caps, "level", G_TYPE_STRING, level, NULL);
+
+    if (format->u.aac.codec_data_len)
+    {
+        buffer = gst_buffer_new_and_alloc(format->u.aac.codec_data_len);
+        gst_buffer_fill(buffer, 0, format->u.aac.codec_data, format->u.aac.codec_data_len);
+        gst_caps_set_simple(caps, "codec_data", GST_TYPE_BUFFER, buffer, NULL);
+        gst_buffer_unref(buffer);
+    }
+
+    return caps;
+}
+
+static GstCaps *wg_format_to_caps_h264(const struct wg_encoded_format *format)
+{
+    const char *profile, *level;
+    GstCaps *caps;
+
+    caps = gst_caps_new_empty_simple("video/x-h264");
+    gst_caps_set_simple(caps, "stream-format", G_TYPE_STRING, "byte-stream", NULL);
+    gst_caps_set_simple(caps, "alignment", G_TYPE_STRING, "au", NULL);
+
+    if (format->u.h264.width)
+        gst_caps_set_simple(caps, "width", G_TYPE_INT, format->u.h264.width, NULL);
+    if (format->u.h264.height)
+        gst_caps_set_simple(caps, "height", G_TYPE_INT, format->u.h264.height, NULL);
+    if (format->u.h264.fps_n || format->u.h264.fps_d)
+        gst_caps_set_simple(caps, "framerate", GST_TYPE_FRACTION, format->u.h264.fps_n, format->u.h264.fps_d, NULL);
+
+    switch (format->u.h264.profile)
+    {
+        case /* eAVEncH264VProfile_Main */ 77:  profile = "main"; break;
+        case /* eAVEncH264VProfile_High */ 100: profile = "high"; break;
+        case /* eAVEncH264VProfile_444 */  244: profile = "high-4:4:4"; break;
+        default:
+            GST_ERROR("Unrecognized H.264 profile attribute %u.", format->u.h264.profile);
+            /* fallthrough */
+        case 0: profile = NULL;
+    }
+    if (profile)
+        gst_caps_set_simple(caps, "profile", G_TYPE_STRING, profile, NULL);
+
+    switch (format->u.h264.level)
+    {
+        case /* eAVEncH264VLevel1 */   10: level = "1";   break;
+        case /* eAVEncH264VLevel1_1 */ 11: level = "1.1"; break;
+        case /* eAVEncH264VLevel1_2 */ 12: level = "1.2"; break;
+        case /* eAVEncH264VLevel1_3 */ 13: level = "1.3"; break;
+        case /* eAVEncH264VLevel2 */   20: level = "2";   break;
+        case /* eAVEncH264VLevel2_1 */ 21: level = "2.1"; break;
+        case /* eAVEncH264VLevel2_2 */ 22: level = "2.2"; break;
+        case /* eAVEncH264VLevel3 */   30: level = "3";   break;
+        case /* eAVEncH264VLevel3_1 */ 31: level = "3.1"; break;
+        case /* eAVEncH264VLevel3_2 */ 32: level = "3.2"; break;
+        case /* eAVEncH264VLevel4 */   40: level = "4";   break;
+        case /* eAVEncH264VLevel4_1 */ 41: level = "4.1"; break;
+        case /* eAVEncH264VLevel4_2 */ 42: level = "4.2"; break;
+        case /* eAVEncH264VLevel5 */   50: level = "5";   break;
+        case /* eAVEncH264VLevel5_1 */ 51: level = "5.1"; break;
+        case /* eAVEncH264VLevel5_2 */ 52: level = "5.2"; break;
+        default:
+            GST_ERROR("Unrecognized H.264 level attribute %u.", format->u.h264.level);
+            /* fallthrough */
+        case 0: level = NULL;
+    }
+    if (level)
+        gst_caps_set_simple(caps, "level", G_TYPE_STRING, level, NULL);
+
+    return caps;
+}
+
+static GstCaps *wg_encoded_format_to_caps(const struct wg_encoded_format *format)
+{
+    switch (format->encoded_type)
+    {
+        case WG_ENCODED_TYPE_UNKNOWN:
+            return NULL;
+        case WG_ENCODED_TYPE_WMA:
+        case WG_ENCODED_TYPE_XMA:
+            return wg_format_to_caps_xwma(format);
+        case WG_ENCODED_TYPE_AAC:
+            return wg_format_to_caps_aac(format);
+        case WG_ENCODED_TYPE_H264:
+            return wg_format_to_caps_h264(format);
+    }
+    assert(0);
+    return NULL;
+}
+
 static GstFlowReturn transform_sink_chain_cb(GstPad *pad, GstObject *parent, GstBuffer *buffer)
 {
     struct wg_transform *transform = gst_pad_get_element_private(pad);
+    struct wg_transform_sample *sample;
 
-    GST_LOG("transform %p, buffer %p.", transform, buffer);
+    GST_INFO("transform %p, buffer %p.", transform, buffer);
 
-    gst_atomic_queue_push(transform->output_queue, buffer);
+    if (!(sample = malloc(sizeof(*sample))))
+        GST_ERROR("Failed to allocate transform sample entry");
+    else
+    {
+        pthread_mutex_lock(&transform->mutex);
+        if (!(sample->sample = gst_sample_new(buffer, transform->sink_caps, NULL, NULL)))
+            GST_ERROR("Failed to allocate transform sample");
+        list_add_tail(&transform->samples, &sample->entry);
+        pthread_mutex_unlock(&transform->mutex);
+    }
 
+    gst_buffer_unref(buffer);
     return GST_FLOW_OK;
 }
 
+static gboolean transform_sink_event_cb(GstPad *pad, GstObject *parent, GstEvent *event)
+{
+    struct wg_transform *transform = gst_pad_get_element_private(pad);
+
+    GST_INFO("transform %p, type \"%s\".", transform, GST_EVENT_TYPE_NAME(event));
+
+    switch (event->type)
+    {
+    case GST_EVENT_CAPS:
+    {
+        GstCaps *caps;
+        gchar *str;
+
+        gst_event_parse_caps(event, &caps);
+        str = gst_caps_to_string(caps);
+        GST_WARNING("Got caps \"%s\".", str);
+        g_free(str);
+
+        pthread_mutex_lock(&transform->mutex);
+        gst_caps_unref(transform->sink_caps);
+        transform->sink_caps = gst_caps_ref(caps);
+        pthread_mutex_unlock(&transform->mutex);
+        break;
+    }
+    default:
+        GST_WARNING("Ignoring \"%s\" event.", GST_EVENT_TYPE_NAME(event));
+    }
+
+    gst_event_unref(event);
+    return TRUE;
+}
+
 NTSTATUS wg_transform_destroy(void *args)
 {
     struct wg_transform *transform = args;
-    GstBuffer *buffer;
+    struct wg_transform_sample *sample, *next;
+
+    if (transform->container)
+        gst_element_set_state(transform->container, GST_STATE_NULL);
 
-    if (transform->input)
-        gst_buffer_list_unref(transform->input);
+    if (transform->their_src && transform->my_sink)
+        gst_pad_unlink(transform->their_src, transform->my_sink);
+    if (transform->their_sink && transform->my_src)
+        gst_pad_unlink(transform->my_src, transform->their_sink);
 
-    gst_element_set_state(transform->container, GST_STATE_NULL);
+    if (transform->their_sink)
+        g_object_unref(transform->their_sink);
+    if (transform->their_src)
+        g_object_unref(transform->their_src);
 
-    if (transform->output_buffer)
-        gst_buffer_unref(transform->output_buffer);
-    while ((buffer = gst_atomic_queue_pop(transform->output_queue)))
-        gst_buffer_unref(buffer);
+    if (transform->container)
+        g_object_unref(transform->container);
 
-    g_object_unref(transform->their_sink);
-    g_object_unref(transform->their_src);
-    g_object_unref(transform->container);
-    g_object_unref(transform->my_sink);
-    g_object_unref(transform->my_src);
-    gst_atomic_queue_unref(transform->output_queue);
-    free(transform);
+    if (transform->my_sink)
+        g_object_unref(transform->my_sink);
+    if (transform->my_src)
+        g_object_unref(transform->my_src);
+
+    LIST_FOR_EACH_ENTRY_SAFE(sample, next, &transform->samples, struct wg_transform_sample, entry)
+    {
+        gst_sample_unref(sample->sample);
+        list_remove(&sample->entry);
+        free(sample);
+    }
 
-    return STATUS_SUCCESS;
+    free(transform);
+    return S_OK;
 }
 
-static GstElement *transform_find_element(GstElementFactoryListType type, GstCaps *src_caps, GstCaps *sink_caps)
+static GstElement *try_create_transform(GstCaps *src_caps, GstCaps *sink_caps)
 {
     GstElement *element = NULL;
     GList *tmp, *transforms;
-    const gchar *name;
+    gchar *type;
 
-    if (!(transforms = gst_element_factory_list_get_elements(type, GST_RANK_MARGINAL)))
-        goto done;
+    transforms = gst_element_factory_list_get_elements(GST_ELEMENT_FACTORY_TYPE_ANY,
+            GST_RANK_MARGINAL);
 
     tmp = gst_element_factory_list_filter(transforms, src_caps, GST_PAD_SINK, FALSE);
     gst_plugin_feature_list_free(transforms);
-    if (!(transforms = tmp))
-        goto done;
+    transforms = tmp;
 
     tmp = gst_element_factory_list_filter(transforms, sink_caps, GST_PAD_SRC, FALSE);
     gst_plugin_feature_list_free(transforms);
-    if (!(transforms = tmp))
-        goto done;
+    transforms = tmp;
 
     transforms = g_list_sort(transforms, gst_plugin_feature_rank_compare_func);
     for (tmp = transforms; tmp != NULL && element == NULL; tmp = tmp->next)
     {
-        name = gst_plugin_feature_get_name(GST_PLUGIN_FEATURE(tmp->data));
-        if (!(element = gst_element_factory_create(GST_ELEMENT_FACTORY(tmp->data), NULL)))
-            GST_WARNING("Failed to create %s element.", name);
+        type = gst_plugin_feature_get_name(GST_PLUGIN_FEATURE(tmp->data));
+        element = gst_element_factory_create(GST_ELEMENT_FACTORY(tmp->data), NULL);
+        if (!element)
+            GST_WARNING("Failed to create %s element.", type);
     }
     gst_plugin_feature_list_free(transforms);
 
-done:
     if (element)
-    {
-        GST_DEBUG("Created %s element %p.", name, element);
-    }
+        GST_INFO("Created %s element %p.", type, element);
     else
     {
         gchar *src_str = gst_caps_to_string(src_caps), *sink_str = gst_caps_to_string(sink_caps);
@@ -139,304 +356,275 @@ static bool transform_append_element(struct wg_transform *transform, GstElement
         GstElement **first, GstElement **last)
 {
     gchar *name = gst_element_get_name(element);
-    bool success = false;
 
-    if (!gst_bin_add(GST_BIN(transform->container), element) ||
-            (*last && !gst_element_link(*last, element)))
+    if (!gst_bin_add(GST_BIN(transform->container), element))
     {
-        GST_ERROR("Failed to link %s element.", name);
+        GST_ERROR("Failed to add %s element to bin.", name);
+        g_free(name);
+        return false;
     }
-    else
+
+    if (*last && !gst_element_link(*last, element))
     {
-        GST_DEBUG("Linked %s element %p.", name, element);
-        if (!*first)
-            *first = element;
-        *last = element;
-        success = true;
+        GST_ERROR("Failed to link %s element.", name);
+        g_free(name);
+        return false;
     }
 
+    GST_INFO("Created %s element %p.", name, element);
     g_free(name);
-    return success;
+
+    if (!*first)
+        *first = element;
+
+    *last = element;
+    return true;
 }
 
 NTSTATUS wg_transform_create(void *args)
 {
     struct wg_transform_create_params *params = args;
-    GstCaps *raw_caps = NULL, *src_caps = NULL, *sink_caps = NULL;
+    struct wg_encoded_format input_format = *params->input_format;
     struct wg_format output_format = *params->output_format;
-    struct wg_format input_format = *params->input_format;
     GstElement *first = NULL, *last = NULL, *element;
-    NTSTATUS status = STATUS_UNSUCCESSFUL;
-    GstPadTemplate *template = NULL;
+    GstCaps *raw_caps, *src_caps, *sink_caps;
     struct wg_transform *transform;
+    GstPadTemplate *template;
     const gchar *media_type;
-    GstEvent *event;
+    GstSegment *segment;
+    int i, ret;
 
     if (!init_gstreamer())
-        return STATUS_UNSUCCESSFUL;
+        return E_FAIL;
 
     if (!(transform = calloc(1, sizeof(*transform))))
-        return STATUS_NO_MEMORY;
-    if (!(transform->container = gst_bin_new("wg_transform")))
-        goto out;
-    if (!(transform->input = gst_buffer_list_new()))
-        goto out;
-    if (!(transform->output_queue = gst_atomic_queue_new(8)))
-        goto out;
-    transform->input_max_length = 1;
-
-    if (!(src_caps = wg_format_to_caps(&input_format)))
-        goto out;
-    if (!(template = gst_pad_template_new("src", GST_PAD_SRC, GST_PAD_ALWAYS, src_caps)))
-        goto out;
+        return E_OUTOFMEMORY;
+
+    list_init(&transform->samples);
+
+    src_caps = wg_encoded_format_to_caps(&input_format);
+    assert(src_caps);
+    sink_caps = wg_format_to_caps(&output_format);
+    assert(sink_caps);
+    media_type = gst_structure_get_name(gst_caps_get_structure(sink_caps, 0));
+    raw_caps = gst_caps_new_empty_simple(media_type);
+    assert(raw_caps);
+
+    transform->sink_caps = gst_caps_copy(sink_caps);
+    transform->container = gst_bin_new("wg_transform");
+    assert(transform->container);
+
+    if (!(element = try_create_transform(src_caps, raw_caps)) ||
+            !transform_append_element(transform, element, &first, &last))
+        goto failed;
+
+    switch (output_format.major_type)
+    {
+    case WG_MAJOR_TYPE_AUDIO:
+        if (!(element = create_element("audioconvert", "base")) ||
+                !transform_append_element(transform, element, &first, &last))
+            goto failed;
+        if (!(element = create_element("audioresample", "base")) ||
+                !transform_append_element(transform, element, &first, &last))
+            goto failed;
+        break;
+    case WG_MAJOR_TYPE_VIDEO:
+        if (!(element = create_element("videoconvert", "base")) ||
+                !transform_append_element(transform, element, &first, &last))
+            goto failed;
+        for (i = 0; i < gst_caps_get_size(sink_caps); ++i)
+            gst_structure_remove_fields(gst_caps_get_structure(sink_caps, i),
+                    "width", "height", NULL);
+        break;
+    default:
+        assert(0);
+        break;
+    }
+
+    if (!(transform->their_sink = gst_element_get_static_pad(first, "sink")))
+    {
+        GST_ERROR("Failed to find target sink pad.");
+        goto failed;
+    }
+    if (!(transform->their_src = gst_element_get_static_pad(last, "src")))
+    {
+        GST_ERROR("Failed to find target src pad.");
+        goto failed;
+    }
+
+    template = gst_pad_template_new("src", GST_PAD_SRC, GST_PAD_ALWAYS, src_caps);
+    assert(template);
     transform->my_src = gst_pad_new_from_template(template, "src");
     g_object_unref(template);
-    if (!transform->my_src)
-        goto out;
+    assert(transform->my_src);
 
-    if (!(sink_caps = wg_format_to_caps(&output_format)))
-        goto out;
-    if (!(template = gst_pad_template_new("sink", GST_PAD_SINK, GST_PAD_ALWAYS, sink_caps)))
-        goto out;
+    template = gst_pad_template_new("sink", GST_PAD_SINK, GST_PAD_ALWAYS, sink_caps);
+    assert(template);
     transform->my_sink = gst_pad_new_from_template(template, "sink");
     g_object_unref(template);
-    if (!transform->my_sink)
-        goto out;
+    assert(transform->my_sink);
 
     gst_pad_set_element_private(transform->my_sink, transform);
+    gst_pad_set_event_function(transform->my_sink, transform_sink_event_cb);
     gst_pad_set_chain_function(transform->my_sink, transform_sink_chain_cb);
 
-    /* Since we append conversion elements, we don't want to filter decoders
-     * based on the actual output caps now. Matching decoders with the
-     * raw output media type should be enough.
-     */
-    media_type = gst_structure_get_name(gst_caps_get_structure(sink_caps, 0));
-    if (!(raw_caps = gst_caps_new_empty_simple(media_type)))
-        goto out;
-
-    switch (input_format.major_type)
-    {
-        case WG_MAJOR_TYPE_H264:
-            /* Call of Duty: Black Ops 3 doesn't care about the ProcessInput/ProcessOutput
-             * return values, it calls them in a specific order and expects the decoder
-             * transform to be able to queue its input buffers. We need to use a buffer list
-             * to match its expectations.
-             */
-            transform->input_max_length = 16;
-            /* fallthrough */
-        case WG_MAJOR_TYPE_WMA:
-            if (!(element = transform_find_element(GST_ELEMENT_FACTORY_TYPE_DECODER, src_caps, raw_caps))
-                    || !transform_append_element(transform, element, &first, &last))
-            {
-                gst_caps_unref(raw_caps);
-                goto out;
-            }
-            break;
-
-        case WG_MAJOR_TYPE_AUDIO:
-        case WG_MAJOR_TYPE_VIDEO:
-        case WG_MAJOR_TYPE_UNKNOWN:
-            GST_FIXME("Format %u not implemented!", input_format.major_type);
-            gst_caps_unref(raw_caps);
-            goto out;
+    if ((ret = gst_pad_link(transform->my_src, transform->their_sink)) < 0)
+    {
+        GST_ERROR("Failed to link sink pads, error %d.", ret);
+        goto failed;
+    }
+    if ((ret = gst_pad_link(transform->their_src, transform->my_sink)) < 0)
+    {
+        GST_ERROR("Failed to link source pads, error %d.", ret);
+        goto failed;
     }
 
-    gst_caps_unref(raw_caps);
+    if (!(ret = gst_pad_set_active(transform->my_sink, 1)))
+        GST_WARNING("Failed to activate my_sink.");
+    if (!(ret = gst_pad_set_active(transform->my_src, 1)))
+        GST_WARNING("Failed to activate my_src.");
 
-    switch (output_format.major_type)
+    gst_element_set_state(transform->container, GST_STATE_PAUSED);
+    ret = gst_element_get_state(transform->container, NULL, NULL, -1);
+    if (ret == GST_STATE_CHANGE_FAILURE)
     {
-        case WG_MAJOR_TYPE_AUDIO:
-            /* The MF audio decoder transforms allow decoding to various formats
-             * as well as resampling the audio at the same time, whereas
-             * GStreamer decoder plugins usually only support decoding to a
-             * single format and at the original rate.
-             *
-             * The WMA decoder transform also has output samples interleaved on
-             * Windows, whereas GStreamer avdec_wmav2 output uses
-             * non-interleaved format.
-             */
-            if (!(element = create_element("audioconvert", "base"))
-                    || !transform_append_element(transform, element, &first, &last))
-                goto out;
-            if (!(element = create_element("audioresample", "base"))
-                    || !transform_append_element(transform, element, &first, &last))
-                goto out;
-            break;
-
-        case WG_MAJOR_TYPE_VIDEO:
-            break;
-
-        case WG_MAJOR_TYPE_H264:
-        case WG_MAJOR_TYPE_WMA:
-        case WG_MAJOR_TYPE_UNKNOWN:
-            GST_FIXME("Format %u not implemented!", output_format.major_type);
-            goto out;
+        GST_ERROR("Failed to play stream.\n");
+        goto failed;
     }
 
-    if (!(transform->their_sink = gst_element_get_static_pad(first, "sink")))
-        goto out;
-    if (!(transform->their_src = gst_element_get_static_pad(last, "src")))
-        goto out;
-    if (gst_pad_link(transform->my_src, transform->their_sink) < 0)
-        goto out;
-    if (gst_pad_link(transform->their_src, transform->my_sink) < 0)
-        goto out;
-    if (!gst_pad_set_active(transform->my_sink, 1))
-        goto out;
-    if (!gst_pad_set_active(transform->my_src, 1))
-        goto out;
+    if (!gst_pad_push_event(transform->my_src, gst_event_new_stream_start("stream")))
+    {
+        GST_ERROR("Failed to send stream-start.");
+        goto failed;
+    }
 
-    gst_element_set_state(transform->container, GST_STATE_PAUSED);
-    if (!gst_element_get_state(transform->container, NULL, NULL, -1))
-        goto out;
-
-    if (!(event = gst_event_new_stream_start("stream"))
-            || !gst_pad_push_event(transform->my_src, event))
-        goto out;
-    if (!(event = gst_event_new_caps(src_caps))
-            || !gst_pad_push_event(transform->my_src, event))
-        goto out;
-
-    /* We need to use GST_FORMAT_TIME here because it's the only format
-     * some elements such avdec_wmav2 correctly support. */
-    gst_segment_init(&transform->segment, GST_FORMAT_TIME);
-    transform->segment.start = 0;
-    transform->segment.stop = -1;
-    if (!(event = gst_event_new_segment(&transform->segment))
-            || !gst_pad_push_event(transform->my_src, event))
-        goto out;
+    if (!gst_pad_push_event(transform->my_src, gst_event_new_caps(src_caps)) ||
+        !gst_pad_has_current_caps(transform->their_sink))
+    {
+        GST_ERROR("Failed to set stream caps.");
+        goto failed;
+    }
 
-    gst_caps_unref(sink_caps);
-    gst_caps_unref(src_caps);
+    segment = gst_segment_new();
+    gst_segment_init(segment, GST_FORMAT_TIME);
+    segment->start = 0;
+    segment->stop = -1;
+    ret = gst_pad_push_event(transform->my_src, gst_event_new_segment(segment));
+    gst_segment_free(segment);
+    if (!ret)
+    {
+        GST_ERROR("Failed to start new segment.");
+        goto failed;
+    }
 
     GST_INFO("Created winegstreamer transform %p.", transform);
     params->transform = transform;
-    return STATUS_SUCCESS;
 
-out:
-    if (transform->their_sink)
-        gst_object_unref(transform->their_sink);
-    if (transform->their_src)
-        gst_object_unref(transform->their_src);
-    if (transform->my_sink)
-        gst_object_unref(transform->my_sink);
-    if (sink_caps)
-        gst_caps_unref(sink_caps);
-    if (transform->my_src)
-        gst_object_unref(transform->my_src);
-    if (src_caps)
-        gst_caps_unref(src_caps);
-    if (transform->output_queue)
-        gst_atomic_queue_unref(transform->output_queue);
-    if (transform->input)
-        gst_buffer_list_unref(transform->input);
-    if (transform->container)
-    {
-        gst_element_set_state(transform->container, GST_STATE_NULL);
-        gst_object_unref(transform->container);
-    }
-    free(transform);
-    GST_ERROR("Failed to create winegstreamer transform.");
-    return status;
+failed:
+    gst_caps_unref(raw_caps);
+    gst_caps_unref(src_caps);
+    gst_caps_unref(sink_caps);
+
+    if (params->transform)
+        return S_OK;
+
+    wg_transform_destroy(transform);
+    return E_FAIL;
 }
 
 NTSTATUS wg_transform_push_data(void *args)
 {
     struct wg_transform_push_data_params *params = args;
     struct wg_transform *transform = params->transform;
-    struct wg_sample *sample = params->sample;
     GstBuffer *buffer;
-    guint length;
+    GstFlowReturn ret;
 
-    length = gst_buffer_list_length(transform->input);
-    if (length >= transform->input_max_length)
-    {
-        GST_INFO("Refusing %u bytes, %u buffers already queued", sample->size, length);
-        params->result = MF_E_NOTACCEPTING;
-        return STATUS_SUCCESS;
-    }
+    buffer = gst_buffer_new_and_alloc(params->size);
+    gst_buffer_fill(buffer, 0, params->data, params->size);
 
-    if (!(buffer = gst_buffer_new_and_alloc(sample->size)))
+    ret = gst_pad_push(transform->my_src, buffer);
+    if (ret)
     {
-        GST_ERROR("Failed to allocate input buffer");
-        return STATUS_NO_MEMORY;
+        GST_ERROR("Failed to push buffer %d", ret);
+        return MF_E_NOTACCEPTING;
     }
-    gst_buffer_fill(buffer, 0, sample->data, sample->size);
-    gst_buffer_list_insert(transform->input, -1, buffer);
 
-    GST_INFO("Copied %u bytes from sample %p to input buffer list", sample->size, sample);
-    params->result = S_OK;
-    return STATUS_SUCCESS;
+    GST_INFO("Pushed %u bytes", params->size);
+    return S_OK;
 }
 
-static NTSTATUS read_transform_output_data(GstBuffer *buffer, struct wg_sample *sample)
+NTSTATUS wg_transform_read_data(void *args)
 {
+    struct wg_transform_read_data_params *params = args;
+    struct wg_transform *transform = params->transform;
+    struct wg_sample *read_sample = params->sample;
+    struct wg_transform_sample *transform_sample;
+    struct wg_format buffer_format;
+    bool broken_timestamp = false;
+    GstBuffer *buffer;
+    struct list *head;
     GstMapInfo info;
+    GstCaps *caps;
 
-    if (!gst_buffer_map(buffer, &info, GST_MAP_READ))
+    pthread_mutex_lock(&transform->mutex);
+    if (!(head = list_head(&transform->samples)))
     {
-        GST_ERROR("Failed to map buffer %p", buffer);
-        return STATUS_UNSUCCESSFUL;
+        pthread_mutex_unlock(&transform->mutex);
+        return MF_E_TRANSFORM_NEED_MORE_INPUT;
     }
 
-    if (sample->max_size >= info.size)
-        sample->size = info.size;
-    else
+    transform_sample = LIST_ENTRY(head, struct wg_transform_sample, entry);
+    buffer = gst_sample_get_buffer(transform_sample->sample);
+
+    if (read_sample->format)
     {
-        sample->flags |= WG_SAMPLE_FLAG_INCOMPLETE;
-        sample->size = sample->max_size;
+        if (!(caps = gst_sample_get_caps(transform_sample->sample)))
+            caps = transform->sink_caps;
+        wg_format_from_caps(&buffer_format, caps);
+        if (!wg_format_compare(read_sample->format, &buffer_format))
+        {
+            *read_sample->format = buffer_format;
+            read_sample->size = gst_buffer_get_size(buffer);
+            pthread_mutex_unlock(&transform->mutex);
+            return MF_E_TRANSFORM_STREAM_CHANGE;
+        }
+
+        if (buffer_format.major_type == WG_MAJOR_TYPE_VIDEO
+                && buffer_format.u.video.fps_n <= 1
+                && buffer_format.u.video.fps_d <= 1)
+            broken_timestamp = true;
     }
 
-    memcpy(sample->data, info.data, sample->size);
+    gst_buffer_map(buffer, &info, GST_MAP_READ);
+    if (read_sample->size > info.size)
+        read_sample->size = info.size;
+    memcpy(read_sample->data, info.data, read_sample->size);
     gst_buffer_unmap(buffer, &info);
-    gst_buffer_resize(buffer, sample->size, -1);
-
-    GST_INFO("Copied %u bytes, sample %p, flags %#x", sample->size, sample, sample->flags);
-    return STATUS_SUCCESS;
-}
-
-NTSTATUS wg_transform_read_data(void *args)
-{
-    struct wg_transform_read_data_params *params = args;
-    struct wg_transform *transform = params->transform;
-    struct wg_sample *sample = params->sample;
-    GstBufferList *input = transform->input;
-    GstFlowReturn ret;
-    NTSTATUS status;
 
-    if (!gst_buffer_list_length(transform->input))
-        GST_DEBUG("Not input buffer queued");
-    else if (!(transform->input = gst_buffer_list_new()))
+    if (buffer->pts != GST_CLOCK_TIME_NONE && !broken_timestamp)
     {
-        GST_ERROR("Failed to allocate new input queue");
-        return STATUS_NO_MEMORY;
+        read_sample->flags |= WG_SAMPLE_FLAG_HAS_PTS;
+        read_sample->pts = buffer->pts / 100;
     }
-    else if ((ret = gst_pad_push_list(transform->my_src, input)))
+    if (buffer->duration != GST_CLOCK_TIME_NONE && !broken_timestamp)
     {
-        GST_ERROR("Failed to push transform input, error %d", ret);
-        return STATUS_UNSUCCESSFUL;
+        read_sample->flags |= WG_SAMPLE_FLAG_HAS_DURATION;
+        read_sample->duration = buffer->duration / 100;
     }
 
-    if (!transform->output_buffer && !(transform->output_buffer = gst_atomic_queue_pop(transform->output_queue)))
+    if (info.size > read_sample->size)
     {
-        sample->size = 0;
-        params->result = MF_E_TRANSFORM_NEED_MORE_INPUT;
-        GST_INFO("Cannot read %u bytes, no output available", sample->max_size);
-        return STATUS_SUCCESS;
+        read_sample->flags |= WG_SAMPLE_FLAG_INCOMPLETE;
+        gst_buffer_resize(buffer, read_sample->size, -1);
     }
-
-    if ((status = read_transform_output_data(transform->output_buffer, sample)))
-    {
-        sample->size = 0;
-        return status;
-    }
-
-    if (!(sample->flags & WG_SAMPLE_FLAG_INCOMPLETE))
+    else
     {
-        gst_buffer_unref(transform->output_buffer);
-        transform->output_buffer = NULL;
+        gst_sample_unref(transform_sample->sample);
+        list_remove(&transform_sample->entry);
+        free(transform_sample);
     }
+    pthread_mutex_unlock(&transform->mutex);
 
-    params->result = S_OK;
-    return STATUS_SUCCESS;
+    GST_INFO("Read %u bytes, flags %#x", read_sample->size, read_sample->flags);
+    return S_OK;
 }
diff --git a/dlls/winegstreamer/winegstreamer_classes.idl b/dlls/winegstreamer/winegstreamer_classes.idl
index 347ee906a52..5762430a5cd 100644
--- wine/dlls/winegstreamer/winegstreamer_classes.idl
+++ wine/dlls/winegstreamer/winegstreamer_classes.idl
@@ -78,4 +78,16 @@ coclass CWMADecMediaObject {};
     threading(both),
     uuid(62ce7e72-4c71-4d20-b15d-452831a87d9d)
 ]
-coclass CMSH264DecoderMFT {}
+coclass CMSH264DecoderMFT { }
+
+[
+    threading(both),
+    uuid(32d186a7-218f-4c75-8876-dd77273a8999)
+]
+coclass CMSAACDecMFT { }
+
+[
+    threading(both),
+    uuid(98230571-0087-4204-b020-3282538e57d3)
+]
+coclass CColorConvertDMO { }
diff --git a/dlls/winegstreamer/wm_asyncreader.c b/dlls/winegstreamer/wm_asyncreader.c
index 947b3307a3a..a7ad6a6c45c 100644
--- wine/dlls/winegstreamer/wm_asyncreader.c
+++ wine/dlls/winegstreamer/wm_asyncreader.c
@@ -66,7 +66,7 @@ static void open_stream(struct async_reader *reader, IWMReaderCallback *callback
     if (FAILED(hr = IWMReaderCallback_QueryInterface(callback,
             &IID_IWMReaderCallbackAdvanced, (void **)&reader->reader.callback_advanced)))
         reader->reader.callback_advanced = NULL;
-    TRACE("Querying for IWMReaderCallbackAdvanced returned %#lx.\n", hr);
+    TRACE("Querying for IWMReaderCallbackAdvanced returned %#x.\n", hr);
 }
 
 static DWORD WINAPI stream_thread(void *arg)
@@ -133,7 +133,7 @@ static DWORD WINAPI stream_thread(void *arg)
             else
                 hr = IWMReaderCallback_OnSample(callback, stream_number - 1, pts, duration,
                         flags, sample, reader->context);
-            TRACE("Callback returned %#lx.\n", hr);
+            TRACE("Callback returned %#x.\n", hr);
             INSSBuffer_Release(sample);
         }
         else if (hr == NS_E_NO_MORE_SAMPLES)
@@ -158,7 +158,7 @@ static DWORD WINAPI stream_thread(void *arg)
         }
         else
         {
-            ERR("Failed to get sample, hr %#lx.\n", hr);
+            ERR("Failed to get sample, hr %#x.\n", hr);
             LeaveCriticalSection(&reader->stream_cs);
             return 0;
         }
@@ -271,7 +271,7 @@ static HRESULT WINAPI WMReader_GetOutputProps(IWMReader *iface, DWORD output, IW
 {
     struct async_reader *reader = impl_from_IWMReader(iface);
 
-    TRACE("reader %p, output %lu, props %p.\n", reader, output, props);
+    TRACE("reader %p, output %u, props %p.\n", reader, output, props);
 
     return wm_reader_get_output_props(&reader->reader, output, props);
 }
@@ -280,7 +280,7 @@ static HRESULT WINAPI WMReader_SetOutputProps(IWMReader *iface, DWORD output, IW
 {
     struct async_reader *reader = impl_from_IWMReader(iface);
 
-    TRACE("reader %p, output %lu, props %p.\n", reader, output, props);
+    TRACE("reader %p, output %u, props %p.\n", reader, output, props);
 
     return wm_reader_set_output_props(&reader->reader, output, props);
 }
@@ -289,7 +289,7 @@ static HRESULT WINAPI WMReader_GetOutputFormatCount(IWMReader *iface, DWORD outp
 {
     struct async_reader *reader = impl_from_IWMReader(iface);
 
-    TRACE("reader %p, output %lu, count %p.\n", reader, output, count);
+    TRACE("reader %p, output %u, count %p.\n", reader, output, count);
 
     return wm_reader_get_output_format_count(&reader->reader, output, count);
 }
@@ -299,7 +299,7 @@ static HRESULT WINAPI WMReader_GetOutputFormat(IWMReader *iface, DWORD output,
 {
     struct async_reader *reader = impl_from_IWMReader(iface);
 
-    TRACE("reader %p, output %lu, index %lu, props %p.\n", reader, output, index, props);
+    TRACE("reader %p, output %u, index %u, props %p.\n", reader, output, index, props);
 
     return wm_reader_get_output_format(&reader->reader, output, index, props);
 }
@@ -530,17 +530,15 @@ static HRESULT WINAPI WMReaderAdvanced_SetAllocateForOutput(IWMReaderAdvanced6 *
 {
     struct async_reader *reader = impl_from_IWMReaderAdvanced6(iface);
 
-    TRACE("reader %p, output %lu, allocate %d.\n", reader, output, allocate);
+    TRACE("reader %p, output %u, allocate %d.\n", reader, output, allocate);
 
     return wm_reader_set_allocate_for_output(&reader->reader, output, allocate);
 }
 
 static HRESULT WINAPI WMReaderAdvanced_GetAllocateForOutput(IWMReaderAdvanced6 *iface, DWORD output_num, BOOL *allocate)
 {
-    struct async_reader *reader = impl_from_IWMReaderAdvanced6(iface);
-
-    FIXME("reader %p, output %lu, allocate %p, stub!\n", reader, output_num, allocate);
-
+    struct async_reader *This = impl_from_IWMReaderAdvanced6(iface);
+    FIXME("(%p)->(%d %p)\n", This, output_num, allocate);
     return E_NOTIMPL;
 }
 
@@ -578,7 +576,7 @@ static HRESULT WINAPI WMReaderAdvanced_SetClientInfo(IWMReaderAdvanced6 *iface,
 static HRESULT WINAPI WMReaderAdvanced_GetMaxOutputSampleSize(IWMReaderAdvanced6 *iface, DWORD output, DWORD *max)
 {
     struct async_reader *This = impl_from_IWMReaderAdvanced6(iface);
-    FIXME("(%p)->(%lu %p)\n", This, output, max);
+    FIXME("(%p)->(%d %p)\n", This, output, max);
     return E_NOTIMPL;
 }
 
@@ -661,7 +659,7 @@ static HRESULT WINAPI WMReaderAdvanced2_GetOutputSetting(IWMReaderAdvanced6 *ifa
         const WCHAR *name, WMT_ATTR_DATATYPE *type, BYTE *value, WORD *length)
 {
     struct async_reader *This = impl_from_IWMReaderAdvanced6(iface);
-    FIXME("(%p)->(%lu %s %p %p %p)\n", This, output_num, debugstr_w(name), type, value, length);
+    FIXME("(%p)->(%d %s %p %p %p)\n", This, output_num, debugstr_w(name), type, value, length);
     return E_NOTIMPL;
 }
 
@@ -669,7 +667,7 @@ static HRESULT WINAPI WMReaderAdvanced2_SetOutputSetting(IWMReaderAdvanced6 *ifa
         const WCHAR *name, WMT_ATTR_DATATYPE type, const BYTE *value, WORD length)
 {
     struct async_reader *This = impl_from_IWMReaderAdvanced6(iface);
-    FIXME("(%p)->(%lu %s %#x %p %u)\n", This, output_num, debugstr_w(name), type, value, length);
+    FIXME("(%p)->(%d %s %d %p %d)\n", This, output_num, debugstr_w(name), type, value, length);
     return E_NOTIMPL;
 }
 
@@ -736,18 +734,15 @@ static HRESULT WINAPI WMReaderAdvanced3_StartAtPosition(IWMReaderAdvanced6 *ifac
 static HRESULT WINAPI WMReaderAdvanced4_GetLanguageCount(IWMReaderAdvanced6 *iface, DWORD output_num, WORD *language_count)
 {
     struct async_reader *This = impl_from_IWMReaderAdvanced6(iface);
-    FIXME("(%p)->(%lu %p)\n", This, output_num, language_count);
+    FIXME("(%p)->(%d %p)\n", This, output_num, language_count);
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI WMReaderAdvanced4_GetLanguage(IWMReaderAdvanced6 *iface, DWORD output_num,
        WORD language, WCHAR *language_string, WORD *language_string_len)
 {
-    struct async_reader *reader = impl_from_IWMReaderAdvanced6(iface);
-
-    FIXME("reader %p, output %lu, language %#x, language_string %p, language_string_len %p, stub!\n",
-            reader, output_num, language, language_string, language_string_len);
-
+    struct async_reader *This = impl_from_IWMReaderAdvanced6(iface);
+    FIXME("(%p)->(%d %x %p %p)\n", This, output_num, language, language_string, language_string_len);
     return E_NOTIMPL;
 }
 
@@ -803,21 +798,17 @@ static HRESULT WINAPI WMReaderAdvanced4_GetURL(IWMReaderAdvanced6 *iface, WCHAR
 
 static HRESULT WINAPI WMReaderAdvanced5_SetPlayerHook(IWMReaderAdvanced6 *iface, DWORD output_num, IWMPlayerHook *hook)
 {
-    struct async_reader *reader = impl_from_IWMReaderAdvanced6(iface);
-
-    FIXME("reader %p, output %lu, hook %p, stub!\n", reader, output_num, hook);
-
+    struct async_reader *This = impl_from_IWMReaderAdvanced6(iface);
+    FIXME("(%p)->(%d %p)\n", This, output_num, hook);
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI WMReaderAdvanced6_SetProtectStreamSamples(IWMReaderAdvanced6 *iface, BYTE *cert,
         DWORD cert_size, DWORD cert_type, DWORD flags, BYTE *initialization_vector, DWORD *initialization_vector_size)
 {
-    struct async_reader *reader = impl_from_IWMReaderAdvanced6(iface);
-
-    FIXME("reader %p, cert %p, cert_size %lu, cert_type %#lx, flags %#lx, vector %p, vector_size %p, stub!\n",
-            reader, cert, cert_size, cert_type, flags, initialization_vector, initialization_vector_size);
-
+    struct async_reader *This = impl_from_IWMReaderAdvanced6(iface);
+    FIXME("(%p)->(%p %d %d %x %p %p)\n", This, cert, cert_size, cert_type, flags, initialization_vector,
+          initialization_vector_size);
     return E_NOTIMPL;
 }
 
@@ -900,18 +891,18 @@ static ULONG WINAPI reader_accl_Release(IWMReaderAccelerator *iface)
 
 static HRESULT WINAPI reader_accl_GetCodecInterface(IWMReaderAccelerator *iface, DWORD output, REFIID riid, void **codec)
 {
-    struct async_reader *reader = impl_from_IWMReaderAccelerator(iface);
+    struct async_reader *This = impl_from_IWMReaderAccelerator(iface);
 
-    FIXME("reader %p, output %lu, iid %s, codec %p, stub!\n", reader, output, debugstr_guid(riid), codec);
+    FIXME("%p, %d, %s, %p\n", This, output, debugstr_guid(riid), codec);
 
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI reader_accl_Notify(IWMReaderAccelerator *iface, DWORD output, WM_MEDIA_TYPE *subtype)
 {
-    struct async_reader *reader = impl_from_IWMReaderAccelerator(iface);
+    struct async_reader *This = impl_from_IWMReaderAccelerator(iface);
 
-    FIXME("reader %p, output %lu, subtype %p, stub!\n", reader, output, subtype);
+    FIXME("%p, %d, %p\n", This, output, subtype);
 
     return E_NOTIMPL;
 }
@@ -969,13 +960,11 @@ static HRESULT WINAPI networkconfig_GetUDPPortRanges(IWMReaderNetworkConfig2 *if
     return E_NOTIMPL;
 }
 
-static HRESULT WINAPI networkconfig_SetUDPPortRanges(IWMReaderNetworkConfig2 *iface,
-        WM_PORT_NUMBER_RANGE *ranges, DWORD count)
+static HRESULT WINAPI networkconfig_SetUDPPortRanges(IWMReaderNetworkConfig2 *iface, WM_PORT_NUMBER_RANGE *array,
+        DWORD ranges)
 {
-    struct async_reader *reader = impl_from_IWMReaderNetworkConfig2(iface);
-
-    FIXME("reader %p, ranges %p, count %lu.\n", reader, ranges, count);
-
+    struct async_reader *This = impl_from_IWMReaderNetworkConfig2(iface);
+    FIXME("%p, %p, %u\n", This, array, ranges);
     return E_NOTIMPL;
 }
 
@@ -1022,10 +1011,8 @@ static HRESULT WINAPI networkconfig_GetProxyPort(IWMReaderNetworkConfig2 *iface,
 static HRESULT WINAPI networkconfig_SetProxyPort(IWMReaderNetworkConfig2 *iface, const WCHAR *protocol,
         DWORD port)
 {
-    struct async_reader *reader = impl_from_IWMReaderNetworkConfig2(iface);
-
-    FIXME("reader %p, protocol %s, port %lu, stub!\n", reader, debugstr_w(protocol), port);
-
+    struct async_reader *This = impl_from_IWMReaderNetworkConfig2(iface);
+    FIXME("%p, %s, %u\n", This, debugstr_w(protocol), port);
     return E_NOTIMPL;
 }
 
@@ -1149,10 +1136,8 @@ static HRESULT WINAPI networkconfig_GetConnectionBandwidth(IWMReaderNetworkConfi
 
 static HRESULT WINAPI networkconfig_SetConnectionBandwidth(IWMReaderNetworkConfig2 *iface, DWORD bandwidth)
 {
-    struct async_reader *reader = impl_from_IWMReaderNetworkConfig2(iface);
-
-    FIXME("reader %p, bandwidth %lu, stub!\n", reader, bandwidth);
-
+    struct async_reader *This = impl_from_IWMReaderNetworkConfig2(iface);
+    FIXME("%p, %u\n", This, bandwidth);
     return E_NOTIMPL;
 }
 
@@ -1166,10 +1151,8 @@ static HRESULT WINAPI networkconfig_GetNumProtocolsSupported(IWMReaderNetworkCon
 static HRESULT WINAPI networkconfig_GetSupportedProtocolName(IWMReaderNetworkConfig2 *iface, DWORD protocol_num,
         WCHAR *protocol, DWORD *size)
 {
-    struct async_reader *reader = impl_from_IWMReaderNetworkConfig2(iface);
-
-    FIXME("reader %p, index %lu, protocol %p, size %p, stub!\n", reader, protocol_num, protocol, size);
-
+    struct async_reader *This = impl_from_IWMReaderNetworkConfig2(iface);
+    FIXME("%p, %u, %p %p\n", This, protocol_num, protocol, size);
     return E_NOTIMPL;
 }
 
@@ -1183,10 +1166,8 @@ static HRESULT WINAPI networkconfig_AddLoggingUrl(IWMReaderNetworkConfig2 *iface
 static HRESULT WINAPI networkconfig_GetLoggingUrl(IWMReaderNetworkConfig2 *iface, DWORD index, WCHAR *url,
         DWORD *size)
 {
-    struct async_reader *reader = impl_from_IWMReaderNetworkConfig2(iface);
-
-    FIXME("reader %p, index %lu, url %p, size %p, stub!\n", reader, index, url, size);
-
+    struct async_reader *This = impl_from_IWMReaderNetworkConfig2(iface);
+    FIXME("%p, %u, %p, %p\n", This, index, url, size);
     return E_NOTIMPL;
 }
 
@@ -1257,10 +1238,8 @@ static HRESULT WINAPI networkconfig_GetAutoReconnectLimit(IWMReaderNetworkConfig
 
 static HRESULT WINAPI networkconfig_SetAutoReconnectLimit(IWMReaderNetworkConfig2 *iface, DWORD limit)
 {
-    struct async_reader *reader = impl_from_IWMReaderNetworkConfig2(iface);
-
-    FIXME("reader %p, limit %lu, stub!\n", reader, limit);
-
+    struct async_reader *This = impl_from_IWMReaderNetworkConfig2(iface);
+    FIXME("%p, %u\n", This, limit);
     return E_NOTIMPL;
 }
 
@@ -1391,10 +1370,8 @@ static HRESULT WINAPI readclock_SetTimer(IWMReaderStreamClock *iface, QWORD when
 
 static HRESULT WINAPI readclock_KillTimer(IWMReaderStreamClock *iface, DWORD id)
 {
-    struct async_reader *reader = impl_from_IWMReaderStreamClock(iface);
-
-    FIXME("reader %p, id %lu, stub!\n", reader, id);
-
+    struct async_reader *This = impl_from_IWMReaderStreamClock(iface);
+    FIXME("%p, %d\n", This, id);
     return E_NOTIMPL;
 }
 
@@ -1433,10 +1410,8 @@ static ULONG WINAPI negotiation_Release(IWMReaderTypeNegotiation *iface)
 
 static HRESULT WINAPI negotiation_TryOutputProps(IWMReaderTypeNegotiation *iface, DWORD output, IWMOutputMediaProps *props)
 {
-    struct async_reader *reader = impl_from_IWMReaderTypeNegotiation(iface);
-
-    FIXME("reader %p, output %lu, props %p, stub!\n", reader, output, props);
-
+    struct async_reader *This = impl_from_IWMReaderTypeNegotiation(iface);
+    FIXME("%p, %d, %p\n", This, output, props);
     return E_NOTIMPL;
 }
 
@@ -1481,31 +1456,25 @@ static HRESULT WINAPI refclock_GetTime(IReferenceClock *iface, REFERENCE_TIME *t
 static HRESULT WINAPI refclock_AdviseTime(IReferenceClock *iface, REFERENCE_TIME basetime,
         REFERENCE_TIME streamtime, HEVENT event, DWORD_PTR *cookie)
 {
-    struct async_reader *reader = impl_from_IReferenceClock(iface);
-
-    FIXME("reader %p, basetime %s, streamtime %s, event %#Ix, cookie %p, stub!\n",
-            reader, debugstr_time(basetime), debugstr_time(streamtime), event, cookie);
-
+    struct async_reader *This = impl_from_IReferenceClock(iface);
+    FIXME("%p, %s, %s, %lu, %p\n", This, wine_dbgstr_longlong(basetime),
+            wine_dbgstr_longlong(streamtime), event, cookie);
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI refclock_AdvisePeriodic(IReferenceClock *iface, REFERENCE_TIME starttime,
         REFERENCE_TIME period, HSEMAPHORE semaphore, DWORD_PTR *cookie)
 {
-    struct async_reader *reader = impl_from_IReferenceClock(iface);
-
-    FIXME("reader %p, starttime %s, period %s, semaphore %#Ix, cookie %p, stub!\n",
-            reader, debugstr_time(starttime), debugstr_time(period), semaphore, cookie);
-
+    struct async_reader *This = impl_from_IReferenceClock(iface);
+    FIXME("%p, %s, %s, %lu, %p\n", This, wine_dbgstr_longlong(starttime),
+            wine_dbgstr_longlong(period), semaphore, cookie);
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI refclock_Unadvise(IReferenceClock *iface, DWORD_PTR cookie)
 {
-    struct async_reader *reader = impl_from_IReferenceClock(iface);
-
-    FIXME("reader %p, cookie %Iu, stub!\n", reader, cookie);
-
+    struct async_reader *This = impl_from_IReferenceClock(iface);
+    FIXME("%p, %lu\n", This, cookie);
     return E_NOTIMPL;
 }
 
diff --git a/dlls/winegstreamer/wm_reader.c b/dlls/winegstreamer/wm_reader.c
index 57ba8633a84..cb667c957b4 100644
--- wine/dlls/winegstreamer/wm_reader.c
+++ wine/dlls/winegstreamer/wm_reader.c
@@ -24,7 +24,7 @@ static struct wm_stream *get_stream_by_output_number(struct wm_reader *reader, D
 {
     if (output < reader->stream_count)
         return &reader->streams[output];
-    WARN("Invalid output number %lu.\n", output);
+    WARN("Invalid output number %u.\n", output);
     return NULL;
 }
 
@@ -65,7 +65,7 @@ static ULONG WINAPI output_props_AddRef(IWMOutputMediaProps *iface)
     struct output_props *props = impl_from_IWMOutputMediaProps(iface);
     ULONG refcount = InterlockedIncrement(&props->refcount);
 
-    TRACE("%p increasing refcount to %lu.\n", props, refcount);
+    TRACE("%p increasing refcount to %u.\n", props, refcount);
 
     return refcount;
 }
@@ -75,7 +75,7 @@ static ULONG WINAPI output_props_Release(IWMOutputMediaProps *iface)
     struct output_props *props = impl_from_IWMOutputMediaProps(iface);
     ULONG refcount = InterlockedDecrement(&props->refcount);
 
-    TRACE("%p decreasing refcount to %lu.\n", props, refcount);
+    TRACE("%p decreasing refcount to %u.\n", props, refcount);
 
     if (!refcount)
         free(props);
@@ -209,7 +209,7 @@ static ULONG WINAPI buffer_AddRef(INSSBuffer *iface)
     struct buffer *buffer = impl_from_INSSBuffer(iface);
     ULONG refcount = InterlockedIncrement(&buffer->refcount);
 
-    TRACE("%p increasing refcount to %lu.\n", buffer, refcount);
+    TRACE("%p increasing refcount to %u.\n", buffer, refcount);
 
     return refcount;
 }
@@ -219,7 +219,7 @@ static ULONG WINAPI buffer_Release(INSSBuffer *iface)
     struct buffer *buffer = impl_from_INSSBuffer(iface);
     ULONG refcount = InterlockedDecrement(&buffer->refcount);
 
-    TRACE("%p decreasing refcount to %lu.\n", buffer, refcount);
+    TRACE("%p decreasing refcount to %u.\n", buffer, refcount);
 
     if (!refcount)
         free(buffer);
@@ -237,7 +237,7 @@ static HRESULT WINAPI buffer_SetLength(INSSBuffer *iface, DWORD size)
 {
     struct buffer *buffer = impl_from_INSSBuffer(iface);
 
-    TRACE("iface %p, size %lu.\n", buffer, size);
+    TRACE("iface %p, size %u.\n", buffer, size);
 
     if (size > buffer->capacity)
         return E_INVALIDARG;
@@ -329,7 +329,7 @@ static ULONG WINAPI stream_config_AddRef(IWMStreamConfig *iface)
     struct stream_config *config = impl_from_IWMStreamConfig(iface);
     ULONG refcount = InterlockedIncrement(&config->refcount);
 
-    TRACE("%p increasing refcount to %lu.\n", config, refcount);
+    TRACE("%p increasing refcount to %u.\n", config, refcount);
 
     return refcount;
 }
@@ -339,7 +339,7 @@ static ULONG WINAPI stream_config_Release(IWMStreamConfig *iface)
     struct stream_config *config = impl_from_IWMStreamConfig(iface);
     ULONG refcount = InterlockedDecrement(&config->refcount);
 
-    TRACE("%p decreasing refcount to %lu.\n", config, refcount);
+    TRACE("%p decreasing refcount to %u.\n", config, refcount);
 
     if (!refcount)
     {
@@ -422,7 +422,7 @@ static HRESULT WINAPI stream_config_GetBitrate(IWMStreamConfig *iface, DWORD *bi
 
 static HRESULT WINAPI stream_config_SetBitrate(IWMStreamConfig *iface, DWORD bitrate)
 {
-    FIXME("iface %p, bitrate %lu, stub!\n", iface, bitrate);
+    FIXME("iface %p, bitrate %u, stub!\n", iface, bitrate);
     return E_NOTIMPL;
 }
 
@@ -434,7 +434,7 @@ static HRESULT WINAPI stream_config_GetBufferWindow(IWMStreamConfig *iface, DWOR
 
 static HRESULT WINAPI stream_config_SetBufferWindow(IWMStreamConfig *iface, DWORD window)
 {
-    FIXME("iface %p, window %lu, stub!\n", iface, window);
+    FIXME("iface %p, window %u, stub!\n", iface, window);
     return E_NOTIMPL;
 }
 
@@ -573,7 +573,7 @@ static DWORD CALLBACK read_thread(void *arg)
 
         if (!size)
         {
-            wg_parser_push_data(reader->wg_parser, data, 0);
+            wg_parser_push_data(reader->wg_parser, WG_READ_SUCCESS, data, 0);
             continue;
         }
 
@@ -591,8 +591,8 @@ static DWORD CALLBACK read_thread(void *arg)
             if (!SetFilePointerEx(file, large_offset, NULL, FILE_BEGIN)
                     || !ReadFile(file, data, size, &ret_size, NULL))
             {
-                ERR("Failed to read %u bytes at offset %I64u, error %lu.\n", size, offset, GetLastError());
-                wg_parser_push_data(reader->wg_parser, NULL, 0);
+                ERR("Failed to read %u bytes at offset %I64u, error %u.\n", size, offset, GetLastError());
+                wg_parser_push_data(reader->wg_parser, WG_READ_FAILURE, NULL, 0);
                 continue;
             }
         }
@@ -602,15 +602,15 @@ static DWORD CALLBACK read_thread(void *arg)
                 hr = IStream_Read(stream, data, size, &ret_size);
             if (FAILED(hr))
             {
-                ERR("Failed to read %u bytes at offset %I64u, hr %#lx.\n", size, offset, hr);
-                wg_parser_push_data(reader->wg_parser, NULL, 0);
+                ERR("Failed to read %u bytes at offset %I64u, hr %#x.\n", size, offset, hr);
+                wg_parser_push_data(reader->wg_parser, WG_READ_FAILURE, NULL, 0);
                 continue;
             }
         }
 
         if (ret_size != size)
-            ERR("Unexpected short read: requested %u bytes, got %lu.\n", size, ret_size);
-        wg_parser_push_data(reader->wg_parser, data, ret_size);
+            ERR("Unexpected short read: requested %u bytes, got %u.\n", size, ret_size);
+        wg_parser_push_data(reader->wg_parser, WG_READ_SUCCESS, data, ret_size);
     }
 
     free(data);
@@ -674,7 +674,7 @@ static ULONG WINAPI profile_AddRef(IWMProfile3 *iface)
     struct wm_reader *reader = impl_from_IWMProfile3(iface);
     ULONG refcount = InterlockedIncrement(&reader->refcount);
 
-    TRACE("%p increasing refcount to %lu.\n", reader, refcount);
+    TRACE("%p increasing refcount to %u.\n", reader, refcount);
 
     return refcount;
 }
@@ -684,7 +684,7 @@ static ULONG WINAPI profile_Release(IWMProfile3 *iface)
     struct wm_reader *reader = impl_from_IWMProfile3(iface);
     ULONG refcount = InterlockedDecrement(&reader->refcount);
 
-    TRACE("%p decreasing refcount to %lu.\n", reader, refcount);
+    TRACE("%p decreasing refcount to %u.\n", reader, refcount);
 
     if (!refcount)
         reader->ops->destroy(reader);
@@ -742,14 +742,14 @@ static HRESULT WINAPI profile_GetStream(IWMProfile3 *iface, DWORD index, IWMStre
     struct wm_reader *reader = impl_from_IWMProfile3(iface);
     struct stream_config *object;
 
-    TRACE("reader %p, index %lu, config %p.\n", reader, index, config);
+    TRACE("reader %p, index %u, config %p.\n", reader, index, config);
 
     EnterCriticalSection(&reader->cs);
 
     if (index >= reader->stream_count)
     {
         LeaveCriticalSection(&reader->cs);
-        WARN("Index %lu exceeds stream count %u; returning E_INVALIDARG.\n", index, reader->stream_count);
+        WARN("Index %u exceeds stream count %u; returning E_INVALIDARG.\n", index, reader->stream_count);
         return E_INVALIDARG;
     }
 
@@ -816,7 +816,7 @@ static HRESULT WINAPI profile_GetMutualExclusionCount(IWMProfile3 *iface, DWORD
 
 static HRESULT WINAPI profile_GetMutualExclusion(IWMProfile3 *iface, DWORD index, IWMMutualExclusion **excl)
 {
-    FIXME("iface %p, index %lu, excl %p, stub!\n", iface, index, excl);
+    FIXME("iface %p, index %u, excl %p, stub!\n", iface, index, excl);
     return E_NOTIMPL;
 }
 
@@ -864,7 +864,7 @@ static HRESULT WINAPI profile_GetBandwidthSharingCount(IWMProfile3 *iface, DWORD
 
 static HRESULT WINAPI profile_GetBandwidthSharing(IWMProfile3 *iface, DWORD index, IWMBandwidthSharing **sharing)
 {
-    FIXME("iface %p, index %lu, sharing %p, stub!\n", iface, index, sharing);
+    FIXME("iface %p, index %d, sharing %p, stub!\n", iface, index, sharing);
     return E_NOTIMPL;
 }
 
@@ -1131,7 +1131,7 @@ static HRESULT WINAPI header_info_GetCodecInfoCount(IWMHeaderInfo3 *iface, DWORD
 static HRESULT WINAPI header_info_GetCodecInfo(IWMHeaderInfo3 *iface, DWORD index, WORD *name_len,
         WCHAR *name, WORD *desc_len, WCHAR *desc, WMT_CODEC_INFO_TYPE *type, WORD *size, BYTE *info)
 {
-    FIXME("iface %p, index %lu, name_len %p, name %p, desc_len %p, desc %p, type %p, size %p, info %p, stub!\n",
+    FIXME("iface %p, index %u, name_len %p, name %p, desc_len %p, desc %p, type %p, size %p, info %p, stub!\n",
             iface, index, name_len, name, desc_len, desc, type, size, info);
     return E_NOTIMPL;
 }
@@ -1163,7 +1163,7 @@ static HRESULT WINAPI header_info_GetAttributeByIndexEx(IWMHeaderInfo3 *iface,
 static HRESULT WINAPI header_info_ModifyAttribute(IWMHeaderInfo3 *iface, WORD stream_number,
         WORD index, WMT_ATTR_DATATYPE type, WORD lang_index, const BYTE *value, DWORD size)
 {
-    FIXME("iface %p, stream_number %u, index %u, type %#x, lang_index %u, value %p, size %lu, stub!\n",
+    FIXME("iface %p, stream_number %u, index %u, type %#x, lang_index %u, value %p, size %u, stub!\n",
             iface, stream_number, index, type, lang_index, value, size);
     return E_NOTIMPL;
 }
@@ -1172,7 +1172,7 @@ static HRESULT WINAPI header_info_AddAttribute(IWMHeaderInfo3 *iface,
         WORD stream_number, const WCHAR *name, WORD *index,
         WMT_ATTR_DATATYPE type, WORD lang_index, const BYTE *value, DWORD size)
 {
-    FIXME("iface %p, stream_number %u, name %s, index %p, type %#x, lang_index %u, value %p, size %lu, stub!\n",
+    FIXME("iface %p, stream_number %u, name %s, index %p, type %#x, lang_index %u, value %p, size %u, stub!\n",
             iface, stream_number, debugstr_w(name), index, type, lang_index, value, size);
     return E_NOTIMPL;
 }
@@ -1309,7 +1309,7 @@ static HRESULT WINAPI packet_size_GetMaxPacketSize(IWMPacketSize2 *iface, DWORD
 
 static HRESULT WINAPI packet_size_SetMaxPacketSize(IWMPacketSize2 *iface, DWORD size)
 {
-    FIXME("iface %p, size %lu, stub!\n", iface, size);
+    FIXME("iface %p, size %u, stub!\n", iface, size);
     return E_NOTIMPL;
 }
 
@@ -1321,7 +1321,7 @@ static HRESULT WINAPI packet_size_GetMinPacketSize(IWMPacketSize2 *iface, DWORD
 
 static HRESULT WINAPI packet_size_SetMinPacketSize(IWMPacketSize2 *iface, DWORD size)
 {
-    FIXME("iface %p, size %lu, stub!\n", iface, size);
+    FIXME("iface %p, size %u, stub!\n", iface, size);
     return E_NOTIMPL;
 }
 
@@ -1365,14 +1365,14 @@ static ULONG WINAPI playlist_Release(IWMReaderPlaylistBurn *iface)
 static HRESULT WINAPI playlist_InitPlaylistBurn(IWMReaderPlaylistBurn *iface, DWORD count,
         const WCHAR **filenames, IWMStatusCallback *callback, void *context)
 {
-    FIXME("iface %p, count %lu, filenames %p, callback %p, context %p, stub!\n",
+    FIXME("iface %p, count %u, filenames %p, callback %p, context %p, stub!\n",
             iface, count, filenames, callback, context);
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI playlist_GetInitResults(IWMReaderPlaylistBurn *iface, DWORD count, HRESULT *hrs)
 {
-    FIXME("iface %p, count %lu, hrs %p, stub!\n", iface, count, hrs);
+    FIXME("iface %p, count %u, hrs %p, stub!\n", iface, count, hrs);
     return E_NOTIMPL;
 }
 
@@ -1384,7 +1384,7 @@ static HRESULT WINAPI playlist_Cancel(IWMReaderPlaylistBurn *iface)
 
 static HRESULT WINAPI playlist_EndPlaylistBurn(IWMReaderPlaylistBurn *iface, HRESULT hr)
 {
-    FIXME("iface %p, hr %#lx, stub!\n", iface, hr);
+    FIXME("iface %p, hr %#x, stub!\n", iface, hr);
     return E_NOTIMPL;
 }
 
@@ -1455,7 +1455,7 @@ static HRESULT init_stream(struct wm_reader *reader, QWORD file_size)
     HRESULT hr;
     WORD i;
 
-    if (!(wg_parser = wg_parser_create(WG_PARSER_DECODEBIN, false)))
+    if (!(wg_parser = wg_parser_create(WG_PARSER_DECODEBIN, true)))
         return E_OUTOFMEMORY;
 
     reader->wg_parser = wg_parser;
@@ -1468,7 +1468,7 @@ static HRESULT init_stream(struct wm_reader *reader, QWORD file_size)
 
     if (FAILED(hr = wg_parser_connect(reader->wg_parser, file_size)))
     {
-        ERR("Failed to connect parser, hr %#lx.\n", hr);
+        ERR("Failed to connect parser, hr %#x.\n", hr);
         goto out_shutdown_thread;
     }
 
@@ -1484,7 +1484,7 @@ static HRESULT init_stream(struct wm_reader *reader, QWORD file_size)
     {
         struct wm_stream *stream = &reader->streams[i];
 
-        stream->wg_stream = wg_parser_get_stream(reader->wg_parser, i);
+        stream->wg_stream = wg_parser_get_stream(reader->wg_parser, reader->stream_count - i - 1);
         stream->reader = reader;
         stream->index = i;
         stream->selection = WMT_ON;
@@ -1508,8 +1508,19 @@ static HRESULT init_stream(struct wm_reader *reader, QWORD file_size)
              * Shadowgrounds provides wmv3 video and assumes that the initial
              * video type will be BGR. */
             stream->format.u.video.format = WG_VIDEO_FORMAT_BGR;
+            {
+                /* HACK: Persona 4 Golden tries to read compressed samples, and
+                 * then autoplug them via quartz to a filter that only accepts
+                 * BGRx. This is not trivial to implement. Return BGRx from the
+                 * wmvcore reader for now. */
+
+                const char *id = getenv("SteamGameId");
+
+                if (id && !strcmp(id, "1113000"))
+                    stream->format.u.video.format = WG_VIDEO_FORMAT_BGRx;
+            }
         }
-        wg_parser_stream_enable(stream->wg_stream, &stream->format);
+        wg_parser_stream_enable(stream->wg_stream, &stream->format, NULL, STREAM_ENABLE_FLAG_FLIP_RGB);
     }
 
     /* We probably discarded events because streams weren't enabled yet.
@@ -1542,7 +1553,7 @@ HRESULT wm_reader_open_stream(struct wm_reader *reader, IStream *stream)
 
     if (FAILED(hr = IStream_Stat(stream, &stat, STATFLAG_NONAME)))
     {
-        ERR("Failed to stat stream, hr %#lx.\n", hr);
+        ERR("Failed to stat stream, hr %#x.\n", hr);
         return hr;
     }
 
@@ -1568,13 +1579,13 @@ HRESULT wm_reader_open_file(struct wm_reader *reader, const WCHAR *filename)
     if ((file = CreateFileW(filename, GENERIC_READ, FILE_SHARE_READ, NULL,
             OPEN_EXISTING, 0, NULL)) == INVALID_HANDLE_VALUE)
     {
-        ERR("Failed to open %s, error %lu.\n", debugstr_w(filename), GetLastError());
+        ERR("Failed to open %s, error %u.\n", debugstr_w(filename), GetLastError());
         return HRESULT_FROM_WIN32(GetLastError());
     }
 
     if (!GetFileSizeEx(file, &size))
     {
-        ERR("Failed to get the size of %s, error %lu.\n", debugstr_w(filename), GetLastError());
+        ERR("Failed to get the size of %s, error %u.\n", debugstr_w(filename), GetLastError());
         CloseHandle(file);
         return HRESULT_FROM_WIN32(GetLastError());
     }
@@ -1686,10 +1697,6 @@ HRESULT wm_reader_get_output_format_count(struct wm_reader *reader, DWORD output
             *count = ARRAY_SIZE(video_formats);
             break;
 
-        case WG_MAJOR_TYPE_WMA:
-        case WG_MAJOR_TYPE_H264:
-            FIXME("Format %u not implemented!\n", format.major_type);
-            /* fallthrough */
         case WG_MAJOR_TYPE_AUDIO:
         case WG_MAJOR_TYPE_UNKNOWN:
             *count = 1;
@@ -1736,10 +1743,6 @@ HRESULT wm_reader_get_output_format(struct wm_reader *reader, DWORD output,
             format.u.audio.format = WG_AUDIO_FORMAT_S16LE;
             break;
 
-        case WG_MAJOR_TYPE_WMA:
-        case WG_MAJOR_TYPE_H264:
-            FIXME("Format %u not implemented!\n", format.major_type);
-            break;
         case WG_MAJOR_TYPE_UNKNOWN:
             break;
     }
@@ -1783,7 +1786,7 @@ HRESULT wm_reader_set_output_props(struct wm_reader *reader, DWORD output,
     }
 
     stream->format = format;
-    wg_parser_stream_enable(stream->wg_stream, &format);
+    wg_parser_stream_enable(stream->wg_stream, &format, NULL, STREAM_ENABLE_FLAG_FLIP_RGB);
 
     /* Re-decode any buffers that might have been generated with the old format.
      *
@@ -1815,10 +1818,6 @@ static const char *get_major_type_string(enum wg_major_type type)
             return "video";
         case WG_MAJOR_TYPE_UNKNOWN:
             return "unknown";
-        case WG_MAJOR_TYPE_WMA:
-            return "wma";
-        case WG_MAJOR_TYPE_H264:
-            return "h264";
     }
     assert(0);
     return NULL;
@@ -1925,7 +1924,7 @@ HRESULT wm_reader_get_stream_sample(struct wm_reader *reader, WORD stream_number
             if (FAILED(hr = IWMReaderCallbackAdvanced_AllocateForStream(callback_advanced,
                     stream->index + 1, wg_buffer.size, &sample, NULL)))
             {
-                ERR("Failed to allocate stream sample of %u bytes, hr %#lx.\n", wg_buffer.size, hr);
+                ERR("Failed to allocate stream sample of %u bytes, hr %#x.\n", wg_buffer.size, hr);
                 wg_parser_stream_release_buffer(wg_stream);
                 return hr;
             }
@@ -1935,7 +1934,7 @@ HRESULT wm_reader_get_stream_sample(struct wm_reader *reader, WORD stream_number
             if (FAILED(hr = IWMReaderCallbackAdvanced_AllocateForOutput(callback_advanced,
                     stream->index, wg_buffer.size, &sample, NULL)))
             {
-                ERR("Failed to allocate output sample of %u bytes, hr %#lx.\n", wg_buffer.size, hr);
+                ERR("Failed to allocate output sample of %u bytes, hr %#x.\n", wg_buffer.size, hr);
                 wg_parser_stream_release_buffer(wg_stream);
                 return hr;
             }
@@ -1960,11 +1959,11 @@ HRESULT wm_reader_get_stream_sample(struct wm_reader *reader, WORD stream_number
         }
 
         if (FAILED(hr = INSSBuffer_GetBufferAndLength(sample, &data, &size)))
-            ERR("Failed to get data pointer, hr %#lx.\n", hr);
+            ERR("Failed to get data pointer, hr %#x.\n", hr);
         if (FAILED(hr = INSSBuffer_GetMaxLength(sample, &capacity)))
-            ERR("Failed to get capacity, hr %#lx.\n", hr);
+            ERR("Failed to get capacity, hr %#x.\n", hr);
         if (wg_buffer.size > capacity)
-            ERR("Returned capacity %lu is less than requested capacity %u.\n", capacity, wg_buffer.size);
+            ERR("Returned capacity %u is less than requested capacity %u.\n", capacity, wg_buffer.size);
 
         if (!wg_parser_stream_copy_buffer(wg_stream, data, 0, wg_buffer.size))
         {
@@ -1974,7 +1973,7 @@ HRESULT wm_reader_get_stream_sample(struct wm_reader *reader, WORD stream_number
         }
 
         if (FAILED(hr = INSSBuffer_SetLength(sample, wg_buffer.size)))
-            ERR("Failed to set size %u, hr %#lx.\n", wg_buffer.size, hr);
+            ERR("Failed to set size %u, hr %#x.\n", wg_buffer.size, hr);
 
         wg_parser_stream_release_buffer(wg_stream);
 
@@ -2050,7 +2049,7 @@ HRESULT wm_reader_set_streams_selected(struct wm_reader *reader, WORD count,
                 FIXME("Ignoring selection %#x for stream %u; treating as enabled.\n",
                         selections[i], stream_numbers[i]);
             TRACE("Enabling stream %u.\n", stream_numbers[i]);
-            wg_parser_stream_enable(stream->wg_stream, &stream->format);
+            wg_parser_stream_enable(stream->wg_stream, &stream->format, NULL, STREAM_ENABLE_FLAG_FLIP_RGB);
         }
     }
 
diff --git a/dlls/winegstreamer/wm_syncreader.c b/dlls/winegstreamer/wm_syncreader.c
index c7cccd52c4f..b03aa69d030 100644
--- wine/dlls/winegstreamer/wm_syncreader.c
+++ wine/dlls/winegstreamer/wm_syncreader.c
@@ -65,7 +65,7 @@ static HRESULT WINAPI WMSyncReader_Close(IWMSyncReader2 *iface)
 static HRESULT WINAPI WMSyncReader_GetMaxOutputSampleSize(IWMSyncReader2 *iface, DWORD output, DWORD *max)
 {
     struct sync_reader *This = impl_from_IWMSyncReader2(iface);
-    FIXME("(%p)->(%lu %p): stub!\n", This, output, max);
+    FIXME("(%p)->(%d %p): stub!\n", This, output, max);
     return E_NOTIMPL;
 }
 
@@ -119,7 +119,7 @@ static HRESULT WINAPI WMSyncReader_GetOutputFormat(IWMSyncReader2 *iface,
 {
     struct sync_reader *reader = impl_from_IWMSyncReader2(iface);
 
-    TRACE("reader %p, output %lu, index %lu, props %p.\n", reader, output, index, props);
+    TRACE("reader %p, output %u, index %u, props %p.\n", reader, output, index, props);
 
     return wm_reader_get_output_format(&reader->reader, output, index, props);
 }
@@ -128,7 +128,7 @@ static HRESULT WINAPI WMSyncReader_GetOutputFormatCount(IWMSyncReader2 *iface, D
 {
     struct sync_reader *reader = impl_from_IWMSyncReader2(iface);
 
-    TRACE("reader %p, output %lu, count %p.\n", reader, output, count);
+    TRACE("reader %p, output %u, count %p.\n", reader, output, count);
 
     return wm_reader_get_output_format_count(&reader->reader, output, count);
 }
@@ -149,7 +149,7 @@ static HRESULT WINAPI WMSyncReader_GetOutputProps(IWMSyncReader2 *iface,
 {
     struct sync_reader *reader = impl_from_IWMSyncReader2(iface);
 
-    TRACE("reader %p, output %lu, props %p.\n", reader, output, props);
+    TRACE("reader %p, output %u, props %p.\n", reader, output, props);
 
     return wm_reader_get_output_props(&reader->reader, output, props);
 }
@@ -158,7 +158,7 @@ static HRESULT WINAPI WMSyncReader_GetOutputSetting(IWMSyncReader2 *iface, DWORD
         WMT_ATTR_DATATYPE *type, BYTE *value, WORD *length)
 {
     struct sync_reader *This = impl_from_IWMSyncReader2(iface);
-    FIXME("(%p)->(%lu %s %p %p %p): stub!\n", This, output_num, debugstr_w(name), type, value, length);
+    FIXME("(%p)->(%u %s %p %p %p): stub!\n", This, output_num, debugstr_w(name), type, value, length);
     return E_NOTIMPL;
 }
 
@@ -174,7 +174,7 @@ static HRESULT WINAPI WMSyncReader_GetStreamNumberForOutput(IWMSyncReader2 *ifac
 {
     struct sync_reader *reader = impl_from_IWMSyncReader2(iface);
 
-    TRACE("reader %p, output %lu, stream_number %p.\n", reader, output, stream_number);
+    TRACE("reader %p, output %u, stream_number %p.\n", reader, output, stream_number);
 
     *stream_number = output + 1;
     return S_OK;
@@ -212,7 +212,7 @@ static HRESULT WINAPI WMSyncReader_SetOutputProps(IWMSyncReader2 *iface, DWORD o
 {
     struct sync_reader *reader = impl_from_IWMSyncReader2(iface);
 
-    TRACE("reader %p, output %lu, props %p.\n", reader, output, props);
+    TRACE("reader %p, output %u, props %p.\n", reader, output, props);
 
     return wm_reader_set_output_props(&reader->reader, output, props);
 }
@@ -222,7 +222,7 @@ static HRESULT WINAPI WMSyncReader_SetOutputSetting(IWMSyncReader2 *iface, DWORD
 {
     struct sync_reader *reader = impl_from_IWMSyncReader2(iface);
 
-    TRACE("reader %p, output %lu, name %s, type %#x, value %p, size %u.\n",
+    TRACE("reader %p, output %u, name %s, type %#x, value %p, size %u.\n",
             reader, output, debugstr_w(name), type, value, size);
 
     if (!wcscmp(name, L"VideoSampleDurations"))
@@ -230,16 +230,6 @@ static HRESULT WINAPI WMSyncReader_SetOutputSetting(IWMSyncReader2 *iface, DWORD
         FIXME("Ignoring VideoSampleDurations setting.\n");
         return S_OK;
     }
-    if (!wcscmp(name, L"EnableDiscreteOutput"))
-    {
-        FIXME("Ignoring EnableDiscreteOutput setting.\n");
-        return S_OK;
-    }
-    if (!wcscmp(name, L"SpeakerConfig"))
-    {
-        FIXME("Ignoring SpeakerConfig setting.\n");
-        return S_OK;
-    }
     else
     {
         FIXME("Unknown setting %s; returning E_NOTIMPL.\n", debugstr_w(name));
@@ -305,28 +295,28 @@ static HRESULT WINAPI WMSyncReader2_SetRangeByFrameEx(IWMSyncReader2 *iface, WOR
 static HRESULT WINAPI WMSyncReader2_SetAllocateForOutput(IWMSyncReader2 *iface, DWORD output_num, IWMReaderAllocatorEx *allocator)
 {
     struct sync_reader *This = impl_from_IWMSyncReader2(iface);
-    FIXME("(%p)->(%lu %p): stub!\n", This, output_num, allocator);
+    FIXME("(%p)->(%d %p): stub!\n", This, output_num, allocator);
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI WMSyncReader2_GetAllocateForOutput(IWMSyncReader2 *iface, DWORD output_num, IWMReaderAllocatorEx **allocator)
 {
     struct sync_reader *This = impl_from_IWMSyncReader2(iface);
-    FIXME("(%p)->(%lu %p): stub!\n", This, output_num, allocator);
+    FIXME("(%p)->(%d %p): stub!\n", This, output_num, allocator);
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI WMSyncReader2_SetAllocateForStream(IWMSyncReader2 *iface, DWORD stream_num, IWMReaderAllocatorEx *allocator)
 {
     struct sync_reader *This = impl_from_IWMSyncReader2(iface);
-    FIXME("(%p)->(%lu %p): stub!\n", This, stream_num, allocator);
+    FIXME("(%p)->(%d %p): stub!\n", This, stream_num, allocator);
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI WMSyncReader2_GetAllocateForStream(IWMSyncReader2 *iface, DWORD stream_num, IWMReaderAllocatorEx **allocator)
 {
     struct sync_reader *This = impl_from_IWMSyncReader2(iface);
-    FIXME("(%p)->(%lu %p): stub!\n", This, stream_num, allocator);
+    FIXME("(%p)->(%d %p): stub!\n", This, stream_num, allocator);
     return E_NOTIMPL;
 }
 
diff --git a/dlls/winegstreamer/wma_decoder.c b/dlls/winegstreamer/wma_decoder.c
index 57b0f204f9e..021d0beb935 100644
--- wine/dlls/winegstreamer/wma_decoder.c
+++ wine/dlls/winegstreamer/wma_decoder.c
@@ -1,4 +1,4 @@
-/* WMA Decoder DMO / MF Transform
+/* WMA Decoder Transform
  *
  * Copyright 2022 Rémi Bernon for CodeWeavers
  *
@@ -28,16 +28,19 @@
 #include "wine/debug.h"
 #include "wine/heap.h"
 
-WINE_DEFAULT_DEBUG_CHANNEL(wmadec);
+WINE_DEFAULT_DEBUG_CHANNEL(mfplat);
 
-static const GUID *const wma_decoder_input_types[] =
+DEFINE_MEDIATYPE_GUID(MFAudioFormat_XMAudio2, 0x0166);
+
+static const GUID *wma_decoder_input_types[] =
 {
     &MEDIASUBTYPE_MSAUDIO1,
     &MFAudioFormat_WMAudioV8,
     &MFAudioFormat_WMAudioV9,
     &MFAudioFormat_WMAudio_Lossless,
+    &MFAudioFormat_XMAudio2,
 };
-static const GUID *const wma_decoder_output_types[] =
+static const GUID *wma_decoder_output_types[] =
 {
     &MFAudioFormat_Float,
     &MFAudioFormat_PCM,
@@ -48,12 +51,12 @@ struct wma_decoder
     IUnknown IUnknown_inner;
     IMFTransform IMFTransform_iface;
     IMediaObject IMediaObject_iface;
-    IPropertyBag IPropertyBag_iface;
     IUnknown *outer;
     LONG refcount;
     IMFMediaType *input_type;
     IMFMediaType *output_type;
 
+    IMFSample *input_sample;
     struct wg_transform *wg_transform;
 };
 
@@ -62,29 +65,7 @@ static inline struct wma_decoder *impl_from_IUnknown(IUnknown *iface)
     return CONTAINING_RECORD(iface, struct wma_decoder, IUnknown_inner);
 }
 
-static HRESULT try_create_wg_transform(struct wma_decoder *decoder)
-{
-    struct wg_format input_format, output_format;
-
-    if (decoder->wg_transform)
-        wg_transform_destroy(decoder->wg_transform);
-    decoder->wg_transform = NULL;
-
-    mf_media_type_to_wg_format(decoder->input_type, &input_format);
-    if (input_format.major_type == WG_MAJOR_TYPE_UNKNOWN)
-        return MF_E_INVALIDMEDIATYPE;
-
-    mf_media_type_to_wg_format(decoder->output_type, &output_format);
-    if (output_format.major_type == WG_MAJOR_TYPE_UNKNOWN)
-        return MF_E_INVALIDMEDIATYPE;
-
-    if (!(decoder->wg_transform = wg_transform_create(&input_format, &output_format)))
-        return E_FAIL;
-
-    return S_OK;
-}
-
-static HRESULT WINAPI unknown_QueryInterface(IUnknown *iface, REFIID iid, void **out)
+static HRESULT WINAPI wma_unknown_QueryInterface(IUnknown *iface, REFIID iid, void **out)
 {
     struct wma_decoder *decoder = impl_from_IUnknown(iface);
 
@@ -96,8 +77,6 @@ static HRESULT WINAPI unknown_QueryInterface(IUnknown *iface, REFIID iid, void *
         *out = &decoder->IMFTransform_iface;
     else if (IsEqualGUID(iid, &IID_IMediaObject))
         *out = &decoder->IMediaObject_iface;
-    else if (IsEqualIID(iid, &IID_IPropertyBag))
-        *out = &decoder->IPropertyBag_iface;
     else
     {
         *out = NULL;
@@ -109,25 +88,27 @@ static HRESULT WINAPI unknown_QueryInterface(IUnknown *iface, REFIID iid, void *
     return S_OK;
 }
 
-static ULONG WINAPI unknown_AddRef(IUnknown *iface)
+static ULONG WINAPI wma_unknown_AddRef(IUnknown *iface)
 {
     struct wma_decoder *decoder = impl_from_IUnknown(iface);
     ULONG refcount = InterlockedIncrement(&decoder->refcount);
 
-    TRACE("iface %p increasing refcount to %lu.\n", decoder, refcount);
+    TRACE("iface %p increasing refcount to %u.\n", decoder, refcount);
 
     return refcount;
 }
 
-static ULONG WINAPI unknown_Release(IUnknown *iface)
+static ULONG WINAPI wma_unknown_Release(IUnknown *iface)
 {
     struct wma_decoder *decoder = impl_from_IUnknown(iface);
     ULONG refcount = InterlockedDecrement(&decoder->refcount);
 
-    TRACE("iface %p decreasing refcount to %lu.\n", decoder, refcount);
+    TRACE("iface %p decreasing refcount to %u.\n", decoder, refcount);
 
     if (!refcount)
     {
+        if (decoder->input_sample)
+            IMFSample_Release(decoder->input_sample);
         if (decoder->wg_transform)
             wg_transform_destroy(decoder->wg_transform);
         if (decoder->input_type)
@@ -140,11 +121,11 @@ static ULONG WINAPI unknown_Release(IUnknown *iface)
     return refcount;
 }
 
-static const IUnknownVtbl unknown_vtbl =
+static const IUnknownVtbl wma_unknown_vtbl =
 {
-    unknown_QueryInterface,
-    unknown_AddRef,
-    unknown_Release,
+    wma_unknown_QueryInterface,
+    wma_unknown_AddRef,
+    wma_unknown_Release,
 };
 
 static struct wma_decoder *impl_from_IMFTransform(IMFTransform *iface)
@@ -152,25 +133,50 @@ static struct wma_decoder *impl_from_IMFTransform(IMFTransform *iface)
     return CONTAINING_RECORD(iface, struct wma_decoder, IMFTransform_iface);
 }
 
-static HRESULT WINAPI transform_QueryInterface(IMFTransform *iface, REFIID iid, void **out)
+static HRESULT try_create_wg_transform(struct wma_decoder *decoder)
+{
+    struct wg_encoded_format input_format;
+    struct wg_format output_format;
+
+    if (decoder->wg_transform)
+        wg_transform_destroy(decoder->wg_transform);
+    decoder->wg_transform = NULL;
+
+    mf_media_type_to_wg_encoded_format(decoder->input_type, &input_format);
+    if (input_format.encoded_type == WG_ENCODED_TYPE_UNKNOWN)
+        return MF_E_INVALIDMEDIATYPE;
+
+    mf_media_type_to_wg_format(decoder->output_type, &output_format);
+    if (output_format.major_type == WG_MAJOR_TYPE_UNKNOWN)
+        return MF_E_INVALIDMEDIATYPE;
+
+    decoder->wg_transform = wg_transform_create(&input_format, &output_format);
+    if (decoder->wg_transform)
+        return S_OK;
+
+    WARN("Failed to create wg_transform.\n");
+    return E_FAIL;
+}
+
+static HRESULT WINAPI wma_decoder_QueryInterface(IMFTransform *iface, REFIID iid, void **out)
 {
     struct wma_decoder *decoder = impl_from_IMFTransform(iface);
     return IUnknown_QueryInterface(decoder->outer, iid, out);
 }
 
-static ULONG WINAPI transform_AddRef(IMFTransform *iface)
+static ULONG WINAPI wma_decoder_AddRef(IMFTransform *iface)
 {
     struct wma_decoder *decoder = impl_from_IMFTransform(iface);
     return IUnknown_AddRef(decoder->outer);
 }
 
-static ULONG WINAPI transform_Release(IMFTransform *iface)
+static ULONG WINAPI wma_decoder_Release(IMFTransform *iface)
 {
     struct wma_decoder *decoder = impl_from_IMFTransform(iface);
     return IUnknown_Release(decoder->outer);
 }
 
-static HRESULT WINAPI transform_GetStreamLimits(IMFTransform *iface, DWORD *input_minimum,
+static HRESULT WINAPI wma_decoder_GetStreamLimits(IMFTransform *iface, DWORD *input_minimum,
         DWORD *input_maximum, DWORD *output_minimum, DWORD *output_maximum)
 {
     FIXME("iface %p, input_minimum %p, input_maximum %p, output_minimum %p, output_maximum %p stub!\n",
@@ -178,27 +184,27 @@ static HRESULT WINAPI transform_GetStreamLimits(IMFTransform *iface, DWORD *inpu
     return E_NOTIMPL;
 }
 
-static HRESULT WINAPI transform_GetStreamCount(IMFTransform *iface, DWORD *inputs, DWORD *outputs)
+static HRESULT WINAPI wma_decoder_GetStreamCount(IMFTransform *iface, DWORD *inputs, DWORD *outputs)
 {
     FIXME("iface %p, inputs %p, outputs %p stub!\n", iface, inputs, outputs);
     return E_NOTIMPL;
 }
 
-static HRESULT WINAPI transform_GetStreamIDs(IMFTransform *iface, DWORD input_size, DWORD *inputs,
+static HRESULT WINAPI wma_decoder_GetStreamIDs(IMFTransform *iface, DWORD input_size, DWORD *inputs,
         DWORD output_size, DWORD *outputs)
 {
-    FIXME("iface %p, input_size %lu, inputs %p, output_size %lu, outputs %p stub!\n", iface,
+    FIXME("iface %p, input_size %u, inputs %p, output_size %u, outputs %p stub!\n", iface,
             input_size, inputs, output_size, outputs);
     return E_NOTIMPL;
 }
 
-static HRESULT WINAPI transform_GetInputStreamInfo(IMFTransform *iface, DWORD id, MFT_INPUT_STREAM_INFO *info)
+static HRESULT WINAPI wma_decoder_GetInputStreamInfo(IMFTransform *iface, DWORD id, MFT_INPUT_STREAM_INFO *info)
 {
     struct wma_decoder *decoder = impl_from_IMFTransform(iface);
     UINT32 block_alignment;
     HRESULT hr;
 
-    TRACE("iface %p, id %lu, info %p.\n", iface, id, info);
+    TRACE("iface %p, id %u, info %p.\n", iface, id, info);
 
     if (!decoder->input_type || !decoder->output_type)
         return MF_E_TRANSFORM_TYPE_NOT_SET;
@@ -215,13 +221,13 @@ static HRESULT WINAPI transform_GetInputStreamInfo(IMFTransform *iface, DWORD id
     return S_OK;
 }
 
-static HRESULT WINAPI transform_GetOutputStreamInfo(IMFTransform *iface, DWORD id, MFT_OUTPUT_STREAM_INFO *info)
+static HRESULT WINAPI wma_decoder_GetOutputStreamInfo(IMFTransform *iface, DWORD id, MFT_OUTPUT_STREAM_INFO *info)
 {
     struct wma_decoder *decoder = impl_from_IMFTransform(iface);
     UINT32 channel_count, block_alignment;
     HRESULT hr;
 
-    TRACE("iface %p, id %lu, info %p.\n", iface, id, info);
+    TRACE("iface %p, id %u, info %p.\n", iface, id, info);
 
     if (!decoder->input_type || !decoder->output_type)
         return MF_E_TRANSFORM_TYPE_NOT_SET;
@@ -238,44 +244,44 @@ static HRESULT WINAPI transform_GetOutputStreamInfo(IMFTransform *iface, DWORD i
     return S_OK;
 }
 
-static HRESULT WINAPI transform_GetAttributes(IMFTransform *iface, IMFAttributes **attributes)
+static HRESULT WINAPI wma_decoder_GetAttributes(IMFTransform *iface, IMFAttributes **attributes)
 {
     FIXME("iface %p, attributes %p stub!\n", iface, attributes);
     return E_NOTIMPL;
 }
 
-static HRESULT WINAPI transform_GetInputStreamAttributes(IMFTransform *iface, DWORD id, IMFAttributes **attributes)
+static HRESULT WINAPI wma_decoder_GetInputStreamAttributes(IMFTransform *iface, DWORD id, IMFAttributes **attributes)
 {
-    FIXME("iface %p, id %lu, attributes %p stub!\n", iface, id, attributes);
+    FIXME("iface %p, id %u, attributes %p stub!\n", iface, id, attributes);
     return E_NOTIMPL;
 }
 
-static HRESULT WINAPI transform_GetOutputStreamAttributes(IMFTransform *iface, DWORD id, IMFAttributes **attributes)
+static HRESULT WINAPI wma_decoder_GetOutputStreamAttributes(IMFTransform *iface, DWORD id, IMFAttributes **attributes)
 {
-    FIXME("iface %p, id %lu, attributes %p stub!\n", iface, id, attributes);
+    FIXME("iface %p, id %u, attributes %p stub!\n", iface, id, attributes);
     return E_NOTIMPL;
 }
 
-static HRESULT WINAPI transform_DeleteInputStream(IMFTransform *iface, DWORD id)
+static HRESULT WINAPI wma_decoder_DeleteInputStream(IMFTransform *iface, DWORD id)
 {
-    FIXME("iface %p, id %lu stub!\n", iface, id);
+    FIXME("iface %p, id %u stub!\n", iface, id);
     return E_NOTIMPL;
 }
 
-static HRESULT WINAPI transform_AddInputStreams(IMFTransform *iface, DWORD streams, DWORD *ids)
+static HRESULT WINAPI wma_decoder_AddInputStreams(IMFTransform *iface, DWORD streams, DWORD *ids)
 {
-    FIXME("iface %p, streams %lu, ids %p stub!\n", iface, streams, ids);
+    FIXME("iface %p, streams %u, ids %p stub!\n", iface, streams, ids);
     return E_NOTIMPL;
 }
 
-static HRESULT WINAPI transform_GetInputAvailableType(IMFTransform *iface, DWORD id, DWORD index,
+static HRESULT WINAPI wma_decoder_GetInputAvailableType(IMFTransform *iface, DWORD id, DWORD index,
         IMFMediaType **type)
 {
-    FIXME("iface %p, id %lu, index %lu, type %p stub!\n", iface, id, index, type);
+    FIXME("iface %p, id %u, index %u, type %p stub!\n", iface, id, index, type);
     return E_NOTIMPL;
 }
 
-static HRESULT WINAPI transform_GetOutputAvailableType(IMFTransform *iface, DWORD id, DWORD index,
+static HRESULT WINAPI wma_decoder_GetOutputAvailableType(IMFTransform *iface, DWORD id, DWORD index,
         IMFMediaType **type)
 {
     UINT32 channel_count, sample_size, sample_rate, block_alignment;
@@ -284,7 +290,7 @@ static HRESULT WINAPI transform_GetOutputAvailableType(IMFTransform *iface, DWOR
     const GUID *output_type;
     HRESULT hr;
 
-    TRACE("iface %p, id %lu, index %lu, type %p.\n", iface, id, index, type);
+    TRACE("iface %p, id %u, index %u, type %p.\n", iface, id, index, type);
 
     if (!decoder->input_type)
         return MF_E_TRANSFORM_TYPE_NOT_SET;
@@ -348,7 +354,7 @@ done:
     return hr;
 }
 
-static HRESULT WINAPI transform_SetInputType(IMFTransform *iface, DWORD id, IMFMediaType *type, DWORD flags)
+static HRESULT WINAPI wma_decoder_SetInputType(IMFTransform *iface, DWORD id, IMFMediaType *type, DWORD flags)
 {
     struct wma_decoder *decoder = impl_from_IMFTransform(iface);
     MF_ATTRIBUTE_TYPE item_type;
@@ -356,7 +362,7 @@ static HRESULT WINAPI transform_SetInputType(IMFTransform *iface, DWORD id, IMFM
     HRESULT hr;
     ULONG i;
 
-    TRACE("iface %p, id %lu, type %p, flags %#lx.\n", iface, id, type, flags);
+    TRACE("iface %p, id %u, type %p, flags %#x.\n", iface, id, type, flags);
 
     if (FAILED(hr = IMFMediaType_GetGUID(type, &MF_MT_MAJOR_TYPE, &major)) ||
         FAILED(hr = IMFMediaType_GetGUID(type, &MF_MT_SUBTYPE, &subtype)))
@@ -402,7 +408,7 @@ static HRESULT WINAPI transform_SetInputType(IMFTransform *iface, DWORD id, IMFM
     return hr;
 }
 
-static HRESULT WINAPI transform_SetOutputType(IMFTransform *iface, DWORD id, IMFMediaType *type, DWORD flags)
+static HRESULT WINAPI wma_decoder_SetOutputType(IMFTransform *iface, DWORD id, IMFMediaType *type, DWORD flags)
 {
     struct wma_decoder *decoder = impl_from_IMFTransform(iface);
     MF_ATTRIBUTE_TYPE item_type;
@@ -410,10 +416,7 @@ static HRESULT WINAPI transform_SetOutputType(IMFTransform *iface, DWORD id, IMF
     GUID major, subtype;
     HRESULT hr;
 
-    TRACE("iface %p, id %lu, type %p, flags %#lx.\n", iface, id, type, flags);
-
-    if (!decoder->input_type)
-        return MF_E_TRANSFORM_TYPE_NOT_SET;
+    TRACE("iface %p, id %u, type %p, flags %#x.\n", iface, id, type, flags);
 
     if (FAILED(hr = IMFMediaType_GetGUID(type, &MF_MT_MAJOR_TYPE, &major)) ||
         FAILED(hr = IMFMediaType_GetGUID(type, &MF_MT_SUBTYPE, &subtype)))
@@ -475,96 +478,114 @@ failed:
     return hr;
 }
 
-static HRESULT WINAPI transform_GetInputCurrentType(IMFTransform *iface, DWORD id, IMFMediaType **type)
+static HRESULT WINAPI wma_decoder_GetInputCurrentType(IMFTransform *iface, DWORD id, IMFMediaType **type)
 {
-    FIXME("iface %p, id %lu, type %p stub!\n", iface, id, type);
+    FIXME("iface %p, id %u, type %p stub!\n", iface, id, type);
     return E_NOTIMPL;
 }
 
-static HRESULT WINAPI transform_GetOutputCurrentType(IMFTransform *iface, DWORD id, IMFMediaType **type)
+static HRESULT WINAPI wma_decoder_GetOutputCurrentType(IMFTransform *iface, DWORD id, IMFMediaType **type)
 {
-    FIXME("iface %p, id %lu, type %p stub!\n", iface, id, type);
+    FIXME("iface %p, id %u, type %p stub!\n", iface, id, type);
     return E_NOTIMPL;
 }
 
-static HRESULT WINAPI transform_GetInputStatus(IMFTransform *iface, DWORD id, DWORD *flags)
+static HRESULT WINAPI wma_decoder_GetInputStatus(IMFTransform *iface, DWORD id, DWORD *flags)
 {
-    FIXME("iface %p, id %lu, flags %p stub!\n", iface, id, flags);
+    FIXME("iface %p, id %u, flags %p stub!\n", iface, id, flags);
     return E_NOTIMPL;
 }
 
-static HRESULT WINAPI transform_GetOutputStatus(IMFTransform *iface, DWORD *flags)
+static HRESULT WINAPI wma_decoder_GetOutputStatus(IMFTransform *iface, DWORD *flags)
 {
     FIXME("iface %p, flags %p stub!\n", iface, flags);
     return E_NOTIMPL;
 }
 
-static HRESULT WINAPI transform_SetOutputBounds(IMFTransform *iface, LONGLONG lower, LONGLONG upper)
+static HRESULT WINAPI wma_decoder_SetOutputBounds(IMFTransform *iface, LONGLONG lower, LONGLONG upper)
 {
     FIXME("iface %p, lower %s, upper %s stub!\n", iface, wine_dbgstr_longlong(lower),
             wine_dbgstr_longlong(upper));
     return E_NOTIMPL;
 }
 
-static HRESULT WINAPI transform_ProcessEvent(IMFTransform *iface, DWORD id, IMFMediaEvent *event)
+static HRESULT WINAPI wma_decoder_ProcessEvent(IMFTransform *iface, DWORD id, IMFMediaEvent *event)
 {
-    FIXME("iface %p, id %lu, event %p stub!\n", iface, id, event);
+    FIXME("iface %p, id %u, event %p stub!\n", iface, id, event);
     return E_NOTIMPL;
 }
 
-static HRESULT WINAPI transform_ProcessMessage(IMFTransform *iface, MFT_MESSAGE_TYPE message, ULONG_PTR param)
+static HRESULT WINAPI wma_decoder_ProcessMessage(IMFTransform *iface, MFT_MESSAGE_TYPE message, ULONG_PTR param)
 {
     FIXME("iface %p, message %#x, param %p stub!\n", iface, message, (void *)param);
     return S_OK;
 }
 
-static HRESULT WINAPI transform_ProcessInput(IMFTransform *iface, DWORD id, IMFSample *sample, DWORD flags)
+static HRESULT WINAPI wma_decoder_ProcessInput(IMFTransform *iface, DWORD id, IMFSample *sample, DWORD flags)
 {
     struct wma_decoder *decoder = impl_from_IMFTransform(iface);
-    struct wg_sample *wg_sample;
+    IMFMediaBuffer *media_buffer;
     MFT_INPUT_STREAM_INFO info;
+    UINT32 buffer_size;
+    BYTE *buffer;
     HRESULT hr;
 
-    TRACE("iface %p, id %lu, sample %p, flags %#lx.\n", iface, id, sample, flags);
+    TRACE("iface %p, id %u, sample %p, flags %#x.\n", iface, id, sample, flags);
+
+    if (FAILED(hr = IMFTransform_GetInputStreamInfo(iface, 0, &info)))
+        return hr;
 
     if (!decoder->wg_transform)
         return MF_E_TRANSFORM_TYPE_NOT_SET;
 
-    if (FAILED(hr = IMFTransform_GetInputStreamInfo(iface, 0, &info)))
+    if (decoder->input_sample)
+        return MF_E_NOTACCEPTING;
+
+    if (FAILED(hr = IMFSample_ConvertToContiguousBuffer(sample, &media_buffer)))
         return hr;
 
-    if (FAILED(hr = mf_create_wg_sample(sample, &wg_sample)))
+    if (FAILED(hr = IMFMediaBuffer_GetCurrentLength(media_buffer, &buffer_size)))
         return hr;
 
-    /* WMA transform uses fixed size input samples and ignores samples with invalid sizes */
-    if (wg_sample->size % info.cbSize)
-        hr = S_OK;
-    else
-        hr = wg_transform_push_data(decoder->wg_transform, wg_sample);
+    if (!(buffer_size = (buffer_size / info.cbSize) * info.cbSize))
+        return S_OK;
 
-    mf_destroy_wg_sample(wg_sample);
+    if (FAILED(hr = IMFMediaBuffer_Lock(media_buffer, &buffer, NULL, NULL)))
+        goto done;
+
+    if (SUCCEEDED(hr = wg_transform_push_data(decoder->wg_transform, buffer, buffer_size)))
+        IMFSample_AddRef((decoder->input_sample = sample));
+
+    IMFMediaBuffer_Unlock(media_buffer);
+
+done:
+    IMFMediaBuffer_Release(media_buffer);
     return hr;
 }
 
-static HRESULT WINAPI transform_ProcessOutput(IMFTransform *iface, DWORD flags, DWORD count,
+static HRESULT WINAPI wma_decoder_ProcessOutput(IMFTransform *iface, DWORD flags, DWORD count,
         MFT_OUTPUT_DATA_BUFFER *samples, DWORD *status)
 {
     struct wma_decoder *decoder = impl_from_IMFTransform(iface);
+    struct wg_sample wg_sample = {0};
+    IMFMediaBuffer *media_buffer;
     MFT_OUTPUT_STREAM_INFO info;
-    struct wg_sample *wg_sample;
     HRESULT hr;
 
-    TRACE("iface %p, flags %#lx, count %lu, samples %p, status %p.\n", iface, flags, count, samples, status);
+    TRACE("iface %p, flags %#x, count %u, samples %p, status %p.\n", iface, flags, count, samples, status);
 
     if (count > 1)
-        return E_INVALIDARG;
-
-    if (!decoder->wg_transform)
-        return MF_E_TRANSFORM_TYPE_NOT_SET;
+    {
+        FIXME("Not implemented count %u\n", count);
+        return E_NOTIMPL;
+    }
 
     if (FAILED(hr = IMFTransform_GetOutputStreamInfo(iface, 0, &info)))
         return hr;
 
+    if (!decoder->wg_transform)
+        return MF_E_TRANSFORM_TYPE_NOT_SET;
+
     *status = 0;
     samples[0].dwStatus = 0;
     if (!samples[0].pSample)
@@ -573,50 +594,62 @@ static HRESULT WINAPI transform_ProcessOutput(IMFTransform *iface, DWORD flags,
         return MF_E_TRANSFORM_NEED_MORE_INPUT;
     }
 
-    if (FAILED(hr = mf_create_wg_sample(samples[0].pSample, &wg_sample)))
+    if (FAILED(hr = IMFSample_ConvertToContiguousBuffer(samples[0].pSample, &media_buffer)))
         return hr;
 
-    wg_sample->size = 0;
-    if (wg_sample->max_size < info.cbSize)
+    if (FAILED(hr = IMFMediaBuffer_Lock(media_buffer, &wg_sample.data, &wg_sample.size, NULL)))
+        goto done;
+
+    if (wg_sample.size < info.cbSize)
         hr = MF_E_BUFFERTOOSMALL;
-    else if (SUCCEEDED(hr = wg_transform_read_data(decoder->wg_transform, wg_sample)))
+    else if (SUCCEEDED(hr = wg_transform_read_data(decoder->wg_transform, &wg_sample)))
     {
-        if (wg_sample->flags & WG_SAMPLE_FLAG_INCOMPLETE)
+        if (wg_sample.flags & WG_SAMPLE_FLAG_INCOMPLETE)
             samples[0].dwStatus |= MFT_OUTPUT_DATA_BUFFER_INCOMPLETE;
     }
+    else
+    {
+        if (decoder->input_sample)
+            IMFSample_Release(decoder->input_sample);
+        decoder->input_sample = NULL;
+    }
+
+    IMFMediaBuffer_Unlock(media_buffer);
 
-    mf_destroy_wg_sample(wg_sample);
+done:
+    IMFMediaBuffer_SetCurrentLength(media_buffer, wg_sample.size);
+    IMFMediaBuffer_Release(media_buffer);
     return hr;
 }
 
-static const IMFTransformVtbl transform_vtbl =
-{
-    transform_QueryInterface,
-    transform_AddRef,
-    transform_Release,
-    transform_GetStreamLimits,
-    transform_GetStreamCount,
-    transform_GetStreamIDs,
-    transform_GetInputStreamInfo,
-    transform_GetOutputStreamInfo,
-    transform_GetAttributes,
-    transform_GetInputStreamAttributes,
-    transform_GetOutputStreamAttributes,
-    transform_DeleteInputStream,
-    transform_AddInputStreams,
-    transform_GetInputAvailableType,
-    transform_GetOutputAvailableType,
-    transform_SetInputType,
-    transform_SetOutputType,
-    transform_GetInputCurrentType,
-    transform_GetOutputCurrentType,
-    transform_GetInputStatus,
-    transform_GetOutputStatus,
-    transform_SetOutputBounds,
-    transform_ProcessEvent,
-    transform_ProcessMessage,
-    transform_ProcessInput,
-    transform_ProcessOutput,
+static const IMFTransformVtbl mf_transform_vtbl =
+{
+    wma_decoder_QueryInterface,
+    wma_decoder_AddRef,
+    wma_decoder_Release,
+    wma_decoder_GetStreamLimits,
+    wma_decoder_GetStreamCount,
+    wma_decoder_GetStreamIDs,
+    wma_decoder_GetInputStreamInfo,
+    wma_decoder_GetOutputStreamInfo,
+    wma_decoder_GetAttributes,
+    wma_decoder_GetInputStreamAttributes,
+    wma_decoder_GetOutputStreamAttributes,
+    wma_decoder_DeleteInputStream,
+    wma_decoder_AddInputStreams,
+    wma_decoder_GetInputAvailableType,
+    wma_decoder_GetOutputAvailableType,
+    wma_decoder_SetInputType,
+    wma_decoder_SetOutputType,
+    wma_decoder_GetInputCurrentType,
+    wma_decoder_GetOutputCurrentType,
+    wma_decoder_GetInputStatus,
+    wma_decoder_GetOutputStatus,
+    wma_decoder_SetOutputBounds,
+    wma_decoder_ProcessEvent,
+    wma_decoder_ProcessMessage,
+    wma_decoder_ProcessInput,
+    wma_decoder_ProcessOutput,
 };
 
 static inline struct wma_decoder *impl_from_IMediaObject(IMediaObject *iface)
@@ -624,231 +657,187 @@ static inline struct wma_decoder *impl_from_IMediaObject(IMediaObject *iface)
     return CONTAINING_RECORD(iface, struct wma_decoder, IMediaObject_iface);
 }
 
-static HRESULT WINAPI media_object_QueryInterface(IMediaObject *iface, REFIID iid, void **obj)
+static HRESULT WINAPI wma_media_object_QueryInterface(IMediaObject *iface, REFIID iid, void **obj)
 {
     struct wma_decoder *decoder = impl_from_IMediaObject(iface);
     return IUnknown_QueryInterface(decoder->outer, iid, obj);
 }
 
-static ULONG WINAPI media_object_AddRef(IMediaObject *iface)
+static ULONG WINAPI wma_media_object_AddRef(IMediaObject *iface)
 {
     struct wma_decoder *decoder = impl_from_IMediaObject(iface);
     return IUnknown_AddRef(decoder->outer);
 }
 
-static ULONG WINAPI media_object_Release(IMediaObject *iface)
+static ULONG WINAPI wma_media_object_Release(IMediaObject *iface)
 {
     struct wma_decoder *decoder = impl_from_IMediaObject(iface);
     return IUnknown_Release(decoder->outer);
 }
 
-static HRESULT WINAPI media_object_GetStreamCount(IMediaObject *iface, DWORD *input, DWORD *output)
+static HRESULT WINAPI wma_media_object_GetStreamCount(IMediaObject *iface, DWORD *input, DWORD *output)
 {
-    FIXME("iface %p, input %p, output %p semi-stub!\n", iface, input, output);
+    FIXME("iface %p, input %p, output %p stub!\n", iface, input, output);
     *input = *output = 1;
     return S_OK;
 }
 
-static HRESULT WINAPI media_object_GetInputStreamInfo(IMediaObject *iface, DWORD index, DWORD *flags)
+static HRESULT WINAPI wma_media_object_GetInputStreamInfo(IMediaObject *iface, DWORD index, DWORD *flags)
 {
-    FIXME("iface %p, index %lu, flags %p stub!\n", iface, index, flags);
+    FIXME("iface %p, index %u, flags %p stub!\n", iface, index, flags);
     return E_NOTIMPL;
 }
 
-static HRESULT WINAPI media_object_GetOutputStreamInfo(IMediaObject *iface, DWORD index, DWORD *flags)
+static HRESULT WINAPI wma_media_object_GetOutputStreamInfo(IMediaObject *iface, DWORD index, DWORD *flags)
 {
-    FIXME("iface %p, index %lu, flags %p stub!\n", iface, index, flags);
+    FIXME("iface %p, index %u, flags %p stub!\n", iface, index, flags);
     return E_NOTIMPL;
 }
 
-static HRESULT WINAPI media_object_GetInputType(IMediaObject *iface, DWORD index, DWORD type_index,
-        DMO_MEDIA_TYPE *type)
+static HRESULT WINAPI wma_media_object_GetInputType(IMediaObject *iface, DWORD index,
+        DWORD type_index, DMO_MEDIA_TYPE *type)
 {
-    FIXME("iface %p, index %lu, type_index %lu, type %p stub!\n", iface, index, type_index, type);
+    FIXME("iface %p, index %u, type_index %u, type %p stub!\n", iface, index, type_index, type);
     return E_NOTIMPL;
 }
 
-static HRESULT WINAPI media_object_GetOutputType(IMediaObject *iface, DWORD index, DWORD type_index,
-        DMO_MEDIA_TYPE *type)
+static HRESULT WINAPI wma_media_object_GetOutputType(IMediaObject *iface, DWORD index,
+        DWORD type_index, DMO_MEDIA_TYPE *type)
 {
-    FIXME("iface %p, index %lu, type_index %lu, type %p stub!\n", iface, index, type_index, type);
+    FIXME("iface %p, index %u, type_index %u, type %p stub!\n", iface, index, type_index, type);
     return E_NOTIMPL;
 }
 
-static HRESULT WINAPI media_object_SetInputType(IMediaObject *iface, DWORD index,
+static HRESULT WINAPI wma_media_object_SetInputType(IMediaObject *iface, DWORD index,
         const DMO_MEDIA_TYPE *type, DWORD flags)
 {
-    FIXME("iface %p, index %lu, type %p, flags %#lx stub!\n", iface, index, type, flags);
+    FIXME("iface %p, index %u, type %p, flags %#x stub!\n", iface, index, type, flags);
     return E_NOTIMPL;
 }
 
-static HRESULT WINAPI media_object_SetOutputType(IMediaObject *iface, DWORD index,
+static HRESULT WINAPI wma_media_object_SetOutputType(IMediaObject *iface, DWORD index,
         const DMO_MEDIA_TYPE *type, DWORD flags)
 {
-    FIXME("iface %p, index %lu, type %p, flags %#lx stub!\n", iface, index, type, flags);
+    FIXME("iface %p, index %u, type %p, flags %#x stub!\n", iface, index, type, flags);
     return E_NOTIMPL;
 }
 
-static HRESULT WINAPI media_object_GetInputCurrentType(IMediaObject *iface, DWORD index, DMO_MEDIA_TYPE *type)
+static HRESULT WINAPI wma_media_object_GetInputCurrentType(IMediaObject *iface, DWORD index, DMO_MEDIA_TYPE *type)
 {
-    FIXME("iface %p, index %lu, type %p stub!\n", iface, index, type);
+    FIXME("iface %p, index %u, type %p stub!\n", iface, index, type);
     return E_NOTIMPL;
 }
 
-static HRESULT WINAPI media_object_GetOutputCurrentType(IMediaObject *iface, DWORD index, DMO_MEDIA_TYPE *type)
+static HRESULT WINAPI wma_media_object_GetOutputCurrentType(IMediaObject *iface, DWORD index, DMO_MEDIA_TYPE *type)
 {
-    FIXME("iface %p, index %lu, type %p stub!\n", iface, index, type);
+    FIXME("iface %p, index %u, type %p stub!\n", iface, index, type);
     return E_NOTIMPL;
 }
 
-static HRESULT WINAPI media_object_GetInputSizeInfo(IMediaObject *iface, DWORD index, DWORD *size,
-        DWORD *lookahead, DWORD *alignment)
+static HRESULT WINAPI wma_media_object_GetInputSizeInfo(IMediaObject *iface, DWORD index,
+        DWORD *size, DWORD *lookahead, DWORD *alignment)
 {
-    FIXME("iface %p, index %lu, size %p, lookahead %p, alignment %p stub!\n", iface, index, size,
+    FIXME("iface %p, index %u, size %p, lookahead %p, alignment %p stub!\n", iface, index, size,
             lookahead, alignment);
     return E_NOTIMPL;
 }
 
-static HRESULT WINAPI media_object_GetOutputSizeInfo(IMediaObject *iface, DWORD index, DWORD *size, DWORD *alignment)
+static HRESULT WINAPI wma_media_object_GetOutputSizeInfo(IMediaObject *iface, DWORD index,
+        DWORD *size, DWORD *alignment)
 {
-    FIXME("iface %p, index %lu, size %p, alignment %p stub!\n", iface, index, size, alignment);
+    FIXME("iface %p, index %u, size %p, alignment %p stub!\n", iface, index, size, alignment);
     return E_NOTIMPL;
 }
 
-static HRESULT WINAPI media_object_GetInputMaxLatency(IMediaObject *iface, DWORD index, REFERENCE_TIME *latency)
+static HRESULT WINAPI wma_media_object_GetInputMaxLatency(IMediaObject *iface, DWORD index, REFERENCE_TIME *latency)
 {
-    FIXME("iface %p, index %lu, latency %p stub!\n", iface, index, latency);
+    FIXME("iface %p, index %u, latency %p stub!\n", iface, index, latency);
     return E_NOTIMPL;
 }
 
-static HRESULT WINAPI media_object_SetInputMaxLatency(IMediaObject *iface, DWORD index, REFERENCE_TIME latency)
+static HRESULT WINAPI wma_media_object_SetInputMaxLatency(IMediaObject *iface, DWORD index, REFERENCE_TIME latency)
 {
-    FIXME("iface %p, index %lu, latency %s stub!\n", iface, index, wine_dbgstr_longlong(latency));
+    FIXME("iface %p, index %u, latency %s stub!\n", iface, index, wine_dbgstr_longlong(latency));
     return E_NOTIMPL;
 }
 
-static HRESULT WINAPI media_object_Flush(IMediaObject *iface)
+static HRESULT WINAPI wma_media_object_Flush(IMediaObject *iface)
 {
     FIXME("iface %p stub!\n", iface);
     return E_NOTIMPL;
 }
 
-static HRESULT WINAPI media_object_Discontinuity(IMediaObject *iface, DWORD index)
+static HRESULT WINAPI wma_media_object_Discontinuity(IMediaObject *iface, DWORD index)
 {
-    FIXME("iface %p, index %lu stub!\n", iface, index);
+    FIXME("iface %p, index %u stub!\n", iface, index);
     return E_NOTIMPL;
 }
 
-static HRESULT WINAPI media_object_AllocateStreamingResources(IMediaObject *iface)
+static HRESULT WINAPI wma_media_object_AllocateStreamingResources(IMediaObject *iface)
 {
     FIXME("iface %p stub!\n", iface);
     return E_NOTIMPL;
 }
 
-static HRESULT WINAPI media_object_FreeStreamingResources(IMediaObject *iface)
+static HRESULT WINAPI wma_media_object_FreeStreamingResources(IMediaObject *iface)
 {
     FIXME("iface %p stub!\n", iface);
     return E_NOTIMPL;
 }
 
-static HRESULT WINAPI media_object_GetInputStatus(IMediaObject *iface, DWORD index, DWORD *flags)
+static HRESULT WINAPI wma_media_object_GetInputStatus(IMediaObject *iface, DWORD index, DWORD *flags)
 {
-    FIXME("iface %p, index %lu, flags %p stub!\n", iface, index, flags);
+    FIXME("iface %p, index %u, flags %p stub!\n", iface, index, flags);
     return E_NOTIMPL;
 }
 
-static HRESULT WINAPI media_object_ProcessInput(IMediaObject *iface, DWORD index,
+static HRESULT WINAPI wma_media_object_ProcessInput(IMediaObject *iface, DWORD index,
         IMediaBuffer *buffer, DWORD flags, REFERENCE_TIME timestamp, REFERENCE_TIME timelength)
 {
-    FIXME("iface %p, index %lu, buffer %p, flags %#lx, timestamp %s, timelength %s stub!\n", iface,
+    FIXME("iface %p, index %u, buffer %p, flags %#x, timestamp %s, timelength %s stub!\n", iface,
             index, buffer, flags, wine_dbgstr_longlong(timestamp), wine_dbgstr_longlong(timelength));
     return E_NOTIMPL;
 }
 
-static HRESULT WINAPI media_object_ProcessOutput(IMediaObject *iface, DWORD flags, DWORD count,
+static HRESULT WINAPI wma_media_object_ProcessOutput(IMediaObject *iface, DWORD flags, DWORD count,
         DMO_OUTPUT_DATA_BUFFER *buffers, DWORD *status)
 {
-    FIXME("iface %p, flags %#lx, count %lu, buffers %p, status %p stub!\n", iface, flags, count, buffers, status);
+    FIXME("iface %p, flags %#x, count %u, buffers %p, status %p stub!\n", iface, flags, count, buffers, status);
     return E_NOTIMPL;
 }
 
-static HRESULT WINAPI media_object_Lock(IMediaObject *iface, LONG lock)
+static HRESULT WINAPI wma_media_object_Lock(IMediaObject *iface, LONG lock)
 {
-    FIXME("iface %p, lock %ld stub!\n", iface, lock);
+    FIXME("iface %p, lock %d stub!\n", iface, lock);
     return E_NOTIMPL;
 }
 
-static const IMediaObjectVtbl media_object_vtbl =
-{
-    media_object_QueryInterface,
-    media_object_AddRef,
-    media_object_Release,
-    media_object_GetStreamCount,
-    media_object_GetInputStreamInfo,
-    media_object_GetOutputStreamInfo,
-    media_object_GetInputType,
-    media_object_GetOutputType,
-    media_object_SetInputType,
-    media_object_SetOutputType,
-    media_object_GetInputCurrentType,
-    media_object_GetOutputCurrentType,
-    media_object_GetInputSizeInfo,
-    media_object_GetOutputSizeInfo,
-    media_object_GetInputMaxLatency,
-    media_object_SetInputMaxLatency,
-    media_object_Flush,
-    media_object_Discontinuity,
-    media_object_AllocateStreamingResources,
-    media_object_FreeStreamingResources,
-    media_object_GetInputStatus,
-    media_object_ProcessInput,
-    media_object_ProcessOutput,
-    media_object_Lock,
-};
-
-static inline struct wma_decoder *impl_from_IPropertyBag(IPropertyBag *iface)
-{
-    return CONTAINING_RECORD(iface, struct wma_decoder, IPropertyBag_iface);
-}
-
-static HRESULT WINAPI property_bag_QueryInterface(IPropertyBag *iface, REFIID iid, void **out)
-{
-    struct wma_decoder *filter = impl_from_IPropertyBag(iface);
-    return IUnknown_QueryInterface(filter->outer, iid, out);
-}
-
-static ULONG WINAPI property_bag_AddRef(IPropertyBag *iface)
-{
-    struct wma_decoder *filter = impl_from_IPropertyBag(iface);
-    return IUnknown_AddRef(filter->outer);
-}
-
-static ULONG WINAPI property_bag_Release(IPropertyBag *iface)
-{
-    struct wma_decoder *filter = impl_from_IPropertyBag(iface);
-    return IUnknown_Release(filter->outer);
-}
-
-static HRESULT WINAPI property_bag_Read(IPropertyBag *iface, const WCHAR *prop_name, VARIANT *value,
-        IErrorLog *error_log)
-{
-    FIXME("iface %p, prop_name %s, value %p, error_log %p stub!\n", iface, debugstr_w(prop_name), value, error_log);
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI property_bag_Write(IPropertyBag *iface, const WCHAR *prop_name, VARIANT *value)
-{
-    FIXME("iface %p, prop_name %s, value %p stub!\n", iface, debugstr_w(prop_name), value);
-    return S_OK;
-}
-
-static const IPropertyBagVtbl property_bag_vtbl =
+static const IMediaObjectVtbl wma_media_object_vtbl =
 {
-    property_bag_QueryInterface,
-    property_bag_AddRef,
-    property_bag_Release,
-    property_bag_Read,
-    property_bag_Write,
+    wma_media_object_QueryInterface,
+    wma_media_object_AddRef,
+    wma_media_object_Release,
+    wma_media_object_GetStreamCount,
+    wma_media_object_GetInputStreamInfo,
+    wma_media_object_GetOutputStreamInfo,
+    wma_media_object_GetInputType,
+    wma_media_object_GetOutputType,
+    wma_media_object_SetInputType,
+    wma_media_object_SetOutputType,
+    wma_media_object_GetInputCurrentType,
+    wma_media_object_GetOutputCurrentType,
+    wma_media_object_GetInputSizeInfo,
+    wma_media_object_GetOutputSizeInfo,
+    wma_media_object_GetInputMaxLatency,
+    wma_media_object_SetInputMaxLatency,
+    wma_media_object_Flush,
+    wma_media_object_Discontinuity,
+    wma_media_object_AllocateStreamingResources,
+    wma_media_object_FreeStreamingResources,
+    wma_media_object_GetInputStatus,
+    wma_media_object_ProcessInput,
+    wma_media_object_ProcessOutput,
+    wma_media_object_Lock,
 };
 
 HRESULT wma_decoder_create(IUnknown *outer, IUnknown **out)
@@ -860,10 +849,9 @@ HRESULT wma_decoder_create(IUnknown *outer, IUnknown **out)
     if (!(decoder = calloc(1, sizeof(*decoder))))
         return E_OUTOFMEMORY;
 
-    decoder->IUnknown_inner.lpVtbl = &unknown_vtbl;
-    decoder->IMFTransform_iface.lpVtbl = &transform_vtbl;
-    decoder->IMediaObject_iface.lpVtbl = &media_object_vtbl;
-    decoder->IPropertyBag_iface.lpVtbl = &property_bag_vtbl;
+    decoder->IUnknown_inner.lpVtbl = &wma_unknown_vtbl;
+    decoder->IMFTransform_iface.lpVtbl = &mf_transform_vtbl;
+    decoder->IMediaObject_iface.lpVtbl = &wma_media_object_vtbl;
     decoder->refcount = 1;
     decoder->outer = outer ? outer : &decoder->IUnknown_inner;
 
diff --git a/include/wine/strmbase.h b/include/wine/strmbase.h
index 4d569e1fc6c..319717e9497 100644
--- wine/include/wine/strmbase.h
+++ wine/include/wine/strmbase.h
@@ -122,6 +122,7 @@ void strmbase_sink_cleanup(struct strmbase_sink *pin);
 struct strmbase_filter
 {
     IBaseFilter IBaseFilter_iface;
+    IPropertyBag IPropertyBag_iface;
     IUnknown IUnknown_inner;
     IUnknown *outer_unk;
     LONG refcount;
diff --git a/libs/strmbase/Makefile.in b/libs/strmbase/Makefile.in
index 8b6ea8a3b43..c9b4a9ebb5c 100644
--- wine/libs/strmbase/Makefile.in
+++ wine/libs/strmbase/Makefile.in
@@ -1,3 +1,4 @@
+EXTRADEFS = -DWINE_NO_LONG_TYPES
 STATICLIB = libstrmbase.a
 
 C_SRCS = \
diff --git a/libs/strmbase/dispatch.c b/libs/strmbase/dispatch.c
index 061655d4693..562c8c12ee6 100644
--- wine/libs/strmbase/dispatch.c
+++ wine/libs/strmbase/dispatch.c
@@ -46,7 +46,7 @@ HRESULT strmbase_get_typeinfo(enum strmbase_type_id tid, ITypeInfo **ret)
         hr = LoadRegTypeLib(&LIBID_QuartzTypeLib, 1, 0, LOCALE_SYSTEM_DEFAULT, &typelib);
         if (FAILED(hr))
         {
-            ERR("Failed to load typelib, hr %#lx.\n", hr);
+            ERR("Failed to load typelib, hr %#x.\n", hr);
             return hr;
         }
         if (InterlockedCompareExchangePointer((void **)&control_typelib, typelib, NULL))
@@ -59,7 +59,7 @@ HRESULT strmbase_get_typeinfo(enum strmbase_type_id tid, ITypeInfo **ret)
         hr = ITypeLib_GetTypeInfoOfGuid(control_typelib, control_tid_id[tid], &typeinfo);
         if (FAILED(hr))
         {
-            ERR("Failed to get type info for %s, hr %#lx.\n", debugstr_guid(control_tid_id[tid]), hr);
+            ERR("Failed to get type info for %s, hr %#x.\n", debugstr_guid(control_tid_id[tid]), hr);
             return hr;
         }
         if (InterlockedCompareExchangePointer((void **)(control_typeinfo + tid), typeinfo, NULL))
diff --git a/libs/strmbase/filter.c b/libs/strmbase/filter.c
index ee41611a198..b30ef6daf4f 100644
--- wine/libs/strmbase/filter.c
+++ wine/libs/strmbase/filter.c
@@ -87,7 +87,7 @@ static ULONG WINAPI enum_pins_AddRef(IEnumPins *iface)
 {
     struct enum_pins *enum_pins = impl_from_IEnumPins(iface);
     ULONG refcount = InterlockedIncrement(&enum_pins->refcount);
-    TRACE("%p increasing refcount to %lu.\n", enum_pins, refcount);
+    TRACE("%p increasing refcount to %u.\n", enum_pins, refcount);
     return refcount;
 }
 
@@ -96,7 +96,7 @@ static ULONG WINAPI enum_pins_Release(IEnumPins *iface)
     struct enum_pins *enum_pins = impl_from_IEnumPins(iface);
     ULONG refcount = InterlockedDecrement(&enum_pins->refcount);
 
-    TRACE("%p decreasing refcount to %lu.\n", enum_pins, refcount);
+    TRACE("%p decreasing refcount to %u.\n", enum_pins, refcount);
     if (!refcount)
     {
         IBaseFilter_Release(&enum_pins->filter->IBaseFilter_iface);
@@ -110,7 +110,7 @@ static HRESULT WINAPI enum_pins_Next(IEnumPins *iface, ULONG count, IPin **pins,
     struct enum_pins *enum_pins = impl_from_IEnumPins(iface);
     unsigned int i;
 
-    TRACE("iface %p, count %lu, pins %p, ret_count %p.\n", iface, count, pins, ret_count);
+    TRACE("iface %p, count %u, pins %p, ret_count %p.\n", iface, count, pins, ret_count);
 
     if (!pins)
         return E_POINTER;
@@ -144,7 +144,7 @@ static HRESULT WINAPI enum_pins_Skip(IEnumPins *iface, ULONG count)
 {
     struct enum_pins *enum_pins = impl_from_IEnumPins(iface);
 
-    TRACE("iface %p, count %lu.\n", iface, count);
+    TRACE("iface %p, count %u.\n", iface, count);
 
     if (enum_pins->version != enum_pins->filter->pin_version)
         return VFW_E_ENUM_OUT_OF_SYNC;
@@ -226,6 +226,8 @@ static HRESULT WINAPI filter_inner_QueryInterface(IUnknown *iface, REFIID iid, v
     {
         *out = &filter->IBaseFilter_iface;
     }
+    else if (IsEqualIID(iid, &IID_IPropertyBag))
+        *out = &filter->IPropertyBag_iface;
     else
     {
         WARN("%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid(iid));
@@ -241,7 +243,7 @@ static ULONG WINAPI filter_inner_AddRef(IUnknown *iface)
     struct strmbase_filter *filter = impl_from_IUnknown(iface);
     ULONG refcount = InterlockedIncrement(&filter->refcount);
 
-    TRACE("%p increasing refcount to %lu.\n", filter, refcount);
+    TRACE("%p increasing refcount to %u.\n", filter, refcount);
 
     return refcount;
 }
@@ -251,7 +253,7 @@ static ULONG WINAPI filter_inner_Release(IUnknown *iface)
     struct strmbase_filter *filter = impl_from_IUnknown(iface);
     ULONG refcount = InterlockedDecrement(&filter->refcount);
 
-    TRACE("%p decreasing refcount to %lu.\n", filter, refcount);
+    TRACE("%p decreasing refcount to %u.\n", filter, refcount);
 
     if (!refcount)
         filter->ops->filter_destroy(filter);
@@ -368,7 +370,7 @@ static HRESULT WINAPI filter_GetState(IBaseFilter *iface, DWORD timeout, FILTER_
     struct strmbase_filter *filter = impl_from_IBaseFilter(iface);
     HRESULT hr = S_OK;
 
-    TRACE("filter %p %s, timeout %lu, state %p.\n", filter, debugstr_w(filter->name), timeout, state);
+    TRACE("filter %p %s, timeout %u, state %p.\n", filter, debugstr_w(filter->name), timeout, state);
 
     EnterCriticalSection(&filter->filter_cs);
 
@@ -436,7 +438,7 @@ static HRESULT WINAPI filter_FindPin(IBaseFilter *iface, const WCHAR *id, IPin *
 
     for (i = 0; (pin = filter->ops->filter_get_pin(filter, i)); ++i)
     {
-        if (!lstrcmpW(id, pin->id))
+        if (!lstrcmpW(id, pin->name))
         {
             IPin_AddRef(*ret = &pin->IPin_iface);
             return S_OK;
@@ -509,6 +511,51 @@ static const IBaseFilterVtbl filter_vtbl =
     filter_QueryVendorInfo,
 };
 
+static inline struct strmbase_filter *impl_from_IPropertyBag(IPropertyBag *iface)
+{
+    return CONTAINING_RECORD(iface, struct strmbase_filter, IPropertyBag_iface);
+}
+
+static HRESULT WINAPI property_bag_QueryInterface(IPropertyBag *iface, REFIID iid, void **out)
+{
+    struct strmbase_filter *filter = impl_from_IPropertyBag(iface);
+    return IUnknown_QueryInterface(filter->outer_unk, iid, out);
+}
+
+static ULONG WINAPI property_bag_AddRef(IPropertyBag *iface)
+{
+    struct strmbase_filter *filter = impl_from_IPropertyBag(iface);
+    return IUnknown_AddRef(filter->outer_unk);
+}
+
+static ULONG WINAPI property_bag_Release(IPropertyBag *iface)
+{
+    struct strmbase_filter *filter = impl_from_IPropertyBag(iface);
+    return IUnknown_Release(filter->outer_unk);
+}
+
+static HRESULT WINAPI property_bag_Read(IPropertyBag *iface, const WCHAR *prop_name, VARIANT *value,
+        IErrorLog *error_log)
+{
+    FIXME("iface %p, prop_name %s, value %p, error_log %p stub!\n", iface, debugstr_w(prop_name), value, error_log);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI property_bag_Write(IPropertyBag *iface, const WCHAR *prop_name, VARIANT *value)
+{
+    FIXME("iface %p, prop_name %s, value %p stub!\n", iface, debugstr_w(prop_name), value);
+    return S_OK;
+}
+
+static const IPropertyBagVtbl property_bag_vtbl =
+{
+    property_bag_QueryInterface,
+    property_bag_AddRef,
+    property_bag_Release,
+    property_bag_Read,
+    property_bag_Write,
+};
+
 VOID WINAPI BaseFilterImpl_IncrementPinVersion(struct strmbase_filter *filter)
 {
     InterlockedIncrement(&filter->pin_version);
@@ -520,6 +567,7 @@ void strmbase_filter_init(struct strmbase_filter *filter, IUnknown *outer,
     memset(filter, 0, sizeof(*filter));
 
     filter->IBaseFilter_iface.lpVtbl = &filter_vtbl;
+    filter->IPropertyBag_iface.lpVtbl = &property_bag_vtbl;
     filter->IUnknown_inner.lpVtbl = &filter_inner_vtbl;
     filter->outer_unk = outer ? outer : &filter->IUnknown_inner;
     filter->refcount = 1;
diff --git a/libs/strmbase/mediatype.c b/libs/strmbase/mediatype.c
index 33af6f2e636..6f66999c390 100644
--- wine/libs/strmbase/mediatype.c
+++ wine/libs/strmbase/mediatype.c
@@ -60,7 +60,7 @@ static const char *debugstr_fourcc(DWORD fourcc)
     char str[4] = {fourcc, fourcc >> 8, fourcc >> 16, fourcc >> 24};
     if (isprint(str[0]) && isprint(str[1]) && isprint(str[2]) && isprint(str[3]))
         return wine_dbgstr_an(str, 4);
-    return wine_dbg_sprintf("%#lx", fourcc);
+    return wine_dbg_sprintf("%#x", fourcc);
 }
 
 void strmbase_dump_media_type(const AM_MEDIA_TYPE *mt)
@@ -71,7 +71,7 @@ void strmbase_dump_media_type(const AM_MEDIA_TYPE *mt)
             mt, strmbase_debugstr_guid(&mt->majortype), strmbase_debugstr_guid(&mt->subtype));
     if (mt->bFixedSizeSamples) TRACE(", fixed size samples");
     if (mt->bTemporalCompression) TRACE(", temporal compression");
-    if (mt->lSampleSize) TRACE(", sample size %ld", mt->lSampleSize);
+    if (mt->lSampleSize) TRACE(", sample size %d", mt->lSampleSize);
     if (mt->pUnk) TRACE(", pUnk %p", mt->pUnk);
     TRACE(", format type %s.\n", strmbase_debugstr_guid(&mt->formattype));
 
@@ -83,7 +83,7 @@ void strmbase_dump_media_type(const AM_MEDIA_TYPE *mt)
     {
         WAVEFORMATEX *wfx = (WAVEFORMATEX *)mt->pbFormat;
 
-        TRACE("tag %#x, %u channels, sample rate %lu, %lu bytes/sec, alignment %u, %u bits/sample.\n",
+        TRACE("tag %#x, %u channels, sample rate %u, %u bytes/sec, alignment %u, %u bits/sample.\n",
                 wfx->wFormatTag, wfx->nChannels, wfx->nSamplesPerSec,
                 wfx->nAvgBytesPerSec, wfx->nBlockAlign, wfx->wBitsPerSample);
 
@@ -107,17 +107,17 @@ void strmbase_dump_media_type(const AM_MEDIA_TYPE *mt)
 
         if (!IsRectEmpty(&vih->rcSource)) TRACE("source %s, ", wine_dbgstr_rect(&vih->rcSource));
         if (!IsRectEmpty(&vih->rcTarget)) TRACE("target %s, ", wine_dbgstr_rect(&vih->rcTarget));
-        if (vih->dwBitRate) TRACE("bitrate %lu, ", vih->dwBitRate);
-        if (vih->dwBitErrorRate) TRACE("error rate %lu, ", vih->dwBitErrorRate);
+        if (vih->dwBitRate) TRACE("bitrate %u, ", vih->dwBitRate);
+        if (vih->dwBitErrorRate) TRACE("error rate %u, ", vih->dwBitErrorRate);
         TRACE("%s sec/frame, ", debugstr_time(vih->AvgTimePerFrame));
-        TRACE("size %ldx%ld, %u planes, %u bpp, compression %s, image size %lu",
+        TRACE("size %dx%d, %u planes, %u bpp, compression %s, image size %u",
                 vih->bmiHeader.biWidth, vih->bmiHeader.biHeight, vih->bmiHeader.biPlanes,
                 vih->bmiHeader.biBitCount, debugstr_fourcc(vih->bmiHeader.biCompression),
                 vih->bmiHeader.biSizeImage);
         if (vih->bmiHeader.biXPelsPerMeter || vih->bmiHeader.biYPelsPerMeter)
-            TRACE(", resolution %ldx%ld", vih->bmiHeader.biXPelsPerMeter, vih->bmiHeader.biYPelsPerMeter);
-        if (vih->bmiHeader.biClrUsed) TRACE(", %lu colours", vih->bmiHeader.biClrUsed);
-        if (vih->bmiHeader.biClrImportant) TRACE(", %lu important colours", vih->bmiHeader.biClrImportant);
+            TRACE(", resolution %dx%d", vih->bmiHeader.biXPelsPerMeter, vih->bmiHeader.biYPelsPerMeter);
+        if (vih->bmiHeader.biClrUsed) TRACE(", %d colours", vih->bmiHeader.biClrUsed);
+        if (vih->bmiHeader.biClrImportant) TRACE(", %d important colours", vih->bmiHeader.biClrImportant);
         TRACE(".\n");
     }
     else if (IsEqualGUID(&mt->formattype, &FORMAT_VideoInfo2) && mt->cbFormat >= sizeof(VIDEOINFOHEADER2))
@@ -126,13 +126,13 @@ void strmbase_dump_media_type(const AM_MEDIA_TYPE *mt)
 
         if (!IsRectEmpty(&vih->rcSource)) TRACE("source %s, ", wine_dbgstr_rect(&vih->rcSource));
         if (!IsRectEmpty(&vih->rcTarget)) TRACE("target %s, ", wine_dbgstr_rect(&vih->rcTarget));
-        if (vih->dwBitRate) TRACE("bitrate %lu, ", vih->dwBitRate);
-        if (vih->dwBitErrorRate) TRACE("error rate %lu, ", vih->dwBitErrorRate);
+        if (vih->dwBitRate) TRACE("bitrate %u, ", vih->dwBitRate);
+        if (vih->dwBitErrorRate) TRACE("error rate %u, ", vih->dwBitErrorRate);
         TRACE("%s sec/frame, ", debugstr_time(vih->AvgTimePerFrame));
-        if (vih->dwInterlaceFlags) TRACE("interlace flags %#lx, ", vih->dwInterlaceFlags);
-        if (vih->dwCopyProtectFlags) TRACE("copy-protection flags %#lx, ", vih->dwCopyProtectFlags);
-        TRACE("aspect ratio %lu/%lu, ", vih->dwPictAspectRatioX, vih->dwPictAspectRatioY);
-        if (vih->u.dwControlFlags) TRACE("control flags %#lx, ", vih->u.dwControlFlags);
+        if (vih->dwInterlaceFlags) TRACE("interlace flags %#x, ", vih->dwInterlaceFlags);
+        if (vih->dwCopyProtectFlags) TRACE("copy-protection flags %#x, ", vih->dwCopyProtectFlags);
+        TRACE("aspect ratio %u/%u, ", vih->dwPictAspectRatioX, vih->dwPictAspectRatioY);
+        if (vih->u.dwControlFlags) TRACE("control flags %#x, ", vih->u.dwControlFlags);
         if (vih->u.dwControlFlags & AMCONTROL_COLORINFO_PRESENT)
         {
             const DXVA_ExtendedFormat *colorimetry = (const DXVA_ExtendedFormat *)&vih->u.dwControlFlags;
@@ -141,14 +141,14 @@ void strmbase_dump_media_type(const AM_MEDIA_TYPE *mt)
                     colorimetry->VideoChromaSubsampling, colorimetry->NominalRange, colorimetry->VideoTransferMatrix,
                     colorimetry->VideoLighting, colorimetry->VideoPrimaries, colorimetry->VideoTransferFunction);
         }
-        TRACE("size %ldx%ld, %u planes, %u bpp, compression %s, image size %lu",
+        TRACE("size %dx%d, %u planes, %u bpp, compression %s, image size %u",
                 vih->bmiHeader.biWidth, vih->bmiHeader.biHeight, vih->bmiHeader.biPlanes,
                 vih->bmiHeader.biBitCount, debugstr_fourcc(vih->bmiHeader.biCompression),
                 vih->bmiHeader.biSizeImage);
         if (vih->bmiHeader.biXPelsPerMeter || vih->bmiHeader.biYPelsPerMeter)
-            TRACE(", resolution %ldx%ld", vih->bmiHeader.biXPelsPerMeter, vih->bmiHeader.biYPelsPerMeter);
-        if (vih->bmiHeader.biClrUsed) TRACE(", %lu colours", vih->bmiHeader.biClrUsed);
-        if (vih->bmiHeader.biClrImportant) TRACE(", %lu important colours", vih->bmiHeader.biClrImportant);
+            TRACE(", resolution %dx%d", vih->bmiHeader.biXPelsPerMeter, vih->bmiHeader.biYPelsPerMeter);
+        if (vih->bmiHeader.biClrUsed) TRACE(", %d colours", vih->bmiHeader.biClrUsed);
+        if (vih->bmiHeader.biClrImportant) TRACE(", %d important colours", vih->bmiHeader.biClrImportant);
         TRACE(".\n");
     }
     else
diff --git a/libs/strmbase/pin.c b/libs/strmbase/pin.c
index 03330837477..36b3fdf1425 100644
--- wine/libs/strmbase/pin.c
+++ wine/libs/strmbase/pin.c
@@ -97,7 +97,7 @@ static ULONG WINAPI enum_media_types_AddRef(IEnumMediaTypes *iface)
 {
     struct enum_media_types *enummt = impl_from_IEnumMediaTypes(iface);
     ULONG refcount = InterlockedIncrement(&enummt->refcount);
-    TRACE("%p increasing refcount to %lu.\n", enummt, refcount);
+    TRACE("%p increasing refcount to %u.\n", enummt, refcount);
     return refcount;
 }
 
@@ -106,7 +106,7 @@ static ULONG WINAPI enum_media_types_Release(IEnumMediaTypes *iface)
     struct enum_media_types *enummt = impl_from_IEnumMediaTypes(iface);
     ULONG refcount = InterlockedDecrement(&enummt->refcount);
 
-    TRACE("%p decreasing refcount to %lu.\n", enummt, refcount);
+    TRACE("%p decreasing refcount to %u.\n", enummt, refcount);
     if (!refcount)
     {
         IPin_Release(&enummt->pin->IPin_iface);
@@ -123,7 +123,7 @@ static HRESULT WINAPI enum_media_types_Next(IEnumMediaTypes *iface, ULONG count,
     unsigned int i;
     HRESULT hr;
 
-    TRACE("enummt %p, count %lu, mts %p, ret_count %p.\n", enummt, count, mts, ret_count);
+    TRACE("enummt %p, count %u, mts %p, ret_count %p.\n", enummt, count, mts, ret_count);
 
     if (!enummt->pin->ops->pin_get_media_type)
     {
@@ -169,7 +169,7 @@ static HRESULT WINAPI enum_media_types_Skip(IEnumMediaTypes *iface, ULONG count)
 {
     struct enum_media_types *enummt = impl_from_IEnumMediaTypes(iface);
 
-    TRACE("enummt %p, count %lu.\n", enummt, count);
+    TRACE("enummt %p, count %u.\n", enummt, count);
 
     enummt->index += count;
 
@@ -383,10 +383,10 @@ static HRESULT WINAPI pin_QueryId(IPin *iface, WCHAR **id)
 
     TRACE("pin %p %s:%s, id %p.\n", pin, debugstr_w(pin->filter->name), debugstr_w(pin->name), id);
 
-    if (!(*id = CoTaskMemAlloc((lstrlenW(pin->id) + 1) * sizeof(WCHAR))))
+    if (!(*id = CoTaskMemAlloc((lstrlenW(pin->name) + 1) * sizeof(WCHAR))))
         return E_OUTOFMEMORY;
 
-    lstrcpyW(*id, pin->id);
+    lstrcpyW(*id, pin->name);
 
     return S_OK;
 }
@@ -677,6 +677,31 @@ static const IPinVtbl source_vtbl =
     source_NewSegment,
 };
 
+HRESULT WINAPI BaseOutputPinImpl_GetDeliveryBuffer(struct strmbase_source *This,
+        IMediaSample **ppSample, REFERENCE_TIME *tStart, REFERENCE_TIME *tStop, DWORD dwFlags)
+{
+    HRESULT hr;
+
+    TRACE("(%p)->(%p, %p, %p, %x)\n", This, ppSample, tStart, tStop, dwFlags);
+
+    if (!This->pin.peer)
+        hr = VFW_E_NOT_CONNECTED;
+    else
+    {
+        hr = IMemAllocator_GetBuffer(This->pAllocator, ppSample, tStart, tStop, dwFlags);
+
+        if (SUCCEEDED(hr))
+            hr = IMediaSample_SetTime(*ppSample, tStart, tStop);
+    }
+
+    return hr;
+}
+
+HRESULT WINAPI BaseOutputPinImpl_InitAllocator(struct strmbase_source *This, IMemAllocator **pMemAlloc)
+{
+    return CoCreateInstance(&CLSID_MemoryAllocator, NULL, CLSCTX_INPROC_SERVER, &IID_IMemAllocator, (LPVOID*)pMemAlloc);
+}
+
 HRESULT WINAPI BaseOutputPinImpl_DecideAllocator(struct strmbase_source *This,
         IMemInputPin *pPin, IMemAllocator **pAlloc)
 {
@@ -685,8 +710,8 @@ HRESULT WINAPI BaseOutputPinImpl_DecideAllocator(struct strmbase_source *This,
     hr = IMemInputPin_GetAllocator(pPin, pAlloc);
 
     if (hr == VFW_E_NO_ALLOCATOR)
-        hr = CoCreateInstance(&CLSID_MemoryAllocator, NULL,
-                CLSCTX_INPROC_SERVER, &IID_IMemAllocator, (void **)pAlloc);
+        /* Input pin provides no allocator, use standard memory allocator */
+        hr = BaseOutputPinImpl_InitAllocator(This, pAlloc);
 
     if (SUCCEEDED(hr))
     {
@@ -758,7 +783,7 @@ HRESULT WINAPI BaseOutputPinImpl_AttemptConnection(struct strmbase_source *This,
         FreeMediaType(&This->pin.mt);
     }
 
-    TRACE("Returning %#lx.\n", hr);
+    TRACE(" -- %x\n", hr);
     return hr;
 }
 
@@ -770,7 +795,6 @@ void strmbase_source_init(struct strmbase_source *pin, struct strmbase_filter *f
     pin->pin.filter = filter;
     pin->pin.dir = PINDIR_OUTPUT;
     lstrcpyW(pin->pin.name, name);
-    lstrcpyW(pin->pin.id, name);
     pin->pin.ops = &func_table->base;
     pin->pFuncsTable = func_table;
 }
@@ -1173,7 +1197,6 @@ void strmbase_sink_init(struct strmbase_sink *pin, struct strmbase_filter *filte
     pin->pin.filter = filter;
     pin->pin.dir = PINDIR_INPUT;
     lstrcpyW(pin->pin.name, name);
-    lstrcpyW(pin->pin.id, name);
     pin->pin.ops = &func_table->base;
     pin->pFuncsTable = func_table;
     pin->pAllocator = pin->preferred_allocator = allocator;
diff --git a/libs/strmbase/pospass.c b/libs/strmbase/pospass.c
index 03cb7783f97..7478c0e67c5 100644
--- wine/libs/strmbase/pospass.c
+++ wine/libs/strmbase/pospass.c
@@ -296,11 +296,7 @@ static HRESULT WINAPI MediaSeekingPassThru_ConvertTimeFormat(IMediaSeeking * ifa
     struct strmbase_passthrough *This = impl_from_IMediaSeeking(iface);
     IMediaSeeking *seek;
     HRESULT hr;
-
-    TRACE("iface %p, target %p, target_format %s, source %s, source_format %s.\n",
-            iface, pTarget, debugstr_guid(pTargetFormat),
-            wine_dbgstr_longlong(Source), debugstr_guid(pSourceFormat));
-
+    TRACE("(%p/%p)->(%p,%s,%x%08x,%s)\n", iface, This, pTarget, debugstr_guid(pTargetFormat), (DWORD)(Source>>32), (DWORD)Source, debugstr_guid(pSourceFormat));
     hr = get_connected(This, &IID_IMediaSeeking, (LPVOID*)&seek);
     if (SUCCEEDED(hr)) {
         hr = IMediaSeeking_ConvertTimeFormat(seek, pTarget, pTargetFormat, Source, pSourceFormat);
@@ -316,10 +312,7 @@ static HRESULT WINAPI MediaSeekingPassThru_SetPositions(IMediaSeeking * iface, L
     struct strmbase_passthrough *This = impl_from_IMediaSeeking(iface);
     IMediaSeeking *seek;
     HRESULT hr;
-
-    TRACE("iface %p, current %p, current_flags %#lx, stop %p, stop_flags %#lx.\n",
-            iface, pCurrent, dwCurrentFlags, pStop, dwStopFlags);
-
+    TRACE("(%p/%p)->(%p,%x,%p,%x)\n", iface, This, pCurrent, dwCurrentFlags, pStop, dwStopFlags);
     hr = get_connected(This, &IID_IMediaSeeking, (LPVOID*)&seek);
     if (SUCCEEDED(hr)) {
         hr = IMediaSeeking_SetPositions(seek, pCurrent, dwCurrentFlags, pStop, dwStopFlags);
@@ -464,7 +457,7 @@ static HRESULT WINAPI MediaPositionPassThru_GetTypeInfoCount(IMediaPosition *ifa
 static HRESULT WINAPI MediaPositionPassThru_GetTypeInfo(IMediaPosition *iface, UINT index,
         LCID lcid, ITypeInfo **typeinfo)
 {
-    TRACE("iface %p, index %u, lcid %#lx, typeinfo %p.\n", iface, index, lcid, typeinfo);
+    TRACE("iface %p, index %u, lcid %#x, typeinfo %p.\n", iface, index, lcid, typeinfo);
     return strmbase_get_typeinfo(IMediaPosition_tid, typeinfo);
 }
 
@@ -474,7 +467,7 @@ static HRESULT WINAPI MediaPositionPassThru_GetIDsOfNames(IMediaPosition *iface,
     ITypeInfo *typeinfo;
     HRESULT hr;
 
-    TRACE("iface %p, iid %s, names %p, count %u, lcid %#lx, ids %p.\n",
+    TRACE("iface %p, iid %s, names %p, count %u, lcid %#x, ids %p.\n",
             iface, debugstr_guid(iid), names, count, lcid, ids);
 
     if (SUCCEEDED(hr = strmbase_get_typeinfo(IMediaPosition_tid, &typeinfo)))
@@ -491,7 +484,7 @@ static HRESULT WINAPI MediaPositionPassThru_Invoke(IMediaPosition *iface, DISPID
     ITypeInfo *typeinfo;
     HRESULT hr;
 
-    TRACE("iface %p, id %ld, iid %s, lcid %#lx, flags %#x, params %p, result %p, excepinfo %p, error_arg %p.\n",
+    TRACE("iface %p, id %d, iid %s, lcid %#x, flags %#x, params %p, result %p, excepinfo %p, error_arg %p.\n",
             iface, id, debugstr_guid(iid), lcid, flags, params, result, excepinfo, error_arg);
 
     if (SUCCEEDED(hr = strmbase_get_typeinfo(IMediaPosition_tid, &typeinfo)))
diff --git a/libs/strmbase/renderer.c b/libs/strmbase/renderer.c
index dc421f499ed..da257555a19 100644
--- wine/libs/strmbase/renderer.c
+++ wine/libs/strmbase/renderer.c
@@ -526,7 +526,7 @@ static HRESULT WINAPI quality_control_Notify(IQualityControl *iface, IBaseFilter
     struct strmbase_renderer *filter = impl_from_IQualityControl(iface);
     HRESULT hr = S_FALSE;
 
-    TRACE("filter %p, sender %p, type %#x, proportion %ld, late %s, timestamp %s.\n",
+    TRACE("filter %p, sender %p, type %#x, proportion %u, late %s, timestamp %s.\n",
             filter, sender, q.Type, q.Proportion, debugstr_time(q.Late), debugstr_time(q.TimeStamp));
 
     if (filter->qc_sink)
diff --git a/libs/strmbase/seeking.c b/libs/strmbase/seeking.c
index b3991f0a5b3..67ef660ba3d 100644
--- wine/libs/strmbase/seeking.c
+++ wine/libs/strmbase/seeking.c
@@ -220,10 +220,7 @@ HRESULT WINAPI SourceSeekingImpl_SetPositions(IMediaSeeking * iface, LONGLONG *
     BOOL bChangeCurrent = FALSE, bChangeStop = FALSE;
     LONGLONG llNewCurrent, llNewStop;
 
-    TRACE("iface %p, current %s, current_flags %#lx, stop %s, stop_flags %#lx.\n", iface,
-            pCurrent ? debugstr_time(*pCurrent) : "<null>", dwCurrentFlags,
-            pStop ? debugstr_time(*pStop): "<null>", dwStopFlags);
-
+    TRACE("(%p, %x, %p, %x)\n", pCurrent, dwCurrentFlags, pStop, dwStopFlags);
     EnterCriticalSection(&This->cs);
 
     llNewCurrent = Adjust(This->llCurrent, pCurrent, dwCurrentFlags);
@@ -234,7 +231,7 @@ HRESULT WINAPI SourceSeekingImpl_SetPositions(IMediaSeeking * iface, LONGLONG *
     if (llNewStop != This->llStop)
         bChangeStop = TRUE;
 
-    TRACE("Seeking from %s to %s.\n", debugstr_time(This->llCurrent), debugstr_time(llNewCurrent));
+    TRACE("Old: %u, New: %u\n", (DWORD)(This->llCurrent/10000000), (DWORD)(llNewCurrent/10000000));
 
     This->llCurrent = llNewCurrent;
     This->llStop = llNewStop;
diff --git a/libs/strmiids/strmiids.c b/libs/strmiids/strmiids.c
index 1a7005bde3c..d07da38bb16 100644
--- wine/libs/strmiids/strmiids.c
+++ wine/libs/strmiids/strmiids.c
@@ -39,4 +39,4 @@
 #include "amstream.h"
 #include "qedit.h"
 #include "vmr9.h"
-#include "videoacc.h"
+#include "videoacc.h"
\ No newline at end of file
-- 
2.39.2 (Apple Git-144)

diff --git a/dlls/mfreadwrite/reader.c b/dlls/mfreadwrite/reader.c
index e7b7b55..ea0058b 100644
--- wine/dlls/mfreadwrite/reader.c
+++ wine/dlls/mfreadwrite/reader.c
@@ -2472,6 +2472,92 @@ failed:
     return hr;
 }
 
+static HRESULT bytestream_get_url_hint(IMFByteStream *stream, WCHAR const **url)
+{
+    static const unsigned char asfmagic[]  = {0x30,0x26,0xb2,0x75,0x8e,0x66,0xcf,0x11,0xa6,0xd9,0x00,0xaa,0x00,0x62,0xce,0x6c};
+    static const unsigned char wavmagic[]  = { 'R', 'I', 'F', 'F',0x00,0x00,0x00,0x00, 'W', 'A', 'V', 'E', 'f', 'm', 't', ' '};
+    static const unsigned char wavmask[]   = {0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff};
+    static const unsigned char isommagic[] = {0x00,0x00,0x00,0x00, 'f', 't', 'y', 'p', 'i', 's', 'o', 'm',0x00,0x00,0x00,0x00};
+    static const unsigned char mp4_magic[] = {0x00,0x00,0x00,0x00, 'f', 't', 'y', 'p', 'M', 'S', 'N', 'V',0x00,0x00,0x00,0x00};
+    static const unsigned char mp42magic[] = {0x00,0x00,0x00,0x00, 'f', 't', 'y', 'p', 'm', 'p', '4', '2',0x00,0x00,0x00,0x00};
+    static const unsigned char mp4vmagic[] = {0x00,0x00,0x00,0x00, 'f', 't', 'y', 'p', 'M', '4', 'V', ' ',0x00,0x00,0x00,0x00};
+    static const unsigned char mp4mask[]   = {0x00,0x00,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00};
+    static const struct stream_content_url_hint
+    {
+        const unsigned char *magic;
+        const WCHAR *url;
+        const unsigned char *mask;
+    }
+    url_hints[] =
+    {
+        { asfmagic,  L".asf" },
+        { wavmagic,  L".wav", wavmask },
+        { isommagic, L".mp4", mp4mask },
+        { mp42magic, L".mp4", mp4mask },
+        { mp4_magic, L".mp4", mp4mask },
+        { mp4vmagic, L".m4v", mp4mask },
+    };
+    unsigned char buffer[4 * sizeof(unsigned int)], pattern[4 * sizeof(unsigned int)];
+    unsigned int i, j, length = 0, caps = 0;
+    IMFAttributes *attributes;
+    QWORD position;
+    HRESULT hr;
+
+    *url = NULL;
+
+    if (SUCCEEDED(IMFByteStream_QueryInterface(stream, &IID_IMFAttributes, (void **)&attributes)))
+    {
+        IMFAttributes_GetStringLength(attributes, &MF_BYTESTREAM_CONTENT_TYPE, &length);
+        IMFAttributes_Release(attributes);
+    }
+
+    if (length)
+        return S_OK;
+
+    if (FAILED(hr = IMFByteStream_GetCapabilities(stream, &caps)))
+        return hr;
+
+    if (!(caps & MFBYTESTREAM_IS_SEEKABLE))
+        return S_OK;
+
+    if (FAILED(hr = IMFByteStream_GetCurrentPosition(stream, &position)))
+        return hr;
+
+    hr = IMFByteStream_Read(stream, buffer, sizeof(buffer), &length);
+    IMFByteStream_SetCurrentPosition(stream, position);
+    if (FAILED(hr))
+        return hr;
+
+    if (length < sizeof(buffer))
+        return S_OK;
+
+    for (i = 0; i < ARRAY_SIZE(url_hints); ++i)
+    {
+        memcpy(pattern, buffer, sizeof(buffer));
+        if (url_hints[i].mask)
+        {
+            unsigned int *mask = (unsigned int *)url_hints[i].mask;
+            unsigned int *data = (unsigned int *)pattern;
+
+            for (j = 0; j < sizeof(buffer) / sizeof(unsigned int); ++j)
+                data[j] &= mask[j];
+
+        }
+        if (!memcmp(pattern, url_hints[i].magic, sizeof(pattern)))
+        {
+            *url = url_hints[i].url;
+            break;
+        }
+    }
+
+    if (*url)
+        TRACE("Stream type guessed as %s from %s.\n", debugstr_w(*url), debugstr_an((char *)buffer, length));
+    else
+        WARN("Unrecognized content type %s.\n", debugstr_an((char *)buffer, length));
+
+    return S_OK;
+}
+
 static HRESULT create_source_reader_from_stream(IMFByteStream *stream, IMFAttributes *attributes,
         REFIID riid, void **out)
 {
@@ -2479,8 +2565,13 @@ static HRESULT create_source_reader_from_stream(IMFByteStream *stream, IMFAttrib
     IMFSourceResolver *resolver;
     MF_OBJECT_TYPE obj_type;
     IMFMediaSource *source;
+    const WCHAR *url;
     HRESULT hr;
 
+    /* If stream does not have content type set, try to guess from starting byte sequence. */
+    if (FAILED(hr = bytestream_get_url_hint(stream, &url)))
+        return hr;
+
     if (FAILED(hr = MFCreateSourceResolver(&resolver)))
         return hr;
 
@@ -2488,7 +2579,7 @@ static HRESULT create_source_reader_from_stream(IMFByteStream *stream, IMFAttrib
         IMFAttributes_GetUnknown(attributes, &MF_SOURCE_READER_MEDIASOURCE_CONFIG, &IID_IPropertyStore,
                 (void **)&props);
 
-    hr = IMFSourceResolver_CreateObjectFromByteStream(resolver, stream, NULL, MF_RESOLUTION_MEDIASOURCE
+    hr = IMFSourceResolver_CreateObjectFromByteStream(resolver, stream, url, MF_RESOLUTION_MEDIASOURCE
             | MF_RESOLUTION_CONTENT_DOES_NOT_HAVE_TO_MATCH_EXTENSION_OR_MIME_TYPE, props, &obj_type, (IUnknown **)&source);
     IMFSourceResolver_Release(resolver);
     if (props)
diff --git a/include/wine/strmbase.h b/include/wine/strmbase.h
index 319717e..02cd1c5 100644
--- wine/include/wine/strmbase.h
+++ wine/include/wine/strmbase.h
@@ -38,7 +38,6 @@ struct strmbase_pin
     struct strmbase_filter *filter;
     PIN_DIRECTION dir;
     WCHAR name[128];
-    WCHAR id[128];
     IPin *peer;
     AM_MEDIA_TYPE mt;
 
@@ -108,6 +107,8 @@ struct strmbase_sink_ops
 };
 
 /* Base Pin */
+HRESULT WINAPI BaseOutputPinImpl_GetDeliveryBuffer(struct strmbase_source *pin, IMediaSample **sample, REFERENCE_TIME *start, REFERENCE_TIME *stop, DWORD flags);
+HRESULT WINAPI BaseOutputPinImpl_InitAllocator(struct strmbase_source *pin, IMemAllocator **allocator);
 HRESULT WINAPI BaseOutputPinImpl_DecideAllocator(struct strmbase_source *pin, IMemInputPin *peer, IMemAllocator **allocator);
 HRESULT WINAPI BaseOutputPinImpl_AttemptConnection(struct strmbase_source *pin, IPin *peer, const AM_MEDIA_TYPE *mt);
 
-- 
2.39.2 (Apple Git-144)

diff --git a/dlls/kernel32/kernel32.spec b/dlls/kernel32/kernel32.spec
index 51a14338..3626c740 100644
--- wine/dlls/kernel32/kernel32.spec
+++ wine/dlls/kernel32/kernel32.spec
@@ -370,6 +370,7 @@
 @ stdcall -import DeleteProcThreadAttributeList(ptr)
 # @ stub DisableThreadProfiling
 @ stdcall DisassociateCurrentThreadFromCallback(ptr) NTDLL.TpDisassociateCallback
+@ stdcall DiscardVirtualMemory(ptr long) kernelbase.DiscardVirtualMemory
 @ stdcall DeleteTimerQueue(long)
 @ stdcall -import DeleteTimerQueueEx(long long)
 @ stdcall -import DeleteTimerQueueTimer(long long long)
diff --git a/dlls/kernelbase/kernelbase.spec b/dlls/kernelbase/kernelbase.spec
index 3fb2192b..ae6bc842 100644
--- wine/dlls/kernelbase/kernelbase.spec
+++ wine/dlls/kernelbase/kernelbase.spec
@@ -269,7 +269,7 @@
 @ stdcall DisablePredefinedHandleTableInternal(long)
 @ stdcall DisableThreadLibraryCalls(long)
 @ stdcall DisassociateCurrentThreadFromCallback(ptr) ntdll.TpDisassociateCallback
-# @ stub DiscardVirtualMemory
+@ stdcall DiscardVirtualMemory(ptr long)
 @ stdcall DisconnectNamedPipe(long)
 @ stdcall DnsHostnameToComputerNameExW(wstr ptr ptr)
 # @ stub DsBindWithSpnExW
@@ -1247,7 +1247,7 @@
 @ stdcall QueryThreadpoolStackInformation(ptr ptr)
 @ stdcall QueryUnbiasedInterruptTime(ptr) ntdll.RtlQueryUnbiasedInterruptTime
 # @ stub QueryUnbiasedInterruptTimePrecise
-# @ stub QueryVirtualMemoryInformation
+@ stdcall QueryVirtualMemoryInformation(long ptr long ptr long ptr)
 @ stdcall QueryWorkingSet(long ptr long)
 @ stdcall QueryWorkingSetEx(long ptr long)
 @ stdcall QueueUserAPC(ptr long long)
diff --git a/dlls/kernelbase/memory.c b/dlls/kernelbase/memory.c
index e5ad1e5a..83a40a7c 100644
--- wine/dlls/kernelbase/memory.c
+++ wine/dlls/kernelbase/memory.c
@@ -49,6 +49,19 @@ WINE_DECLARE_DEBUG_CHANNEL(globalmem);
  ***********************************************************************/
 
 
+/***********************************************************************
+ *             DiscardVirtualMemory   (kernelbase.@)
+ */
+DWORD WINAPI DECLSPEC_HOTPATCH DiscardVirtualMemory( void *addr, SIZE_T size )
+{
+    NTSTATUS status;
+    LPVOID ret = addr;
+
+    status = NtAllocateVirtualMemory( GetCurrentProcess(), &ret, 0, &size, MEM_RESET, PAGE_NOACCESS );
+    return RtlNtStatusToDosError( status );
+}
+
+
 /***********************************************************************
  *             FlushViewOfFile   (kernelbase.@)
  */
@@ -1286,6 +1299,23 @@ LPVOID WINAPI DECLSPEC_HOTPATCH VirtualAllocExNuma( HANDLE process, void *addr,
 }
 
 
+/***********************************************************************
+ *             QueryVirtualMemoryInformation   (kernelbase.@)
+ */
+BOOL WINAPI DECLSPEC_HOTPATCH QueryVirtualMemoryInformation( HANDLE process, const void *addr,
+        WIN32_MEMORY_INFORMATION_CLASS info_class, void *info, SIZE_T size, SIZE_T *ret_size)
+{
+    switch (info_class)
+    {
+        case MemoryRegionInfo:
+            return set_ntstatus( NtQueryVirtualMemory( process, addr, MemoryRegionInformation, info, size, ret_size ));
+        default:
+            FIXME("Unsupported info class %u.\n", info_class);
+            return FALSE;
+    }
+}
+
+
 /***********************************************************************
  * CPU functions
  ***********************************************************************/
diff --git a/include/Makefile.in b/include/Makefile.in
index f262c7a9..8cf0db6d 100644
--- wine/include/Makefile.in
+++ wine/include/Makefile.in
@@ -413,6 +413,7 @@ SOURCES = \
 	mcx.h \
 	mediaerr.h \
 	mediaobj.idl \
+	memoryapi.h \
 	metahost.idl \
 	mfapi.h \
 	mfd3d12.idl \
diff --git a/include/memoryapi.h b/include/memoryapi.h
new file mode 100644
index 00000000..6728b832
--- /dev/null
+++ wine/include/memoryapi.h
@@ -0,0 +1,46 @@
+/*
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+typedef enum WIN32_MEMORY_INFORMATION_CLASS
+{
+    MemoryRegionInfo
+} WIN32_MEMORY_INFORMATION_CLASS;
+
+typedef struct WIN32_MEMORY_REGION_INFORMATION
+{
+    PVOID AllocationBase;
+    ULONG AllocationProtect;
+    union
+    {
+        ULONG Flags;
+        struct
+        {
+            ULONG Private : 1;
+            ULONG MappedDataFile : 1;
+            ULONG MappedImage : 1;
+            ULONG MappedPageFile : 1;
+            ULONG MappedPhysical : 1;
+            ULONG DirectMapped : 1;
+            ULONG Reserved : 26;
+        } DUMMYSTRUCTNAME;
+    } DUMMYUNIONNAME;
+    SIZE_T RegionSize;
+    SIZE_T CommitSize;
+} WIN32_MEMORY_REGION_INFORMATION;
+
+DWORD WINAPI DiscardVirtualMemory(void *addr, SIZE_T size);
+BOOL WINAPI QueryVirtualMemoryInformation(HANDLE process,const void *addr,
+        WIN32_MEMORY_INFORMATION_CLASS info_class, void *info, SIZE_T size, SIZE_T *ret_size);
diff --git a/include/winbase.h b/include/winbase.h
index c8c893d8..55a5c59c 100644
--- wine/include/winbase.h
+++ wine/include/winbase.h
@@ -45,6 +45,7 @@ extern "C" {
 #include <processthreadsapi.h>
 #include <synchapi.h>
 #include <threadpoolapiset.h>
+#include <memoryapi.h>
 
   /* Windows Exit Procedure flag values */
 #define	WEP_FREE_DLL        0
-- 
2.39.2 (Apple Git-144)

diff --git a/dlls/winemac.drv/macdrv_main.c b/dlls/winemac.drv/macdrv_main.c
index 50e926c6aaa..35f0c3e9204 100644
--- wine/dlls/winemac.drv/macdrv_main.c
+++ wine/dlls/winemac.drv/macdrv_main.c
@@ -507,3 +507,62 @@ BOOL macdrv_SystemParametersInfo( UINT action, UINT int_param, void *ptr_param,
     }
     return FALSE;
 }
+
+#if defined(__x86_64__) && !defined(__i386_on_x86_64__)
+struct macdrv_functions_t
+{
+    void (*macdrv_init_display_devices)(BOOL);
+    struct macdrv_win_data*(*get_win_data)(HWND hwnd);
+    void (*release_win_data)(struct macdrv_win_data *data);
+    macdrv_window(*macdrv_get_cocoa_window)(HWND hwnd, BOOL require_on_screen);
+    macdrv_metal_device (*macdrv_create_metal_device)(void);
+    void (*macdrv_release_metal_device)(macdrv_metal_device d);
+    macdrv_metal_view (*macdrv_view_create_metal_view)(macdrv_view v, macdrv_metal_device d);
+    macdrv_metal_layer (*macdrv_view_get_metal_layer)(macdrv_metal_view v);
+    void (*macdrv_view_release_metal_view)(macdrv_metal_view v);
+    void (*on_main_thread)(dispatch_block_t b);
+    LSTATUS(WINAPI*RegQueryValueExA)(HKEY, LPCSTR, LPDWORD, LPDWORD, BYTE*, LPDWORD);
+    LSTATUS(WINAPI*RegSetValueExA)(HKEY, LPCSTR, DWORD, DWORD, const BYTE*, DWORD);
+    LSTATUS(WINAPI*RegOpenKeyExA)(HKEY, LPCSTR, DWORD, DWORD, HKEY*);
+    LSTATUS(WINAPI*RegCreateKeyExA)(HKEY, LPCSTR, DWORD, LPSTR, DWORD, DWORD, LPSECURITY_ATTRIBUTES, HKEY*, LPDWORD);
+    LSTATUS(WINAPI*RegCloseKey)(HKEY);
+    BOOL(WINAPI*EnumDisplayMonitors)(HDC,LPRECT,MONITORENUMPROC,LPARAM);
+    BOOL(WINAPI*GetMonitorInfoA)(HMONITOR,LPMONITORINFO);
+    BOOL(WINAPI*AdjustWindowRectEx)(LPRECT,DWORD,BOOL,DWORD);
+    LONG_PTR(WINAPI*GetWindowLongPtrW)(HWND,int);
+    BOOL(WINAPI*GetWindowRect)(HWND,LPRECT);
+    BOOL(WINAPI*MoveWindow)(HWND,int,int,int,int,BOOL);
+    BOOL(WINAPI*SetWindowPos)(HWND,HWND,int,int,int,int,UINT);
+    INT(WINAPI*GetSystemMetrics)(INT);
+    LONG_PTR(WINAPI*SetWindowLongPtrW)(HWND,INT,LONG_PTR);
+};
+
+void OnMainThread(dispatch_block_t);
+
+struct macdrv_functions_t macdrv_functions = {
+    &macdrv_init_display_devices,
+    &get_win_data,
+    &release_win_data,
+    &macdrv_get_cocoa_window,
+    &macdrv_create_metal_device,
+    &macdrv_release_metal_device,
+    &macdrv_view_create_metal_view,
+    &macdrv_view_get_metal_layer,
+    &macdrv_view_release_metal_view,
+    &OnMainThread,
+    &RegQueryValueExA,
+    &RegSetValueExA,
+    &RegOpenKeyExA,
+    &RegCreateKeyExA,
+    &RegCloseKey,
+    &EnumDisplayMonitors,
+    &GetMonitorInfoA,
+    &AdjustWindowRectEx,
+    &GetWindowLongPtrW,
+    &GetWindowRect,
+    &MoveWindow,
+    &SetWindowPos,
+    &GetSystemMetrics,
+    &SetWindowLongPtrW,
+};
+#endif
\ No newline at end of file
-- 
2.39.2 (Apple Git-144)

diff --git a/loader/preloader_mac.c b/loader/preloader_mac.c
index 8b924f78c15..412bd638a3a 100644
--- wine/loader/preloader_mac.c
+++ wine/loader/preloader_mac.c
@@ -299,6 +299,7 @@ void *wld_munmap( void *start, size_t len );
 SYSCALL_FUNC( wld_munmap, 73 /* SYS_munmap */ );
 
 static intptr_t (*p_dyld_get_image_slide)( const struct target_mach_header* mh );
+static void (*p_dyld_make_delayed_module_initializer_calls)(void);
 
 #define MAKE_FUNCPTR(f) static typeof(f) * p##f
 MAKE_FUNCPTR(dlopen);
@@ -635,6 +636,7 @@ void *wld_start( void *stack, int *is_unix_thread )
     LOAD_POSIX_DYLD_FUNC( dlopen );
     LOAD_POSIX_DYLD_FUNC( dlsym );
     LOAD_POSIX_DYLD_FUNC( dladdr );
+    LOAD_MACHO_DYLD_FUNC( _dyld_make_delayed_module_initializer_calls );
     LOAD_MACHO_DYLD_FUNC( _dyld_get_image_slide );
 
 #ifdef __i386__ /* CrossOver Hack #16371 */
@@ -664,6 +666,8 @@ void *wld_start( void *stack, int *is_unix_thread )
     if (!map_region( &builtin_dlls ))
         builtin_dlls.size = 0;
 
+    p_dyld_make_delayed_module_initializer_calls();
+
     /* load the main binary */
     if (!(mod = pdlopen( argv[1], RTLD_NOW )))
         fatal_error( "%s: could not load binary\n", argv[1] );
-- 
2.39.2 (Apple Git-144)

diff --git a/dlls/ntdll/unix/signal_x86_64.c b/dlls/ntdll/unix/signal_x86_64.c
index 3d85d46abfc..950b6da44d3 100644
--- wine/dlls/ntdll/unix/signal_x86_64.c
+++ wine/dlls/ntdll/unix/signal_x86_64.c
@@ -2949,6 +2949,20 @@ static void usr1_handler( int signal, siginfo_t *siginfo, void *ucontext )
     }
 }
 
+static void sigsys_handler( int signal, siginfo_t *siginfo, void *sigcontext )
+{
+    ucontext_t *ctx = sigcontext;
+    void ***rsp;
+
+    TRACE("SIGSYS, rax %#llx, rip %#llx.\n", RAX_sig(ctx), RIP_sig(ctx));
+    
+    rsp = (void ***)&RSP_sig(ctx);
+    *rsp -= 1;
+    **rsp = (void *)(RIP_sig(ctx) + 0xb);
+
+    RIP_sig(ctx) = ((ULONG64)__wine_syscall_dispatcher);
+}
+
 
 /***********************************************************************
  *           LDT support
@@ -3292,6 +3311,8 @@ void signal_init_process(void)
     if (sigaction( SIGSEGV, &sig_act, NULL ) == -1) goto error;
     if (sigaction( SIGILL, &sig_act, NULL ) == -1) goto error;
     if (sigaction( SIGBUS, &sig_act, NULL ) == -1) goto error;
+    sig_act.sa_sigaction = sigsys_handler;
+    if (sigaction( SIGSYS, &sig_act, NULL ) == -1) goto error;
     return;
 
  error:
-- 
2.39.2 (Apple Git-144)

diff --git a/dlls/atiadlxx/atiadlxx.spec b/dlls/atiadlxx/atiadlxx.spec
index 1e447f38ded..80efd6eebb6 100644
--- wine/dlls/atiadlxx/atiadlxx.spec
+++ wine/dlls/atiadlxx/atiadlxx.spec
@@ -17,10 +17,10 @@
 @ stub ADL2_Adapter_Active_Get
 @ stub ADL2_Adapter_Active_Set
 @ stub ADL2_Adapter_Active_SetPrefer
-@ stub ADL2_Adapter_AdapterInfoX2_Get
+@ stdcall ADL2_Adapter_AdapterInfoX2_Get(ptr ptr)
 @ stub ADL2_Adapter_AdapterInfoX3_Get
 @ stub ADL2_Adapter_AdapterInfoX4_Get
-@ stub ADL2_Adapter_AdapterInfo_Get
+@ stdcall ADL2_Adapter_AdapterInfo_Get(ptr ptr long)
 @ stub ADL2_Adapter_AdapterList_Disable
 @ stub ADL2_Adapter_AdapterLocationPath_Get
 @ stub ADL2_Adapter_Aspects_Get
@@ -82,7 +82,7 @@
 @ stub ADL2_Adapter_FrameMetrics_Stop
 @ stub ADL2_Adapter_Gamma_Get
 @ stub ADL2_Adapter_Gamma_Set
-@ stub ADL2_Adapter_Graphic_Core_Info_Get
+@ stdcall ADL2_Adapter_Graphic_Core_Info_Get(ptr long ptr)
 @ stub ADL2_Adapter_HBC_Caps
 @ stub ADL2_Adapter_HBM_ECC_UC_Check
 @ stub ADL2_Adapter_Headless_Get
@@ -452,7 +452,7 @@
 @ stub ADL2_MMD_Video_Caps
 @ stub ADL2_Main_ControlX2_Create
 @ stdcall ADL2_Main_Control_Create(ptr long ptr)
-@ stub ADL2_Main_Control_Destroy
+@ stdcall ADL2_Main_Control_Destroy()
 @ stub ADL2_Main_Control_GetProcAddress
 @ stub ADL2_Main_Control_IsFunctionValid
 @ stub ADL2_Main_Control_Refresh
@@ -553,7 +553,7 @@
 @ stub ADL2_OverdriveN_ThrottleNotification_Get
 @ stub ADL2_OverdriveN_ZeroRPMFan_Get
 @ stub ADL2_OverdriveN_ZeroRPMFan_Set
-@ stub ADL2_Overdrive_Caps
+@ stdcall ADL2_Overdrive_Caps(ptr long ptr ptr ptr)
 @ stub ADL2_PPLogSettings_Get
 @ stub ADL2_PPLogSettings_Set
 @ stub ADL2_PPW_Caps
@@ -745,7 +745,7 @@
 @ stdcall ADL_Adapter_NumberOfAdapters_Get(ptr)
 @ stdcall ADL_Adapter_ObservedClockInfo_Get(long ptr ptr)
 @ stub ADL_Adapter_ObservedGameClockInfo_Get
-@ stub ADL_Adapter_Primary_Get
+@ stdcall ADL_Adapter_Primary_Get(long)
 @ stub ADL_Adapter_Primary_Set
 @ stub ADL_Adapter_RegValueInt_Get
 @ stub ADL_Adapter_RegValueInt_Set
@@ -853,7 +853,7 @@
 @ stub ADL_Display_DitherState_Set
 @ stub ADL_Display_Downscaling_Caps
 @ stub ADL_Display_DpMstInfo_Get
-@ stub ADL_Display_EdidData_Get
+@ stdcall ADL_Display_EdidData_Get(long long ptr)
 @ stub ADL_Display_EdidData_Set
 @ stub ADL_Display_EnumDisplays_Get
 @ stub ADL_Display_FilterSVideo_Get
diff --git a/dlls/atiadlxx/atiadlxx_main.c b/dlls/atiadlxx/atiadlxx_main.c
index 21dfbe71096..9b35cac4fb1 100644
--- wine/dlls/atiadlxx/atiadlxx_main.c
+++ wine/dlls/atiadlxx/atiadlxx_main.c
@@ -171,6 +171,24 @@ typedef struct ADLDisplayMap
     int iDisplayMapValue;
 } ADLDisplayMap, *LPADLDisplayMap;
 
+typedef struct ADLGraphicInfoCore
+{
+    union
+    {
+        int iNumPEsPerCU;
+        int iNumPEsPerWGP;
+    };
+    union
+    {
+        int iNumCUs;
+        int iNumWGPs;
+    };
+    int iGCGen;
+    int iNumROPs;
+    int iNumSIMDs;
+    int iReserved[11];
+} ADLGraphicInfoCore, *LPADLGraphicInfoCore;
+
 static const ADLVersionsInfo version = {
     "22.20.19.16-221003a-384125E-AMD-Software-Adrenalin-Edition",
     "",
@@ -184,10 +202,11 @@ static const ADLVersionsInfoX2 version2 = {
     "http://support.amd.com/drivers/xml/driver_09_us.xml",
 };
 
+int WINAPI ADL_Main_Control_Create(ADL_MAIN_MALLOC_CALLBACK cb, int arg);
 int WINAPI ADL2_Main_Control_Create(ADL_MAIN_MALLOC_CALLBACK cb, int arg, ADL_CONTEXT_HANDLE *ptr)
 {
     FIXME("cb %p, arg %d, ptr %p stub!\n", cb, arg, ptr);
-    return ADL_OK;
+    return ADL_Main_Control_Create(cb, arg);
 }
 
 int WINAPI ADL_Main_Control_Create(ADL_MAIN_MALLOC_CALLBACK cb, int arg)
@@ -212,15 +231,20 @@ int WINAPI ADL_Main_Control_Destroy(void)
     return ADL_OK;
 }
 
-int WINAPI ADL2_Adapter_NumberOfAdapters_Get(ADL_CONTEXT_HANDLE *ptr, int *count)
+int WINAPI ADL2_Main_Control_Destroy(void)
 {
-    FIXME("ptr %p, count %p stub!\n", ptr, count);
-
-    *count = 0;
+    FIXME("stub!\n");
 
     return ADL_OK;
 }
 
+int WINAPI ADL_Adapter_NumberOfAdapters_Get(int *count);
+int WINAPI ADL2_Adapter_NumberOfAdapters_Get(ADL_CONTEXT_HANDLE *ptr, int *count)
+{
+    FIXME("ptr %p, count %p stub!\n", ptr, count);
+    return ADL_Adapter_NumberOfAdapters_Get(count);
+}
+
 int WINAPI ADL2_Graphics_VersionsX2_Get(ADL_CONTEXT_HANDLE *ptr, ADLVersionsInfoX2 *ver)
 {
     FIXME("ptr %p, ver %p stub!\n", ptr, ver);
@@ -235,6 +259,21 @@ int WINAPI ADL_Graphics_Versions_Get(ADLVersionsInfo *ver)
     return ADL_OK;
 }
 
+int WINAPI ADL2_Adapter_Graphic_Core_Info_Get(ADL_CONTEXT_HANDLE *ptr, int iAdapterIndex, LPADLGraphicInfoCore pGraphicsInfo)
+{
+    FIXME("ptr %p, iAdapterIndex %u, pGraphicsInfo %p\n", ptr, iAdapterIndex, pGraphicsInfo);
+    return ADL_OK;
+}
+
+int WINAPI ADL2_Overdrive_Caps(ADL_CONTEXT_HANDLE *ptr, int iAdapterIndex, int *iSupported, int *iEnabled, int *iVersion)
+{
+    FIXME("ptr %p, iAdapterIndex %u\n");
+    *iSupported = 0;
+    *iEnabled = 0;
+    *iVersion = 0;
+    return ADL_OK;
+}
+
 int WINAPI ADL_Adapter_NumberOfAdapters_Get(int *count)
 {
     IDXGIAdapter *adapter;
@@ -275,6 +314,36 @@ static int convert_vendor_id(int id)
     return atoi(str);
 }
 
+int WINAPI ADL_Adapter_AdapterInfo_Get(ADLAdapterInfo *adapters, int input_size);
+
+int WINAPI ADL2_Display_EdidData_Get(int adapter_index, int display_index, void* edid_data)
+{
+    FIXME("adapter_index %d, display_index %p, edid_data %p\n", 
+        adapter_index, display_index, edid_data);
+    return ADL_ERR_NOT_SUPPORTED;
+}
+
+int WINAPI ADL2_Adapter_AdapterInfoX2_Get(ADL_CONTEXT_HANDLE* ptr, ADLAdapterInfo **adapters)
+{
+    TRACE("\n");
+    *adapters = (ADLAdapterInfo*)adl_malloc(sizeof(ADLAdapterInfo) * 1);
+    return ADL_Adapter_AdapterInfo_Get(*adapters, sizeof(ADLAdapterInfo) * 1);
+}
+
+int WINAPI ADL2_Adapter_AdapterInfo_Get(ADL_CONTEXT_HANDLE* ptr, ADLAdapterInfo *adapters, int bufferSize)
+{
+    TRACE("\n");
+    ADLAdapterInfo adapterInfo;
+    ADL_Adapter_AdapterInfo_Get(&adapterInfo, sizeof(ADLAdapterInfo));
+    if (bufferSize <= sizeof(ADLAdapterInfo))
+    {
+        memcpy(adapters, &adapterInfo, bufferSize);
+        return ADL_OK;
+    }
+
+    return ADL_ERR;
+}
+
 int WINAPI ADL_Adapter_AdapterInfo_Get(ADLAdapterInfo *adapters, int input_size)
 {
     int count, i;
@@ -452,6 +521,13 @@ int WINAPI ADL_Adapter_MemoryInfo_Get(int adapter_index, ADLMemoryInfo *mem_info
     return ADL_OK;
 }
 
+int WINAPI ADL_Adapter_Primary_Get(int* adapter_index)
+{
+    FIXME("stub!\n");
+    *adapter_index = 0;
+    return ADL_OK;
+}
+
 int WINAPI ADL_Graphics_Platform_Get(int *platform)
 {
     DXGI_ADAPTER_DESC adapter_desc;
@@ -491,3 +567,10 @@ int WINAPI ADL_Display_DisplayMapConfig_Get(int adapter_index, int *display_map_
 
     return ADL_ERR;
 }
+
+int WINAPI ADL_Display_EdidData_Get(int adapter_index, int display_index, void* edid_data)
+{
+    FIXME("adapter_index %d, display_index %p, edid_data %p\n", 
+        adapter_index, display_index, edid_data);
+    return ADL_ERR_NOT_SUPPORTED;
+}
-- 
2.39.2 (Apple Git-144)

diff --git a/dlls/ntdll/loader.c b/dlls/ntdll/loader.c
index fd0af32e..51c619b7 100644
--- wine/dlls/ntdll/loader.c
+++ wine/dlls/ntdll/loader.c
@@ -2294,6 +2294,12 @@ static NTSTATUS build_module( LPCWSTR load_path, const UNICODE_STRING *nt_name,
     TRACE_(loaddll)( "Loaded %s at %p: %s\n", debugstr_w(wm->ldr.FullDllName.Buffer), *module,
                      is_builtin ? "builtin" : "native" );
 
+#if defined(__x86_64__)
+    if (is_builtin == FALSE)
+    {
+        unix_funcs->pe_module_loaded(*module, (void*)((BYTE*)*module + map_size));
+    }
+#endif
     wm->ldr.LoadCount = 1;
     *pwm = wm;
     *module = NULL;
@@ -3477,8 +3483,8 @@ static NTSTATUS load_dll( const WCHAR *load_path, const WCHAR *libname, DWORD fl
 
     case STATUS_SUCCESS:  /* valid PE file */
         nts = load_native_dll( load_path, &nt_name, mapping, &image_info, &id, flags, system, pwm );
-#ifdef __x86_64__
-        if (nts == STATUS_SUCCESS && !wcscmp( libname, L"libcef.dll" ))
+#if defined(__APPLE__) && defined(__x86_64__)
+        if (nts == STATUS_SUCCESS && !wcscmp( libname, L"libcef.dll" ) && unix_funcs->gs_patching_needed())
             patch_libcef( pwm );
 #endif
         break;
diff --git a/dlls/ntdll/unix/loader.c b/dlls/ntdll/unix/loader.c
index e086c88e..bed76762 100644
--- wine/dlls/ntdll/unix/loader.c
+++ wine/dlls/ntdll/unix/loader.c
@@ -1544,6 +1544,44 @@ NTSTATUS WINAPI __wine_unix_call( unixlib_handle_t handle, unsigned int code, vo
     return ((unixlib_entry_t*)(UINT_PTR)handle)[code]( args );
 }
 
+#if defined(__APPLE__) && defined(__x86_64__)
+static void* non_native_support_lib;
+static void (*register_non_native_code_region) (void*, void*);
+static bool (*supports_non_native_code_regions) (void);
+static void init_non_native_support(void)
+{
+    register_non_native_code_region = NULL;
+    register_non_native_code_region = NULL;
+    non_native_support_lib = dlopen("@rpath/libd3dshared.dylib", RTLD_LOCAL);
+    if (non_native_support_lib)
+    {
+        register_non_native_code_region = dlsym(non_native_support_lib, "register_non_native_code_region");
+        supports_non_native_code_regions = dlsym(non_native_support_lib, "supports_non_native_code_regions");
+    }
+}
+
+static void CDECL pe_module_loaded(void* start, void* end)
+{
+    if ((supports_non_native_code_regions && supports_non_native_code_regions()))
+    {
+        TRACE("Marking non_native_code_region: %p, %p", start, end);
+        register_non_native_code_region(start, end);
+    }
+}
+static BOOL CDECL gs_patching_needed(void)
+{
+    return (supports_non_native_code_regions && supports_non_native_code_regions() == false);
+}
+#elif defined(__x86_64__)
+static void CDECL pe_module_loaded(void* start, void* end)
+{
+
+}
+static BOOL CDECL gs_patching_needed(void)
+{
+    return false;
+}
+#endif
 
 /***********************************************************************
  *           load_so_dll
@@ -2345,6 +2383,10 @@ static struct unix_funcs unix_funcs =
 #ifdef __aarch64__
     NtCurrentTeb,
 #endif
+#if defined(__x86_64__)
+    pe_module_loaded,
+    gs_patching_needed,
+#endif
 };
 
 
@@ -2460,6 +2502,10 @@ static void start_main_thread(void)
             dlopen_32on64_opengl32();
 #endif
     }
+    else
+    {
+        init_non_native_support();
+    }
     load_apiset_dll();
     ntdll_init_syscalls( 0, &syscall_table, p__wine_syscall_dispatcher );
     status = p__wine_set_unix_funcs( NTDLL_UNIXLIB_VERSION, &unix_funcs );
diff --git a/dlls/ntdll/unixlib.h b/dlls/ntdll/unixlib.h
index cb184431..1ea1a3b4 100644
--- wine/dlls/ntdll/unixlib.h
+++ wine/dlls/ntdll/unixlib.h
@@ -26,7 +26,7 @@
 struct _DISPATCHER_CONTEXT;
 
 /* increment this when you change the function table */
-#define NTDLL_UNIXLIB_VERSION 134
+#define NTDLL_UNIXLIB_VERSION 135
 
 struct unix_funcs
 {
@@ -40,6 +40,10 @@ struct unix_funcs
 #ifdef __aarch64__
     TEB *         (WINAPI *NtCurrentTeb)(void);
 #endif
+#if defined(__x86_64__)
+    void          (CDECL *pe_module_loaded)(void* start, void* end);
+    BOOL          (CDECL *gs_patching_needed)(void);
+#endif
 };
 
 #endif /* __NTDLL_UNIXLIB_H */
diff --git a/dlls/atiadlxx/atiadlxx.spec b/dlls/atiadlxx/atiadlxx.spec
index 80efd6ee..752e805a 100644
--- wine/dlls/atiadlxx/atiadlxx.spec
+++ wine/dlls/atiadlxx/atiadlxx.spec
@@ -94,7 +94,7 @@
 @ stub ADL2_Adapter_MVPU_Set
 @ stub ADL2_Adapter_MaxCursorSize_Get
 @ stub ADL2_Adapter_MemoryInfo2_Get
-@ stub ADL2_Adapter_MemoryInfo_Get
+@ stdcall ADL2_Adapter_MemoryInfo_Get(ptr long ptr)
 @ stub ADL2_Adapter_MirabilisSupport_Get
 @ stub ADL2_Adapter_ModeSwitch
 @ stub ADL2_Adapter_ModeTimingOverride_Caps
@@ -249,7 +249,7 @@
 @ stub ADL2_Display_DCE_Get
 @ stub ADL2_Display_DCE_Set
 @ stub ADL2_Display_DDCBlockAccess_Get
-@ stub ADL2_Display_DDCInfo2_Get
+@ stdcall ADL2_Display_DDCInfo2_Get(ptr long long ptr)
 @ stub ADL2_Display_DDCInfo_Get
 @ stub ADL2_Display_Deflicker_Get
 @ stub ADL2_Display_Deflicker_Set
@@ -257,9 +257,9 @@
 @ stub ADL2_Display_DisplayContent_Cap
 @ stub ADL2_Display_DisplayContent_Get
 @ stub ADL2_Display_DisplayContent_Set
-@ stub ADL2_Display_DisplayInfo_Get
+@ stdcall ADL2_Display_DisplayInfo_Get(ptr long ptr ptr long)
 @ stub ADL2_Display_DisplayMapConfigX2_Set
-@ stub ADL2_Display_DisplayMapConfig_Get
+@ stdcall ADL2_Display_DisplayMapConfig_Get(ptr long ptr ptr ptr ptr long)
 @ stub ADL2_Display_DisplayMapConfig_PossibleAddAndRemove
 @ stub ADL2_Display_DisplayMapConfig_Set
 @ stub ADL2_Display_DisplayMapConfig_Validate
@@ -281,7 +281,7 @@
 @ stub ADL2_Display_FormatsOverride_Set
 @ stub ADL2_Display_FreeSyncState_Get
 @ stub ADL2_Display_FreeSyncState_Set
-@ stub ADL2_Display_FreeSync_Cap
+@ stdcall ADL2_Display_FreeSync_Cap(ptr long long ptr)
 @ stub ADL2_Display_GamutMapping_Get
 @ stub ADL2_Display_GamutMapping_Reset
 @ stub ADL2_Display_GamutMapping_Set
@@ -315,7 +315,7 @@
 @ stub ADL2_Display_ModeTimingOverride_Delete
 @ stub ADL2_Display_ModeTimingOverride_Get
 @ stub ADL2_Display_ModeTimingOverride_Set
-@ stub ADL2_Display_Modes_Get
+@ stdcall ADL2_Display_Modes_Get(ptr long long ptr ptr)
 @ stub ADL2_Display_Modes_Set
 @ stub ADL2_Display_Modes_X2_Get
 @ stub ADL2_Display_MonitorPowerState_Set
@@ -744,7 +744,7 @@
 @ stub ADL_Adapter_NumberOfActivatableSources_Get
 @ stdcall ADL_Adapter_NumberOfAdapters_Get(ptr)
 @ stdcall ADL_Adapter_ObservedClockInfo_Get(long ptr ptr)
-@ stub ADL_Adapter_ObservedGameClockInfo_Get
+@ stdcall ADL_Adapter_ObservedGameClockInfo_Get(ptr long ptr ptr ptr ptr)
 @ stdcall ADL_Adapter_Primary_Get(long)
 @ stub ADL_Adapter_Primary_Set
 @ stub ADL_Adapter_RegValueInt_Get
diff --git a/dlls/atiadlxx/atiadlxx_main.c b/dlls/atiadlxx/atiadlxx_main.c
index 9b35cac4..3018336c 100644
--- wine/dlls/atiadlxx/atiadlxx_main.c
+++ wine/dlls/atiadlxx/atiadlxx_main.c
@@ -63,6 +63,14 @@ typedef void *ADL_CONTEXT_HANDLE;
 ADL_MAIN_MALLOC_CALLBACK adl_malloc;
 #define ADL_MAX_PATH 256
 
+typedef struct ADLDDCInfo2 {
+
+} ADLDDCInfo2;
+
+typedef struct ADLFreeSyncCap {
+
+} ADLFreeSyncCap;
+
 typedef struct ADLVersionsInfo
 {
     char strDriverVer[ADL_MAX_PATH];
@@ -325,15 +333,15 @@ int WINAPI ADL2_Display_EdidData_Get(int adapter_index, int display_index, void*
 
 int WINAPI ADL2_Adapter_AdapterInfoX2_Get(ADL_CONTEXT_HANDLE* ptr, ADLAdapterInfo **adapters)
 {
-    TRACE("\n");
+    FIXME("stub!\n");
     *adapters = (ADLAdapterInfo*)adl_malloc(sizeof(ADLAdapterInfo) * 1);
     return ADL_Adapter_AdapterInfo_Get(*adapters, sizeof(ADLAdapterInfo) * 1);
 }
 
 int WINAPI ADL2_Adapter_AdapterInfo_Get(ADL_CONTEXT_HANDLE* ptr, ADLAdapterInfo *adapters, int bufferSize)
 {
-    TRACE("\n");
     ADLAdapterInfo adapterInfo;
+    TRACE("stub!");
     ADL_Adapter_AdapterInfo_Get(&adapterInfo, sizeof(ADLAdapterInfo));
     if (bufferSize <= sizeof(ADLAdapterInfo))
     {
@@ -346,7 +354,7 @@ int WINAPI ADL2_Adapter_AdapterInfo_Get(ADL_CONTEXT_HANDLE* ptr, ADLAdapterInfo
 
 int WINAPI ADL_Adapter_AdapterInfo_Get(ADLAdapterInfo *adapters, int input_size)
 {
-    int count, i;
+    int count, i, j;
     DXGI_ADAPTER_DESC adapter_desc;
 
     FIXME("adapters %p, input_size %d, stub!\n", adapters, input_size);
@@ -362,11 +370,18 @@ int WINAPI ADL_Adapter_AdapterInfo_Get(ADLAdapterInfo *adapters, int input_size)
     {
         adapters[i].iSize = sizeof(ADLAdapterInfo);
         adapters[i].iAdapterIndex = i;
 
         if (get_adapter_desc(i, &adapter_desc) != ADL_OK)
             return ADL_ERR;
 
         adapters[i].iVendorID = convert_vendor_id(adapter_desc.VendorId);
+
+        for (j = 0; j < 128; ++j)
+        {
+            adapters[i].strAdapterName[j] = (char)adapter_desc.Description[j];
+            if (adapters[i].strAdapterName[j] == 0)
+               break;
+        }
     }
 
     return ADL_OK;
@@ -411,6 +434,12 @@ int WINAPI ADL_Display_DisplayInfo_Get(int adapter_index, int *num_displays, ADL
     return ADL_OK;
 }
 
+int WINAPI ADL2_Display_DisplayInfo_Get(ADL_CONTEXT_HANDLE context, int adapter_index, int *num_displays, ADLDisplayInfo **info, int force_detect)
+{
+    FIXME("adapter: %d, stub!\n", adapter_index);
+    return ADL_Display_DisplayInfo_Get(adapter_index, num_displays, info, force_detect);    
+}
+
 int WINAPI ADL_Adapter_Crossfire_Caps(int adapter_index, int *preffered, int *num_comb, ADLCrossfireComb** comb)
 {
     FIXME("adapter %d, preffered %p, num_comb %p, comb %p stub!\n", adapter_index, preffered, num_comb, comb);
@@ -501,6 +530,23 @@ int WINAPI ADL_Adapter_ObservedClockInfo_Get(int adapter_index, int *core_clock,
     return ADL_OK;
 }
 
+int WINAPI ADL_Adapter_ObservedGameClockInfo_Get(ADL_CONTEXT_HANDLE context, int adapter_index, int* base_clock, int* game_clock, int* boost_clock, int* memory_clock)
+{
+    int retStatus;
+    FIXME("adapter: %d, stub!\n", adapter_index);
+    retStatus = ADL_Adapter_ObservedClockInfo_Get(adapter_index, base_clock, memory_clock);
+    if (retStatus == ADL_OK)
+    {
+        *game_clock = *base_clock;
+        *boost_clock = *base_clock;
+
+        TRACE("*base_clock: %i, *game_clock: %i, *boost_clock: %i, *memory_clock: %i\n", 
+                *base_clock, *game_clock, *boost_clock, *memory_clock);
+    }
+    return retStatus;
+}
+
+
 /* documented in the "Linux Specific APIs" section, present and used on Windows */
 int WINAPI ADL_Adapter_MemoryInfo_Get(int adapter_index, ADLMemoryInfo *mem_info)
 {
@@ -521,6 +567,12 @@ int WINAPI ADL_Adapter_MemoryInfo_Get(int adapter_index, ADLMemoryInfo *mem_info
     return ADL_OK;
 }
 
+int WINAPI ADL2_Adapter_MemoryInfo_Get(ADL_CONTEXT_HANDLE context, int adapter_index, ADLMemoryInfo *mem_info)
+{
+    FIXME("adapter %d, stub!\n", adapter_index);
+    return ADL_Adapter_MemoryInfo_Get(adapter_index, mem_info);
+}
+
 int WINAPI ADL_Adapter_Primary_Get(int* adapter_index)
 {
     FIXME("stub!\n");
@@ -565,7 +617,14 @@ int WINAPI ADL_Display_DisplayMapConfig_Get(int adapter_index, int *display_map_
             adapter_index, display_map_count, display_maps, display_target_count,
             display_targets, options);
 
-    return ADL_ERR;
+    return ADL_ERR_NOT_SUPPORTED;
+}
+
+int WINAPI ADL2_Display_DisplayMapConfig_Get(ADL_CONTEXT_HANDLE context, int adapter_index, int *display_map_count, ADLDisplayMap **display_maps,
+        int *display_target_count, ADLDisplayTarget **display_targets, int options)
+{
+    FIXME("adapter_index %d, stub!\n", adapter_index);
+    return ADL_Display_DisplayMapConfig_Get(adapter_index, display_map_count, display_maps, display_target_count, display_targets, options);
 }
 
 int WINAPI ADL_Display_EdidData_Get(int adapter_index, int display_index, void* edid_data)
@@ -574,3 +633,21 @@ int WINAPI ADL_Display_EdidData_Get(int adapter_index, int display_index, void*
         adapter_index, display_index, edid_data);
     return ADL_ERR_NOT_SUPPORTED;
 }
+
+int WINAPI ADL2_Display_Modes_Get(ADL_CONTEXT_HANDLE context, int adapter_index, int display_index, int *num_modes, ADLMode *modes)
+{
+    FIXME("adapter: %d, display: %d, stub!\n", adapter_index, display_index);
+    return ADL_ERR_NOT_SUPPORTED;
+}
+
+int WINAPI ADL2_Display_DDCInfo2_Get(ADL_CONTEXT_HANDLE context, int adapter_index, int display_index, ADLDDCInfo2 *info)
+{
+    FIXME("adapter: %d, display: %d, stub!\n", adapter_index, display_index);
+    return ADL_ERR_NOT_SUPPORTED;
+}
+
+int WINAPI ADL2_Display_FreeSync_Cap(ADL_CONTEXT_HANDLE context, int adapter_index, int display_index, ADLFreeSyncCap *cap)
+{
+    FIXME("adapter: %d, display: %d, stub!\n", adapter_index, display_index);
+    return ADL_ERR_NOT_SUPPORTED;
+}
\ No newline at end of file
-- 
2.39.2 (Apple Git-144)

diff --git a/dlls/atiadlxx/atiadlxx.spec b/dlls/atiadlxx/atiadlxx.spec
index 752e805a..147f6bad 100644
--- wine/dlls/atiadlxx/atiadlxx.spec
+++ wine/dlls/atiadlxx/atiadlxx.spec
@@ -10,17 +10,17 @@
 @ stub ADL2_AdapterLimitation_Caps
 @ stub ADL2_AdapterX2_Caps
 @ stub ADL2_Adapter_AMDAndNonAMDDIsplayClone_Get
-@ stub ADL2_Adapter_ASICFamilyType_Get
+@ stdcall ADL2_Adapter_ASICFamilyType_Get(long long ptr ptr)
 @ stub ADL2_Adapter_ASICInfo_Get
 @ stub ADL2_Adapter_Accessibility_Get
 @ stub ADL2_Adapter_AceDefaults_Restore
 @ stub ADL2_Adapter_Active_Get
 @ stub ADL2_Adapter_Active_Set
 @ stub ADL2_Adapter_Active_SetPrefer
-@ stdcall ADL2_Adapter_AdapterInfoX2_Get(ptr ptr)
+@ stdcall ADL2_Adapter_AdapterInfoX2_Get(long ptr)
 @ stub ADL2_Adapter_AdapterInfoX3_Get
-@ stub ADL2_Adapter_AdapterInfoX4_Get
-@ stdcall ADL2_Adapter_AdapterInfo_Get(ptr ptr long)
+@ stdcall ADL2_Adapter_AdapterInfoX4_Get(long long ptr ptr)
+@ stdcall ADL2_Adapter_AdapterInfo_Get(long ptr long)
 @ stub ADL2_Adapter_AdapterList_Disable
 @ stub ADL2_Adapter_AdapterLocationPath_Get
 @ stub ADL2_Adapter_Aspects_Get
@@ -93,7 +93,7 @@
 @ stub ADL2_Adapter_LocalDisplayState_Get
 @ stub ADL2_Adapter_MVPU_Set
 @ stub ADL2_Adapter_MaxCursorSize_Get
-@ stub ADL2_Adapter_MemoryInfo2_Get
+@ stdcall ADL2_Adapter_MemoryInfo2_Get(long long ptr)
 @ stdcall ADL2_Adapter_MemoryInfo_Get(ptr long ptr)
 @ stub ADL2_Adapter_MirabilisSupport_Get
 @ stub ADL2_Adapter_ModeSwitch
diff --git a/dlls/atiadlxx/atiadlxx_main.c b/dlls/atiadlxx/atiadlxx_main.c
index 3018336c..5d35aff2 100644
--- wine/dlls/atiadlxx/atiadlxx_main.c
+++ wine/dlls/atiadlxx/atiadlxx_main.c
@@ -104,6 +104,26 @@ typedef struct ADLAdapterInfo {
     int iOSDisplayIndex;
 } ADLAdapterInfo, *LPADLAdapterInfo;
 
+typedef struct ADLAdapterInfoX2 { //Matches ADLAdapterInfo until iInfoMask
+    int iSize;
+    int iAdapterIndex;
+    char strUDID[ADL_MAX_PATH];
+    int iBusNumber;
+    int iDeviceNumber;
+    int iFunctionNumber;
+    int iVendorID;
+    char strAdapterName[ADL_MAX_PATH];
+    char strDisplayName[ADL_MAX_PATH];
+    int iPresent;
+    int iExist;
+    char strDriverPath[ADL_MAX_PATH];
+    char strDriverPathExt[ADL_MAX_PATH];
+    char strPNPString[ADL_MAX_PATH];
+    int iOSDisplayIndex;
+    int iInfoMask;
+    int iInfoValue;
+} ADLAdapterInfoX2, *LPADLAdapterInfoX2;
+
 typedef struct ADLDisplayID
 {
     int iDisplayLogicalIndex;
@@ -145,6 +165,16 @@ typedef struct ADLMemoryInfo
     long long iMemoryBandwidth;
 } ADLMemoryInfo, *LPADLMemoryInfo;
 
+typedef struct ADLMemoryInfo2
+{
+    long long iHyperMemorySize;
+    long long iInvisibleMemorySize;
+    long long iMemoryBandwidth;
+    long long iMemorySize;
+    long long iVisibleMemorySize;
+    char strMemoryType[ADL_MAX_PATH];
+} ADLMemoryInfo2, *LPADLMemoryInfo2;
+
 typedef struct ADLDisplayTarget
 {
     ADLDisplayID displayID;
@@ -331,14 +361,37 @@ int WINAPI ADL2_Display_EdidData_Get(int adapter_index, int display_index, void*
     return ADL_ERR_NOT_SUPPORTED;
 }
 
-int WINAPI ADL2_Adapter_AdapterInfoX2_Get(ADL_CONTEXT_HANDLE* ptr, ADLAdapterInfo **adapters)
+int WINAPI ADL2_Adapter_AdapterInfoX2_Get(ADL_CONTEXT_HANDLE handle, ADLAdapterInfo **adapters)
 {
     FIXME("stub!\n");
     *adapters = (ADLAdapterInfo*)adl_malloc(sizeof(ADLAdapterInfo) * 1);
     return ADL_Adapter_AdapterInfo_Get(*adapters, sizeof(ADLAdapterInfo) * 1);
 }
 
-int WINAPI ADL2_Adapter_AdapterInfo_Get(ADL_CONTEXT_HANDLE* ptr, ADLAdapterInfo *adapters, int bufferSize)
+int WINAPI ADL2_Adapter_AdapterInfoX4_Get(ADL_CONTEXT_HANDLE handle, int adapter_index, int *num_adapters, ADLAdapterInfoX2 **info)
+{
+    int status;
+    FIXME("adapter: %u, stub!\n", adapter_index);
+    if (adapter_index == -1)
+    {
+        adapter_index = 0;
+    }
+    if (num_adapters)
+    {
+        *num_adapters = 1;
+    }
+    *info = (ADLAdapterInfoX2*)adl_malloc(sizeof(ADLAdapterInfoX2) * 1);
+    memset(*info, 0, sizeof(ADLAdapterInfoX2));
+    status = ADL_Adapter_AdapterInfo_Get(*info, sizeof(ADLAdapterInfo));
+    if (status == ADL_OK)
+    {
+        info[0]->iInfoMask = 1; 
+        info[0]->iInfoValue = 1;
+    }
+    return status;
+}
+
+int WINAPI ADL2_Adapter_AdapterInfo_Get(ADL_CONTEXT_HANDLE handle, ADLAdapterInfo *adapters, int bufferSize)
 {
     ADLAdapterInfo adapterInfo;
     TRACE("stub!");
@@ -473,6 +526,12 @@ int WINAPI ADL_Adapter_ASICFamilyType_Get(int adapter_index, int *asic_type, int
     return ADL_OK;
 }
 
+int WINAPI ADL2_Adapter_ASICFamilyType_Get(ADL_CONTEXT_HANDLE handle, int adapter_index, int *asic_types, int *valids)
+{
+    FIXME("adapter_index: %u, stub!\n", adapter_index);
+    return ADL_Adapter_ASICFamilyType_Get(adapter_index, asic_types, valids);
+}
+
 static int get_max_clock(const char *clock, int default_value)
 {
     char path[MAX_PATH], line[256];
@@ -573,6 +632,25 @@ int WINAPI ADL2_Adapter_MemoryInfo_Get(ADL_CONTEXT_HANDLE context, int adapter_i
     return ADL_Adapter_MemoryInfo_Get(adapter_index, mem_info);
 }
 
+int WINAPI ADL2_Adapter_MemoryInfo2_Get(ADL_CONTEXT_HANDLE context, int adapter_index, ADLMemoryInfo2 *mem_info)
+{
+    ADLMemoryInfo meminfo1;
+    int status;
+    FIXME("adapter %d, stub!\n", adapter_index);
+    
+    status = ADL2_Adapter_MemoryInfo_Get(context, adapter_index, &meminfo1);
+    if (status == ADL_OK)
+    {
+        mem_info->iHyperMemorySize = 0;
+        mem_info->iInvisibleMemorySize = 0;
+        mem_info->iMemoryBandwidth = meminfo1.iMemoryBandwidth;
+        mem_info->iMemorySize = meminfo1.iMemorySize;
+        mem_info->iVisibleMemorySize = mem_info->iMemorySize;
+        memcpy(mem_info->strMemoryType, meminfo1.strMemoryType, ADL_MAX_PATH);
+    }
+    return status;
+}
+
 int WINAPI ADL_Adapter_Primary_Get(int* adapter_index)
 {
     FIXME("stub!\n");
-- 
2.39.2 (Apple Git-144)

diff --git a/dlls/atiadlxx/atiadlxx.spec b/dlls/atiadlxx/atiadlxx.spec
index 147f6bad..222fb744 100644
--- wine/dlls/atiadlxx/atiadlxx.spec
+++ wine/dlls/atiadlxx/atiadlxx.spec
@@ -464,7 +464,7 @@
 @ stub ADL2_Overdrive5_FanSpeedToDefault_Set
 @ stub ADL2_Overdrive5_FanSpeed_Get
 @ stub ADL2_Overdrive5_FanSpeed_Set
-@ stub ADL2_Overdrive5_ODParameters_Get
+@ stdcall ADL2_Overdrive5_ODParameters_Get(ptr long ptr)
 @ stub ADL2_Overdrive5_ODPerformanceLevels_Get
 @ stub ADL2_Overdrive5_ODPerformanceLevels_Set
 @ stub ADL2_Overdrive5_PowerControlAbsValue_Caps
@@ -997,7 +997,7 @@
 @ stub ADL_Overdrive5_FanSpeedToDefault_Set
 @ stub ADL_Overdrive5_FanSpeed_Get
 @ stub ADL_Overdrive5_FanSpeed_Set
-@ stub ADL_Overdrive5_ODParameters_Get
+@ stdcall ADL_Overdrive5_ODParameters_Get(long ptr)
 @ stub ADL_Overdrive5_ODPerformanceLevels_Get
 @ stub ADL_Overdrive5_ODPerformanceLevels_Set
 @ stub ADL_Overdrive5_PowerControlAbsValue_Caps
diff --git a/dlls/atiadlxx/atiadlxx_main.c b/dlls/atiadlxx/atiadlxx_main.c
index d5f8a1b4..9f887387 100644
--- wine/dlls/atiadlxx/atiadlxx_main.c
+++ wine/dlls/atiadlxx/atiadlxx_main.c
@@ -227,6 +227,25 @@ typedef struct ADLGraphicInfoCore
     int iReserved[11];
 } ADLGraphicInfoCore, *LPADLGraphicInfoCore;
 
+typedef struct ADLODParameterRange
+{
+   int iMin;
+   int iMax;
+   int iStep;
+} ADLODParameterRange;
+  
+typedef struct ADLODParameters
+{
+   int iSize;
+   int iNumberOfPerformanceLevels;
+   int iActivityReportingSupported;
+   int iDiscretePerformanceLevels;
+   int iReserved;
+   ADLODParameterRange sEngineClock;
+   ADLODParameterRange sMemoryClock;
+   ADLODParameterRange sVddc;
+} ADLODParameters;
+
 static const ADLVersionsInfo version = {
     "22.20.19.16-221003a-384125E-AMD-Software-Adrenalin-Edition",
     "",
@@ -720,4 +739,14 @@ int WINAPI ADL2_Display_FreeSync_Cap(ADL_CONTEXT_HANDLE context, int adapter_ind
 {
     FIXME("adapter: %d, display: %d, stub!\n", adapter_index, display_index);
     return ADL_ERR_NOT_SUPPORTED;
-}
\ No newline at end of file
+}
+
+int WINAPI ADL_Overdrive5_ODParameters_Get(int iAdapterIndex, ADLODParameters *lpOdParameters)
+{
+    return ADL_ERR_NOT_SUPPORTED;
+}
+
+int WINAPI ADL2_Overdrive5_ODParameters_Get(ADL_CONTEXT_HANDLE context, int iAdapterIndex, ADLODParameters *lpOdParameters)
+{
+    return ADL_ERR_NOT_SUPPORTED;
+}
